Comments,Surrounding Code Context,Class
/*test 529*/,"-10.   int res = 0;
-9.   CURL *curl = NULL;
-8.   FILE *hd_src = NULL;
-7.   int hd;
-6.   struct_stat file_info;
-5.   CURLM *m = NULL;
-4.   int running;
-3.   start_test_timing();
-2.   if(!libtest_arg2) {
-1. #ifdef LIB529

/*test 529*/

1.     fprin",Not Useful
/*test 525*/,"-2.     fprintf(stderr, ""Usage: lib529 [url] [uploadfile]\n"");
-1. #else

/*test 525*/

1.     fprintf(stderr, ""Usage: lib525 [url] [uploadfile]\n"");
2. #endif
3.     return TEST_ERR_USAGE;
4.   }
5.   hd_src = fopen(libtest_arg2, ""rb"");
6.   if(!hd_src) ",Not Useful
/*done*/,"-10.   multi_add_handle(m, curl);
-9.   for(;;) {
-8.     struct timeval interval;
-7.     fd_set rd, wr, exc;
-6.     int maxfd = -99;
-5.     interval.tv_sec = 1;
-4.     interval.tv_usec = 0;
-3.     multi_perform(m, &running);
-2.     abort_on_test_ti",Not Useful
/*test 529*/,"-10.   int res = 0;
-9.   CURL *curl = NULL;
-8.   FILE *hd_src = NULL;
-7.   int hd;
-6.   struct_stat file_info;
-5.   CURLM *m = NULL;
-4.   int running;
-3.   start_test_timing();
-2.   if(!libtest_arg2) {
-1. #ifdef LIB529

/*test 529*/

1.     fprin",Not Useful
/*test 525*/,"-2.     fprintf(stderr, ""Usage: lib529 [url] [uploadfile]\n"");
-1. #else

/*test 525*/

1.     fprintf(stderr, ""Usage: lib525 [url] [uploadfile]\n"");
2. #endif
3.     return TEST_ERR_USAGE;
4.   }
5.   hd_src = fopen(libtest_arg2, ""rb"");
6.   if(!hd_src) ",Not Useful
"/*argv1 = URL
 * argv2 = proxy
 * argv3 = non-zero means ASCII transfer*/",#NAME?,Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*ignores error*/,"-10. {
-9.   struct initurl *u = (struct initurl *)ptr;
-8.   int i;
-7.   time_t end = time(NULL) + RUN_FOR_SECONDS;
-6.   for(i = 0; time(NULL) < end; i++) {
-5.     CURL *curl = curl_easy_init();
-4.     curl_easy_setopt(curl, CURLOPT_URL, u->url);
-3.",Not Useful
/*if this happens things are major weird*/,"-10.   struct_stat file_info;
-9.   if(!libtest_arg2) {
-8.     fprintf(stderr, ""Usage: <url> <file-to-upload>\n"");
-7.     return TEST_ERR_USAGE;
-6.   }
-5.   hd_src = fopen(libtest_arg2, ""rb"");
-4.   if(!hd_src) {
-3.     fprintf(stderr, ""fopen failed ",Not Useful
/*enable uploading*/,"-7.   curl = curl_easy_init();
-6.   if(!curl) {
-5.     fprintf(stderr, ""curl_easy_init() failed\n"");
-4.     curl_global_cleanup();
-3.     fclose(hd_src);
-2.     return TEST_ERR_MAJOR_BAD;
-1.   }

/*enable uploading*/

1.   test_setopt(curl, CURLOPT_",Not Useful
/*enable verbose*/,"-1.   test_setopt(curl, CURLOPT_UPLOAD, 1L);

/*enable verbose*/

1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);",Not Useful
/*now specify which file to upload*/,"-1.   test_setopt(curl, CURLOPT_URL, URL);

/*now specify which file to upload*/

1.   test_setopt(curl, CURLOPT_READDATA, hd_src);",Not Useful
/*Now run off and do what you've been told!*/,"-1.   test_setopt(curl, CURLOPT_READDATA, hd_src);

/*Now run off and do what you've been told!*/

1.   curl_easy_perform(curl);",Not Useful
"/*and now upload the exact same again, but without rewinding so it already
     is at end of file*/","-1.   curl_easy_perform(curl);

/*and now upload the exact same again, but without rewinding so it already
     is at end of file*/

1.   res = curl_easy_perform(curl);
2. test_cleanup:",Not Useful
/*close the local file*/,"-2.   res = curl_easy_perform(curl);
-1. test_cleanup:

/*close the local file*/

1.   fclose(hd_src);
2.   curl_easy_cleanup(curl);
3.   curl_global_cleanup();
4.   return res;
5. }",Not Useful
"/*****************************************************************************
*                      STRUCT DECLARATIONS AND DEFINES                       *
*****************************************************************************/","-1. #include ""memdebug.h""
/*****************************************************************************

/*****************************************************************************
*                      STRUCT DECLARATIONS AND DEFINES                ",Not Useful
/*SEGSIZE defined in arpa/tftp.h*/,"-1. #ifndef PKTSIZE

/*SEGSIZE defined in arpa/tftp.h*/

1. #endif
2. struct testcase {",Not Useful
/*size of the data in buffer*/,"-3. #endif
-2. struct testcase {

/*size of the data in buffer*/

111",Not Useful
/*read pointer into the buffer*/,"-4. #endif
-3. struct testcase {

/*read pointer into the buffer*/

111",Not Useful
/*test case number*/,"-6. #endif
-5. struct testcase {

/*test case number*/

111",Not Useful
/*number of seconds between each packet*/,"-8. #endif
-7. struct testcase {

/*number of seconds between each packet*/

1. };
2. struct formats {
3.   const char *f_mode;
4.   int f_convert;
5. };
6. struct errmsg {
7.   int e_code;
8.   const char *e_msg;
9. };
10. typedef union {",Not Useful
"/*size of data in buffer, or flag*/","-1. struct bf {

/*size of data in buffer, or flag*/

111",Not Useful
/*room for data packet*/,"-2. struct bf {

/*room for data packet*/

1. };",Not Useful
/*UDP*/,"-10. #define opcode_DATA  3
-9. #define opcode_ACK   4
-8. #define opcode_ERROR 5
-7. #define TIMEOUT      5
-6. #undef MIN
-5. #define MIN(x,y) ((x)<(y)?(x):(y))
-4. #ifndef DEFAULT_LOGFILE
-3. #define DEFAULT_LOGFILE ""log/tftpd.log""
-2. #endif
-1. #defi",Not Useful
"/*****************************************************************************
*                              GLOBAL VARIABLES                              *
*****************************************************************************/","-1. #include ""memdebug.h""
/*****************************************************************************

/*****************************************************************************
*                              GLOBAL VARIABLES                       ",Not Useful
/*index of next buffer to use*/,"-10.   { EEXISTS,      ""File already exists"" },
-9.   { ENOUSER,      ""No such user"" },
-8.   { -1,           0 }
-7. };
-6. static const struct formats formata[] = {
-5.   { ""netascii"",   1 },
-4.   { ""octet"",      0 },
-3.   { NULL,         0 }
-2. };
-",Not Useful
/*index of buffer in use*/,"-10.   { ENOUSER,      ""No such user"" },
-9.   { -1,           0 }
-8. };
-7. static const struct formats formata[] = {
-6.   { ""netascii"",   1 },
-5.   { ""octet"",      0 },
-4.   { NULL,         0 }
-3. };
-2. static struct bf bfs[2];

/*index of buffer ",Not Useful
"/*****************************************************************************
*                            FUNCTION PROTOTYPES                             *
*****************************************************************************/","-1. #include ""memdebug.h""
/*****************************************************************************

/*****************************************************************************
*                            FUNCTION PROTOTYPES                      ",Not Useful
/*HAVE_ALARM && SIGALRM*/,"-10. static int synchnet(curl_socket_t);
-9. static int do_tftp(struct testcase *test, struct tftphdr *tp, ssize_t size);
-8. static int validate_access(struct testcase *test, const char *fname, int mode);
-7. static void sendtftp(struct testcase *test, c",Not Useful
"/*****************************************************************************
*                          FUNCTION IMPLEMENTATIONS                          *
*****************************************************************************/","-1. #include ""memdebug.h""
/*****************************************************************************

/*****************************************************************************
*                          FUNCTION IMPLEMENTATIONS                   ",Not Useful
/*HAVE_ALARM && SIGALRM*/,"-10. static int synchnet(curl_socket_t);
-9. static int do_tftp(struct testcase *test, struct tftphdr *tp, ssize_t size);
-8. static int validate_access(struct testcase *test, const char *fname, int mode);
-7. static void sendtftp(struct testcase *test, c",Not Useful
/*init crlf flag*/,"-2. static struct tftphdr *rw_init(int x)
-1. {

/*init crlf flag*/

1.   prevchar = -1;",Not Useful
/*ahead or behind?*/,"-2.   current = 0;
-1.   bfs[1].counter = BF_FREE;

/*ahead or behind?*/

1.   return &bfs[0].buf.hdr;
2. }
3. static struct tftphdr *w_init(void)
4. {",Not Useful
/*write-behind*/,"-1. /*
 * init for either read-ahead or write-behind.

/*write-behind*/

1.  * zero for write-behind, one for read-head.
2.  */
3. static struct tftphdr *rw_init(int x)
4. {",Not Useful
/*read-ahead*/,"-1. /*
 * init for either read-ahead or write-behind.

/*read-ahead*/

1.  * zero for write-behind, one for read-head.
2.  */
3. static struct tftphdr *rw_init(int x)
4. {",Not Useful
"/*The former file reading code did this:
       b->counter = read(fileno(file), dp->th_data, SEGSIZE);*/","-2.   dp = &b->buf.hdr;
-1.   if(convert == 0) {

/*The former file reading code did this:
       b->counter = read(fileno(file), dp->th_data, SEGSIZE);*/

1.     size_t copy_n = MIN(SEGSIZE, test->rcount);
2.     memcpy(dp->th_data, test->rptr, copy_n);",Not Useful
"/*decrease amount, advance pointer*/","-2.     size_t copy_n = MIN(SEGSIZE, test->rcount);
-1.     memcpy(dp->th_data, test->rptr, copy_n);

/*decrease amount, advance pointer*/

1.     test->rcount -= copy_n;
2.     test->rptr += copy_n;
3.     b->counter = (int)copy_n;
4.     return;
5.   }
",Not Useful
"/*lf to cr,lf*/","-9.     test->rcount -= copy_n;
-8.     test->rptr += copy_n;
-7.     b->counter = (int)copy_n;
-6.     return;
-5.   }
-4.   p = dp->th_data;
-3.   for(i = 0 ; i < SEGSIZE; i++) {
-2.     if(newline) {
-1.       if(prevchar == '\n')

/*lf to cr,lf*/

1. ",Not Useful
"/*cr to cr,nul*/","-1.       else

/*cr to cr,nul*/

1.       newline = 0;
2.     }
3.     else {
4.       if(test->rcount) {
5.         c = test->rptr[0];
6.         test->rptr++;
7.         test->rcount--;
8.       }
9.       else
10.         break;",Not Useful
/*set size of data to write*/,"-3. static int writeit(struct testcase *test, struct tftphdr * volatile *dpp,
-2.                    int ct, int convert)
-1. {

/*set size of data to write*/

111",Not Useful
/*switch to other buffer*/,"-4. static int writeit(struct testcase *test, struct tftphdr * volatile *dpp,
-3.                    int ct, int convert)
-2. {

/*switch to other buffer*/

111",Not Useful
/*if not free*/,"-7. {
-6.   int i;
-5.   char *p;
-4.   int c;
-3.   struct bf *b;
-2.   struct tftphdr *dp;

/*if not free*/

1.     return;",Not Useful
/*flush it*/,"-6. static int writeit(struct testcase *test, struct tftphdr * volatile *dpp,
-5.                    int ct, int convert)
-4. {

/*flush it*/

111",Not Useful
/*mark as alloc'd*/,"-7. static int writeit(struct testcase *test, struct tftphdr * volatile *dpp,
-6.                    int ct, int convert)
-5. {

/*mark as alloc'd*/

1.   *dpp =  &bfs[current].buf.hdr;",Not Useful
/*this is a lie of course*/,"-1.   *dpp =  &bfs[current].buf.hdr;

/*this is a lie of course*/

1. }",Not Useful
/*current character*/,"-10.  * CR, NUL -> CR  and CR, LF => LF.
-9.  * Note spec is undefined if we get CR as last byte of file or a
-8.  * CR followed by anything else.  In this case we leave it alone.
-7.  */
-6. static ssize_t write_behind(struct testcase *test, int convert)",Not Useful
/*anything to flush?*/,"-3.   struct bf *b;
-2.   struct tftphdr *dp;
-1.   b = &bfs[nextone];

/*anything to flush?*/

111",Not Useful
/*just nop if nothing to do*/,"-4.   struct bf *b;
-3.   struct tftphdr *dp;
-2.   b = &bfs[nextone];

/*just nop if nothing to do*/

1.   if(!test->ofile) {
2.     char outfile[256];
3.     msnprintf(outfile, sizeof(outfile), ""log/upload.%ld"", test->testno);
4. #ifdef WIN32
5.     tes",Not Useful
/*remember byte count*/,"-2.     }
-1.   }

/*remember byte count*/

111",Not Useful
/*reset flag*/,"-3.     }
-2.   }

/*reset flag*/

1.   dp = &b->buf.hdr;",Not Useful
/*incr for next time*/,"-1.   dp = &b->buf.hdr;

/*incr for next time*/

1.   writebuf = dp->th_data;
2.   if(count <= 0)",Not Useful
/*loop over the buffer*/,"-4.   if(convert == 0)
-3.     return write(test->ofile, writebuf, count);
-2.   p = writebuf;
-1.   ct = count;

/*loop over the buffer*/

111",Not Useful
/*pick up a character*/,"-5.   if(convert == 0)
-4.     return write(test->ofile, writebuf, count);
-3.   p = writebuf;
-2.   ct = count;

/*pick up a character*/

111",Not Useful
/*if prev char was cr*/,"-6.   if(convert == 0)
-5.     return write(test->ofile, writebuf, count);
-4.   p = writebuf;
-3.   ct = count;

/*if prev char was cr*/

111",Not Useful
"/*if have cr,lf then just*/","-7.   if(convert == 0)
-6.     return write(test->ofile, writebuf, count);
-5.   p = writebuf;
-4.   ct = count;

/*if have cr,lf then just*/

111",Not Useful
/*smash lf on top of the cr*/,"-8.   if(convert == 0)
-7.     return write(test->ofile, writebuf, count);
-6.   p = writebuf;
-5.   ct = count;

/*smash lf on top of the cr*/

1.       else",Not Useful
"/*if have cr,nul then*/","-1.       else

/*if have cr,nul then*/

111",Not Useful
/*just skip over the putc*/,"-2.       else

/*just skip over the putc*/

111",Not Useful
/*else just fall through and allow it*/,"-3.       else

/*else just fall through and allow it*/

1.     }",Not Useful
"/*formerly
       putc(c, file);*/","-5.       else

/*formerly
       putc(c, file);*/

1.     if(1 != write(test->ofile, &c, 1))
2.       break;
3.     skipit:
4.     prevchar = c;
5.   }
6.   return count;
7. }
8. /* When an error has occurred, it is possible that the two sides are out of",Not Useful
/*store input protocol*/,"-7.   FILE *server = fopen(REQUEST_DUMP, ""ab"");
-6.   if(!server) {
-5.     int error = errno;
-4.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-3.     logmsg(""Error opening file: %s"", REQUEST_DUMP);
-2.     return -1;
-1.   }

",Not Useful
/*no more options*/,"-10.   do {
-9.     bool endofit = true;
-8.     while(cp < &buf.storage[size]) {
-7.       if(*cp == '\0') {
-6.         endofit = false;
-5.         break;
-4.       }
-3.       cp++;
-2.     }
-1.     if(endofit)

/*no more options*/

1.       break;",Not Useful
/*No more options*/,"-5.         option = cp;
-4.       }
-3.       toggle ^= 1;
-2.     }
-1.     else

/*No more options*/

1.       break;
2.   } while(1);
3.   if(*cp) {
4.     nak(EBADOP);
5.     fclose(server);
6.     return 3;
7.   }",Not Useful
/*get to the letter following the newline*/,"-4.       check = strchr(cmd, '\r');
-3.       if(!check)
-2.         check = strchr(cmd, '\n');
-1.       if(check) {

/*get to the letter following the newline*/

1.         while((*check == '\r') || (*check == '\n'))
2.           check++;
3.         if",Not Useful
"/*if we reached a zero, get out*/","-3.         while((*check == '\r') || (*check == '\n'))
-2.           check++;
-1.         if(!*check)

/*if we reached a zero, get out*/

1.           break;
2.         cmd = check;
3.       }
4.       else
5.         break;
6.     }
7.     free(orgcmd);",Not Useful
/** Validate file access.*/,"-2. }
-1. /*
 * Validate file access.

/** Validate file access.*/

1.  */
2. static int validate_access(struct testcase *test,
3.                            const char *filename, int mode)
4. {
5.   char *ptr;
6.   logmsg(""trying to get file: %s mode %x""",Not Useful
/*set read pointer*/,"-10.                            const char *filename, int mode)
-9. {
-8.   char *ptr;
-7.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-6.   if(!strncmp(""verifiedserver"", filename, 14)) {
-5.     char weare[128];
-4.     size_t count = msn",Not Useful
/*set total count*/,"-10. {
-9.   char *ptr;
-8.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-7.   if(!strncmp(""verifiedserver"", filename, 14)) {
-6.     char weare[128];
-5.     size_t count = msnprintf(weare, sizeof(weare), ""WE ROOLZ: %""
-4.                 ",Not Useful
/*set data left to read*/,"-10.   char *ptr;
-9.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-8.   if(!strncmp(""verifiedserver"", filename, 14)) {
-7.     char weare[128];
-6.     size_t count = msnprintf(weare, sizeof(weare), ""WE ROOLZ: %""
-5.                       ",Not Useful
/*find the last slash*/,"-1.   }

/*find the last slash*/

1.   ptr = strrchr(filename, '/');
2.   if(ptr) {
3.     char partbuf[80]=""data"";
4.     long partno;
5.     long testno;
6.     FILE *stream;",Not Useful
/*set read pointer*/,"-10.                            const char *filename, int mode)
-9. {
-8.   char *ptr;
-7.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-6.   if(!strncmp(""verifiedserver"", filename, 14)) {
-5.     char weare[128];
-4.     size_t count = msn",Not Useful
/*set total count*/,"-10. {
-9.   char *ptr;
-8.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-7.   if(!strncmp(""verifiedserver"", filename, 14)) {
-6.     char weare[128];
-5.     size_t count = msnprintf(weare, sizeof(weare), ""WE ROOLZ: %""
-4.                 ",Not Useful
/*set data left to read*/,"-10.   char *ptr;
-9.   logmsg(""trying to get file: %s mode %x"", filename, mode);
-8.   if(!strncmp(""verifiedserver"", filename, 14)) {
-7.     char weare[128];
-6.     size_t count = msnprintf(weare, sizeof(weare), ""WE ROOLZ: %""
-5.                       ",Not Useful
/*block count*/,"-5. static void sendtftp(struct testcase *test, const struct formats *pf)
-4. {
-3.   int size;
-2.   ssize_t n;

/*block count*/

111",Not Useful
/*block count*/,"-5. static void sendtftp(struct testcase *test, const struct formats *pf)
-4. {
-3.   int size;
-2.   ssize_t n;

/*block count*/

111",Not Useful
/*really?*/,"-10.       alarm(rexmtval);
-9. #endif
-8.       logmsg(""read"");
-7.       n = sread(peer, rdp, PKTSIZE);
-6.       logmsg(""read: %zd"", n);
-5. #ifdef HAVE_ALARM
-4.       alarm(0);
-3. #endif
-2.       if(got_exit_signal)
-1.         goto abort;

/*reall",Not Useful
/*rexmit*/,"-2.         (void) synchnet(peer);
-1.         if(rdp->th_block == (recvblock-1))

/*rexmit*/

1.       }
2.     }
3.     size = writeit(test, &rdp, (int)(n - 4), pf->f_convert);",Not Useful
/*ahem*/,"-3.       }
-2.     }
-1.     size = writeit(test, &rdp, (int)(n - 4), pf->f_convert);

/*ahem*/

1.       if(size < 0)
2.         nak(errno + 100);
3.       else
4.         nak(ENOSPACE);
5.       goto abort;
6.     }
7.   } while(size == SEGSIZE);
8.   ",Not Useful
/*if read some data*/,"-6.   n = sread(peer, &buf.storage[0], sizeof(buf.storage));
-5. #ifdef HAVE_ALARM
-4.   alarm(0);
-3. #endif
-2.   if(got_exit_signal)
-1.     goto abort;

/*if read some data*/

111",Not Useful
/*and got a data block*/,"-7.   n = sread(peer, &buf.storage[0], sizeof(buf.storage));
-6. #ifdef HAVE_ALARM
-5.   alarm(0);
-4. #endif
-3.   if(got_exit_signal)
-2.     goto abort;

/*and got a data block*/

111",Not Useful
"/** This is a fake ntlm_auth, which is used for testing NTLM single-sign-on.
 * When DEBUGBUILD is defined, libcurl invoke this tool instead of real winbind
 * daemon helper /usr/bin/ntlm_auth. This tool will accept commands and
 * responses with a pre-written string saved in test case test2005.*/",#NAME?,Not Useful
"/** The purpose of this tool is to figure out which, if any, features that are
 * disabled which should otherwise exist and work. These aren't visible in
 * regular curl -V output.
 *
 * Disabled protocols are visible in curl_version_info() and are not included
 * in this table.*/",#NAME?,Not Useful
"/*argv1 = URL
 * argv2 = proxy
 * argv3 = proxyuser:password*/",#NAME?,Not Useful
/*bump*/,"-3.     fprintf(stderr, ""READ ALREADY DONE!\n"");
-2.     return 0;
-1.   }

/*bump*/

1.   if(size * nmemb > strlen(UPLOADTHIS)) {
2.     fprintf(stderr, ""READ!\n"");
3.     strcpy(ptr, UPLOADTHIS);
4.     return strlen(UPLOADTHIS);
5.   }
6.   fprintf(std",Not Useful
/*unused*/,"-10.     return strlen(UPLOADTHIS);
-9.   }
-8.   fprintf(stderr, ""READ NOT FINE!\n"");
-7.   return 0;
-6. }
-5. static curlioerr ioctlcallback(CURL *handle,
-4.                                int cmd,
-3.                                void *clientp)
-2.",Not Useful
/*clear counter to make the read callback restart*/,"-2.   if(cmd == CURLIOCMD_RESTARTREAD) {
-1.     fprintf(stderr, ""REWIND!\n"");

/*clear counter to make the read callback restart*/

1.   }
2.   return CURLIOE_OK;
3. }
4. #endif
5. int test(char *URL)
6. {
7.   CURLcode res;
8.   CURL *curl;
9. #ifndef L",Not Useful
/*always cleanup*/,"-2.   res = curl_easy_perform(curl);
-1. test_cleanup:

/*always cleanup*/

1.   curl_easy_cleanup(curl);
2.   curl_global_cleanup();
3.   return (int)res;
4. }",Not Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful
/** read-wrapper to support reading from stdin on Windows.*/,"-3. };
-2. #ifdef WIN32
-1. /*
 * read-wrapper to support reading from stdin on Windows.

/** read-wrapper to support reading from stdin on Windows.*/

1.  */
2. static ssize_t read_wincon(int fd, void *buf, size_t count)
3. {
4.   HANDLE handle = NULL;
5",Not Useful
/** write-wrapper to support writing to stdout and stderr on Windows.*/,"-10.   }
-9.   if(success) {
-8.     return rcount;
-7.   }
-6.   errno = GetLastError();
-5.   return -1;
-4. }
-3. #undef  read
-2. #define read(a,b,c) read_wincon(a,b,c)
-1. /*
 * write-wrapper to support writing to stdout and stderr on Windows.

/** w",Not Useful
/*actual handle to wait for during select*/,"-2.  */
-1. struct select_ws_wait_data {

/*actual handle to wait for during select*/

111",Not Useful
/*internal event to abort waiting thread*/,"-4.  */
-3. struct select_ws_wait_data {

/*internal event to abort waiting thread*/

111",Not Useful
/*get total size of file*/,"-10.         * - comparison of current position in file and total size of
-9.         *   the file can be used to check if we reached the end yet.
-8.         *
-7.         * Approach: Loop till either the internal event is signalled
-6.         *        ",Not Useful
/*get the current position within the file*/,"-6.           length = 0;
-5.           size.QuadPart = 0;
-4.           size.LowPart = GetFileSize(handle, &length);
-3.           if((size.LowPart != INVALID_FILE_SIZE) ||
-2.              (GetLastError() == NO_ERROR)) {
-1.             size.HighPart = ",Not Useful
"/*compare position with size, abort if not equal*/","-5.             pos.QuadPart = 0;
-4.             pos.LowPart = SetFilePointer(handle, 0, &pos.HighPart,
-3.                                         FILE_CURRENT);
-2.             if((pos.LowPart != INVALID_SET_FILE_POINTER) ||
-1.                (GetLast",Not Useful
/*sleep and continue waiting*/,"-1.               if(size.QuadPart == pos.QuadPart) {

/*sleep and continue waiting*/

1.                 SleepEx(0, FALSE);
2.                 ReleaseMutex(mutex);
3.                 continue;
4.               }
5.             }
6.           }",Not Useful
"/*there is some data available, stop waiting*/","-6.                 SleepEx(0, FALSE);
-5.                 ReleaseMutex(mutex);
-4.                 continue;
-3.               }
-2.             }
-1.           }

/*there is some data available, stop waiting*/

1.           logmsg(""[select_ws_wait_threa",Not Useful
/*check if this is an actual console handle*/,"-10.         * - WaitForMultipleObjectsEx will be signalled on any kind of input,
-9.         *   including mouse and window size events we do not care about.
-8.         *
-7.         * Approach: Loop till either the internal event is signalled
-6.      ",Not Useful
/*retrieve an event from the console buffer*/,"-1.           if(GetConsoleMode(handle, &ret)) {

/*retrieve an event from the console buffer*/

1.             length = 0;
2.             if(PeekConsoleInput(handle, &inputrecord, 1, &length)) {",Not Useful
/*check if the event is not an actual key-event*/,"-2.             length = 0;
-1.             if(PeekConsoleInput(handle, &inputrecord, 1, &length)) {

/*check if the event is not an actual key-event*/

1.               if(length == 1 && inputrecord.EventType != KEY_EVENT) {",Not Useful
/*purge the non-key-event and continue waiting*/,"-1.               if(length == 1 && inputrecord.EventType != KEY_EVENT) {

/*purge the non-key-event and continue waiting*/

1.                 ReadConsoleInput(handle, &inputrecord, 1, &length);
2.                 ReleaseMutex(mutex);
3.                 ",Not Useful
"/*there is some data available, stop waiting*/","-6.                 SleepEx(0, FALSE);
-5.                 ReleaseMutex(mutex);
-4.                 continue;
-3.               }
-2.             }
-1.           }

/*there is some data available, stop waiting*/

1.           logmsg(""[select_ws_wait_threa",Not Useful
/*peek into the pipe and retrieve the amount of data available*/,"-7.           break;
-6.         }
-5.       }
-4.       break;
-3.     case FILE_TYPE_PIPE:
-2.        /* The handle represents an anonymous or named pipe, this means:
-1.         * - WaitForMultipleObjectsEx will always be signalled for it.
        * - ",Not Useful
"/*if there is no data available, sleep and continue waiting*/","-2.           length = 0;
-1.           if(PeekNamedPipe(handle, NULL, 0, NULL, &length, NULL)) {

/*if there is no data available, sleep and continue waiting*/

1.             if(length == 0) {
2.               SleepEx(0, FALSE);
3.               Release",Not Useful
"/*there is some data available, stop waiting*/","-6.                 SleepEx(0, FALSE);
-5.                 ReleaseMutex(mutex);
-4.                 continue;
-3.               }
-2.             }
-1.           }

/*there is some data available, stop waiting*/

1.           logmsg(""[select_ws_wait_threa",Not Useful
"/*The handle has an unknown type, try to wait on it*/","-5.           break;
-4.         }
-3.       }
-2.       break;
-1.     default:

/*The handle has an unknown type, try to wait on it*/

1.       if(WaitForMultipleObjectsEx(2, handles, FALSE, INFINITE, FALSE)
2.          == WAIT_OBJECT_0 + 1) {
3.       ",Not Useful
/*allocate internal waiting data structure*/,"-10.       }
-9.       break;
-8.   }
-7.   return 0;
-6. }
-5. static HANDLE select_ws_wait(HANDLE handle, HANDLE signal,
-4.                              HANDLE abort, HANDLE mutex)
-3. {
-2.   struct select_ws_wait_data *data;
-1.   HANDLE thread = NUL",Not Useful
/*free data if thread failed to launch*/,"-3.     thread = CreateThread(NULL, 0,
-2.                           &select_ws_wait_thread,
-1.                           data, 0, NULL);

/*free data if thread failed to launch*/

1.     if(!thread) {
2.       free(data);
3.     }
4.   }
5.   return thr",Not Useful
/*check if the input value is valid*/,"-10.                      fd_set *exceptfds, struct timeval *tv)
-9. {
-8.   HANDLE abort, mutex, signal, handle, *handles;
-7.   DWORD timeout_ms, wait, nfd, nth, nws, i;
-6.   fd_set readsock, writesock, exceptsock;
-5.   struct select_ws_data *data;
-4",Not Useful
/*convert struct timeval to milliseconds*/,"-4.   if(nfds < 0) {
-3.     errno = EINVAL;
-2.     return -1;
-1.   }

/*convert struct timeval to milliseconds*/

1.   if(tv) {
2.     timeout_ms = (DWORD)curlx_tvtoms(tv);
3.   }
4.   else {
5.     timeout_ms = INFINITE;
6.   }",Not Useful
"/*first handle stdin, stdout and stderr*/","-2.     if(wait != WAIT_FAILED && (wait - WAIT_OBJECT_0) <= i &&
-1.        WaitForSingleObjectEx(handle, 0, FALSE) == WAIT_OBJECT_0) {

/*first handle stdin, stdout and stderr*/

1.       if(fd == fileno(stdin)) {",Not Useful
/*sockfd turns CURL_SOCKET_BAD when our connection has been closed*/,"-6.       FD_SET(sockfd, &fds_read);
-5.       maxfd = (int)sockfd;
-4.     }
-3.     break;
-2.   case ACTIVE:
-1.     sockfd = *sockfdp;

/*sockfd turns CURL_SOCKET_BAD when our connection has been closed*/

1.     if(CURL_SOCKET_BAD != sockfd) {
2.    ",Not Useful
/*switch(*mode)*/,"-10.     logmsg(""process becomes orphan, exiting"");
-9.     return FALSE;
-8.   }
-7. #endif
-6.   timeout.tv_sec = 120;
-5.   timeout.tv_usec = 0;
-4.   FD_ZERO(&fds_read);
-3.   FD_ZERO(&fds_write);
-2.   FD_ZERO(&fds_err);
-1.   FD_SET((curl_socket_t)f",Not Useful
/*timeout*/,"-5. };
-4. static int select_ws(int nfds, fd_set *readfds, fd_set *writefds,
-3.                      fd_set *exceptfds, struct timeval *tv)
-2. {
-1.   HANDLE abort, mutex, signal, handle, *handles;
  DWORD timeout_ms, wait, nfd, nth, nws, i;

/*timeout*",Not Useful
"/*send reply on stdout, just proving we are alive*/","-10.        4-digit hexadecimal data length + LF [if the command takes data]
-9.        data                       [the data being as long as set above]
-8.        Commands:
-7.        DATA - plain pass-through data
-6.     */
-5.     if(!read_stdin(buffe",Not Useful
/*just die*/,"-10.          Replies to PORT with ""IPv[num]/[port]"" */
-9.       msnprintf((char *)buffer, sizeof(buffer), ""%s/%hu\n"", ipv_inuse, port);
-8.       buffer_len = (ssize_t)strlen((char *)buffer);
-7.       msnprintf(data, sizeof(data), ""PORT\n%04zx\n"", buff",Not Useful
/*store the new socket*/,"-10.       curl_socket_t newfd = accept(sockfd, NULL, NULL);
-9.       if(CURL_SOCKET_BAD == newfd) {
-8.         error = SOCKERRNO;
-7.         logmsg(""accept(%d, NULL, NULL) failed with error: (%d) %s"",
-6.                sockfd, error, strerror(error))",Not Useful
/*we have connected*/,"-10.       if(CURL_SOCKET_BAD == newfd) {
-9.         error = SOCKERRNO;
-8.         logmsg(""accept(%d, NULL, NULL) failed with error: (%d) %s"",
-7.                sockfd, error, strerror(error));
-6.       }
-5.       else {
-4.         logmsg(""====> Cli",Not Useful
"/*read from socket, pass on data to stdout*/","-3.       }
-2.       return TRUE;
-1.     }

/*read from socket, pass on data to stdout*/

1.     nread_socket = sread(sockfd, buffer, sizeof(buffer));
2.     if(nread_socket > 0) {
3.       msnprintf(data, sizeof(data), ""DATA\n%04zx\n"", nread_socket);
4",Not Useful
/*double the sleep for next attempt*/,"-10.                  error, strerror(error));
-9.           sclose(sock);
-8.           return CURL_SOCKET_BAD;
-7.         }
-6.         if(got_exit_signal) {
-5.           logmsg(""signalled to die, exiting..."");
-4.           sclose(sock);
-3.         ",Not Useful
/*ENABLE_IPV6*/,"-8. #endif
-7. #define DEFAULT_PORT 8999
-6. #ifndef DEFAULT_LOGFILE
-5. #define DEFAULT_LOGFILE ""log/sockfilt.log""
-4. #endif
-3. const char *serverlogfile = DEFAULT_LOGFILE;
-2. static bool verbose = FALSE;
-1. static bool bind_only = FALSE;
#ifdef ENAB",Not Useful
/*start accepting connections*/,"-4.   if(bind_only) {
-3.     logmsg(""instructed to bind port without listening"");
-2.     return sock;
-1.   }

/*start accepting connections*/

1.   rc = listen(sock, 5);
2.   if(0 != rc) {
3.     error = SOCKERRNO;
4.     logmsg(""listen(%d, 5) failed w",Not Useful
/*default*/,"-10.       width += 2;
-9.       optr += 2;
-8.       left -= 2;
-7.       break;
-6.     case '\r':
-5.       msnprintf(optr, left, ""\\r"");
-4.       width += 2;
-3.       optr += 2;
-2.       left -= 2;
-1.       break;
    default:

/*default*/

1.    ",Not Useful
/*ENABLE_IPV6*/,"-8. #endif
-7. #define DEFAULT_PORT 8999
-6. #ifndef DEFAULT_LOGFILE
-5. #define DEFAULT_LOGFILE ""log/sockfilt.log""
-4. #endif
-3. const char *serverlogfile = DEFAULT_LOGFILE;
-2. static bool verbose = FALSE;
-1. static bool bind_only = FALSE;
#ifdef ENAB",Not Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  EAGAIN",Not Useful
/*previous test number we served*/,"-10.   , socket_domain_inet6 = AF_INET6
-9. #endif
-8. #ifdef USE_UNIX_SOCKETS
-7.   , socket_domain_unix = AF_UNIX
-6. #endif
-5. } socket_domain = AF_INET;
-4. static bool use_gopher = FALSE;
-3. static int serverlogslocked = 0;
-2. static bool is_proxy",Not Useful
/*previous part number we served*/,"-10. #endif
-9. #ifdef USE_UNIX_SOCKETS
-8.   , socket_domain_unix = AF_UNIX
-7. #endif
-6. } socket_domain = AF_INET;
-5. static bool use_gopher = FALSE;
-4. static int serverlogslocked = 0;
-3. static bool is_proxy = FALSE;
-2. #define REQBUFSIZ (2*1024",Not Useful
/*buffer area for the incoming request*/,"-1. struct httprequest {

/*buffer area for the incoming request*/

111",Not Useful
/*if a CONNECT*/,"-2. struct httprequest {

/*if a CONNECT*/

111",Not Useful
/*the port number CONNECT used*/,"-3. struct httprequest {

/*the port number CONNECT used*/

111",Not Useful
/*where to start checking of the request*/,"-4. struct httprequest {

/*where to start checking of the request*/

111",Not Useful
/*size of the incoming request*/,"-5. struct httprequest {

/*size of the incoming request*/

111",Not Useful
/*test number found in the request*/,"-6. struct httprequest {

/*test number found in the request*/

111",Not Useful
/*part number found in the request*/,"-7. struct httprequest {

/*part number found in the request*/

111",Not Useful
/*Authorization header present in the incoming request*/,"-10.   char reqbuf[REQBUFSIZ]; /* buffer area for the incoming request */
-9.   bool connect_request; /* if a CONNECT */
-8.   unsigned short connect_port; /* the port number CONNECT used */
-7.   size_t checkindex; /* where to start checking of the reque",Not Useful
/*Content-Length of the incoming request*/,"-10.   bool connect_request; /* if a CONNECT */
-9.   unsigned short connect_port; /* the port number CONNECT used */
-8.   size_t checkindex; /* where to start checking of the request */
-7.   size_t offset;     /* size of the incoming request */
-6.   l",Not Useful
/*Authorization digest header found*/,"-10.   unsigned short connect_port; /* the port number CONNECT used */
-9.   size_t checkindex; /* where to start checking of the request */
-8.   size_t offset;     /* size of the incoming request */
-7.   long testno;       /* test number found in the r",Not Useful
/*Authorization ntlm header found*/,"-10.   size_t checkindex; /* where to start checking of the request */
-9.   size_t offset;     /* size of the incoming request */
-8.   long testno;       /* test number found in the request */
-7.   long partno;       /* part number found in the request",Not Useful
"/*if non-zero, delay this number of seconds between
                     writes in the response*/","-10.   size_t offset;     /* size of the incoming request */
-9.   long testno;       /* test number found in the request */
-8.   long partno;       /* part number found in the request */
-7.   bool open;      /* keep connection open info, as found in th",Not Useful
"/*if non-zero, the server is instructed to not read this
                     many bytes from a PUT/POST request. Ie the client sends N
                     bytes said in Content-Length, but the server only reads N
                     - skip bytes.*/","-10.   long partno;       /* part number found in the request */
-9.   bool open;      /* keep connection open info, as found in the request */
-8.   bool auth_req;  /* authentication required, don't wait for body unless
-7.                      there's a",Not Useful
"/*doing a special command, see defines above*/","-10.   bool auth;      /* Authorization header present in the incoming request */
-9.   size_t cl;      /* Content-Length of the incoming request */
-8.   bool digest;    /* Authorization digest header found */
-7.   bool ntlm;      /* Authorization ntlm ",Not Useful
/*times ProcessRequest() gets called*/,"-10.   bool digest;    /* Authorization digest header found */
-9.   bool ntlm;      /* Authorization ntlm header found */
-8.   int writedelay; /* if non-zero, delay this number of seconds between
-7.                      writes in the response */
-6.   ",Not Useful
/*upgrade request found and allowed*/,"-10.                      many bytes from a PUT/POST request. Ie the client sends N
-9.                      bytes said in Content-Length, but the server only reads N
-8.                      - skip bytes. */

/*upgrade request found and allowed*/

111",Not Useful
"/*similar to swsclose in response: close connection after
                     response is sent*/","-10.                      bytes said in Content-Length, but the server only reads N
-9.                      - skip bytes. */

/*similar to swsclose in response: close connection after
                     response is sent*/

1.   int done_processing;
2. ",Not Useful
/*very-big-path support*/,"-2. #define DEFAULT_CMDFILE ""log/ftpserver.cmd""
-1. const char *cmdfile = DEFAULT_CMDFILE;

/*very-big-path support*/

1. #define MAXDOCNAMELEN 140000
2. #define MAXDOCNAMELEN_TXT ""139999""
3. #define REQUEST_KEYWORD_SIZE 256
4. #define REQUEST_KEYWORD_SIZ",Not Useful
/*close connection*/,"-10.                      bytes said in Content-Length, but the server only reads N
-9.                      - skip bytes. */

/*close connection*/

1.                      response is sent */
2.   int done_processing;
3. };
4. #define MAX_SOCKETS 1024
5.",Not Useful
"/*IETF//DTD HTML 2.0//EN\"">\n""*/","-5. static const char *doc404 = ""HTTP/1.1 404 Not Found\r\n""
-4.     ""Server: "" SWSVERSION ""\r\n""
-3.     ""Connection: close\r\n""
-2.     ""Content-Type: text/html""
-1.     END_OF_HEADERS

/*IETF//DTD HTML 2.0//EN\"">\n""*/

1.     ""<HTML><HEAD>\n""
2.     ""<",Not Useful
/*returns true if the current socket is an IP one*/,"-1. static int already_recv_zeroed_chunk = FALSE;

/*returns true if the current socket is an IP one*/

1. static bool socket_domain_is_ip(void)
2. {
3.   switch(socket_domain) {
4.   case AF_INET:
5. #ifdef ENABLE_IPV6
6.   case AF_INET6:
7. #endif
8.   ",Not Useful
/*case AF_UNIX:*/,"-9. static bool socket_domain_is_ip(void)
-8. {
-7.   switch(socket_domain) {
-6.   case AF_INET:
-5. #ifdef ENABLE_IPV6
-4.   case AF_INET6:
-3. #endif
-2.     return true;
-1.   default:

/*case AF_UNIX:*/

1.     return false;
2.   }
3. }",Not Useful
"/*based on the testno, parse the correct server commands*/","-10.     while(fgets(buf, sizeof(buf), f)) {
-9.       if(1 == sscanf(buf, ""Testnum %d"", &testnum)) {
-8.         logmsg(""[%s] cmdfile says testnum %d"", cmdfile, testnum);
-7.         req->testno = testnum;
-6.       }
-5.     }
-4.     fclose(f);
-3.   }",Not Useful
/*closes connection*/,"-10. {
-9.   FILE *stream;
-8.   int error;
-7.   stream = test2fopen(req->testno);
-6.   req->close = FALSE;
-5.   req->connmon = FALSE;
-4.   if(!stream) {
-3.     error = errno;
-2.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error))",Not Useful
/*closes connection*/,"-10. {
-9.   FILE *stream;
-8.   int error;
-7.   stream = test2fopen(req->testno);
-6.   req->close = FALSE;
-5.   req->connmon = FALSE;
-4.   if(!stream) {
-3.     error = errno;
-2.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error))",Not Useful
/*try to deal with CRLF or just LF*/,"-10.         logmsg(""instructed to reject Expect: 100-continue"");
-9.         req->noexpect = TRUE;
-8.       }
-7.       else if(1 == sscanf(cmd, ""writedelay: %d"", &num)) {
-6.         logmsg(""instructed to delay %d secs between packets"", num);
-5.      ",Not Useful
/*get to the letter following the newline*/,"-4.       check = strchr(cmd, '\r');
-3.       if(!check)
-2.         check = strchr(cmd, '\n');
-1.       if(check) {

/*get to the letter following the newline*/

1.         while((*check == '\r') || (*check == '\n'))
2.           check++;
3.         if",Not Useful
"/*if we reached a zero, get out*/","-3.         while((*check == '\r') || (*check == '\n'))
-2.           check++;
-1.         if(!*check)

/*if we reached a zero, get out*/

1.           break;
2.         cmd = check;
3.       }
4.       else
5.         break;
6.     }
7.     free(orgcmd);",Not Useful
/*find the last slash*/,"-10.   }
-9.   else if((req->testno == DOCNUMBER_NOTHING) &&
-8.      sscanf(line,
-7.             ""%"" REQUEST_KEYWORD_SIZE_TXT""s %"" MAXDOCNAMELEN_TXT ""s HTTP/%d.%d"",
-6.             request,
-5.             doc,
-4.             &prot_major,
-3.          ",Not Useful
/*get the number after it*/,"-1.     ptr = strrchr(doc, '/');

/*get the number after it*/

1.     if(ptr) {
2.       if((strlen(doc) + strlen(request)) < 400)
3.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s HTTP/%d.%d"",
4.                   request, doc, prot_major,",Not Useful
/*skip the slash*/,"-1.       }

/*skip the slash*/

111",Not Useful
/*find the last dot*/,"-10.             req->connect_port = curlx_ultous(ulnum);
-9.         }
-8.         logmsg(""Port number: %d, test case number: %ld"",
-7.                req->connect_port, req->testno);
-6.       }
-5.     }
-4.     if(req->testno == DOCNUMBER_NOTHING) {

",Not Useful
/*skip the dot*/,"-2.       if(ptr) {
-1.         long num;

/*skip the dot*/

1.         num = strtol(ptr, &ptr, 10);
2.         if(num) {
3.           req->testno = num;
4.           if(req->testno > 10000) {
5.             req->partno = req->testno % 10000;
6.          ",Not Useful
/*not complete yet*/,"
    logmsg(""request not complete yet"");



/*not complete yet*/

111",Not Useful
/*find the last slash in the line*/,"-1.     char *ptr;

/*find the last slash in the line*/

1.     ptr = strrchr(line, '/');
2.     if(ptr) {",Not Useful
/*skip the slash*/,"-1.       }

/*skip the slash*/

111",Not Useful
/*closes connection*/,"-10. {
-9.   FILE *stream;
-8.   int error;
-7.   stream = test2fopen(req->testno);
-6.   req->close = FALSE;
-5.   req->connmon = FALSE;
-4.   if(!stream) {
-3.     error = errno;
-2.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error))",Not Useful
/*header found*/,"-10.   unsigned short connect_port; /* the port number CONNECT used */
-9.   size_t checkindex; /* where to start checking of the request */
-8.   size_t offset;     /* size of the incoming request */
-7.   long testno;       /* test number found in the r",Not Useful
/*NTLM found*/,"-1.     req->partno += 1002;

/*NTLM found*/

1.     logmsg(""Received NTLM type-3, sending back data %ld"", req->partno);
2.     if(req->cl) {
3.       logmsg(""  Expecting %zu POSTed bytes"", req->cl);
4.     }
5.   }
6.   else if(!req->ntlm &&
7.          ",Not Useful
/*NTLM found*/,"-1.     req->partno += 1002;

/*NTLM found*/

1.     logmsg(""Received NTLM type-3, sending back data %ld"", req->partno);
2.     if(req->cl) {
3.       logmsg(""  Expecting %zu POSTed bytes"", req->cl);
4.     }
5.   }
6.   else if(!req->ntlm &&
7.          ",Not Useful
/*we allow upgrade and there was one!*/,"-2.   }
-1.   if(req->upgrade && strstr(req->reqbuf, ""Upgrade:"")) {

/*we allow upgrade and there was one!*/

1.     logmsg(""Found Upgrade: in request and allows it"");
2.     req->upgrade_request = TRUE;
3.   }
4.   if(req->cl > 0) {
5.     if(req->cl <= ",Not Useful
/*continue with business as usual*/,"-10.   bool persistent = TRUE;
-9.   bool sendfailure = FALSE;
-8.   size_t responsesize;
-7.   int error = 0;
-6.   int res;
-5.   const char *responsedump = is_proxy?RESPONSE_PROXY_DUMP:RESPONSE_DUMP;
-4.   static char weare[256];
-3.   switch(req->rcmd",Not Useful
/*Do nothing. Sit idle. Pretend it rains.*/,"-10.       written = swrite(sock, STREAMTHIS, count);
-9.       if(got_exit_signal)
-8.         return -1;
-7.       if(written != (ssize_t)count) {
-6.         logmsg(""Stopped streaming"");
-5.         break;
-4.       }
-3.     }
-2.     return -1;
-1.  ",Not Useful
/*write to file as well*/,"-10.     retry:
-9.     written = swrite(sock, buffer, num);
-8.     if(written < 0) {
-7.       if((EWOULDBLOCK == SOCKERRNO) || (EAGAIN == SOCKERRNO)) {
-6.         wait_ms(10);
-5.         goto retry;
-4.       }
-3.       sendfailure = TRUE;
-2.      ",Not Useful
/*USE_UNIX_SOCKETS*/,"-6. #endif
-5. static enum {
-4.   socket_domain_inet = AF_INET
-3. #ifdef ENABLE_IPV6
-2.   , socket_domain_inet6 = AF_INET6
-1. #endif
#ifdef USE_UNIX_SOCKETS

/*USE_UNIX_SOCKETS*/

1.   , socket_domain_unix = AF_UNIX
2. #endif
3. } socket_domain = AF_I",Not Useful
/*number of bytes to client*/,"-10. #define data_or_ctrl(x) ((x)?""DATA"":""CTRL"")
-9. #define CTRL  0
-8. #define DATA  1
-7. static void http_connect(curl_socket_t *infdp,
-6.                          curl_socket_t rootfd,
-5.                          const char *ipaddr,
-4.            ",Not Useful
/*number of bytes to server*/,"-10. #define CTRL  0
-9. #define DATA  1
-8. static void http_connect(curl_socket_t *infdp,
-7.                          curl_socket_t rootfd,
-6.                          const char *ipaddr,
-5.                          unsigned short ipport)
-4. {
-3.  ",Not Useful
/*1000 ms*/,"-5.   max_tunnel_idx = CTRL;
-4.   primary = TRUE;
-3.   while(!got_exit_signal) {
-2.     fd_set input;
-1.     fd_set output;

/*1000 ms*/

1.     ssize_t rc;
2.     curl_socket_t maxfd = (curl_socket_t)-1;
3.     FD_ZERO(&input);
4.     FD_ZERO(&output",Not Useful
/*----------------------------------------------------------*/,"-2.       bool tcp_fin_wr = FALSE;
-1.       timeout_count = 0;

/*----------------------------------------------------------*/

111",Not Useful
/*----------------------------------------------------------*/,"-2.       bool tcp_fin_wr = FALSE;
-1.       timeout_count = 0;

/*----------------------------------------------------------*/

111",Not Useful
/*read from client*/,"-5.       for(i = 0; i <= max_tunnel_idx; i++) {
-4.         size_t len;
-3.         if(clientfd[i] != CURL_SOCKET_BAD) {
-2.           len = sizeof(readclient[i]) - tos[i];
-1.           if(len && FD_ISSET(clientfd[i], &input)) {

/*read from client*/

1",Not Useful
/*read from server*/,"-10.               logmsg(""[%s] READ %zd bytes from client"", data_or_ctrl(i), rc);
-9.               logmsg(""[%s] READ \""%s\"""", data_or_ctrl(i),
-8.                      data_to_hex(&readclient[i][tos[i]], rc));
-7.               tos[i] += rc;
-6.        ",Not Useful
/*write to client*/,"-10.             else {
-9.               logmsg(""[%s] READ %zd bytes from server"", data_or_ctrl(i), rc);
-8.               logmsg(""[%s] READ \""%s\"""", data_or_ctrl(i),
-7.                      data_to_hex(&readserver[i][toc[i]], rc));
-6.               to",Not Useful
/*write to server*/,"-10.               logmsg(""[%s] SENT \""%s\"""", data_or_ctrl(i),
-9.                      data_to_hex(readserver[i], rc));
-8.               if(toc[i] - rc)
-7.                 memmove(&readserver[i][0], &readserver[i][rc], toc[i]-rc);
-6.               toc",Not Useful
/*----------------------------------------------------------*/,"-2.       bool tcp_fin_wr = FALSE;
-1.       timeout_count = 0;

/*----------------------------------------------------------*/

111",Not Useful
/*----------------------------------------------------------*/,"-2.       bool tcp_fin_wr = FALSE;
-1.       timeout_count = 0;

/*----------------------------------------------------------*/

111",Not Useful
/*(rc > 0)*/,"-10.         }
-9.       }
-8.     }
-7.     if(got_exit_signal)
-6.       break;
-5.     do {
-4.       rc = select((int)maxfd + 1, &input, &output, NULL, &timeout);
-3.     } while(rc < 0 && errno == EINTR && !got_exit_signal);
-2.     if(got_exit_signa",Not Useful
/*left to implement*/,"-10.        (clientfd[i] != CURL_SOCKET_BAD)) {
-9.       logmsg(""[%s] ABORTING"", data_or_ctrl(i));
-8.     }
-7.   }
-6.   *infdp = CURL_SOCKET_BAD;
-5. }
-4. static void http2(struct httprequest *req)
-3. {
-2.   (void)req;
-1.   logmsg(""switched to htt",Not Useful
/*nothing to accept*/,"-10.   }
-9.   msgsock = accept(sock, NULL, NULL);
-8.   if(got_exit_signal) {
-7.     if(CURL_SOCKET_BAD != msgsock)
-6.       sclose(msgsock);
-5.     return CURL_SOCKET_BAD;
-4.   }
-3.   if(CURL_SOCKET_BAD == msgsock) {
-2.     error = SOCKERRNO;
-1. ",Not Useful
/*bounce treatment requested*/,"-4.       return rc;
-3.     }
-2.   }
-1.   if(prevbounce) {

/*bounce treatment requested*/

1.     if((req->testno == prevtestno) &&
2.        (req->partno == prevpartno)) {
3.       req->partno++;
4.       logmsg(""BOUNCE part number to %ld"", req->part",Not Useful
"/*an upgrade request, switch to http2 here*/","-10.     if(!is_proxy) {
-9.       logmsg(""received CONNECT but isn't running as proxy!"");
-8.       return 1;
-7.     }
-6.     else {
-5.       http_connect(&msgsock, listensock, connecthost, req->connect_port);
-4.       return -1;
-3.     }
-2.   }
-1",Not Useful
/*a default CONNECT port is basically pointless but still ...*/,"-10.   const char *pidname = "".http.pid"";
-9.   const char *portname = "".http.port"";
-8.   struct httprequest *req = NULL;
-7.   int rc = 0;
-6.   int error;
-5.   int arg = 1;
-4.   const char *connecthost = ""127.0.0.1"";
-3.   const char *socket_type = """,Not Useful
/*gopher style is much simpler*/,"-10.         serverlogfile = argv[arg++];
-9.     }
-8.     else if(!strcmp(""--cmdfile"", argv[arg])) {
-7.       arg++;
-6.       if(argc>arg)
-5.         cmdfile = argv[arg++];
-4.     }
-3.     else if(!strcmp(""--gopher"", argv[arg])) {
-2.       arg++;
",Not Useful
"/*listen succeeds, so let's assume a valid listening Unix socket*/","-8.   rc = listen(sock, 5);
-7.   if(0 != rc) {
-6.     error = SOCKERRNO;
-5.     logmsg(""listen() failed with error: (%d) %s"",
-4.            error, strerror(error));
-3.     goto sws_cleanup;
-2.   }
-1. #ifdef USE_UNIX_SOCKETS

/*listen succeeds, so l",Not Useful
/*250 ms*/,"-4.   init_httprequest(req);
-3.   for(;;) {
-2.     fd_set input;
-1.     fd_set output;

/*250 ms*/

1.     curl_socket_t maxfd = (curl_socket_t)-1;
2.     int active;",Not Useful
/*Listen on all sockets*/,"-3.     FD_ZERO(&input);
-2.     FD_ZERO(&output);
-1.     for(socket_idx = 0; socket_idx < num_sockets; ++socket_idx) {

/*Listen on all sockets*/

1.       FD_SET(all_sockets[socket_idx], &input);
2.       if(all_sockets[socket_idx] > maxfd)
3.         ",Not Useful
/*Timed out - try again*/,"-10.     } while(rc < 0 && errno == EINTR && !got_exit_signal);
-9.     if(got_exit_signal)
-8.       goto sws_cleanup;
-7.     if(rc < 0) {
-6.       error = SOCKERRNO;
-5.       logmsg(""select() failed with error: (%d) %s"",
-4.              error, strer",Not Useful
"/*When instructed to close connection after server-reply we
                 wait a very small amount of time before doing so. If this
                 is not done client might get an ECONNRESET before reading
                 a single byte of server-reply.*/","-10.                                   connecthost);
-9.           if(got_exit_signal)
-8.             goto sws_cleanup;
-7.           if(rc < 0) {
-6.             logmsg(""====> Client disconnect %d"", req->connmon);
-5.             if(req->connmon) {
-4. ",Not Useful
/*copy one single byte*/,"-10. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-9. {
-8.   struct WriteThis *pooh = (struct WriteThis *)userp;
-7.   int eof = !*pooh->readptr;
-6.   if(size*nmemb < 1)
-5.     return 0;
-4.   eof = pooh->sizeleft <= 0",Not Useful
/*advance pointer*/,"-10. {
-9.   struct WriteThis *pooh = (struct WriteThis *)userp;
-8.   int eof = !*pooh->readptr;
-7.   if(size*nmemb < 1)
-6.     return 0;
-5.   eof = pooh->sizeleft <= 0;
-4.   if(!eof)
-3.     pooh->sizeleft--;
-2.   if(!eof) {

/*advance pointer*/

1",Not Useful
"/*Now free the mime structure: it should unbind it from the first
     easy handle.*/","-6.   easy2 = curl_easy_duphandle(easy);
-5.   if(!easy2) {
-4.     fprintf(stderr, ""curl_easy_duphandle() failed\n"");
-3.     res = TEST_ERR_FAILURE;
-2.     goto test_cleanup;
-1.   }

/*Now free the mime structure: it should unbind it from the first
  ",Not Useful
/*Already cleaned up.*/,"-1.   curl_mime_free(mime);

/*Already cleaned up.*/

111",Not Useful
"/*Free the duplicated handle: it should call free_callback again.
     If the mime copy was bad or not automatically released, valgrind
     will signal it.*/","-6.   result = curl_easy_perform(easy2);
-5.   if(result) {
-4.     fprintf(stderr, ""curl_easy_perform(duplicated) failed\n"");
-3.     res = (int) result;
-2.     goto test_cleanup;
-1.   }

/*Free the duplicated handle: it should call free_callback again",Not Useful
/*Already cleaned up.*/,"-1.   curl_mime_free(mime);

/*Already cleaned up.*/

111",Not Useful
/*Test CURLINFO_SCHEME*/,#NAME?,Not Useful
/*number of sockets actually stored in array*/,"-10.  ***************************************************************************/
-9. #include ""test.h""
-8. #include <fcntl.h>
-7. #include ""testutil.h""
-6. #include ""warnless.h""
-5. #include ""memdebug.h""
-4. #define TEST_HANG_TIMEOUT 60 * 1000
-3. struc",Not Useful
/*max number of sockets that fit in allocated array*/,"-10. #include ""test.h""
-9. #include <fcntl.h>
-8. #include ""testutil.h""
-7. #include ""warnless.h""
-6. #include ""memdebug.h""
-5. #define TEST_HANG_TIMEOUT 60 * 1000
-4. struct Sockets
-3. {
-2.   curl_socket_t *sockets;

/*max number of sockets that fit in",Not Useful
/*cleanup in test_cleanup*/,"-10.     sockets->sockets = malloc(sizeof(curl_socket_t) * 20U);
-9.     if(!sockets->sockets)
-8.       return;
-7.     sockets->max_count = 20;
-6.   }
-5.   else if(sockets->count + 1 > sockets->max_count) {
-4.     curl_socket_t *oldptr = sockets->soc",Not Useful
/*unused*/,"-4. static int curlSocketCallback(CURL *easy, curl_socket_t s, int action,
-3.                               void *userp, void *socketp)
-2. {
-1.   struct ReadWriteSockets *sockets = userp;

/*unused*/

111",Not Useful
/*unused*/,"-4. static int curlSocketCallback(CURL *easy, curl_socket_t s, int action,
-3.                               void *userp, void *socketp)
-2. {
-1.   struct ReadWriteSockets *sockets = userp;

/*unused*/

111",Not Useful
/*unused*/,"-4. static int curlSocketCallback(CURL *easy, curl_socket_t s, int action,
-3.                               void *userp, void *socketp)
-2. {
-1.   struct ReadWriteSockets *sockets = userp;

/*unused*/

111",Not Useful
/*get the file size of the local file*/,"-10.     fprintf(stderr, ""Usage: lib582 [url] [filename] [username]\n"");
-9.     return TEST_ERR_USAGE;
-8.   }
-7.   hd_src = fopen(libtest_arg2, ""rb"");
-6.   if(!hd_src) {
-5.     fprintf(stderr, ""fopen() failed with error: %d (%s)\n"",
-4.             e",Not Useful
/*enable uploading*/,"-10.     fclose(hd_src);
-9.     return TEST_ERR_FSTAT;
-8.   }
-7.   fprintf(stderr, ""Set to upload %d bytes\n"", (int)file_info.st_size);
-6.   res_global_init(CURL_GLOBAL_ALL);
-5.   if(res) {
-4.     fclose(hd_src);
-3.     return res;
-2.   }
-1.   ea",Not Useful
/*specify target*/,"-1.   easy_setopt(curl, CURLOPT_UPLOAD, 1L);

/*specify target*/

1.   easy_setopt(curl, CURLOPT_URL, URL);",Not Useful
/*go verbose*/,"-1.   easy_setopt(curl, CURLOPT_URL, URL);

/*go verbose*/

1.   easy_setopt(curl, CURLOPT_VERBOSE, 1L);",Not Useful
/*now specify which file to upload*/,"-1.   easy_setopt(curl, CURLOPT_VERBOSE, 1L);

/*now specify which file to upload*/

1.   easy_setopt(curl, CURLOPT_READDATA, hd_src);
2.   easy_setopt(curl, CURLOPT_USERPWD, libtest_arg3);
3.   easy_setopt(curl, CURLOPT_SSH_PUBLIC_KEYFILE, ""curl_client_k",Not Useful
/*Curl's timer has elapsed.*/,"-3.     checkFdSet(m, &sockets.read, &readSet, CURL_CSELECT_IN, ""read"");
-2.     checkFdSet(m, &sockets.write, &writeSet, CURL_CSELECT_OUT, ""write"");
-1.     if(timeout.tv_sec != -1 && getMicroSecondTimeout(&timeout) == 0) {

/*Curl's timer has elapsed.*/",Not Useful
/*we don't use this*/,"-10. #include ""memdebug.h""
-9. int test(char *URL)
-8. {
-7.   const unsigned char a[] = {0x2f, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
-6.                              0x91, 0xa2, 0xb3, 0xc4, 0xd5, 0xe6, 0xf7};
-5.   CURLcode res = CURLE_OK;
-4.   char *ptr ",Not Useful
/*deprecated API*/,"-8.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-7.     fprintf(stderr, ""curl_global_init() failed\n"");
-6.     return TEST_ERR_MAJOR_BAD;
-5.   }
-4.   asize = (int)sizeof(a);
-3.   ptr = curl_easy_escape(NULL, (char *)a, asize);
-2.   printf(""",Not Useful
/*deprecated API*/,"-8.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-7.     fprintf(stderr, ""curl_global_init() failed\n"");
-6.     return TEST_ERR_MAJOR_BAD;
-5.   }
-4.   asize = (int)sizeof(a);
-3.   ptr = curl_easy_escape(NULL, (char *)a, asize);
-2.   printf(""",Not Useful
/*unused*/,"-10. int test(char *URL)
-9. {
-8.   CURLM *handle;
-7.   int res = CURLE_OK;
-6.   static const char * const bl_servers[] =
-5.      {""Microsoft-IIS/6.0"", ""nginx/0.8.54"", NULL};
-4.   static const char * const bl_sites[] =
-3.      {""curl.se:443"", ""examp",Not Useful
/*done*/,"-10.       easy_setopt(easy[num_handles], CURLOPT_HEADER, 1L);
-9.       multi_add_handle(multi, easy[num_handles]);
-8.       num_handles += 1;
-7.       state = NeedSocketForNewHandle;
-6.     }
-5.     multi_perform(multi, &running);
-4.     fprintf(st",Not Useful
/** This is the list of basic details you need to tweak to get things right.*/,"-10.  * copies of the Software, and permit persons to whom the Software is
-9.  * furnished to do so, under the terms of the COPYING file.
-8.  *
-7.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-6.  * KIND, either express ",Not Useful
/*provide this to the rest*/,"-10.   if(argc< 2) {
-9.     fprintf(stderr, ""Pass URL as argument please\n"");
-8.     return 1;
-7.   }
-6.   test_argc = argc;
-5.   test_argv = argv;
-4.   if(argc>2)
-3.     libtest_arg2 = argv[2];
-2.   if(argc>3)
-1.     libtest_arg3 = argv[3];

/*p",Not Useful
"/*prevent valgrind from reporting possibly lost memory (fd cache, ...)*/","-4.   fprintf(stderr, ""URL: %s\n"", URL);
-3.   result = test(URL);
-2. #ifdef USE_NSS
-1.   if(PR_Initialized())

/*prevent valgrind from reporting possibly lost memory (fd cache, ...)*/

1.     PR_Cleanup();
2. #endif
3. #ifdef WIN32",Not Useful
/*just to please curl_base64.h we create a fake struct*/,"-10.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-9.  * KIND, either express or implied.
-8.  *
-7.  ***************************************************************************/
-6. #include ""server_setup.h""
-5. #include """,Not Useful
/*dest buffer*/,#NAME?,Not Useful
/*dest buffer data length*/,"-10.  * Destination buffer will be enlarged and relocated as needed.
-9.  *
-8.  * Calling function is responsible to provide preallocated destination
-7.  * buffer and also to deallocate it when no longer needed.
-6.  *
-5.  * This function may return:
-",Not Useful
/*dest buffer allocated size*/,"-10.  *
-9.  * Calling function is responsible to provide preallocated destination
-8.  * buffer and also to deallocate it when no longer needed.
-7.  *
-6.  * This function may return:
-5.  *   GPE_OUT_OF_MEMORY
-4.  *   GPE_OK
-3.  */

/*dest buffer all",Not Useful
/*source buffer*/,"-10.     if(!newptr)
-9.       return GPE_OUT_OF_MEMORY;
-8.     *buffer = newptr;
-7.     *bufsize *= 2;
-6.   }
-5.   return GPE_OK;
-4. }
-3. /*
-2.  * appenddata()
-1.  *
 * This appends data from a given source buffer to the end of the used part of

",Not Useful
/*!= 0 if source is base64 encoded*/,"-10.  *
-9.  * This function may return:
-8.  *   GPE_OUT_OF_MEMORY
-7.  *   GPE_OK
-6.  */

/*!= 0 if source is base64 encoded*/

1. {
2.   size_t need_alloc = 0;
3.   if(!src_len)
4.     return GPE_OK;
5.   need_alloc = src_len + *dst_len + 1;
6.   if(s",Not Useful
/*enlarge destination buffer if required*/,"-10.   size_t need_alloc = 0;
-9.   if(!src_len)
-8.     return GPE_OK;
-7.   need_alloc = src_len + *dst_len + 1;
-6.   if(src_b64) {
-5.     if(src_buf[src_len - 1] == '\r')
-4.       src_len--;
-3.     if(src_buf[src_len - 1] == '\n')
-2.       src_len",Not Useful
/*memcpy to support binary blobs*/,"-9.   if(need_alloc > *dst_alloc) {
-8.     size_t newsize = need_alloc * 2;
-7.     char *newptr = realloc(*dst_buf, newsize);
-6.     if(!newptr) {
-5.       return GPE_OUT_OF_MEMORY;
-4.     }
-3.     *dst_alloc = newsize;
-2.     *dst_buf = newptr;
-1",Not Useful
/*dest buffer*/,#NAME?,Not Useful
/*dest buffer data length*/,"-10.  * Destination buffer will be enlarged and relocated as needed.
-9.  *
-8.  * Calling function is responsible to provide preallocated destination
-7.  * buffer and also to deallocate it when no longer needed.
-6.  *
-5.  * This function may return:
-",Not Useful
/*base64 decode the given buffer*/,"-6. {
-5.   CURLcode error = CURLE_OK;
-4.   unsigned char *buf64 = NULL;
-3.   size_t src_len = 0;
-2.   if(!*len)
-1.     return GPE_OK;

/*base64 decode the given buffer*/

1.   error = Curl_base64_decode(*buf, &buf64, &src_len);
2.   if(error)
3.     ",Not Useful
/*memcpy to support binary blobs*/,"-9.   if(need_alloc > *dst_alloc) {
-8.     size_t newsize = need_alloc * 2;
-7.     char *newptr = realloc(*dst_buf, newsize);
-6.     if(!newptr) {
-5.       return GPE_OUT_OF_MEMORY;
-4.     }
-3.     *dst_alloc = newsize;
-2.     *dst_buf = newptr;
-1",Not Useful
/*current outermost section*/,"-10.  *
-9.  * This function may return:
-8.  *   GPE_NO_BUFFER_SPACE
-7.  *   GPE_OUT_OF_MEMORY
-6.  *   GPE_OK
-5.  */
-4. int getpart(char **outbuf, size_t *outlen,
-3.             const char *main, const char *sub, FILE *stream)
-2. {
-1. # define MAX",Not Useful
/*current main section*/,"-10.  * This function may return:
-9.  *   GPE_NO_BUFFER_SPACE
-8.  *   GPE_OUT_OF_MEMORY
-7.  *   GPE_OK
-6.  */
-5. int getpart(char **outbuf, size_t *outlen,
-4.             const char *main, const char *sub, FILE *stream)
-3. {
-2. # define MAX_TAG_LE",Not Useful
/*current sub section*/,"-10.  *   GPE_NO_BUFFER_SPACE
-9.  *   GPE_OUT_OF_MEMORY
-8.  *   GPE_OK
-7.  */
-6. int getpart(char **outbuf, size_t *outlen,
-5.             const char *main, const char *sub, FILE *stream)
-4. {
-3. # define MAX_TAG_LEN 200

/*current sub section*/

1",Not Useful
/*potential tag*/,"-10.  *   GPE_OUT_OF_MEMORY
-9.  *   GPE_OK
-8.  */
-7. int getpart(char **outbuf, size_t *outlen,
-6.             const char *main, const char *sub, FILE *stream)
-5. {
-4. # define MAX_TAG_LEN 200

/*potential tag*/

111",Not Useful
/*potential attributes*/,"-10.  *   GPE_OK
-9.  */
-8. int getpart(char **outbuf, size_t *outlen,
-7.             const char *main, const char *sub, FILE *stream)
-6. {
-5. # define MAX_TAG_LEN 200

/*potential attributes*/

1.   char *buffer = NULL;
2.   char *ptr;
3.   char *end",Not Useful
/*while*/,"-1. #include ""memdebug.h""
#define EAT_SPACE(p) while(*(p) && ISSPACE(*(p))) (p)++

/*while*/

1. #define EAT_WORD(p)  while(*(p) && !ISSPACE(*(p)) && ('>' != *(p))) (p)++
2. #ifdef DEBUG_GETPART
3. #define show(x) printf x
4. #else
5. #define show(x) Curl",Not Useful
/*this doesn't set the PATH part*/,"-10.   CURL *handle = NULL;
-9.   CURLcode res = 0;
-8.   CURLU *urlp = NULL;
-7.   global_init(CURL_GLOBAL_ALL);
-6.   easy_init(handle);
-5.   urlp = curl_url();
-4.   if(!urlp) {
-3.     fprintf(stderr, ""problem init URL api."");
-2.     goto test_clean",Not Useful
/*no wakeup*/,"-10. {
-9.   CURLM *multi = NULL;
-8.   int numfds;
-7.   int i;
-6.   int res = 0;
-5.   struct timeval time_before_wait, time_after_wait;
-4.   (void)URL;
-3.   start_test_timing();
-2.   global_init(CURL_GLOBAL_ALL);
-1.   multi_init(multi);

/*no wake",Not Useful
"/*Check range/resume returned error codes and data presence.

  The input parameters are:
  - CURLOPT_RANGE/CURLOPT_RESUME_FROM
  - CURLOPT_FAILONERROR
  - Returned http code (2xx/416)
  - Content-Range header present in reply.*/",#NAME?,Not Useful
/*TIMEVALUE in the future*/,"-10. int test(char *URL)
-9. {
-8.   long unmet;
-7.   CURL *curl = NULL;
-6.   int res = 0;
-5.   global_init(CURL_GLOBAL_ALL);
-4.   easy_init(curl);
-3.   easy_setopt(curl, CURLOPT_URL, URL);
-2.   easy_setopt(curl, CURLOPT_HEADER, 1L);
-1.   easy_seto",Not Useful
/*TIMEVALUE in the past*/,"-2.     goto test_cleanup;
-1.   }

/*TIMEVALUE in the past*/

1.   easy_setopt(curl, CURLOPT_TIMEVALUE, 1L);
2.   res = curl_easy_perform(curl);
3.   if(res)
4.     goto test_cleanup;
5.   curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &unmet);
6.   i",Not Useful
/*this is where we should be*/,"-2.     goto test_cleanup;
-1.   }

/*this is where we should be*/

1. test_cleanup:",Not Useful
/*unused parameter*/,"-10.   else {
-9.     data->paused = 1;
-8.     return CURL_READFUNC_PAUSE;
-7.   }
-6. }
-5. static size_t write_callback(char *ptr, size_t size, size_t nmemb,
-4.                              void *userdata)
-3. {
-2.   struct cb_data *data = (struct cb",Not Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  ERANGE",Not Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

/*errno.h value*/

1. #undef  ERANGE",Not Useful
/*previous test number we served*/,"-8. #endif
-7. #ifdef ENABLE_IPV6
-6. static bool use_ipv6 = FALSE;
-5. #endif
-4. static const char *ipv_inuse = ""IPv4"";
-3. static int serverlogslocked = 0;
-2. #define REQBUFSIZ 150000
-1. #define REQBUFSIZ_TXT ""149999""

/*previous test number we serve",Not Useful
/*previous part number we served*/,"-9. #endif
-8. #ifdef ENABLE_IPV6
-7. static bool use_ipv6 = FALSE;
-6. #endif
-5. static const char *ipv_inuse = ""IPv4"";
-4. static int serverlogslocked = 0;
-3. #define REQBUFSIZ 150000
-2. #define REQBUFSIZ_TXT ""149999""

/*previous part number we serve",Not Useful
/*buffer area for the incoming request*/,"-9. typedef enum {
-8.   RPROT_NONE = 0,
-7.   RPROT_RTSP = 1,
-6.   RPROT_HTTP = 2
-5. } reqprot_t;
-4. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-3. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)), ",Not Useful
/*where to start checking of the request*/,"-10. typedef enum {
-9.   RPROT_NONE = 0,
-8.   RPROT_RTSP = 1,
-7.   RPROT_HTTP = 2
-6. } reqprot_t;
-5. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-4. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)),",Not Useful
/*size of the incoming request*/,"-10.   RPROT_NONE = 0,
-9.   RPROT_RTSP = 1,
-8.   RPROT_HTTP = 2
-7. } reqprot_t;
-6. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-5. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)), \
-4.             ",Not Useful
/*test number found in the request*/,"-10.   RPROT_RTSP = 1,
-9.   RPROT_HTTP = 2
-8. } reqprot_t;
-7. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-6. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)), \
-5.                               ((p)",Not Useful
/*part number found in the request*/,"-10.   RPROT_HTTP = 2
-9. } reqprot_t;
-8. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-7. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)), \
-6.                               ((p)[3] = (unsigned char)(",Not Useful
/*Authorization header present in the incoming request*/,"-10.                               ((p)[3] = (unsigned char)((l) & 0xFF)))
-9. struct httprequest {

/*Authorization header present in the incoming request*/

111",Not Useful
/*Content-Length of the incoming request*/,"-10. struct httprequest {

/*Content-Length of the incoming request*/

111",Not Useful
/*Authorization digest header found*/,"-10.   char reqbuf[REQBUFSIZ]; /* buffer area for the incoming request */
-9.   size_t checkindex; /* where to start checking of the request */
-8.   size_t offset;     /* size of the incoming request */
-7.   long testno;       /* test number found in th",Not Useful
/*Authorization ntlm header found*/,"-10.   size_t checkindex; /* where to start checking of the request */
-9.   size_t offset;     /* size of the incoming request */
-8.   long testno;       /* test number found in the request */
-7.   long partno;       /* part number found in the request",Not Useful
"/*if non-zero, expect this many requests to do a ""piped""
                     request/response*/","-10.   size_t offset;     /* size of the incoming request */
-9.   long testno;       /* test number found in the request */
-8.   long partno;       /* part number found in the request */
-7.   bool open;      /* keep connection open info, as found in th",Not Useful
"/*if non-zero, the server is instructed to not read this
                     many bytes from a PUT/POST request. Ie the client sends N
                     bytes said in Content-Length, but the server only reads N
                     - skip bytes.*/","-10.   long partno;       /* part number found in the request */
-9.   bool open;      /* keep connection open info, as found in the request */
-8.   bool auth_req;  /* authentication required, don't wait for body unless
-7.                      there's a",Not Useful
"/*doing a special command, see defines above*/","-10.   bool auth;      /* Authorization header present in the incoming request */
-9.   size_t cl;      /* Content-Length of the incoming request */
-8.   bool digest;    /* Authorization digest header found */
-7.   bool ntlm;      /* Authorization ntlm ",Not Useful
"/*request protocol, HTTP or RTSP*/","-10.   size_t cl;      /* Content-Length of the incoming request */
-9.   bool digest;    /* Authorization digest header found */
-8.   bool ntlm;      /* Authorization ntlm header found */
-7.   int pipe;       /* if non-zero, expect this many requests t",Not Useful
/*very-big-path support*/,"-10. static int ProcessRequest(struct httprequest *req);
-9. static void storerequest(char *reqbuf, size_t totalsize);
-8. #define DEFAULT_PORT 8999
-7. #ifndef DEFAULT_LOGFILE
-6. #define DEFAULT_LOGFILE ""log/rtspd.log""
-5. #endif
-4. const char *serverl",Not Useful
"/*IETF//DTD HTML 2.0//EN\"">\n""*/","-5. static const char *doc404_HTTP = ""HTTP/1.1 404 Not Found\r\n""
-4.     ""Server: "" RTSPDVERSION ""\r\n""
-3.     ""Connection: close\r\n""
-2.     ""Content-Type: text/html""
-1.     END_OF_HEADERS

/*IETF//DTD HTML 2.0//EN\"">\n""*/

1.     ""<HTML><HEAD>\n""
2.",Not Useful
/*find the last slash*/,"-10.     }
-9.     else if(!strcmp(prot_str, ""RTSP"")) {
-8.       req->protocol = RPROT_RTSP;
-7.     }
-6.     else {
-5.       req->protocol = RPROT_NONE;
-4.       logmsg(""got unknown protocol %s"", prot_str);
-3.       return 1;
-2.     }
-1.     req->",Not Useful
/*get the number after it*/,"-1.     ptr = strrchr(doc, '/');

/*get the number after it*/

1.     if(ptr) {
2.       FILE *stream;
3.       if((strlen(doc) + strlen(request)) < 200)
4.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
5.                   requ",Not Useful
/*skip the slash*/,"-1.       }

/*skip the slash*/

111",Not Useful
/*skip all non-numericals following the slash*/,"-2.       }

/*skip all non-numericals following the slash*/

1.       while(*ptr && !ISDIGIT(*ptr))
2.         ptr++;
3.       req->testno = strtol(ptr, &ptr, 10);
4.       if(req->testno > 10000) {
5.         req->partno = req->testno % 10000;
6.       ",Not Useful
/*closes connection*/,"-10.       else
-9.         req->partno = 0;
-8.       msnprintf(logbuf, sizeof(logbuf), ""Requested test number %ld part %ld"",
-7.                 req->testno, req->partno);
-6.       logmsg(""%s"", logbuf);
-5.       stream = test2fopen(req->testno);
-4.  ",Not Useful
/*closes connection*/,"-10.       else
-9.         req->partno = 0;
-8.       msnprintf(logbuf, sizeof(logbuf), ""Requested test number %ld part %ld"",
-7.                 req->testno, req->partno);
-6.       logmsg(""%s"", logbuf);
-5.       stream = test2fopen(req->testno);
-4.  ",Not Useful
"/*Make our scratch buffer enough to fit all the
                 * desired data and one for padding*/","-10.             else if(1 == sscanf(ptr, ""skip: %d"", &num)) {
-9.               logmsg(""instructed to skip this number of bytes %d"", num);
-8.               req->skip = num;
-7.             }
-6.             else if(3 == sscanf(ptr, ""rtp: part %d channel",Not Useful
/*HTTP 1.0 closes connection by default*/,"-10.       }
-9.     }
-8.     else {
-7.       if(sscanf(req->reqbuf, ""CONNECT %"" MAXDOCNAMELEN_TXT ""s HTTP/%d.%d"",
-6.                 doc, &prot_major, &prot_minor) == 3) {
-5.         msnprintf(logbuf, sizeof(logbuf),
-4.                   ""Received a",Not Useful
/*we don't have a complete request yet!*/,"-10.         else
-9.           req->testno = DOCNUMBER_CONNECT;
-8.       }
-7.       else {
-6.         logmsg(""Did not find test number in PATH"");
-5.         req->testno = DOCNUMBER_404;
-4.       }
-3.     }
-2.   }
-1.   if(!end) {

/*we don't have ",Not Useful
/*not complete yet*/,"-1.     logmsg(""ProcessRequest returned without a complete request"");

/*not complete yet*/

1.   }
2.   logmsg(""ProcessRequest found a complete request"");
3.   if(req->pipe)",Not Useful
/*closes connection*/,"-10.       else
-9.         req->partno = 0;
-8.       msnprintf(logbuf, sizeof(logbuf), ""Requested test number %ld part %ld"",
-7.                 req->testno, req->partno);
-6.       logmsg(""%s"", logbuf);
-5.       stream = test2fopen(req->testno);
-4.  ",Not Useful
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(lo",Not Useful
/*chunked data coming in*/,"-9.       }
-8.       req->cl = clen - req->skip;
-7.       logmsg(""Found Content-Length: %lu in the request"", clen);
-6.       if(req->skip)
-5.         logmsg(""... but will abort after %zu bytes"", req->cl);
-4.       break;
-3.     }
-2.     else if(str",Not Useful
/*Authorization: header present!*/,"-6.     }
-5.     line = strchr(line, '\n');
-4.     if(line)
-3.       line++;
-2.   } while(line);
-1.   if(!req->auth && strstr(req->reqbuf, ""Authorization:"")) {

/*Authorization: header present!*/

1.     if(req->auth_req)
2.       logmsg(""Authorizati",Not Useful
/*header found*/,"-10.   char reqbuf[REQBUFSIZ]; /* buffer area for the incoming request */
-9.   size_t checkindex; /* where to start checking of the request */
-8.   size_t offset;     /* size of the incoming request */
-7.   long testno;       /* test number found in th",Not Useful
/*If the client is passing this type-3 NTLM header*/,"-4.     logmsg(""Received Digest request, sending back data %ld"", req->partno);
-3.   }
-2.   else if(!req->ntlm &&
-1.           strstr(req->reqbuf, ""Authorization: NTLM TlRMTVNTUAAD"")) {

/*If the client is passing this type-3 NTLM header*/

1.     req->",Not Useful
/*NTLM found*/,"-1.     req->partno += 1002;

/*NTLM found*/

1.     logmsg(""Received NTLM type-3, sending back data %ld"", req->partno);
2.     if(req->cl) {
3.       logmsg(""  Expecting %zu POSTed bytes"", req->cl);
4.     }
5.   }
6.   else if(!req->ntlm &&
7.          ",Not Useful
/*If the client is passing this type-1 NTLM header*/,"-7.     logmsg(""Received NTLM type-3, sending back data %ld"", req->partno);
-6.     if(req->cl) {
-5.       logmsg(""  Expecting %zu POSTed bytes"", req->cl);
-4.     }
-3.   }
-2.   else if(!req->ntlm &&
-1.           strstr(req->reqbuf, ""Authorization: NT",Not Useful
/*NTLM found*/,"-1.     req->partno += 1002;

/*NTLM found*/

1.     logmsg(""Received NTLM type-3, sending back data %ld"", req->partno);
2.     if(req->cl) {
3.       logmsg(""  Expecting %zu POSTed bytes"", req->cl);
4.     }
5.   }
6.   else if(!req->ntlm &&
7.          ",Not Useful
/*close connection after this request*/,"-4.     req->partno += 1;
-3.     logmsg(""Received Basic request, sending back data %ld"", req->partno);
-2.   }
-1.   if(strstr(req->reqbuf, ""Connection: close""))

/*close connection after this request*/

1.   if(!req->pipe &&
2.      req->open &&
3.     ",Not Useful
"/*If we have a persistent connection, HTTP version >= 1.1
       and GET/HEAD request, enable pipelining.*/","-6.   if(!req->pipe &&
-5.      req->open &&
-4.      req->prot_version >= 11 &&
-3.      req->reqbuf + req->offset > end + strlen(END_OF_HEADERS) &&
-2.      (!strncmp(req->reqbuf, ""GET"", strlen(""GET"")) ||
-1.       !strncmp(req->reqbuf, ""HEAD"", strlen(""",Not Useful
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(lo",Not Useful
"/*If authentication is required and no auth was provided, end now. This
     makes the server NOT wait for PUT/POST data and you can then make the
     test case send a rejection before any such data has been sent. Test case
     154 uses this.*/","-7.     line = &req->reqbuf[req->checkindex];
-6.     end = strstr(line, END_OF_HEADERS);
-5.     if(!end)
-4.       break;
-3.     req->checkindex += (end - line) + strlen(END_OF_HEADERS);
-2.     req->pipe--;
-1.   }

/*If authentication is required and",Not Useful
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(lo",Not Useful
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(lo",Not Useful
/*not complete yet*/,"-1.     logmsg(""ProcessRequest returned without a complete request"");

/*not complete yet*/

1.   }
2.   logmsg(""ProcessRequest found a complete request"");
3.   if(req->pipe)",Not Useful
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(lo",Not Useful
/*** Init the httprequest structure properly for the upcoming request ***/,"-10.   int fail = 0;
-9.   int done_processing = 0;
-8.   char *reqbuf = req->reqbuf;
-7.   ssize_t got = 0;
-6.   char *pipereq = NULL;
-5.   size_t pipereq_length = 0;
-4.   if(req->pipelining) {
-3.     pipereq = reqbuf + req->checkindex;
-2.     piper",Not Useful
/*** end of httprequest init ***/,"-10.   req->digest = FALSE;
-9.   req->ntlm = FALSE;
-8.   req->pipe = 0;
-7.   req->skip = 0;
-6.   req->rcmd = RCMD_NORMALREQ;
-5.   req->protocol = RPROT_NONE;
-4.   req->prot_version = 0;
-3.   req->pipelining = FALSE;
-2.   req->rtp_buffer = NULL;
-1",Not Useful
/*Do nothing. Sit idle. Pretend it rains.*/,"-10.       written = swrite(sock, STREAMTHIS, count);
-9.       if(got_exit_signal)
-8.         return -1;
-7.       if(written != (ssize_t)count) {
-6.         logmsg(""Stopped streaming"");
-5.         break;
-4.       }
-3.     }
-2.     return -1;
-1.  ",Not Useful
"/*non-zero means error, break out of loop*/","-5.     req.pipelining = FALSE;
-4.     do {
-3.       if(got_exit_signal)
-2.         break;
-1.       if(get_request(msgsock, &req))

/*non-zero means error, break out of loop*/

1.         break;
2.       if(prevbounce) {",Not Useful
/*we don't use this*/,"-10.  ***************************************************************************/
-9. #include ""test.h""
-8. #include ""memdebug.h""
-7. int test(char *URL)
-6. {
-5.   unsigned char a[] = {0x2f, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
-4.                      ",Not Useful
/*test function*/,"-10.   (void)useptr;
-9.   printf(""-> Mutex lock\n"");
-8. }
-7. static void my_unlock(CURL *handle, curl_lock_data data, void *useptr)
-6. {
-5.   (void)handle;
-4.   (void)data;
-3.   (void)useptr;
-2.   printf(""<- Mutex unlock\n"");
-1. }

/*test functio",Not Useful
/*use the share object*/,"-4.   for(i = 0; i < 3; i++) {
-3.     CURL *curl = curl_easy_init();
-2.     if(curl) {
-1.       curl_easy_setopt(curl, CURLOPT_URL, URL);

/*use the share object*/

1.       curl_easy_setopt(curl, CURLOPT_SHARE, share);",Not Useful
/*always cleanup*/,"-3.       if(res != CURLE_OK)
-2.         fprintf(stderr, ""curl_easy_perform() failed: %s\n"",
-1.                 curl_easy_strerror(res));

/*always cleanup*/

1.       curl_easy_cleanup(curl);
2.     }
3.   }
4.   curl_share_cleanup(share);
5.   curl_gl",Not Useful
"/** Make sure libcurl does not send a `Content-Length: -1` header when HTTP POST
 * size is unknown.*/",#NAME?,Not Useful
/*copy one single byte*/,"-10. struct WriteThis {
-9.   char *readptr;
-8.   size_t sizeleft;
-7. };
-6. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-5. {
-4.   struct WriteThis *pooh = (struct WriteThis *)userp;
-3.   if(size*nmemb < 1)
-2.     ",Not Useful
/*advance pointer*/,"-10.   char *readptr;
-9.   size_t sizeleft;
-8. };
-7. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-6. {
-5.   struct WriteThis *pooh = (struct WriteThis *)userp;
-4.   if(size*nmemb < 1)
-3.     return 0;
-2.   if(pooh",Not Useful
/*less data left*/,"-10.   size_t sizeleft;
-9. };
-8. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-7. {
-6.   struct WriteThis *pooh = (struct WriteThis *)userp;
-5.   if(size*nmemb < 1)
-4.     return 0;
-3.   if(pooh->sizeleft) {

/*less",Not Useful
/*First set the URL that is about to receive our POST.*/,"-10.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-9.     fprintf(stderr, ""curl_global_init() failed\n"");
-8.     return TEST_ERR_MAJOR_BAD;
-7.   }
-6.   curl = curl_easy_init();
-5.   if(!curl) {
-4.     fprintf(stderr, ""curl_easy_init() failed",Not Useful
/*we want to use our own progress function*/,"-1.   test_setopt(curl, CURLOPT_URL, URL);

/*we want to use our own progress function*/

1.   test_setopt(curl, CURLOPT_NOPROGRESS, 0L);
2.   test_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_callback);",Not Useful
/*get verbose debug output please*/,"-2.   test_setopt(curl, CURLOPT_NOPROGRESS, 0L);
-1.   test_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_callback);

/*get verbose debug output please*/

1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);",Not Useful
/*follow redirects*/,"-1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);

/*follow redirects*/

1.   test_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);",Not Useful
/*include headers in the output*/,"-1.   test_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

/*include headers in the output*/

1.   test_setopt(curl, CURLOPT_HEADER, 1L);",Not Useful
"/*Perform the request, res will get the return code*/","-1.   test_setopt(curl, CURLOPT_HEADER, 1L);

/*Perform the request, res will get the return code*/

1.   res = curl_easy_perform(curl);
2.   if(!res) {
3.     FILE *moo;
4.     res = curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD,
5.           ",Not Useful
/*always cleanup*/,"-10.     FILE *moo;
-9.     res = curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD,
-8.                             &content_length);
-7.     moo = fopen(libtest_arg2, ""wb"");
-6.     if(moo) {
-5.       fprintf(moo, ""CL %.0f\n"", content_length);
-",Not Useful
/*Total bytes curl wants*/,"-5. #include ""test.h""
-4. #include ""memdebug.h""
-3. static char data [] = ""Hello Cloud!\n"";
-2. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *stream)
-1. {

/*Total bytes curl wants*/

1.   if(amount < strlen(data)) {
2.     retu",Not Useful
/*the smallest!*/,"-10.     return TEST_ERR_MAJOR_BAD;
-9.   }
-8.   curl = curl_easy_init();
-7.   if(!curl) {
-6.     fprintf(stderr, ""curl_easy_init() failed\n"");
-5.     curl_global_cleanup();
-4.     return TEST_ERR_MAJOR_BAD;
-3.   }
-2.   test_setopt(curl, CURLOPT_UR",Not Useful
/*done*/,"-10.     multi_add_handle(m, curl[i]);
-9.     for(;;) {
-8.       struct timeval interval;
-7.       fd_set rd, wr, exc;
-6.       int maxfd = -99;
-5.       interval.tv_sec = 1;
-4.       interval.tv_usec = 0;
-3.       multi_perform(m, &running);
-2.  ",Not Useful
/*Generate our SPN*/,"-4.     Curl_auth_cleanup_spnego(nego);
-3.     return CURLE_LOGIN_DENIED;
-2.   }
-1.   if(!nego->spn) {

/*Generate our SPN*/

1.     char *spn = Curl_auth_build_spn(service, NULL, host);
2.     if(!spn)
3.       return CURLE_OUT_OF_MEMORY;",Not Useful
/*Populate the SPN structure*/,"-3.     char *spn = Curl_auth_build_spn(service, NULL, host);
-2.     if(!spn)
-1.       return CURLE_OUT_OF_MEMORY;

/*Populate the SPN structure*/

1.     spn_token.value = spn;
2.     spn_token.length = strlen(spn);",Not Useful
/*Import the SPN*/,"-2.     spn_token.value = spn;
-1.     spn_token.length = strlen(spn);

/*Import the SPN*/

1.     major_status = gss_import_name(&minor_status, &spn_token,
2.                                    GSS_C_NT_HOSTBASED_SERVICE,
3.                              ",Not Useful
"/*Setup the challenge ""input"" security buffer*/","-4.     if(!chlg) {
-3.       infof(data, ""SPNEGO handshake failure (empty challenge message)"");
-2.       return CURLE_BAD_CONTENT_ENCODING;
-1.     }

/*Setup the challenge ""input"" security buffer*/

1.     input_token.value = chlg;
2.     input_token.l",Not Useful
/*Free our security context*/,"-10.  * This is used to clean up the SPNEGO (Negotiate) specific data.
-9.  *
-8.  * Parameters:
-7.  *
-6.  * nego     [in/out] - The Negotiate data struct being cleaned up.
-5.  *
-4.  */
-3. void Curl_auth_cleanup_spnego(struct negotiatedata *nego)
-2.",Not Useful
/*Free the output token*/,"-4.   if(nego->context != GSS_C_NO_CONTEXT) {
-3.     gss_delete_sec_context(&minor_status, &nego->context, GSS_C_NO_BUFFER);
-2.     nego->context = GSS_C_NO_CONTEXT;
-1.   }

/*Free the output token*/

1.   if(nego->output_token.value) {
2.     gss_rele",Not Useful
/*Free the SPN*/,"-5.   if(nego->output_token.value) {
-4.     gss_release_buffer(&minor_status, &nego->output_token);
-3.     nego->output_token.value = NULL;
-2.     nego->output_token.length = 0;
-1.   }

/*Free the SPN*/

1.   if(nego->spn != GSS_C_NO_NAME) {
2.     gs",Not Useful
/*Query the security package for Negotiate*/,"-10.  * This is used to evaluate if SPNEGO (Negotiate) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Negotiate is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_spnego_supported(void)
-3. {
-2.   PSecPkgInfo Security",Not Useful
/*Query the security package for Negotiate*/,"-10.  * This is used to evaluate if SPNEGO (Negotiate) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Negotiate is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_spnego_supported(void)
-3. {
-2.   PSecPkgInfo Security",Not Useful
/*Do we have credentials to use or are we using single sign-on?*/,"-5.     nego->output_token = malloc(nego->token_max);
-4.     if(!nego->output_token)
-3.       return CURLE_OUT_OF_MEMORY;
-2.  }
-1.   if(!nego->credentials) {

/*Do we have credentials to use or are we using single sign-on?*/

1.     if(user && *user) ",Not Useful
/*Allow proper cleanup of the identity structure*/,"-3.       result = Curl_create_sspi_identity(user, password, &nego->identity);
-2.       if(result)
-1.         return result;

/*Allow proper cleanup of the identity structure*/

1.       nego->p_identity = &nego->identity;
2.     }
3.     else",Not Useful
/*Acquire our credentials handle*/,"-3.     nego->credentials = calloc(1, sizeof(CredHandle));
-2.     if(!nego->credentials)
-1.       return CURLE_OUT_OF_MEMORY;

/*Acquire our credentials handle*/

1.     nego->status =
2.       s_pSecFn->AcquireCredentialsHandle(NULL,
3.                ",Not Useful
/*Base64 encode the already generated response*/,"-10.  * nego        [in/out] - The Negotiate data struct being used and modified.
-9.  * outptr      [in/out] - The address where a pointer to newly allocated memory
-8.  *                        holding the result will be stored upon completion.
-7.  * o",Not Useful
/*Free our security context*/,"-10.  *
-9.  * This is used to clean up the SPNEGO (Negotiate) specific data.
-8.  *
-7.  * Parameters:
-6.  *
-5.  * nego     [in/out] - The Negotiate data struct being cleaned up.
-4.  *
-3.  */
-2. void Curl_auth_cleanup_spnego(struct negotiatedata *ne",Not Useful
/*Free our credentials handle*/,"-5.   if(nego->context) {
-4.     s_pSecFn->DeleteSecurityContext(nego->context);
-3.     free(nego->context);
-2.     nego->context = NULL;
-1.   }

/*Free our credentials handle*/

1.   if(nego->credentials) {
2.     s_pSecFn->FreeCredentialsHandle(nego",Not Useful
/*Free our identity*/,"-5.   if(nego->credentials) {
-4.     s_pSecFn->FreeCredentialsHandle(nego->credentials);
-3.     free(nego->credentials);
-2.     nego->credentials = NULL;
-1.   }

/*Free our identity*/

1.   Curl_sspi_free_identity(nego->p_identity);
2.   nego->p_ident",Not Useful
/*Free the SPN and output token*/,"-2.   Curl_sspi_free_identity(nego->p_identity);
-1.   nego->p_identity = NULL;

/*Free the SPN and output token*/

1.   Curl_safefree(nego->spn);
2.   Curl_safefree(nego->output_token);",Not Useful
/*HAVE_BASENAME*/,"
#ifndef HAVE_BASENAME



/*HAVE_BASENAME*/

1. char *tool_basename(char *path)
2. {
3.   char *s1;
4.   char *s2;
5.   s1 = strrchr(path, '/');
6.   s2 = strrchr(path, '\\');
7.   if(s1 && s2) {
8.     path = (s1 > s2) ? s1 + 1 : s2 + 1;
9.   }
10.   else if(s1)",Not Useful
/*HAVE_MEMRCHR*/,"-1. #include ""memdebug.h""
#ifndef HAVE_MEMRCHR

/*HAVE_MEMRCHR*/

111",Not Useful
/*Finalise the digest*/,"-3.   if(Curl_bufref_len(chlg))
-2.     Curl_HMAC_update(ctxt, Curl_bufref_ptr(chlg),
-1.                      curlx_uztoui(Curl_bufref_len(chlg)));

/*Finalise the digest*/

1.   Curl_HMAC_final(ctxt, digest);",Not Useful
/*Generate the response*/,"-1.   Curl_HMAC_final(ctxt, digest);

/*Generate the response*/

1.   response = aprintf(
2.     ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
3.     userp, digest[0], digest[1], digest[2], digest[3], digest[4],
4.     digest[5], ",Not Useful
/*Query the security package for Digest*/,"-10. * This is used to evaluate if DIGEST is supported.
-9. *
-8. * Parameters: None
-7. *
-6. * Returns TRUE if DIGEST is supported by Windows SSPI.
-5. */
-4. bool Curl_auth_is_digest_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURI",Not Useful
/*Query the security package for DigestSSP*/,"-4.   if(!Curl_bufref_len(chlg)) {
-3.     infof(data, ""DIGEST-MD5 handshake failure (empty challenge message)"");
-2.     return CURLE_BAD_CONTENT_ENCODING;
-1.   }

/*Query the security package for DigestSSP*/

1.   status = s_pSecFn->QuerySecurityPackag",Not Useful
/*Allow proper cleanup of the identity structure*/,"-6.     result = Curl_create_sspi_identity(userp, passwdp, &identity);
-5.     if(result) {
-4.       free(spn);
-3.       free(output_token);
-2.       return result;
-1.     }

/*Allow proper cleanup of the identity structure*/

1.     p_identity = &ide",Not Useful
/*Acquire our credentials handle*/,"-1.     p_identity = NULL;

/*Acquire our credentials handle*/

1.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                               (TCHAR *) TEXT(SP_NAME_DIGEST),
3.                                               SECPKG",Not Useful
/*Free our handles*/,"-1.   Curl_bufref_set(out, output_token, resp_buf.cbBuffer, curl_free);

/*Free our handles*/

1.   s_pSecFn->DeleteSecurityContext(&context);
2.   s_pSecFn->FreeCredentialsHandle(&credentials);",Not Useful
/*Free the identity structure*/,"-2.   s_pSecFn->DeleteSecurityContext(&context);
-1.   s_pSecFn->FreeCredentialsHandle(&credentials);

/*Free the identity structure*/

1.   Curl_sspi_free_identity(p_identity);",Not Useful
/*Free the SPN*/,"-1.   Curl_sspi_free_identity(p_identity);

/*Free the SPN*/

1.   free(spn);
2.   return result;
3. }
4. /*
5.  * Curl_override_sspi_http_realm()
6.  *
7.  * This is used to populate the domain in a SSPI identity structure
8.  * The realm is extracted fr",Not Useful
"/*If domain is blank or unset, check challenge message for realm*/","-10.  *
-9.  * chlg     [in]     - The challenge message.
-8.  * identity [in/out] - The identity structure.
-7.  *
-6.  * Returns CURLE_OK on success.
-5.  */
-4. CURLcode Curl_override_sspi_http_realm(const char *chlg,
-3.                               ",Not Useful
/*Pass all additional spaces here*/,"-4.   if(!identity->Domain || !identity->DomainLength) {
-3.     for(;;) {
-2.       char value[DIGEST_MAX_VALUE_LENGTH];
-1.       char content[DIGEST_MAX_CONTENT_LENGTH];

/*Pass all additional spaces here*/

1.       while(*chlg && ISSPACE(*chlg))
2.  ",Not Useful
/*Pass all additional spaces here*/,"-4.   if(!identity->Domain || !identity->DomainLength) {
-3.     for(;;) {
-2.       char value[DIGEST_MAX_VALUE_LENGTH];
-1.       char content[DIGEST_MAX_CONTENT_LENGTH];

/*Pass all additional spaces here*/

1.       while(*chlg && ISSPACE(*chlg))
2.  ",Not Useful
"/*We had an input token before so if there's another one now that means we
     provided bad credentials in the previous request or it's stale.*/","-10.  *
-9.  * chlg    [in]     - The challenge message.
-8.  * digest  [in/out] - The digest data struct being used and modified.
-7.  *
-6.  * Returns CURLE_OK on success.
-5.  */
-4. CURLcode Curl_auth_decode_digest_http_message(const char *chlg,
-3.  ",Not Useful
/*Check for the 'stale' directive*/,"-3.   if(digest->input_token) {
-2.     bool stale = false;
-1.     const char *p = chlg;

/*Check for the 'stale' directive*/

1.     for(;;) {
2.       char value[DIGEST_MAX_VALUE_LENGTH];
3.       char content[DIGEST_MAX_CONTENT_LENGTH];
4.       while",Not Useful
/*Query the security package for DigestSSP*/,"-4.   if(!Curl_bufref_len(chlg)) {
-3.     infof(data, ""DIGEST-MD5 handshake failure (empty challenge message)"");
-2.     return CURLE_BAD_CONTENT_ENCODING;
-1.   }

/*Query the security package for DigestSSP*/

1.   status = s_pSecFn->QuerySecurityPackag",Not Useful
"/*If the user/passwd that was used to make the identity for http_context
     has changed then delete that context.*/","-4.   output_token = malloc(token_max);
-3.   if(!output_token) {
-2.     return CURLE_OUT_OF_MEMORY;
-1.   }

/*If the user/passwd that was used to make the identity for http_context
     has changed then delete that context.*/

1.   if((userp && !digest",Not Useful
/*free the copy of user/passwd used to make the previous identity*/,"-1.     TCHAR *spn;

/*free the copy of user/passwd used to make the previous identity*/

1.     Curl_safefree(digest->user);
2.     Curl_safefree(digest->passwd);
3.     if(userp && *userp) {",Not Useful
/*Allow proper cleanup of the identity structure*/,"-6.     result = Curl_create_sspi_identity(userp, passwdp, &identity);
-5.     if(result) {
-4.       free(spn);
-3.       free(output_token);
-2.       return result;
-1.     }

/*Allow proper cleanup of the identity structure*/

1.     p_identity = &ide",Not Useful
/*Acquire our credentials handle*/,"-1.     p_identity = NULL;

/*Acquire our credentials handle*/

1.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                               (TCHAR *) TEXT(SP_NAME_DIGEST),
3.                                               SECPKG",Not Useful
/*Copy the generated response*/,"-10.     }
-9.     output_token_len = resp_buf.cbBuffer;
-8.     s_pSecFn->FreeCredentialsHandle(&credentials);
-7.     Curl_sspi_free_identity(p_identity);
-6.   }
-5.   resp = malloc(output_token_len + 1);
-4.   if(!resp) {
-3.     free(output_token);
-",Not Useful
/*Free the input token*/,"-10.  *
-9.  * This is used to clean up the digest specific data.
-8.  *
-7.  * Parameters:
-6.  *
-5.  * digest    [in/out] - The digest data struct being cleaned up.
-4.  *
-3.  */
-2. void Curl_auth_digest_cleanup(struct digestdata *digest)
-1. {

/*Fr",Not Useful
/*Delete security context*/,"-1.   digest->input_token_len = 0;

/*Delete security context*/

1.   if(digest->http_context) {
2.     s_pSecFn->DeleteSecurityContext(digest->http_context);
3.     Curl_safefree(digest->http_context);
4.   }",Not Useful
/*Free the copy of user/passwd used to make the identity for http_context*/,"-4.   if(digest->http_context) {
-3.     s_pSecFn->DeleteSecurityContext(digest->http_context);
-2.     Curl_safefree(digest->http_context);
-1.   }

/*Free the copy of user/passwd used to make the identity for http_context*/

1.   Curl_safefree(digest->u",Not Useful
/*move finfo pointers to b_data*/,"-10. static CURLcode ftp_pl_insert_finfo(struct Curl_easy *data,
-9.                                     struct fileinfo *infop)
-8. {
-7.   curl_fnmatch_callback compare;
-6.   struct WildcardData *wc = &data->wildcard;
-5.   struct ftp_wc *ftpwc = wc->p",Not Useful
/*get correct fnmatch callback*/,"-10.   finfo->filename       = str + parser->offsets.filename;
-9.   finfo->strings.group  = parser->offsets.group ?
-8.                           str + parser->offsets.group : NULL;
-7.   finfo->strings.perm   = parser->offsets.perm ?
-6.                ",Not Useful
/*filter pattern-corresponding filenames*/,"-3.   compare = data->set.fnmatch;
-2.   if(!compare)
-1.     compare = Curl_fnmatch;

/*filter pattern-corresponding filenames*/

1.   Curl_set_in_callback(data, true);
2.   if(compare(data->set.fnmatch_data, wc->pattern,
3.              finfo->filename)",Not Useful
/*error in previous call*/,"-10. {
-9.   size_t bufflen = size*nmemb;
-8.   struct Curl_easy *data = (struct Curl_easy *)connptr;
-7.   struct ftp_wc *ftpwc = data->wildcard.protdata;
-6.   struct ftp_parselist_data *parser = ftpwc->parser;
-5.   struct fileinfo *infop;
-4.   struct",Not Useful
/*tmp file data is not allocated yet*/,"-1.     char c = buffer[i];

/*tmp file data is not allocated yet*/

1.       parser->file_data = Curl_fileinfo_alloc();
2.       if(!parser->file_data) {
3.         parser->error = CURLE_OUT_OF_MEMORY;
4.         goto fail;
5.       }
6.       parser->fi",Not Useful
/*correct file type*/,"-10.               finfo->size = 0;
-9.             }
-8.             else {
-7.               char *endptr;
-6.               if(curlx_strtoofft(finfo->b_data +
-5.                                  parser->item_offset,
-4.                                ",Not Useful
/*CURL_DISABLE_FTP*/,"-10.  * 2) Unix version 2
-9.  * drwxr-xr-x 1 user01 ftp  512 Jan 29 1997  prog
-8.  * 3) Unix version 3
-7.  * drwxr-xr-x 1      1   1  512 Jan 29 23:32 prog
-6.  * 4) Unix symlink
-5.  * lrwxr-xr-x 1 user01 ftp  512 Jan 29 23:32 prog -> prog2000
-4.  * ",Not Useful
/*Query the security package for NTLM*/,"-10.  * This is used to evaluate if NTLM is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if NTLM is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_ntlm_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURI",Not Useful
/*Query the security package for NTLM*/,"-10.  * This is used to evaluate if NTLM is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if NTLM is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_ntlm_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURI",Not Useful
/*Populate our identity structure*/,"-5.   ntlm->output_token = malloc(ntlm->token_max);
-4.   if(!ntlm->output_token)
-3.     return CURLE_OUT_OF_MEMORY;
-2.   if(userp && *userp) {
-1.     CURLcode result;

/*Populate our identity structure*/

1.     result = Curl_create_sspi_identity(user",Not Useful
/*Allow proper cleanup of the identity structure*/,"-3.     result = Curl_create_sspi_identity(userp, passwdp, &ntlm->identity);
-2.     if(result)
-1.       return result;

/*Allow proper cleanup of the identity structure*/

1.     ntlm->p_identity = &ntlm->identity;
2.   }
3.   else",Not Useful
/*Acquire our credentials handle*/,"-3.   ntlm->credentials = calloc(1, sizeof(CredHandle));
-2.   if(!ntlm->credentials)
-1.     return CURLE_OUT_OF_MEMORY;

/*Acquire our credentials handle*/

1.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                       ",Not Useful
/*Free our credentials handle*/,"-5.   if(ntlm->context) {
-4.     s_pSecFn->DeleteSecurityContext(ntlm->context);
-3.     free(ntlm->context);
-2.     ntlm->context = NULL;
-1.   }

/*Free our credentials handle*/

1.   if(ntlm->credentials) {
2.     s_pSecFn->FreeCredentialsHandle(ntlm",Not Useful
/*Free our identity*/,"-5.   if(ntlm->credentials) {
-4.     s_pSecFn->FreeCredentialsHandle(ntlm->credentials);
-3.     free(ntlm->credentials);
-2.     ntlm->credentials = NULL;
-1.   }

/*Free our identity*/

1.   Curl_sspi_free_identity(ntlm->p_identity);
2.   ntlm->p_ident",Not Useful
/*Free the input and output tokens*/,"-2.   Curl_sspi_free_identity(ntlm->p_identity);
-1.   ntlm->p_identity = NULL;

/*Free the input and output tokens*/

1.   Curl_safefree(ntlm->input_token);
2.   Curl_safefree(ntlm->output_token);",Not Useful
/*we have got more than the expected total!*/,"-9.   bar->calls++;
-8.   if((total > 0) && (point != bar->prev)) {
-7.     char line[MAX_BARLENGTH + 1];
-6.     char format[40];
-5.     double frac;
-4.     double percent;
-3.     int barwidth;
-2.     int num;
-1.     if(point > total)

/*we have got",Not Useful
/*TIOCGSIZE*/,"-10.   if(colp) {
-9.     char *endptr;
-8.     long num = strtol(colp, &endptr, 10);
-7.     if((endptr != colp) && (endptr == colp + strlen(colp)) && (num > 20) &&
-6.        (num < 10000))
-5.       bar->width = (int)num;
-4.     curl_free(colp);
-3.  ",Not Useful
/*download*/,"-10.       Curl_safefree(node->infile);
-9.       Curl_safefree(node);
-8.       node = next;
-7.     }
-6.     config->url_list = NULL;
-5.   }
-4. }
-3. bool output_expected(const char *url, const char *uploadfile)
-2. {
-1.   if(!uploadfile)

/*downloa",Not Useful
"/*"", url) || checkprefix(""https://"", url))*/","-10.       Curl_safefree(node);
-9.       node = next;
-8.     }
-7.     config->url_list = NULL;
-6.   }
-5. }
-4. bool output_expected(const char *url, const char *uploadfile)
-3. {
-2.   if(!uploadfile)

/*"", url) || checkprefix(""https://"", url))*/

11",Not Useful
/*HTTP(S) upload*/,"-10.       node = next;
-9.     }
-8.     config->url_list = NULL;
-7.   }
-6. }
-5. bool output_expected(const char *url, const char *uploadfile)
-4. {
-3.   if(!uploadfile)

/*HTTP(S) upload*/

111",Not Useful
"/*"");*/","-3. char *add_file_name_to_url(char *url, const char *filename)
-2. {

/*"");*/

111",Not Useful
/*Curl's timer has elapsed.*/,"-3.     checkFdSet(m, &sockets.read, &readSet, CURL_CSELECT_IN, ""read"");
-2.     checkFdSet(m, &sockets.write, &writeSet, CURL_CSELECT_OUT, ""write"");
-1.     if(timeout.tv_sec != -1 && getMicroSecondTimeout(&timeout) == 0) {

/*Curl's timer has elapsed.*/",Not Useful
/*close the local file*/,"-4.   curl_multi_remove_handle(m, curl);
-3.   curl_easy_cleanup(curl);
-2.   curl_multi_cleanup(m);
-1.   curl_global_cleanup();

/*close the local file*/

1.   fclose(hd_src);",Not Useful
/*free local memory*/,"-1.   fclose(hd_src);

/*free local memory*/

1.   free(sockets.read.sockets);
2.   free(sockets.write.sockets);
3.   return res;
4. }",Not Useful
/*32 bytes/256 bits*/,"-10.                   const char *passwdp,
-9.                   const unsigned char *request,
-8.                   const unsigned char *uripath,
-7.                   struct digestdata *digest,
-6.                   char **outptr, size_t *outlen,
-5.  ",Not Useful
/*64 digits and 1 zero byte*/,"-1.   unsigned char request_digest[65];

/*64 digits and 1 zero byte*/

111",Not Useful
/*64 digits and 1 zero byte*/,"-1.   unsigned char request_digest[65];

/*64 digits and 1 zero byte*/

111",Not Useful
/*nonce and cnonce are OUTSIDE the hash*/,"-10.   */
-9.   hashthis = aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
-8.   if(!hashthis)
-7.     return CURLE_OUT_OF_MEMORY;
-6.   hash(hashbuf, (unsigned char *) hashthis, strlen(hashthis));
-5.   free(hashthis);
-4.   convert_to_ascii(hashbuf,",Not Useful
/*Append the opaque*/,"-1.   if(digest->opaque) {

/*Append the opaque*/

1.     tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
2.     free(response);
3.     if(!tmp)
4.       return CURLE_OUT_OF_MEMORY;
5.     response = tmp;
6.   }
7.   if(digest->algorithm) {",Not Useful
/*Append the algorithm*/,"-7.     tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
-6.     free(response);
-5.     if(!tmp)
-4.       return CURLE_OUT_OF_MEMORY;
-3.     response = tmp;
-2.   }
-1.   if(digest->algorithm) {

/*Append the algorithm*/

1.     tmp = apri",Not Useful
/*Append the userhash*/,"-7.     tmp = aprintf(""%s, algorithm=%s"", response, digest->algorithm);
-6.     free(response);
-5.     if(!tmp)
-4.       return CURLE_OUT_OF_MEMORY;
-3.     response = tmp;
-2.   }
-1.   if(digest->userhash) {

/*Append the userhash*/

1.     tmp = apri",Not Useful
"/*default means normal, not stale*/","-10. void Curl_auth_digest_cleanup(struct digestdata *digest)
-9. {
-8.   Curl_safefree(digest->nonce);
-7.   Curl_safefree(digest->cnonce);
-6.   Curl_safefree(digest->realm);
-5.   Curl_safefree(digest->opaque);
-4.   Curl_safefree(digest->qop);
-3.   C",Not Useful
/*!USE_WINDOWS_SSPI*/,"-2.   digest->userhash = FALSE;
-1. }

/*!USE_WINDOWS_SSPI*/

111",Not Useful
/*CURL_DISABLE_CRYPTO_AUTH*/,"-10.  * furnished to do so, under the terms of the COPYING file.
-9.  *
-8.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-7.  * KIND, either express or implied.
-6.  *
-5.  * RFC2831 DIGEST-MD5 authentication
-4.  * RFC7616",Not Useful
"/*It is referenced to the home directory, so strip the
         leading '/'*/","-10.       memcpy(real_path, working_path, 1 + working_path_len);
-9.   }
-8.   else if(data->conn->handler->protocol & CURLPROTO_SFTP) {
-7.     if((working_path_len > 1) && (working_path[1] == '~')) {
-6.       size_t homelen = strlen(homedir);
-5.     ",Not Useful
/*Send the LOGOUT command*/,"-2. static CURLcode imap_perform_logout(struct Curl_easy *data)
-1. {

/*Send the LOGOUT command*/

1.   CURLcode result = imap_sendf(data, ""LOGOUT"");
2.   if(!result)
3.     state(data, IMAP_LOGOUT);
4.   return result;
5. }",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*PREAUTH*/,"-5.   PROTOPT_URLOPTIONS
-4. };
-3. #endif
-2. #define IMAP_RESP_OK       1
-1. #define IMAP_RESP_NOT_OK   2
#define IMAP_RESP_PREAUTH  3

/*PREAUTH*/

111",Not Useful
/*For CAPABILITY responses*/,"-10.     struct imap_conn *imapc = &conn->proto.imapc;
-9.     imapc->preauth = TRUE;
-8.     infof(data, ""PREAUTH connection, already authenticated"");
-7.   }
-6.   else if(imapcode != IMAP_RESP_OK) {
-5.     failf(data, ""Got unexpected imap-server respo",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*Loop through the data line*/,"-2.   if(imapcode == '*') {
-1.     line += 2;

/*Loop through the data line*/

1.     for(;;) {
2.       size_t wordlen;
3.       while(*line &&
4.             (*line == ' ' || *line == '\t' ||
5.               *line == '\r' || *line == '\n')) {
6.      ",Not Useful
/*For STARTTLS responses*/,"-10.       result = imap_perform_authentication(data, conn);
-9.     else {
-8.       failf(data, ""STARTTLS not available."");
-7.       result = CURLE_USE_SSL_FAILED;
-6.     }
-5.   }
-4.   else
-3.     result = imap_perform_authentication(data, conn);
-",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*Perform clear text authentication*/,"-5.   result = Curl_sasl_start(&imapc->sasl, data, imapc->ir_supported, &progress);
-4.   if(!result) {
-3.     if(progress == SASL_INPROGRESS)
-2.       state(data, IMAP_AUTHENTICATE);
-1.     else if(!imapc->login_disabled && (imapc->preftype & IMAP_TYP",Not Useful
/*For LOGIN responses*/,"-10.       else {
-9.         failf(data, ""Authentication cancelled"");
-8.         result = CURLE_LOGIN_DENIED;
-7.       }
-6.       break;
-5.     default:
-4.       break;
-3.     }
-2.   return result;
-1. }

/*For LOGIN responses*/

1. static CURLcod",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*For LIST and SEARCH responses*/,"-3.     state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For LIST and SEARCH responses*/

1. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
2.                                            int imapcode,
3.                            ",Not Useful
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line ",Not Useful
/*For SELECT responses*/,"-3.     state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For SELECT responses*/

1. static CURLcode imap_state_select_resp(struct Curl_easy *data, int imapcode,
2.                                        imapstate instate)
3. {
4.   CURLcode result = ",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*Note the currently opened mailbox on this connection*/,"-6.     if(imap->uidvalidity && imapc->mailbox_uidvalidity &&
-5.        !strcasecompare(imap->uidvalidity, imapc->mailbox_uidvalidity)) {
-4.       failf(data, ""Mailbox UIDVALIDITY has changed"");
-3.       result = CURLE_REMOTE_FILE_NOT_FOUND;
-2.     }
",Not Useful
/*For the (first line of the) FETCH responses*/,"-10.       else
-9.         result = imap_perform_fetch(data);
-8.     }
-7.   }
-6.   else {
-5.     failf(data, ""Select failed"");
-4.     result = CURLE_LOGIN_DENIED;
-3.   }
-2.   return result;
-1. }

/*For the (first line of the) FETCH responses*/

1",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*The conversion from curl_off_t to size_t is always fine here*/,"-2.       size_t chunk = pp->cache_size;
-1.       if(chunk > (size_t)size)

/*The conversion from curl_off_t to size_t is always fine here*/

1.         chunk = (size_t)size;
2.       if(!chunk) {",Not Useful
/*Have we used the entire cache or just part of it?*/,"-9.         state(data, IMAP_STOP);
-8.         return CURLE_OK;
-7.       }
-6.       result = Curl_client_write(data, CLIENTWRITE_BODY, pp->cache, chunk);
-5.       if(result)
-4.         return result;
-3.       data->req.bytecount += chunk;
-2.       ",Not Useful
/*Only part of it so shrink the cache to fit the trailing data*/,"-1.       if(pp->cache_size > chunk) {

/*Only part of it so shrink the cache to fit the trailing data*/

1.         memmove(pp->cache, pp->cache + chunk, pp->cache_size - chunk);
2.         pp->cache_size -= chunk;
3.       }
4.       else {",Not Useful
/*Free the cache*/,"-4.         memmove(pp->cache, pp->cache + chunk, pp->cache_size - chunk);
-3.         pp->cache_size -= chunk;
-2.       }
-1.       else {

/*Free the cache*/

1.         Curl_safefree(pp->cache);",Not Useful
/*Reset the cache size*/,"-1.         Curl_safefree(pp->cache);

/*Reset the cache size*/

1.         pp->cache_size = 0;
2.       }
3.     }
4.     if(data->req.bytecount == size)",Not Useful
/*For final FETCH responses performed after the download*/,"-3.   state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For final FETCH responses performed after the download*/

1. static CURLcode imap_state_fetch_final_resp(struct Curl_easy *data,
2.                                             int imapcode,
3.   ",Not Useful
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line ",Not Useful
/*For APPEND responses*/,"-3.     state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For APPEND responses*/

1. static CURLcode imap_state_append_resp(struct Curl_easy *data, int imapcode,
2.                                        imapstate instate)
3. {
4.   CURLcode result = ",Not Useful
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line ",Not Useful
/*For final APPEND responses performed after the upload*/,"-4.     state(data, IMAP_STOP);
-3.   }
-2.   return result;
-1. }

/*For final APPEND responses performed after the upload*/

1. static CURLcode imap_state_append_final_resp(struct Curl_easy *data,
2.                                              int imap",Not Useful
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line ",Not Useful
/*Flush any data that needs to be sent*/,"-2.   if(imapc->state == IMAP_UPGRADETLS)
-1.     return imap_perform_upgrade_tls(data, conn);

/*Flush any data that needs to be sent*/

1.   if(pp->sendleft)
2.     return Curl_pp_flushsend(data, pp);
3.   do {",Not Useful
"/*Allocate and initialize the struct IMAP for the current Curl_easy if
   required*/","-10. static CURLcode imap_block_statemach(struct Curl_easy *data,
-9.                                      struct connectdata *conn,
-8.                                      bool disconnecting)
-7. {
-6.   CURLcode result = CURLE_OK;
-5.   struct imap_con",Not Useful
/*default to not done yet*/,"-10.  *
-9.  * The variable 'done' points to will be TRUE if the protocol-layer connect
-8.  * phase is done when this function returns, or FALSE if not.
-7.  */
-6. static CURLcode imap_connect(struct Curl_easy *data, bool *done)
-5. {
-4.   CURLcode res",Not Useful
/*Parse the URL options*/,"-2.   Curl_pp_setup(pp);
-1.   Curl_pp_init(data, pp);

/*Parse the URL options*/

1.   result = imap_parse_url_options(conn);
2.   if(result)
3.     return result;",Not Useful
/*Clear the transfer mode for the next request*/,"-9.   Curl_safefree(imap->mailbox);
-8.   Curl_safefree(imap->uidvalidity);
-7.   Curl_safefree(imap->uid);
-6.   Curl_safefree(imap->mindex);
-5.   Curl_safefree(imap->section);
-4.   Curl_safefree(imap->partial);
-3.   Curl_safefree(imap->query);
-2.   ",Not Useful
/*This is IMAP and no proxy*/,"-3. static CURLcode imap_perform(struct Curl_easy *data, bool *connected,
-2.                              bool *dophase_done)
-1. {

/*This is IMAP and no proxy*/

1.   CURLcode result = CURLE_OK;
2.   struct connectdata *conn = data->conn;
3.   struct I",Not Useful
/*Requested no body means no transfer*/,"-7.   CURLcode result = CURLE_OK;
-6.   struct connectdata *conn = data->conn;
-5.   struct IMAP *imap = data->req.p.imap;
-4.   struct imap_conn *imapc = &conn->proto.imapc;
-3.   bool selected = FALSE;
-2.   DEBUGF(infof(data, ""DO phase starts""));
-1.  ",Not Useful
"/*Determine if the requested mailbox (with the same UIDVALIDITY if set)
     has already been selected on this connection*/","-3.     imap->transfer = PPTRANSFER_INFO;
-2.   }

/*Determine if the requested mailbox (with the same UIDVALIDITY if set)
     has already been selected on this connection*/

1.   if(imap->mailbox && imapc->mailbox &&
2.      strcasecompare(imap->mailbox",Not Useful
/*LIST*/,"-4.       case IMAP_CAPABILITY:
-3.         if(!imap_matchresp(line, len, ""CAPABILITY""))
-2.           return FALSE;
-1.         break;
      case IMAP_LIST:

/*LIST*/

1.         if((!imap->custom && !imap_matchresp(line, len, ""LIST"")) ||
2.           (i",Not Useful
/*Parse the URL path*/,"-10.  *
-9.  * This function is registered as 'curl_do' function. It decodes the path
-8.  * parts etc as a wrapper to the actual DO function (imap_perform).
-7.  *
-6.  * The input argument is already checked for validity.
-5.  */
-4. static CURLcode ima",Not Useful
/*Parse the custom request*/,"-3.   result = imap_parse_url_path(data);
-2.   if(result)
-1.     return result;

/*Parse the custom request*/

1.   result = imap_parse_custom_request(data);
2.   if(result)
3.     return result;
4.   result = imap_regular_transfer(data, done);
5.   ret",Not Useful
"/***********************************************************************
 *
 * imap_disconnect()
 *
 * Disconnect from an IMAP server. Cleanup protocol-specific per-connection
 * resources. BLOCKING.*/","-6.   result = imap_parse_custom_request(data);
-5.   if(result)
-4.     return result;
-3.   result = imap_regular_transfer(data, done);
-2.   return result;
-1. }
/***********************************************************************
 *
 * imap_discon",Not Useful
/*Cleanup the SASL module*/,"-2.   Curl_pp_disconnect(&imapc->pp);
-1.   Curl_dyn_free(&imapc->dyn);

/*Cleanup the SASL module*/

1.   Curl_sasl_cleanup(conn, imapc->sasl.authused);",Not Useful
/*Make sure size is unknown at this point*/,"-10.  * The input argument is already checked for validity.
-9.  *
-8.  * Performs all commands done before a regular transfer between a local and a
-7.  * remote host.
-6.  */
-5. static CURLcode imap_regular_transfer(struct Curl_easy *data,
-4.         ",Not Useful
/*Carry out the perform*/,"-4.   Curl_pgrsSetUploadCounter(data, 0);
-3.   Curl_pgrsSetDownloadCounter(data, 0);
-2.   Curl_pgrsSetUploadSize(data, -1);
-1.   Curl_pgrsSetDownloadSize(data, -1);

/*Carry out the perform*/

1.   result = imap_perform(data, &connected, dophase_done);",Not Useful
/*Initialise the IMAP layer*/,"-7.   if(!result && *dophase_done)
-6.     result = imap_dophase_done(data, connected);
-5.   return result;
-4. }
-3. static CURLcode imap_setup_connection(struct Curl_easy *data,
-2.                                       struct connectdata *conn)
-1. {
",Not Useful
/*Clear the TLS upgraded flag*/,"-3.   CURLcode result = imap_init(data);
-2.   if(result)
-1.     return result;

/*Clear the TLS upgraded flag*/

1.   conn->bits.tls_upgraded = FALSE;
2.   return CURLE_OK;
3. }
4. /***********************************************************************",Not Useful
"/***********************************************************************
 *
 * imap_sendf()
 *
 * Sends the formatted string as an IMAP command to the server.
 *
 * Designed to never block.*/","-3.   conn->bits.tls_upgraded = FALSE;
-2.   return CURLE_OK;
-1. }
/***********************************************************************
 *
 * imap_sendf()
 *
 * Sends the formatted string as an IMAP command to the server.
 *
 * Designed to never bloc",Not Useful
/*!checksrc! disable PARENBRACE 1*/,"-10.  * imap_atom()
-9.  *
-8.  * Checks the input string for characters that need escaping and returns an
-7.  * atom ready for sending to the server.
-6.  *
-5.  * The returned string needs to be freed.
-4.  *
-3.  */
-2. static char *imap_atom(const ch",Not Useful
"/*Look for ""atom-specials"", counting the backslash and quote characters as
     these will need escaping*/","-10.   const char atom_specials[] = ""(){ %*]"";
-9.   const char *p1;
-8.   char *p2;
-7.   size_t backsp_count = 0;
-6.   size_t quote_count = 0;
-5.   bool others_exists = FALSE;
-4.   size_t newlen = 0;
-3.   char *newstr = NULL;
-2.   if(!str)
-1.     ",Not Useful
/*Terminate the string*/,"-10.   p1 = str;
-9.   while(*p1) {
-8.     if(*p1 == '\\' || *p1 == '""') {
-7.       *p2 = '\\';
-6.       p2++;
-5.     }
-4.    *p2 = *p1;
-3.     p1++;
-2.     p2++;
-1.   }

/*Terminate the string*/

1.   newstr[newlen] = '\0';
2.   return newstr;
3.",Not Useful
"/***********************************************************************
 *
 * imap_parse_url_options()
 *
 * Parse the URL login options.*/","-5.       return true;
-4.     default:
-3.       return false;
-2.   }
-1. }
/***********************************************************************
 *
 * imap_parse_url_options()
 *
 * Parse the URL login options.

/************************************",Not Useful
"/***********************************************************************
 *
 * imap_parse_url_path()
 *
 * Parse the URL path into separate path components.
 **/","
/***************************************************************************
 *                                  _   _ ____  _



/***********************************************************************
 *
 * imap_parse_url_path()
 *
 * Parse the URL path into separate path components.
 **/

1.  *  Project                     ___| | | |  _ \| |
2.  *                             / __| | | | |_) | |
3.  *                            | (__| |_| |  _ <| |___
4.  *                             \___|\___/|_| \_\_____|
5.  *
6.  * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
7.  *
8.  * This software is licensed as described in the file COPYING, which
9.  * you should have received as part of this distribution. The terms",Not Useful
/*The imap struct is already initialised in imap_connect()*/,"-2. static CURLcode imap_parse_url_path(struct Curl_easy *data)
-1. {

/*The imap struct is already initialised in imap_connect()*/

1.   CURLcode result = CURLE_OK;
2.   struct IMAP *imap = data->req.p.imap;",Not Useful
"/*There can be any number of parameters in the form "";NAME=VALUE""*/","-10.     const char *end = ptr;
-9.     if(end > begin && end[-1] == '/')
-8.       end--;
-7.     result = Curl_urldecode(begin, end - begin, &imap->mailbox, NULL,
-6.                             REJECT_CTRL);
-5.     if(result)
-4.       return result;
",Not Useful
/*Decode the name parameter*/,"-5.     begin = ++ptr;
-4.     while(*ptr && *ptr != '=')
-3.       ptr++;
-2.     if(!*ptr)
-1.       return CURLE_URL_MALFORMAT;

/*Decode the name parameter*/

1.     result = Curl_urldecode(begin, ptr - begin, &name, NULL,
2.                          ",Not Useful
/*Decode the value parameter*/,"-3.     begin = ++ptr;
-2.     while(imap_is_bchar(*ptr))
-1.       ptr++;

/*Decode the value parameter*/

1.     result = Curl_urldecode(begin, ptr - begin, &value, &valuelen,
2.                             REJECT_CTRL);
3.     if(result) {
4.       fre",Not Useful
"/*Get the query parameter, URL decoded*/","-1.   if(imap->mailbox && !imap->uid && !imap->mindex) {

/*Get the query parameter, URL decoded*/

1.     (void)curl_url_get(data->state.uh, CURLUPART_QUERY, &imap->query,
2.                        CURLU_URLDECODE);
3.   }",Not Useful
"/***********************************************************************
 *
 * imap_parse_custom_request()
 *
 * Parse the custom request.*/","-4.   if(*ptr)
-3.     return CURLE_URL_MALFORMAT;
-2.   return CURLE_OK;
-1. }
/***********************************************************************
 *
 * imap_parse_custom_request()
 *
 * Parse the custom request.

/**********************************",Not Useful
/*URL decode the custom request*/,"-10.  * imap_parse_custom_request()
-9.  *
-8.  * Parse the custom request.
-7.  */
-6. static CURLcode imap_parse_custom_request(struct Curl_easy *data)
-5. {
-4.   CURLcode result = CURLE_OK;
-3.   struct IMAP *imap = data->req.p.imap;
-2.   const char ",Not Useful
/*CURL_DISABLE_IMAP*/,"-10.  * RFC4616 PLAIN authentication
-9.  * RFC4752 The Kerberos V5 (""GSSAPI"") SASL Mechanism
-8.  * RFC4959 IMAP Extension for SASL Initial Client Response
-7.  * RFC5092 IMAP URL Scheme
-6.  * RFC6749 OAuth 2.0 Authorization Framework
-5.  * RFC8314 Use",Not Useful
/*normalize pattern and hostname by stripping off trailing dots*/,"-10.  *
-9.  * Return TRUE on a match. FALSE if not.
-8.  */
-7. static bool hostmatch(const char *hostname,
-6.                       size_t hostlen,
-5.                       const char *pattern,
-4.                       size_t patternlen)
-3. {
-2.   ",Not Useful
/*flush the stream to send off what we got earlier*/,"-4.   if(per->config->headerfile && heads->stream) {
-3.     size_t rc = fwrite(ptr, size, nmemb, heads->stream);
-2.     if(rc != cb)
-1.       return rc;

/*flush the stream to send off what we got earlier*/

1.     (void)fflush(heads->stream);
2.   }",Not Useful
"/*look for the 'filename=' parameter
       (encoded filenames (*=) are not supported)*/","-10.    * This callback sets the filename where output shall be written when
-9.    * curl options --remote-name (-O) and --remote-header-name (-J) have
-8.    * been simultaneously given and additionally server returns an HTTP
-7.    * Content-Dispositio",Not Useful
/*done now!*/,"-8.           free(filename);
-7.           return failure;
-6.         }
-5.         outs->is_cd_filename = TRUE;
-4.         outs->s_isreg = TRUE;
-3.         outs->fopened = FALSE;
-2.         outs->filename = filename;
-1.         outs->alloc_filename",Not Useful
/*MSDOS || WIN32*/,"-10.     memmove(copy, p, strlen(p) + 1);
-9. #if defined(MSDOS) || defined(WIN32)
-8.   {
-7.     char *sanitized;
-6.     SANITIZEcode sc = sanitize_file_name(&sanitized, copy, 0);
-5.     Curl_safefree(copy);
-4.     if(sc)
-3.       return NULL;
-2.  ",Not Useful
/*suitably large*/,"-4. #ifdef DEBUGBUILD
-3.   {
-2.     char *tdir = curlx_getenv(""CURL_TESTDIR"");
-1.     if(tdir) {

/*suitably large*/

1.       msnprintf(buffer, sizeof(buffer), ""%s/%s"", tdir, copy);
2.       Curl_safefree(copy);",Not Useful
/*Generate our UTF8 based SPN*/,"-10.   char *utf8_spn = NULL;
-9.   TCHAR *tchar_spn = NULL;
-8.   TCHAR *dupe_tchar_spn = NULL;
-7.   (void) realm;

/*Generate our UTF8 based SPN*/

1.   utf8_spn = aprintf(""%s/%s"", service, host);
2.   if(!utf8_spn)
3.     return NULL;",Not Useful
/*USE_WINDOWS_SSPI*/,"-10.  * service@realm      (Not used by Windows SSPI)
-9.  *
-8.  * Parameters:
-7.  *
-6.  * service  [in] - The service type such as http, smtp, pop or imap.
-5.  * host     [in] - The host name.
-4.  * realm    [in] - The realm.
-3.  *
-2.  * Returns a",Not Useful
/*stand-alone but not a boolean*/,"-1.   enum {

/*stand-alone but not a boolean*/

111",Not Useful
"/*epsv' made like this to make --no-epsv and --epsv to work
             although --disable-epsv is the documented option*/","-10.   {""*a"", ""random-file"",              ARG_FILENAME},
-9.   {""*b"", ""egd-file"",                 ARG_STRING},
-8.   {""*B"", ""oauth2-bearer"",            ARG_STRING},
-7.   {""*c"", ""connect-timeout"",          ARG_STRING},
-6.   {""*C"", ""doh-url""        ,     ",Not Useful
/*krb4' is the previous name*/,"-10.   {""*r"", ""create-dirs"",              ARG_BOOL},
-9.   {""*R"", ""create-file-mode"",         ARG_STRING},
-8.   {""*s"", ""max-redirs"",               ARG_STRING},
-7.   {""*t"", ""proxy-ntlm"",               ARG_BOOL},
-6.   {""*u"", ""crlf"",                     A",Not Useful
"/*eprt' made like this to make --no-eprt and --eprt to work
             although --disable-eprt is the documented option*/","-4.   {""*X"", ""haproxy-protocol"",         ARG_BOOL},
-3.   {""*y"", ""max-filesize"",             ARG_STRING},
-2.   {""*z"", ""disable-eprt"",             ARG_BOOL},
-1.   {""*Z"", ""eprt"",                     ARG_BOOL},

/*eprt' made like this to make --no-eprt and",Not Useful
/*sessionid' listed as --no-sessionid in the help*/,"-1.   {""$w"", ""sessionid"",                ARG_BOOL},

/*sessionid' listed as --no-sessionid in the help*/

1.   {""$x"", ""ftp-ssl-control"",          ARG_BOOL},
2.   {""$y"", ""ftp-ssl-ccc"",              ARG_BOOL},
3.   {""$j"", ""ftp-ssl-ccc-mode"",         ARG_STR",Not Useful
/*keepalive' listed as --no-keepalive in the help*/,"-7.   {""$x"", ""ftp-ssl-control"",          ARG_BOOL},
-6.   {""$y"", ""ftp-ssl-ccc"",              ARG_BOOL},
-5.   {""$j"", ""ftp-ssl-ccc-mode"",         ARG_STRING},
-4.   {""$z"", ""libcurl"",                  ARG_STRING},
-3.   {""$#"", ""raw"",                      AR",Not Useful
/*Eo*/,"-10.   {""Ef"", ""engine"",                   ARG_STRING},
-9.   {""Eg"", ""capath"",                   ARG_FILENAME},
-8.   {""Eh"", ""pubkey"",                   ARG_STRING},
-7.   {""Ei"", ""hostpubmd5"",               ARG_STRING},
-6.   {""EF"", ""hostpubsha256"",       ",Not Useful
/*buffer' listed as --no-buffer in the help*/,"-10.   {""K"",  ""config"",                   ARG_FILENAME},
-9.   {""l"",  ""list-only"",                ARG_BOOL},
-8.   {""L"",  ""location"",                 ARG_BOOL},
-7.   {""Lt"", ""location-trusted"",         ARG_BOOL},
-6.   {""m"",  ""max-time"",                 A",Not Useful
"/*next less trivial: cert_parameter starts 'pkcs11:' and thus
   * looks like a RFC7512 PKCS#11 URI which can be used as-is.
   * Also if cert_parameter contains no colon nor backslash, this
   * means no passphrase was given and no characters escaped*/","-2.   if(param_length == 0)
-1.     return;

/*next less trivial: cert_parameter starts 'pkcs11:' and thus
   * looks like a RFC7512 PKCS#11 URI which can be used as-is.
   * Also if cert_parameter contains no colon nor backslash, this
   * means no passp",Not Useful
"/*Get a size parameter for '--limit-rate' or '--max-filesize'.
 * We support a 'G', 'M' or 'K' suffix too.*/","-10.   char *certname, *passphrase;
-9.   parse_cert_parameter(nextarg, &certname, &passphrase);
-8.   Curl_safefree(*file);
-7.   *file = certname;
-6.   if(passphrase) {
-5.     Curl_safefree(*password);
-4.     *password = passphrase;
-3.   }
-2.   cle",Not Useful
/*unsupported*/,"-10. {
-9.   char *unit;
-8.   curl_off_t value;
-7.   if(curlx_strtoofft(arg, &unit, 0, &value)) {
-6.     warnf(global, ""invalid number specified for %s\n"", which);
-5.     return PARAM_BAD_USE;
-4.   }
-3.   if(!*unit)
-2.     unit = (char *)""b"";
-1.  ",Not Useful
/*f or -long-flag*/,"-8.     break;
-7.   default:
-6.     warnf(global, ""unsupported %s unit. Use G, M, K or B!\n"", which);
-5.     return PARAM_BAD_USE;
-4.   }
-3.   *value_out = value;
-2.   return PARAM_OK;
-1. }

/*f or -long-flag*/

111",Not Useful
/*subletters can only occur on long options*/,"-4.                             struct GlobalConfig *global,
-3.                             struct OperationConfig *config)
-2. {
-1.   char letter;

/*subletters can only occur on long options*/

1.   int rc;
2.   const char *parse = NULL;
3.   unsigned",Not Useful
/*we can loop here if we have multiple single-letters*/,"-4.     hit = -1;
-3.     parse = flag;
-2.   }
-1.   do {

/*we can loop here if we have multiple single-letters*/

1.     if(!longopt) {
2.       letter = (char)*parse;
3.       subletter = '\0';
4.     }
5.     else {
6.       letter = parse[0];
7.    ",Not Useful
/*don't loop anymore after this*/,"-2.       if(!longopt && parse[1]) {

/*don't loop anymore after this*/

1.       }
2.       else if(!nextarg)
3.         return PARAM_REQUIRES_PARAMETER;
4.       else",Not Useful
/*mark it as used*/,"-4.       }
-3.       else if(!nextarg)
-2.         return PARAM_REQUIRES_PARAMETER;
-1.       else

/*mark it as used*/

1.       if((aliases[hit].desc == ARG_FILENAME) &&
2.          (nextarg[0] == '-') && nextarg[1]) {",Not Useful
/*--dns-ipv4-addr*/,"-1.       switch(subletter) {

/*--dns-ipv4-addr*/

111",Not Useful
/*--dns-ipv6-addr*/,"-2.         GetStr(&config->dns_ipv4_addr, nextarg);
-1.         break;

/*--dns-ipv6-addr*/

111",Not Useful
/*random-file*/,"-3.   {""*@"", ""url"",                      ARG_STRING},
-2.   {""*4"", ""dns-ipv4-addr"",            ARG_STRING},
-1.   {""*6"", ""dns-ipv6-addr"",            ARG_STRING},
  {""*a"", ""random-file"",              ARG_FILENAME},

/*random-file*/

1.   {""*b"", ""egd-file"",",Not Useful
/*egd-file*/,"-4.   {""*@"", ""url"",                      ARG_STRING},
-3.   {""*4"", ""dns-ipv4-addr"",            ARG_STRING},
-2.   {""*6"", ""dns-ipv6-addr"",            ARG_STRING},
-1.   {""*a"", ""random-file"",              ARG_FILENAME},
  {""*b"", ""egd-file"",                 ",Not Useful
/*connect-timeout*/,"-6.   {""*@"", ""url"",                      ARG_STRING},
-5.   {""*4"", ""dns-ipv4-addr"",            ARG_STRING},
-4.   {""*6"", ""dns-ipv6-addr"",            ARG_STRING},
-3.   {""*a"", ""random-file"",              ARG_FILENAME},
-2.   {""*b"", ""egd-file"",             ",Not Useful
/*doh-url*/,"-7.   {""*@"", ""url"",                      ARG_STRING},
-6.   {""*4"", ""dns-ipv4-addr"",            ARG_STRING},
-5.   {""*6"", ""dns-ipv6-addr"",            ARG_STRING},
-4.   {""*a"", ""random-file"",              ARG_FILENAME},
-3.   {""*b"", ""egd-file"",             ",Not Useful
/*--dns-interface*/,"-2.         GetStr(&config->cipher_list, nextarg);
-1.         break;

/*--dns-interface*/

111",Not Useful
/*interface name*/,"-1.           return PARAM_LIBCURL_DOESNT_SUPPORT;

/*interface name*/

1.         GetStr(&config->dns_interface, nextarg);
2.         break;",Not Useful
/*--disable-epsv*/,"-10.   {""*b"", ""egd-file"",                 ARG_STRING},
-9.   {""*B"", ""oauth2-bearer"",            ARG_STRING},
-8.   {""*c"", ""connect-timeout"",          ARG_STRING},
-7.   {""*C"", ""doh-url""        ,          ARG_STRING},
-6.   {""*d"", ""ciphers"",               ",Not Useful
/*--disallow-username-in-url*/,"-2.         config->disable_epsv = toggle;
-1.         break;

/*--disallow-username-in-url*/

1.         config->disallow_username_in_url = toggle;
2.         break;",Not Useful
/*--epsv*/,"-10.   {""*a"", ""random-file"",              ARG_FILENAME},
-9.   {""*b"", ""egd-file"",                 ARG_STRING},
-8.   {""*B"", ""oauth2-bearer"",            ARG_STRING},
-7.   {""*c"", ""connect-timeout"",          ARG_STRING},
-6.   {""*C"", ""doh-url""        ,     ",Not Useful
/*--dns-servers*/,"-2.         config->disable_epsv = (!toggle)?TRUE:FALSE;
-1.         break;

/*--dns-servers*/

111",Not Useful
/*--trace*/,"-2.         GetStr(&config->dns_servers, nextarg);
-1.         break;

/*--trace*/

1.         GetStr(&global->trace_dump, nextarg);
2.         if(global->tracetype && (global->tracetype != TRACE_BIN))
3.           warnf(global, ""--trace overrides an earl",Not Useful
/*--npn*/,"-5.         GetStr(&global->trace_dump, nextarg);
-4.         if(global->tracetype && (global->tracetype != TRACE_BIN))
-3.           warnf(global, ""--trace overrides an earlier trace/verbose option\n"");
-2.         global->tracetype = TRACE_BIN;
-1.     ",Not Useful
/*--trace-ascii*/,"-2.         config->nonpn = (!toggle)?TRUE:FALSE;
-1.         break;

/*--trace-ascii*/

1.         GetStr(&global->trace_dump, nextarg);
2.         if(global->tracetype && (global->tracetype != TRACE_ASCII))
3.           warnf(global,
4.                 ",Not Useful
/*--alpn*/,"-6.         GetStr(&global->trace_dump, nextarg);
-5.         if(global->tracetype && (global->tracetype != TRACE_ASCII))
-4.           warnf(global,
-3.                 ""--trace-ascii overrides an earlier trace/verbose option\n"");
-2.         global->tra",Not Useful
/*--limit-rate*/,"-10.   char *certname, *passphrase;
-9.   parse_cert_parameter(nextarg, &certname, &passphrase);
-8.   Curl_safefree(*file);
-7.   *file = certname;
-6.   if(passphrase) {
-5.     Curl_safefree(*password);
-4.     *password = passphrase;
-3.   }
-2.   cle",Not Useful
/*--compressed*/,"-9.       {
-8.         curl_off_t value;
-7.         ParameterError pe = GetSizeParameter(global, nextarg, ""rate"", &value);
-6.         if(pe != PARAM_OK)
-5.            return pe;
-4.         config->recvpersecond = value;
-3.         config->sendpersec",Not Useful
/*--tr-encoding*/,"-6.         if(toggle &&
-5.            !(curlinfo->features & (CURL_VERSION_LIBZ |
-4.                                    CURL_VERSION_BROTLI | CURL_VERSION_ZSTD)))
-3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-2.         config->encoding = toggle;",Not Useful
/*--negotiate*/,"-5.         if(toggle)
-4.           config->authtype |= CURLAUTH_DIGEST;
-3.         else
-2.           config->authtype &= ~CURLAUTH_DIGEST;
-1.         break;

/*--negotiate*/

1.         if(toggle) {
2.           if(curlinfo->features & CURL_VERSION_S",Not Useful
/*--ntlm*/,"-9.         if(toggle) {
-8.           if(curlinfo->features & CURL_VERSION_SPNEGO)
-7.             config->authtype |= CURLAUTH_NEGOTIATE;
-6.           else
-5.             return PARAM_LIBCURL_DOESNT_SUPPORT;
-4.         }
-3.         else
-2.         ",Not Useful
/*--ntlm-wb*/,"-9.         if(toggle) {
-8.           if(curlinfo->features & CURL_VERSION_NTLM)
-7.             config->authtype |= CURLAUTH_NTLM;
-6.           else
-5.             return PARAM_LIBCURL_DOESNT_SUPPORT;
-4.         }
-3.         else
-2.           confi",Not Useful
"/*--anyauth, let libcurl pick it*/","-5.         if(toggle)
-4.           config->authtype |= CURLAUTH_BASIC;
-3.         else
-2.           config->authtype &= ~CURLAUTH_BASIC;
-1.         break;

/*--anyauth, let libcurl pick it*/

1.         if(toggle)
2.           config->authtype = CURL",Not Useful
/*--no-anyauth simply doesn't touch it*/,"-2.         if(toggle)
-1.           config->authtype = CURLAUTH_ANY;

/*--no-anyauth simply doesn't touch it*/

1.         break;
2. #ifdef USE_WATT32",Not Useful
/*--wdebug*/,"-2.         break;
-1. #ifdef USE_WATT32

/*--wdebug*/

1.         dbug_init();
2.         break;
3. #endif",Not Useful
/*--ftp-create-dirs*/,"-3.         dbug_init();
-2.         break;
-1. #endif

/*--ftp-create-dirs*/

1.         config->ftp_create_dirs = toggle;
2.         break;",Not Useful
/*--create-dirs*/,"-2.         config->ftp_create_dirs = toggle;
-1.         break;

/*--create-dirs*/

1.         config->create_dirs = toggle;
2.         break;",Not Useful
/*--max-redirs*/,"-4.         err = oct2nummax(&config->create_file_mode, nextarg, 0777);
-3.         if(err)
-2.           return err;
-1.         break;

/*--max-redirs*/

111",Not Useful
/*--proxy-ntlm*/,"-6.         err = str2num(&config->maxredirs, nextarg);
-5.         if(err)
-4.           return err;
-3.         if(config->maxredirs < -1)
-2.           return PARAM_BAD_NUMERIC;
-1.         break;

/*--proxy-ntlm*/

1.         if(curlinfo->features & C",Not Useful
/*--crlf*/,"-5.         if(curlinfo->features & CURL_VERSION_NTLM)
-4.           config->proxyntlm = toggle;
-3.         else
-2.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-1.         break;

/*--crlf*/

111",Not Useful
/*LF -> CRLF conversion?*/,"-6.         if(curlinfo->features & CURL_VERSION_NTLM)
-5.           config->proxyntlm = toggle;
-4.         else
-3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-2.         break;

/*LF -> CRLF conversion?*/

1.         config->crlf = toggle;
2.      ",Not Useful
/*--stderr*/,"-3.         config->authtype |= CURLAUTH_AWS_SIGV4;
-2.         GetStr(&config->aws_sigv4, nextarg);
-1.         break;

/*--stderr*/

1.         if(strcmp(nextarg, ""-"")) {
2.           FILE *newfile = fopen(nextarg, FOPEN_WRITETEXT);
3.           if(!new",Not Useful
/*--interface*/,"-10.           else {
-9.             if(global->errors_fopened)
-8.               fclose(global->errors);
-7.             global->errors = newfile;
-6.             global->errors_fopened = TRUE;
-5.           }
-4.         }
-3.         else
-2.         ",Not Useful
/*interface*/,"-10.      mention. */
-9.   {""*@"", ""url"",                      ARG_STRING},
-8.   {""*4"", ""dns-ipv4-addr"",            ARG_STRING},
-7.   {""*6"", ""dns-ipv6-addr"",            ARG_STRING},
-6.   {""*a"", ""random-file"",              ARG_FILENAME},
-5.   {""*b"", ""e",Not Useful
/*--krb*/,"-2.         GetStr(&config->iface, nextarg);
-1.         break;

/*--krb*/

111",Not Useful
/*--haproxy-protocol*/,"-5.         if(curlinfo->features & CURL_VERSION_SPNEGO)
-4.           GetStr(&config->krblevel, nextarg);
-3.         else
-2.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-1.         break;

/*--haproxy-protocol*/

1.         config->haproxy_protocol ",Not Useful
/*--max-filesize*/,"-10.   char *certname, *passphrase;
-9.   parse_cert_parameter(nextarg, &certname, &passphrase);
-8.   Curl_safefree(*file);
-7.   *file = certname;
-6.   if(passphrase) {
-5.     Curl_safefree(*password);
-4.     *password = passphrase;
-3.   }
-2.   cle",Not Useful
/*--disable-eprt*/,"-5.   {""*X"", ""haproxy-protocol"",         ARG_BOOL},
-4.   {""*y"", ""max-filesize"",             ARG_STRING},
-3.   {""*z"", ""disable-eprt"",             ARG_BOOL},
-2.   {""*Z"", ""eprt"",                     ARG_BOOL},

/*--disable-eprt*/

1.   {""*~"", ""xattr"",    ",Not Useful
/*--eprt*/,"-4.   {""*X"", ""haproxy-protocol"",         ARG_BOOL},
-3.   {""*y"", ""max-filesize"",             ARG_STRING},
-2.   {""*z"", ""disable-eprt"",             ARG_BOOL},
-1.   {""*Z"", ""eprt"",                     ARG_BOOL},
         /* 'eprt' made like this to make --n",Not Useful
/*--xattr*/,"-2.         config->disable_eprt = (!toggle)?TRUE:FALSE;
-1.         break;

/*--xattr*/

1.         config->xattr = toggle;
2.         break;",Not Useful
/*the URL!*/,"-2.         config->xattr = toggle;
-1.         break;

/*the URL!*/

1.       {
2.         struct getout *url;
3.         if(!config->url_get)
4.           config->url_get = config->url_list;
5.         if(config->url_get) {",Not Useful
/*fill in the URL*/,"-3.           config->url_get = url = new_getout(config);
-2.         if(!url)
-1.           return PARAM_NO_MEM;

/*fill in the URL*/

1.         GetStr(&url->url, nextarg);
2.         url->flags |= GETOUT_URL;
3.       }
4.       }
5.       break;",Not Useful
"/*--socks5-hostname specifies a socks5 proxy and enables name
                   resolving with the proxy*/","-3.         GetStr(&config->proxy, nextarg);
-2.         config->proxyver = CURLPROXY_SOCKS4A;
-1.         break;

/*--socks5-hostname specifies a socks5 proxy and enables name
                   resolving with the proxy*/

1.         GetStr(&config->prox",Not Useful
/*--tcp-nodelay option*/,"-3.         GetStr(&config->proxy, nextarg);
-2.         config->proxyver = CURLPROXY_SOCKS5_HOSTNAME;
-1.         break;

/*--tcp-nodelay option*/

1.         config->tcp_nodelay = toggle;
2.         break;",Not Useful
/*--proxy-digest*/,"-2.         config->tcp_nodelay = toggle;
-1.         break;

/*--proxy-digest*/

1.         config->proxydigest = toggle;
2.         break;",Not Useful
/*--proxy-basic*/,"-2.         config->proxydigest = toggle;
-1.         break;

/*--proxy-basic*/

1.         config->proxybasic = toggle;
2.         break;",Not Useful
/*--retry-connrefused*/,"-4.         err = str2unum(&config->req_retry, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--retry-connrefused*/

1.         config->retry_connrefused = toggle;
2.         break;",Not Useful
/*--retry-delay*/,"-2.         config->retry_connrefused = toggle;
-1.         break;

/*--retry-delay*/

1.         err = str2unummax(&config->retry_delay, nextarg, LONG_MAX/1000);
2.         if(err)
3.           return err;
4.         break;",Not Useful
/*--retry-max-time*/,"-4.         err = str2unummax(&config->retry_delay, nextarg, LONG_MAX/1000);
-3.         if(err)
-2.           return err;
-1.         break;

/*--retry-max-time*/

1.         err = str2unummax(&config->retry_maxtime, nextarg, LONG_MAX/1000);
2.         i",Not Useful
/*--proxy-negotiate*/,"-2.         config->retry_all_errors = toggle;
-1.         break;

/*--proxy-negotiate*/

1.         if(curlinfo->features & CURL_VERSION_SPNEGO)
2.           config->proxynegotiate = toggle;
3.         else
4.           return PARAM_LIBCURL_DOESNT_SUPPOR",Not Useful
/*--ftp-account*/,"-4.         config->mime_options &= ~CURLMIMEOPT_FORMESCAPE;
-3.         if(toggle)
-2.           config->mime_options |= CURLMIMEOPT_FORMESCAPE;
-1.         break;

/*--ftp-account*/

1.         GetStr(&config->ftp_account, nextarg);
2.         break;",Not Useful
/*--proxy-anyauth*/,"-2.         GetStr(&config->ftp_account, nextarg);
-1.         break;

/*--proxy-anyauth*/

1.         config->proxyanyauth = toggle;
2.         break;",Not Useful
/*--trace-time*/,"-2.         config->proxyanyauth = toggle;
-1.         break;

/*--trace-time*/

1.         global->tracetime = toggle;
2.         break;",Not Useful
/*--ignore-content-length*/,"-2.         global->tracetime = toggle;
-1.         break;

/*--ignore-content-length*/

1.         config->ignorecl = toggle;
2.         break;",Not Useful
/*--local-port*/,"-2.         config->ftp_filemethod = ftpfilemethod(config, nextarg);
-1.         break;

/*--local-port*/

111",Not Useful
/*--ftp-alternative-to-user*/,"-10.         else {
-9.           err = str2unum(&config->localportrange, lrange);
-8.           if(err || (config->localportrange > 65535))
-7.             return PARAM_BAD_USE;
-6.           config->localportrange -= (config->localport-1);
-5.          ",Not Useful
/*--ftp-ssl-control*/,"-2.         config->disable_sessionid = (!toggle)?TRUE:FALSE;
-1.         break;

/*--ftp-ssl-control*/

1.         if(toggle && !(curlinfo->features & CURL_VERSION_SSL))
2.           return PARAM_LIBCURL_DOESNT_SUPPORT;
3.         config->ftp_ssl_control",Not Useful
/*--ftp-ssl-ccc*/,"-4.         if(toggle && !(curlinfo->features & CURL_VERSION_SSL))
-3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-2.         config->ftp_ssl_control = toggle;
-1.         break;

/*--ftp-ssl-ccc*/

1.         config->ftp_ssl_ccc = toggle;
2.         ",Not Useful
/*--ftp-ssl-ccc-mode*/,"-4.         config->ftp_ssl_ccc = toggle;
-3.         if(!config->ftp_ssl_ccc_mode)
-2.           config->ftp_ssl_ccc_mode = CURLFTPSSL_CCC_PASSIVE;
-1.         break;

/*--ftp-ssl-ccc-mode*/

1.         config->ftp_ssl_ccc = TRUE;
2.         config->ftp_",Not Useful
/*--raw*/,"-8. #ifdef CURL_DISABLE_LIBCURL_OPTION
-7.         warnf(global,
-6.               ""--libcurl option was disabled at build-time!\n"");
-5.         return PARAM_OPTION_UNKNOWN;
-4. #else
-3.         GetStr(&global->libcurl, nextarg);
-2.         break;
-1. ",Not Useful
/*--post301*/,"-2.         config->raw = toggle;
-1.         break;

/*--post301*/

1.         config->post301 = toggle;
2.         break;",Not Useful
/*--no-keepalive*/,"-7.   {""$x"", ""ftp-ssl-control"",          ARG_BOOL},
-6.   {""$y"", ""ftp-ssl-ccc"",              ARG_BOOL},
-5.   {""$j"", ""ftp-ssl-ccc-mode"",         ARG_STRING},
-4.   {""$z"", ""libcurl"",                  ARG_STRING},
-3.   {""$#"", ""raw"",                      AR",Not Useful
/*--keepalive-time*/,"-2.         config->nokeepalive = (!toggle)?TRUE:FALSE;
-1.         break;

/*--keepalive-time*/

1.         err = str2unum(&config->alivetime, nextarg);
2.         if(err)
3.           return err;
4.         break;",Not Useful
/*--post302*/,"-4.         err = str2unum(&config->alivetime, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--post302*/

1.         config->post302 = toggle;
2.         break;",Not Useful
/*--post303*/,"-2.         config->post302 = toggle;
-1.         break;

/*--post303*/

1.         config->post303 = toggle;
2.         break;",Not Useful
/*--noproxy*/,"-2.         config->post303 = toggle;
-1.         break;

/*--noproxy*/

111",Not Useful
/*--socks5-gssapi-nec*/,"-2.         GetStr(&config->noproxy, nextarg);
-1.         break;

/*--socks5-gssapi-nec*/

1.         config->socks5_gssapi_nec = toggle;
2.         break;",Not Useful
/*--proxy1.0*/,"-2.         config->socks5_gssapi_nec = toggle;
-1.         break;

/*--proxy1.0*/

111",Not Useful
/*http 1.0 proxy*/,"-3.         config->socks5_gssapi_nec = toggle;
-2.         break;

/*http 1.0 proxy*/

1.         GetStr(&config->proxy, nextarg);
2.         config->proxyver = CURLPROXY_HTTP_1_0;
3.         break;",Not Useful
/*--tftp-blksize*/,"-3.         GetStr(&config->proxy, nextarg);
-2.         config->proxyver = CURLPROXY_HTTP_1_0;
-1.         break;

/*--tftp-blksize*/

1.         err = str2unum(&config->tftp_blksize, nextarg);
2.         if(err)
3.           return err;
4.         break",Not Useful
/*--mail-from*/,"-4.         err = str2unum(&config->tftp_blksize, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--mail-from*/

1.         GetStr(&config->mail_from, nextarg);
2.         break;",Not Useful
/*--mail-rcpt*/,"-2.         GetStr(&config->mail_from, nextarg);
-1.         break;

/*--mail-rcpt*/

111",Not Useful
/*--ftp-pret*/,"-4.         err = add2list(&config->mail_rcpt, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--ftp-pret*/

1.         config->ftp_pret = toggle;
2.         break;",Not Useful
/*--proto*/,"-2.         config->ftp_pret = toggle;
-1.         break;

/*--proto*/

1.         config->proto_present = TRUE;
2.         if(proto2num(config, &config->proto, nextarg))
3.           return PARAM_BAD_USE;
4.         break;",Not Useful
/*--proto-redir*/,"-4.         config->proto_present = TRUE;
-3.         if(proto2num(config, &config->proto, nextarg))
-2.           return PARAM_BAD_USE;
-1.         break;

/*--proto-redir*/

1.         config->proto_redir_present = TRUE;
2.         if(proto2num(config, ",Not Useful
/*--resolve*/,"-4.         config->proto_redir_present = TRUE;
-3.         if(proto2num(config, &config->proto_redir, nextarg))
-2.           return PARAM_BAD_USE;
-1.         break;

/*--resolve*/

1.         err = add2list(&config->resolve, nextarg);
2.         if(err",Not Useful
/*--mail-auth*/,"-2.         config->gssapi_delegation = delegation(config, nextarg);
-1.         break;

/*--mail-auth*/

1.         GetStr(&config->mail_auth, nextarg);
2.         break;",Not Useful
/*--sasl-authzid*/,"-2.         errorf(global, ""--metalink is disabled\n"");
-1.         return PARAM_BAD_USE;

/*--sasl-authzid*/

1.         GetStr(&config->sasl_authzid, nextarg);
2.         break;",Not Useful
/*--sasl-ir*/,"-2.         GetStr(&config->sasl_authzid, nextarg);
-1.         break;

/*--sasl-ir*/

1.         config->sasl_ir = toggle;
2.         break;",Not Useful
/*--test-event*/,"-2.         config->sasl_ir = toggle;
-1.         break;

/*--test-event*/

1. #ifdef CURLDEBUG
2.         global->test_event_based = toggle;
3. #else
4.         warnf(global, ""--test-event is ignored unless a debug build!\n"");
5. #endif
6.         break;",Not Useful
/*--unix-socket*/,"-6. #ifdef CURLDEBUG
-5.         global->test_event_based = toggle;
-4. #else
-3.         warnf(global, ""--test-event is ignored unless a debug build!\n"");
-2. #endif
-1.         break;

/*--unix-socket*/

1.         config->abstract_unix_socket = FALSE;
",Not Useful
/*--path-as-is*/,"-3.         config->abstract_unix_socket = FALSE;
-2.         GetStr(&config->unix_socket_path, nextarg);
-1.         break;

/*--path-as-is*/

1.         config->path_as_is = toggle;
2.         break;",Not Useful
/*--proxy-service-name*/,"-2.         config->path_as_is = toggle;
-1.         break;

/*--proxy-service-name*/

1.         GetStr(&config->proxy_service_name, nextarg);
2.         break;",Not Useful
/*--service-name*/,"-2.         GetStr(&config->proxy_service_name, nextarg);
-1.         break;

/*--service-name*/

1.         GetStr(&config->service_name, nextarg);
2.         break;",Not Useful
/*--proto-default*/,"-2.         GetStr(&config->service_name, nextarg);
-1.         break;

/*--proto-default*/

1.         GetStr(&config->proto_default, nextarg);
2.         err = check_protocol(config->proto_default);
3.         if(err)
4.           return err;
5.        ",Not Useful
/*--expect100-timeout*/,"-5.         GetStr(&config->proto_default, nextarg);
-4.         err = check_protocol(config->proto_default);
-3.         if(err)
-2.           return err;
-1.         break;

/*--expect100-timeout*/

1.         err = str2udouble(&config->expect100timeout",Not Useful
/*--tftp-no-options*/,"-4.         err = str2udouble(&config->expect100timeout, nextarg, LONG_MAX/1000);
-3.         if(err)
-2.           return err;
-1.         break;

/*--tftp-no-options*/

1.         config->tftp_no_options = toggle;
2.         break;",Not Useful
/*--connect-to*/,"-2.         config->tftp_no_options = toggle;
-1.         break;

/*--connect-to*/

1.         err = add2list(&config->connect_to, nextarg);
2.         if(err)
3.           return err;
4.         break;",Not Useful
/*--abstract-unix-socket*/,"-4.         err = add2list(&config->connect_to, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--abstract-unix-socket*/

1.         config->abstract_unix_socket = TRUE;
2.         GetStr(&config->unix_socket_path, nextarg);
",Not Useful
/*--tls-max*/,"-3.         config->abstract_unix_socket = TRUE;
-2.         GetStr(&config->unix_socket_path, nextarg);
-1.         break;

/*--tls-max*/

1.         err = str2tls_max(&config->ssl_version_max, nextarg);
2.         if(err)
3.           return err;
4.    ",Not Useful
/*--suppress-connect-headers*/,"-4.         err = str2tls_max(&config->ssl_version_max, nextarg);
-3.         if(err)
-2.           return err;
-1.         break;

/*--suppress-connect-headers*/

1.         config->suppress_connect_headers = toggle;
2.         break;",Not Useful
/*--compressed-ssh*/,"-2.         config->suppress_connect_headers = toggle;
-1.         break;

/*--compressed-ssh*/

1.         config->ssh_compression = toggle;
2.         break;",Not Useful
/*--happy-eyeballs-timeout-ms*/,"-2.         config->ssh_compression = toggle;
-1.         break;

/*--happy-eyeballs-timeout-ms*/

1.         err = str2unum(&config->happy_eyeballs_timeout_ms, nextarg);
2.         if(err)
3.           return err;",Not Useful
/*--progress-meter*/,"-5.         break;
-4.       }
-3.       break;
-2.     case '#':
-1.       switch(subletter) {

/*--progress-meter*/

1.         global->noprogress = !toggle;
2.         break;",Not Useful
/*--http2-prior-knowledge*/,"-2.         config->httpversion = CURL_HTTP_VERSION_2_0;
-1.         break;

/*--http2-prior-knowledge*/

111",Not Useful
/*This specifies the User-Agent name*/,"-3.       config->ftp_append = toggle;
-2.       break;
-1.     case 'A':

/*This specifies the User-Agent name*/

1.       GetStr(&config->useragent, nextarg);
2.       break;
3.     case 'b':
4.       switch(subletter) {",Not Useful
/*--alt-svc*/,"-4.       GetStr(&config->useragent, nextarg);
-3.       break;
-2.     case 'b':
-1.       switch(subletter) {

/*--alt-svc*/

1.         if(curlinfo->features & CURL_VERSION_ALTSVC)
2.           GetStr(&config->altsvc, nextarg);
3.         else
4.      ",Not Useful
/*We have a cookie file to read from!*/,"-5.           err = add2list(&config->cookies, nextarg);
-4.           if(err)
-3.             return err;
-2.           break;
-1.         }

/*We have a cookie file to read from!*/

1.         err = add2list(&config->cookiefiles, nextarg);
2.         if",Not Useful
/*use ASCII/text when transferring*/,"-6.         err = add2list(&config->cookiefiles, nextarg);
-5.         if(err)
-4.           return err;
-3.       }
-2.       break;
-1.     case 'B':

/*use ASCII/text when transferring*/

1.       config->use_ascii = toggle;
2.       break;
3.     case",Not Useful
/*postfield data*/,"-10.           return err;
-9.         config->resume_from_current = FALSE;
-8.       }
-7.       else {
-6.         config->resume_from_current = TRUE;
-5.         config->resume_from = 0;
-4.       }
-3.       config->use_resume = TRUE;
-2.       break;",Not Useful
/*--data-urlencode*/,"-5.     {
-4.       char *postdata = NULL;
-3.       FILE *file;
-2.       size_t size = 0;
-1.       bool raw_mode = (subletter == 'r');

/*--data-urlencode*/

111",Not Useful
/*pass the @*/,"-10.             curl_free(enc);
-9.             postdata = n;
-8.           }
-7.           else
-6.             return PARAM_NO_MEM;
-5.         }
-4.       }
-3.       else if('@' == *nextarg && !raw_mode) {

/*pass the @*/

1.         if(!strcmp(""-"", ",Not Useful
/*forced data-binary*/,"-2.         if(!strcmp(""-"", nextarg)) {
-1.           file = stdin;

/*forced data-binary*/

1.             set_binmode(stdin);
2.         }
3.         else {
4.           file = fopen(nextarg, ""rb"");
5.           if(!file)
6.             warnf(global, ""C",Not Useful
"/*Automatic referer requested, this may be combined with a
           set initial one*/","-6.       GetStr(&config->headerfile, nextarg);
-5.       break;
-4.     case 'e':
-3.     {
-2.       char *ptr = strstr(nextarg, "";auto"");
-1.       if(ptr) {

/*Automatic referer requested, this may be combined with a
           set initial one*/

1.  ",Not Useful
/*cert file type*/,"-2.         GetStr(&config->cacert, nextarg);
-1.         break;

/*cert file type*/

1.         GetStr(&config->cert_type, nextarg);
2.         break;",Not Useful
/*CRL file*/,"-2.         GetStr(&config->hostpubsha256, nextarg);
-1.         break;

/*CRL file*/

1.         GetStr(&config->crlfile, nextarg);
2.         break;",Not Useful
/*TLS username*/,"-2.         GetStr(&config->crlfile, nextarg);
-1.         break;

/*TLS username*/

1.         if(!(curlinfo->features & CURL_VERSION_TLSAUTH_SRP)) {
2.           cleanarg(nextarg);
3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
4.         }
5.       ",Not Useful
/*TLS password*/,"-7.         if(!(curlinfo->features & CURL_VERSION_TLSAUTH_SRP)) {
-6.           cleanarg(nextarg);
-5.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-4.         }
-3.         GetStr(&config->tls_username, nextarg);
-2.         cleanarg(nextarg);
-1.    ",Not Useful
"/*no empty SSL fragments, --ssl-allow-beast*/","-4.         }
-3.         else
-2.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-1.         break;

/*no empty SSL fragments, --ssl-allow-beast*/

1.         if(curlinfo->features & CURL_VERSION_SSL)
2.           config->ssl_allow_beast = toggle;
3.    ",Not Useful
/*--cert-status*/,"-2.         GetStr(&config->proxy_pinnedpubkey, nextarg);
-1.         break;

/*--cert-status*/

1.         config->verifystatus = TRUE;
2.         break;",Not Useful
/*--false-start*/,"-2.         config->doh_verifystatus = TRUE;
-1.         break;

/*--false-start*/

1.         config->falsestart = TRUE;
2.         break;",Not Useful
/*--ssl-no-revoke*/,"-2.         config->falsestart = TRUE;
-1.         break;

/*--ssl-no-revoke*/

1.         if(curlinfo->features & CURL_VERSION_SSL)
2.           config->ssl_no_revoke = TRUE;
3.         break;",Not Useful
/*--tcp-fastopen*/,"-3.         if(curlinfo->features & CURL_VERSION_SSL)
-2.           config->ssl_revoke_best_effort = TRUE;
-1.         break;

/*--tcp-fastopen*/

1.         config->tcp_fastopen = TRUE;
2.         break;",Not Useful
/*TLS username for proxy*/,"-2.         config->tcp_fastopen = TRUE;
-1.         break;

/*TLS username for proxy*/

1.         if(!(curlinfo->features & CURL_VERSION_TLSAUTH_SRP)) {
2.           cleanarg(nextarg);
3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
4.         }
5.   ",Not Useful
/*TLS password for proxy*/,"-7.         if(!(curlinfo->features & CURL_VERSION_TLSAUTH_SRP)) {
-6.           cleanarg(nextarg);
-5.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-4.         }
-3.         GetStr(&config->proxy_tls_username, nextarg);
-2.         cleanarg(nextarg);
-",Not Useful
/*cert file type for proxy*/,"-3.         GetFileAndPassword(nextarg, &config->proxy_cert,
-2.                            &config->proxy_key_passwd);
-1.         break;

/*cert file type for proxy*/

1.         GetStr(&config->proxy_cert_type, nextarg);
2.         break;",Not Useful
/*CRL file for proxy*/,"-2.         GetStr(&config->proxy_cipher_list, nextarg);
-1.         break;

/*CRL file for proxy*/

1.         GetStr(&config->proxy_crlfile, nextarg);
2.         break;",Not Useful
/*--login-options*/,"-3.         if(curlinfo->features & CURL_VERSION_SSL)
-2.           config->proxy_ssl_allow_beast = toggle;
-1.         break;

/*--login-options*/

1.         GetStr(&config->login_options, nextarg);
2.         break;",Not Useful
/*--socks5-basic*/,"-3.         config->proxy_ssl_version = CURL_SSLVERSION_TLSv1;
-2.         break;
-1.       case 'A':

/*--socks5-basic*/

1.         if(toggle)
2.           config->socks5_auth |= CURLAUTH_BASIC;
3.         else
4.           config->socks5_auth &= ~CURLA",Not Useful
/*--socks5-gssapi*/,"-2.         GetStr(&config->noproxy, nextarg);
-1.         break;

/*--socks5-gssapi*/

1.         config->socks5_gssapi_nec = toggle;
2.         break;",Not Useful
/*unknown flag*/,"-10.         break;
-9.       case 'C':
-8.         GetStr(&config->etag_save_file, nextarg);
-7.         break;
-6.       case 'D':
-5.         GetStr(&config->etag_compare_file, nextarg);
-4.         break;
-3.       case 'E':
-2.         GetStr(&config",Not Useful
/*--fail-early*/,"-5.         return PARAM_OPTION_UNKNOWN;
-4.       }
-3.       break;
-2.     case 'f':
-1.       switch(subletter) {

/*--fail-early*/

1.         global->fail_early = toggle;
2.         break;",Not Useful
/*--styled-output*/,"-2.         global->fail_early = toggle;
-1.         break;

/*--styled-output*/

1.         global->styled_output = toggle;
2.         break;",Not Useful
/*--fail (hard on errors)*/,"-2.         config->rm_partial = toggle;
-1.         break;

/*--fail (hard on errors)*/

1.         config->failonerror = toggle;
2.         break;
3.       }
4.       if(config->failonerror && config->failwithbody) {
5.         errorf(config->global, ""Y",Not Useful
/*g disables URLglobbing*/,"-4.         return PARAM_BAD_USE;
-3.       if(SetHTTPrequest(config, HTTPREQ_MIMEPOST, &config->httpreq))
-2.         return PARAM_BAD_USE;
-1.       break;

/*g disables URLglobbing*/

1.       config->globoff = toggle;
2.       break;",Not Useful
/*HTTP GET*/,"-2.       config->globoff = toggle;
-1.       break;

/*HTTP GET*/

111",Not Useful
/*--request-target*/,"-3.       config->globoff = toggle;
-2.       break;

/*--request-target*/

1.         GetStr(&config->request_target, nextarg);
2.       }
3.       else
4.         config->use_httpget = TRUE;
5.       break;",Not Useful
/*Allow strtok() here since this isn't used threaded*/,"-9.         char *string;
-8.         size_t len;
-7.         bool use_stdin = !strcmp(&nextarg[1], ""-"");
-6.         FILE *file = use_stdin?stdin:fopen(&nextarg[1], FOPEN_READTEXT);
-5.         if(!file)
-4.           warnf(global, ""Failed to open %s!\n""",Not Useful
/*!checksrc! disable BANNEDFUNC 2*/,"-10.         char *string;
-9.         size_t len;
-8.         bool use_stdin = !strcmp(&nextarg[1], ""-"");
-7.         FILE *file = use_stdin?stdin:fopen(&nextarg[1], FOPEN_READTEXT);
-6.         if(!file)
-5.           warnf(global, ""Failed to open %s!\n",Not Useful
/*--proxy-header*/,"-2.             char *h = strtok(string, ""\r\n"");
-1.             while(h) {

/*--proxy-header*/

1.                 err = add2list(&config->proxyheaders, h);
2.               else
3.                 err = add2list(&config->headers, h);
4.               i",Not Useful
/*--proxy-header*/,"-2.             char *h = strtok(string, ""\r\n"");
-1.             while(h) {

/*--proxy-header*/

1.                 err = add2list(&config->proxyheaders, h);
2.               else
3.                 err = add2list(&config->headers, h);
4.               i",Not Useful
/*parse config file*/,"-4.         config->doh_insecure_ok = toggle;
-3.       else
-2.         config->insecure_ok = toggle;
-1.       break;

/*parse config file*/

1.       if(parseconfig(nextarg, global)) {
2.         errorf(global, ""cannot read config from '%s'\n"", nextarg",Not Useful
/*--no-manual shows no manual...*/,"-5.       err = str2udouble(&config->timeout, nextarg, LONG_MAX/1000);
-4.       if(err)
-3.         return err;
-2.       break;

/*--no-manual shows no manual...*/

1. #ifdef USE_MANUAL
2.         return PARAM_MANUAL_REQUESTED;
3. #else
4.         warnf",Not Useful
/*netrc-file*/,"-10.   {""k"",  ""insecure"",                 ARG_BOOL},
-9.   {""kd"", ""doh-insecure"",             ARG_BOOL},
-8.   {""K"",  ""config"",                   ARG_FILENAME},
-7.   {""l"",  ""list-only"",                ARG_BOOL},
-6.   {""L"",  ""location"",                 A",Not Useful
/*FALLTHROUGH*/,"-3.         config->file_clobber_mode = toggle ? CLOBBER_ALWAYS : CLOBBER_NEVER;
-2.         break;
-1.       }

/*FALLTHROUGH*/

111",Not Useful
/*fill in the outfile*/,"-3.         config->url_out = url = new_getout(config);
-2.       if(!url)
-1.         return PARAM_NO_MEM;

/*fill in the outfile*/

1.       if('o' == letter) {
2.         if(!*nextarg) {
3.           warnf(global, ""output file name has no length\n"");
4",Not Useful
/*leave it*/,"-2.       }
-1.       else {

/*leave it*/

1.         if(toggle)",Not Useful
/*use remote file's time*/,"-10.                   ""\'start\'-\'stop\'. The server's response to this ""
-9.                   ""request is uncertain.\n"");
-8.             break;
-7.           }
-6.           tmp_range++;
-5.         }
-4.         GetStr(&config->range, nextarg);
-3. ",Not Useful
/*toggle off*/,"-8.       if(toggle)
-7.         global->mute = global->noprogress = TRUE;
-6.       else
-5.         global->mute = global->noprogress = FALSE;
-4.       if(global->showerror < 0)

/*toggle off*/

1.       break;
2.     case 'S':",Not Useful
/*show errors*/,"-3.       config->remote_time = toggle;
-2.       break;
-1.     case 's':

/*show errors*/

1.       if(toggle)
2.         global->mute = global->noprogress = TRUE;
3.       else
4.         global->mute = global->noprogress = FALSE;
5.       if(global->s",Not Useful
/*Telnet options*/,"-2.       break;
-1.     case 't':

/*Telnet options*/

1.       err = add2list(&config->telnet_options, nextarg);
2.       if(err)
3.         return err;
4.       break;
5.     case 'T':",Not Useful
/*mark -T used*/,"-3.         config->url_ul = url = new_getout(config);
-2.       if(!url)
-1.         return PARAM_NO_MEM;

/*mark -T used*/

1.       if(!*nextarg)
2.         url->flags |= GETOUT_NOUPLOAD;
3.       else {",Not Useful
/*verbose is disabled here*/,"-10.         Curl_safefree(global->trace_dump);
-9.         global->trace_dump = strdup(""%"");
-8.         if(!global->trace_dump)
-7.           return PARAM_NO_MEM;
-6.         if(global->tracetype && (global->tracetype != TRACE_PLAIN))
-5.           warn",Not Useful
/*pass the @*/,"-10.             curl_free(enc);
-9.             postdata = n;
-8.           }
-7.           else
-6.             return PARAM_NO_MEM;
-5.         }
-4.       }
-3.       else if('@' == *nextarg && !raw_mode) {

/*pass the @*/

1.         if(!strcmp(""-"", ",Not Useful
/*--preproxy*/,"-10.         if(err)
-9.           return err;
-8.         if(!config->writeout)
-7.           warnf(global, ""Failed to read %s"", fname);
-6.       }
-5.       else
-4.         GetStr(&config->writeout, nextarg);
-3.       break;
-2.     case 'x':
-1.    ",Not Useful
/*--proxy*/,"-6.         err = str2num(&config->maxredirs, nextarg);
-5.         if(err)
-4.           return err;
-3.         if(config->maxredirs < -1)
-2.           return PARAM_BAD_NUMERIC;
-1.         break;

/*--proxy*/

1.         if(curlinfo->features & CURL_V",Not Useful
/*set custom request*/,"-6.         GetStr(&config->proxy, nextarg);
-5.         config->proxyver = CURLPROXY_HTTP;
-4.         break;
-3.       }
-2.       break;
-1.     case 'X':

/*set custom request*/

1.       GetStr(&config->customrequest, nextarg);
2.       break;
3.    ",Not Useful
/*low speed time*/,"-3.       GetStr(&config->customrequest, nextarg);
-2.       break;
-1.     case 'y':

/*low speed time*/

1.       err = str2unum(&config->low_speed_time, nextarg);
2.       if(err)
3.         return err;
4.       if(!config->low_speed_limit)
5.         ",Not Useful
/*low speed limit*/,"-7.       err = str2unum(&config->low_speed_time, nextarg);
-6.       if(err)
-5.         return err;
-4.       if(!config->low_speed_limit)
-3.         config->low_speed_limit = 1;
-2.       break;
-1.     case 'Y':

/*low speed limit*/

1.       err = s",Not Useful
/*--parallel*/,"-8.       err = str2unum(&config->low_speed_limit, nextarg);
-7.       if(err)
-6.         return err;
-5.       if(!config->low_speed_time)
-4.         config->low_speed_time = 30;
-3.       break;
-2.     case 'Z':
-1.       switch(subletter) {

/*--par",Not Useful
/*--parallel-max*/,"-2.         global->parallel = toggle;
-1.         break;

/*--parallel-max*/

1.         err = str2unum(&global->parallel_max, nextarg);
2.         if(err)
3.           return err;
4.         if((global->parallel_max > MAX_PARALLEL) ||
5.            (glo",Not Useful
/*--parallel-connect*/,"-7.         err = str2unum(&global->parallel_max, nextarg);
-6.         if(err)
-5.           return err;
-4.         if((global->parallel_max > MAX_PARALLEL) ||
-3.            (global->parallel_max < 1))
-2.           global->parallel_max = PARALLEL_DEFA",Not Useful
/*FALLTHROUGH*/,"-3.         config->file_clobber_mode = toggle ? CLOBBER_ALWAYS : CLOBBER_NEVER;
-2.         break;
-1.       }

/*FALLTHROUGH*/

111",Not Useful
/*now let's see if it is a file name to get the time from instead!*/,"-7.         config->timecond = CURL_TIMECOND_LASTMOD;
-6.         nextarg++;
-5.         break;
-4.       }
-3.       now = time(NULL);
-2.       config->condtime = (curl_off_t)curl_getdate(nextarg, &now);
-1.       if(-1 == config->condtime) {

/*now let",Not Useful
/*unknown flag*/,"-10.         break;
-9.       case 'C':
-8.         GetStr(&config->etag_save_file, nextarg);
-7.         break;
-6.       case 'D':
-5.         GetStr(&config->etag_compare_file, nextarg);
-4.         break;
-3.       case 'E':
-2.         GetStr(&config",Not Useful
"/*Reset result as PARAM_NEXT_OPERATION is only used here and not
             returned from this function*/","-10.            following (URL) argument to start with -. */
-9.         stillflags = FALSE;
-8.       else {
-7.         char *nextarg = (i < (argc - 1))
-6.           ? curlx_convert_tchar_to_UTF8(argv[i + 1])
-5.           : NULL;
-4.         result = ",Not Useful
/*Set the global config pointer*/,"-1.               config_init(config->next);

/*Set the global config pointer*/

1.               config->next->global = global;",Not Useful
/*Update the last config pointer*/,"-1.               config->next->global = global;

/*Update the last config pointer*/

1.               global->last = config->next;",Not Useful
/*Move onto the new config*/,"-1.               global->last = config->next;

/*Move onto the new config*/

1.               config->next->prev = config;
2.               config = config->next;
3.             }
4.             else
5.               result = PARAM_NO_MEM;
6.           }",Not Useful
/*we're supposed to skip this*/,"-8.               config->next->prev = config;
-7.               config = config->next;
-6.             }
-5.             else
-4.               result = PARAM_NO_MEM;
-3.           }
-2.         }
-1.         else if(!result && passarg)

/*we're supposed",Not Useful
/*Query the security package for Kerberos*/,"-10.  * This is used to evaluate if GSSAPI (Kerberos V5) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Kerberos V5 is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_gssapi_supported(void)
-3. {
-2.   PSecPkgInfo Secu",Not Useful
/*Query the security package for Kerberos*/,"-10.  * This is used to evaluate if GSSAPI (Kerberos V5) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Kerberos V5 is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_gssapi_supported(void)
-3. {
-2.   PSecPkgInfo Secu",Not Useful
/*Do we have credentials to use or are we using single sign-on?*/,"-5.     krb5->output_token = malloc(krb5->token_max);
-4.     if(!krb5->output_token)
-3.       return CURLE_OUT_OF_MEMORY;
-2.   }
-1.   if(!krb5->credentials) {

/*Do we have credentials to use or are we using single sign-on?*/

1.     if(userp && *user",Not Useful
/*Allow proper cleanup of the identity structure*/,"-3.       result = Curl_create_sspi_identity(userp, passwdp, &krb5->identity);
-2.       if(result)
-1.         return result;

/*Allow proper cleanup of the identity structure*/

1.       krb5->p_identity = &krb5->identity;
2.     }
3.     else",Not Useful
/*Acquire our credentials handle*/,"-3.     krb5->credentials = calloc(1, sizeof(CredHandle));
-2.     if(!krb5->credentials)
-1.       return CURLE_OUT_OF_MEMORY;

/*Acquire our credentials handle*/

1.     status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                               ",Not Useful
/*Allocate the trailer*/,"-2.     max_size = 0;
-1.   }

/*Allocate the trailer*/

1.   trailer = malloc(sizes.cbSecurityTrailer);
2.   if(!trailer)
3.     return CURLE_OUT_OF_MEMORY;",Not Useful
/*Allocate our message*/,"-3.   trailer = malloc(sizes.cbSecurityTrailer);
-2.   if(!trailer)
-1.     return CURLE_OUT_OF_MEMORY;

/*Allocate our message*/

1.   messagelen = 4;
2.   if(authzid)
3.     messagelen += strlen(authzid);
4.   message = malloc(messagelen);
5.   if(!mess",Not Useful
/*Allocate the padding*/,"-2.   if(authzid && *authzid)
-1.     memcpy(message + 4, authzid, messagelen - 4);

/*Allocate the padding*/

1.   padding = malloc(sizes.cbBlockSize);
2.   if(!padding) {
3.     free(message);
4.     free(trailer);
5.     return CURLE_OUT_OF_MEMORY;
6. ",Not Useful
/*Encrypt the data*/,"-10.   wrap_desc.pBuffers     = wrap_buf;
-9.   wrap_buf[0].BufferType = SECBUFFER_TOKEN;
-8.   wrap_buf[0].pvBuffer   = trailer;
-7.   wrap_buf[0].cbBuffer   = sizes.cbSecurityTrailer;
-6.   wrap_buf[1].BufferType = SECBUFFER_DATA;
-5.   wrap_buf[1].pvBu",Not Useful
"/** Curl_auth_cleanup_gssapi()
 *
 * This is used to clean up the GSSAPI (Kerberos V5) specific data.
 *
 * Parameters:
 *
 * krb5     [in/out] - The Kerberos 5 data struct being cleaned up.
 **/","Curl_sspi_free_identity(krb5->p_identity);
  krb5->p_identity = NULL;

/** Curl_auth_cleanup_gssapi()
 *
 * This is used to clean up the GSSAPI (Kerberos V5) specific data.
 *
 * Parameters:
 *
 * krb5     [in/out] - The Kerberos 5 data struct being cleaned up.
 **/

1.   krb5->token_max = 0;
2. }",Not Useful
/*Free our security context*/,"-10.  *
-9.  * This is used to clean up the GSSAPI (Kerberos V5) specific data.
-8.  *
-7.  * Parameters:
-6.  *
-5.  * krb5     [in/out] - The Kerberos 5 data struct being cleaned up.
-4.  *
-3.  */
-2. void Curl_auth_cleanup_gssapi(struct kerberos5data ",Not Useful
/*Free our credentials handle*/,"-5.   if(krb5->context) {
-4.     s_pSecFn->DeleteSecurityContext(krb5->context);
-3.     free(krb5->context);
-2.     krb5->context = NULL;
-1.   }

/*Free our credentials handle*/

1.   if(krb5->credentials) {
2.     s_pSecFn->FreeCredentialsHandle(krb5",Not Useful
/*Free our identity*/,"-5.   if(krb5->credentials) {
-4.     s_pSecFn->FreeCredentialsHandle(krb5->credentials);
-3.     free(krb5->credentials);
-2.     krb5->credentials = NULL;
-1.   }

/*Free our identity*/

1.   Curl_sspi_free_identity(krb5->p_identity);
2.   krb5->p_ident",Not Useful
/*Free the SPN and output token*/,"-2.   Curl_sspi_free_identity(krb5->p_identity);
-1.   krb5->p_identity = NULL;

/*Free the SPN and output token*/

1.   Curl_safefree(krb5->spn);
2.   Curl_safefree(krb5->output_token);",Not Useful
/*Import the SPN*/,"-2.     spn_token.value = spn;
-1.     spn_token.length = strlen(spn);

/*Import the SPN*/

1.     major_status = gss_import_name(&minor_status, &spn_token,
2.                                    GSS_C_NT_HOSTBASED_SERVICE,
3.                              ",Not Useful
/*Query the security package for Negotiate*/,"-10.  * This is used to evaluate if SPNEGO (Negotiate) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Negotiate is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_spnego_supported(void)
-3. {
-2.   PSecPkgInfo Security",Not Useful
/*Query the security package for Negotiate*/,"-10.  * This is used to evaluate if SPNEGO (Negotiate) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Negotiate is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_spnego_supported(void)
-3. {
-2.   PSecPkgInfo Security",Not Useful
/*Allocate our credentials handle*/,"-1.       nego->p_identity = NULL;

/*Allocate our credentials handle*/

1.     nego->credentials = calloc(1, sizeof(CredHandle));
2.     if(!nego->credentials)
3.       return CURLE_OUT_OF_MEMORY;",Not Useful
/*Acquire our credentials handle*/,"-3.     nego->credentials = calloc(1, sizeof(CredHandle));
-2.     if(!nego->credentials)
-1.       return CURLE_OUT_OF_MEMORY;

/*Acquire our credentials handle*/

1.     nego->status =
2.       s_pSecFn->AcquireCredentialsHandle(NULL,
3.                ",Not Useful
/*Allocate our new context handle*/,"-8.     nego->status =
-7.       s_pSecFn->AcquireCredentialsHandle(NULL,
-6.                                          (TCHAR *)TEXT(SP_NAME_NEGOTIATE),
-5.                                          SECPKG_CRED_OUTBOUND, NULL,
-4.                          ",Not Useful
/*The last 3 #include files should be in this order*/,"-7. #include ""mime.h""
-6. #include ""vtls/vtls.h""
-5. #include ""strcase.h""
-4. #include ""sendf.h""
-3. #include ""strdup.h""
-2. #include ""rand.h""
-1. #include ""warnless.h""

/*The last 3 #include files should be in this order*/

1. #include ""curl_printf.h""
2.",Not Useful
/*end of array state*/,"-1.       if(CURLFORM_END == option) {

/*end of array state*/

1.         array_state = FALSE;
2.         continue;
3.       }
4.     }
5.     else {",Not Useful
/*The last 3 #include files should be in this order*/,"-10. #include ""curl_addrinfo.h""
-9. #include ""doh.h""
-8. #include ""sendf.h""
-7. #include ""multiif.h""
-6. #include ""url.h""
-5. #include ""share.h""
-4. #include ""curl_base64.h""
-3. #include ""connect.h""
-2. #include ""strdup.h""
-1. #include ""dynbuf.h""

/*The l",Not Useful
/*bytes*/,"-4. {
-3.   const size_t hostlen = strlen(host);
-2.   unsigned char *orig = dnsp;
-1.   const char *hostp = host;
  /* The expected output length is 16 bytes more than the length of

/*bytes*/

1.    * the QNAME-encoding of the host name.
2.    *
3.    *",Not Useful
/*next label*/,"-2.     if(dot)
-1.       hostp++;

/*next label*/

111",Not Useful
"/** This specific transfer on this connection has been ""drained"".*/","-9.         if(stream->push_headers[i][len] != ':')
-8.           continue;
-7.         return &stream->push_headers[i][len + 1];
-6.       }
-5.     }
-4.   }
-3.   return NULL;
-2. }
-1. /*
 * This specific transfer on this connection has been ""drained""",Not Useful
/*setup the request struct*/,"-10.                        struct http_conn *httpc)
-9. {
-8.   data->state.drain++;
-7.   httpc->drain_total++;
-6.   DEBUGASSERT(httpc->drain_total >= data->state.drain);
-5. }
-4. static struct Curl_easy *duphandle(struct Curl_easy *data)
-3. {
-2.   ",Not Useful
/*FAIL HARD*/,"-3.     struct Curl_easy *newhandle = duphandle(data);
-2.     if(!newhandle) {
-1.       infof(data, ""failed to duplicate handle"");

/*FAIL HARD*/

1.       goto fail;
2.     }
3.     heads.data = data;
4.     heads.frame = frame;",Not Useful
/*ask the application*/,"-4.       goto fail;
-3.     }
-2.     heads.data = data;
-1.     heads.frame = frame;

/*ask the application*/

1.     H2BUGF(infof(data, ""Got PUSH_PROMISE, ask application""));
2.     stream = data->req.p.http;
3.     if(!stream) {
4.       failf(data, """,Not Useful
/*free the headers again*/,"-10.     if(rv) {
-9.       (void)Curl_close(&newhandle);
-8.       rv = CURL_PUSH_DENY;
-7.       goto fail;
-6.     }
-5.     Curl_set_in_callback(data, true);
-4.     rv = data->multi->push_cb(data, newhandle,
-3.                               stream->",Not Useful
/*should never be a zero stream ID here*/,"-10.                               int32_t stream_id,
-9.                               const uint8_t *mem, size_t len, void *userp)
-8. {
-7.   struct HTTP *stream;
-6.   struct Curl_easy *data_s;
-5.   size_t nread;
-4.   struct connectdata *conn = (str",Not Useful
/*cleared*/,"-10.     if(rv) {
-9.       infof(data_s, ""http/2: failed to clear user_data for stream %d"",
-8.             stream_id);
-7.       DEBUGASSERT(0);
-6.     }
-5.     if(stream_id == httpc->pause_stream_id) {
-4.       H2BUGF(infof(data_s, ""Stopped the paus",Not Useful
/*frame->hd.type is either NGHTTP2_HEADERS or NGHTTP2_PUSH_PROMISE*/,"-10.   for(i = 0; i < 3; ++i) {
-9.     char c = value[i];
-8.     if(c < '0' || c > '9') {
-7.       return -1;
-6.     }
-5.     res *= 10;
-4.     res += c - '0';
-3.   }
-2.   return res;
-1. }

/*frame->hd.type is either NGHTTP2_HEADERS or NGHTTP2_PU",Not Useful
/*should never be a zero stream ID here*/,"-10.                               int32_t stream_id,
-9.                               const uint8_t *mem, size_t len, void *userp)
-8. {
-7.   struct HTTP *stream;
-6.   struct Curl_easy *data_s;
-5.   size_t nread;
-4.   struct connectdata *conn = (str",Not Useful
/*if they weren't used and then freed before*/,"-3.   Curl_dyn_free(&http->header_recvbuf);
-2.   Curl_dyn_free(&http->trailer_recvbuf);
-1.   if(http->push_headers) {

/*if they weren't used and then freed before*/

1.     for(; http->push_headers_used > 0; --http->push_headers_used) {
2.       free(h",Not Useful
/*not HTTP/2 ?*/,"-7.     for(; http->push_headers_used > 0; --http->push_headers_used) {
-6.       free(http->push_headers[http->push_headers_used - 1]);
-5.     }
-4.     free(http->push_headers);
-3.     http->push_headers = NULL;
-2.   }
-1.   if(!(data->conn->handler-",Not Useful
/*RST_STREAM*/,"-5.   if(http->stream_id == httpc->pause_stream_id) {
-4.     H2BUGF(infof(data, ""DONE the pause stream (%x)"", http->stream_id));
-3.     httpc->pause_stream_id = 0;
-2.   }
-1.   if(premature || (!http->closed && http->stream_id)) {

/*RST_STREAM*/

111",Not Useful
/** Initialize nghttp2 for a Curl connection*/,"-10.     if(rv) {
-9.       infof(data, ""http/2: failed to clear user_data for stream %d"",
-8.             http->stream_id);
-7.       DEBUGASSERT(0);
-6.     }
-5.     set_transfer(httpc, NULL);
-4.     http->stream_id = 0;
-3.   }
-2. }
-1. /*
 * Initia",Not Useful
/*nghttp2_send_callback*/,"-6. void Curl_http2_ver(char *p, size_t len)
-5. {
-4.   nghttp2_info *h2 = nghttp2_version(0);
-3.   (void)msnprintf(p, len, ""nghttp2/%s"", h2->version_str);
-2. }
-1. /*
 * The implementation of nghttp2_send_callback type. Here we write |data| with

/*ng",Not Useful
/*nghttp2_on_frame_recv_callback*/,"-1.     nghttp2_session_callbacks_set_send_callback(callbacks, send_callback);

/*nghttp2_on_frame_recv_callback*/

1.     nghttp2_session_callbacks_set_on_frame_recv_callback
2.       (callbacks, on_frame_recv);",Not Useful
/*nghttp2_on_data_chunk_recv_callback*/,"-2.     nghttp2_session_callbacks_set_on_frame_recv_callback
-1.       (callbacks, on_frame_recv);

/*nghttp2_on_data_chunk_recv_callback*/

1.     nghttp2_session_callbacks_set_on_data_chunk_recv_callback
2.       (callbacks, on_data_chunk_recv);",Not Useful
/*nghttp2_on_stream_close_callback*/,"-2.     nghttp2_session_callbacks_set_on_data_chunk_recv_callback
-1.       (callbacks, on_data_chunk_recv);

/*nghttp2_on_stream_close_callback*/

1.     nghttp2_session_callbacks_set_on_stream_close_callback
2.       (callbacks, on_stream_close);",Not Useful
/*nghttp2_on_begin_headers_callback*/,"-2.     nghttp2_session_callbacks_set_on_stream_close_callback
-1.       (callbacks, on_stream_close);

/*nghttp2_on_begin_headers_callback*/

1.     nghttp2_session_callbacks_set_on_begin_headers_callback
2.       (callbacks, on_begin_headers);",Not Useful
/*nghttp2_on_header_callback*/,"-2.     nghttp2_session_callbacks_set_on_begin_headers_callback
-1.       (callbacks, on_begin_headers);

/*nghttp2_on_header_callback*/

1.     nghttp2_session_callbacks_set_on_header_callback(callbacks, on_header);
2.     nghttp2_session_callbacks_set_e",Not Useful
/** Returns nonzero if current HTTP/2 session should be closed.*/,"-10.   result = Curl_dyn_addf(req,
-9.                          ""Connection: Upgrade, HTTP2-Settings\r\n""
-8.                          ""Upgrade: %s\r\n""
-7.                          ""HTTP2-Settings: %s\r\n"",
-6.                          NGHTTP2_CLEARTEXT_",Not Useful
"/** h2_process_pending_input() processes pending input left in
 * httpc->inbuf.  Then, call h2_session_send() to send pending data.
 * This function returns 0 if it succeeds, or -1 and error code will
 * be assigned to *err.*/","-6. static int should_close_session(struct http_conn *httpc)
-5. {
-4.   return httpc->drain_total == 0 && !nghttp2_session_want_read(httpc->h2) &&
-3.     !nghttp2_session_want_write(httpc->h2);
-2. }
-1. /*
 * h2_process_pending_input() processes pendin",Not Useful
/*don't use this anymore*/,"-4.   stream->closed = FALSE;
-3.   if(stream->error == NGHTTP2_REFUSED_STREAM) {
-2.     H2BUGF(infof(data, ""REFUSED_STREAM (%d), try again on a new connection"",
-1.                  stream->stream_id));

/*don't use this anymore*/

1.     data->state.re",Not Useful
"/*data for this stream is returned now, but this stream caused a pause
         already so we need it called again asap*/","-10.     }
-9.     if(h2_process_pending_input(data, httpc, err))
-8.       return -1;
-7.   }
-6.   if(stream->memlen) {
-5.     ssize_t retlen = stream->memlen;
-4.     H2BUGF(infof(data, ""http2_recv: returns %zd for stream %u"",
-3.                  ret",Not Useful
"/*unknown, but not zero*/","-10.                nghttp2_session_check_request_allowed(h2), (void *)data));
-9.   switch(data->state.httpreq) {
-8.   case HTTPREQ_POST:
-7.   case HTTPREQ_POST_FORM:
-6.   case HTTPREQ_POST_MIME:
-5.   case HTTPREQ_PUT:
-4.     if(data->state.infilesi",Not Useful
/*stream 1 is opened implicitly on upgrade*/,"-10.   int rv;
-9.   struct HTTP *stream = data->req.p.http;
-8.   result = Curl_http2_setup(data, conn);
-7.   if(result)
-6.     return result;
-5.   httpc->recv_underlying = conn->recv[FIRSTSOCKET];
-4.   httpc->send_underlying = conn->send[FIRSTSOCKET",Not Useful
/*stream ID is unknown at this point*/,"-10.                                               stream->stream_id,
-9.                                               data);
-8.     if(rv) {
-7.       infof(data, ""http/2: failed to set user_data for stream %d"",
-6.             stream->stream_id);
-5. ",Not Useful
/*The last #include file should be:*/,"-10. #include ""progress.h""
-9. #include ""gopher.h""
-8. #include ""select.h""
-7. #include ""strdup.h""
-6. #include ""vtls/vtls.h""
-5. #include ""url.h""
-4. #include ""escape.h""
-3. #include ""warnless.h""
-2. #include ""curl_printf.h""
-1. #include ""curl_memory.h""
",Not Useful
/** Forward declarations.*/,"-2. #include ""memdebug.h""
-1. /*
 * Forward declarations.

/** Forward declarations.*/

1.  */
2. static CURLcode gopher_do(struct Curl_easy *data, bool *done);
3. #ifdef USE_SSL
4. static CURLcode gopher_connect(struct Curl_easy *data, bool *done);
5. st",Not Useful
/*Which may not have written it all!*/,"-3.     if(strlen(sel) < 1)
-2.       break;
-1.     result = Curl_write(data, sockfd, sel, k, &amount);

/*Which may not have written it all!*/

1.       result = Curl_client_write(data, CLIENTWRITE_HEADER, sel, amount);
2.       if(result)
3.         br",Not Useful
/*but it did write it all*/,"-6.       result = Curl_client_write(data, CLIENTWRITE_HEADER, sel, amount);
-5.       if(result)
-4.         break;
-3.       k -= amount;
-2.       sel += amount;
-1.       if(k < 1)

/*but it did write it all*/

1.     }
2.     else
3.       break;
4. ",Not Useful
/*The last #include file should be:*/,"-10. #include ""urldata.h""
-9. #include <curl/curl.h>
-8. #include ""transfer.h""
-7. #include ""sendf.h""
-6. #include ""escape.h""
-5. #include ""progress.h""
-4. #include ""dict.h""
-3. #include ""curl_printf.h""
-2. #include ""strcase.h""
-1. #include ""curl_memory.h",Not Useful
/** Forward declarations.*/,"-2. #include ""memdebug.h""
-1. /*
 * Forward declarations.

/** Forward declarations.*/

1.  */
2. static CURLcode dict_do(struct Curl_easy *data, bool *done);",Not Useful
/*unconditionally*/,"-4.   CURLcode result = CURLE_OK;
-3.   struct connectdata *conn = data->conn;
-2.   curl_socket_t sockfd = conn->sock[FIRSTSOCKET];
-1.   char *path = data->state.up.path;

/*unconditionally*/

1.   if(strncasecompare(path, DICT_MATCH, sizeof(DICT_MATCH)",Not Useful
/*database*/,"-7.   return result;
-6. }
-5. static CURLcode dict_do(struct Curl_easy *data, bool *done)
-4. {
-3.   char *word;
-2.   char *eword;
-1.   char *ppath;
  char *database = NULL;

/*database*/

1.   char *strategy = NULL;",Not Useful
/*strategy*/,"-8.   return result;
-7. }
-6. static CURLcode dict_do(struct Curl_easy *data, bool *done)
-5. {
-4.   char *word;
-3.   char *eword;
-2.   char *ppath;
-1.   char *database = NULL;
  char *strategy = NULL;

/*strategy*/

111",Not Useful
/*word*/,"-10.   ZERO_NULL,                            /* perform_getsock */
-9.   ZERO_NULL,                            /* disconnect */
-8.   ZERO_NULL,                            /* readwrite */
-7.   ZERO_NULL,                            /* connection_check */
",Not Useful
/*database*/,"-7.   return result;
-6. }
-5. static CURLcode dict_do(struct Curl_easy *data, bool *done)
-4. {
-3.   char *word;
-2.   char *eword;
-1.   char *ppath;
  char *database = NULL;

/*database*/

1.   char *strategy = NULL;",Not Useful
/*word*/,"-10.   ZERO_NULL,                            /* perform_getsock */
-9.   ZERO_NULL,                            /* disconnect */
-8.   ZERO_NULL,                            /* readwrite */
-7.   ZERO_NULL,                            /* connection_check */
",Not Useful
/*Finalise the digest*/,"-3.   if(Curl_bufref_len(chlg))
-2.     Curl_HMAC_update(ctxt, Curl_bufref_ptr(chlg),
-1.                      curlx_uztoui(Curl_bufref_len(chlg)));

/*Finalise the digest*/

1.   Curl_HMAC_final(ctxt, digest);",Not Useful
"/** Curl_auth_is_digest_supported()
*
* This is used to evaluate if DIGEST is supported.
*
* Parameters: None
*
* Returns TRUE if DIGEST is supported by Windows SSPI.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
* Curl_auth_is_digest_supported()
*
* This is used to evaluate if DIGEST is supported.
*
* Parameters: None
*
* Returns TRUE if DIGEST is supported by Windows SSPI.

/** Curl_auth_is_digest_sup",Not Useful
/*Query the security package for Digest*/,"-10. * This is used to evaluate if DIGEST is supported.
-9. *
-8. * Parameters: None
-7. *
-6. * Returns TRUE if DIGEST is supported by Windows SSPI.
-5. */
-4. bool Curl_auth_is_digest_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURI",Not Useful
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
-1.                                               &SecurityPackage);

/*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_pS",Not Useful
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
-1.                                               &SecurityPackage);

/*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_pS",Not Useful
/*Acquire our credentials handle*/,"-1.     p_identity = NULL;

/*Acquire our credentials handle*/

1.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                               (TCHAR *) TEXT(SP_NAME_DIGEST),
3.                                               SECPKG",Not Useful
"/*Unknown specifier, ignore it!*/","-10.             curlx_unicodefree(domain.tchar_ptr);
-9.             return CURLE_OUT_OF_MEMORY;
-8.           }
-7.           free(identity->Domain);
-6.           identity->Domain = dup_domain.tbyte_ptr;
-5.           identity->DomainLength = curlx_uzt",Not Useful
/*We're done here*/,"-3.         }
-2.       }
-1.       else

/*We're done here*/

111",Not Useful
/*Allow the list to be comma-separated*/,"-2.       while(*chlg && ISSPACE(*chlg))
-1.         chlg++;

/*Allow the list to be comma-separated*/

1.       if(',' == *chlg)
2.         chlg++;
3.     }
4.   }
5.   return CURLE_OK;
6. }
7. /*
8.  * Curl_auth_decode_digest_http_message()
9.  *
10.  *",Not Useful
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
-1.                                               &SecurityPackage);

/*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_pS",Not Useful
/*delete the context so a new one can be made*/,"-10.     chlg_buf[2].cbBuffer   = curlx_uztoul(strlen((const char *) uripath));
-9.     chlg_buf[3].BufferType = SECBUFFER_PKG_PARAMS;
-8.     chlg_buf[3].pvBuffer   = NULL;
-7.     chlg_buf[3].cbBuffer   = 0;
-6.     chlg_buf[4].BufferType = SECBUFFER_PA",Not Useful
/*Acquire our credentials handle*/,"-1.     p_identity = NULL;

/*Acquire our credentials handle*/

1.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                               (TCHAR *) TEXT(SP_NAME_DIGEST),
3.                                               SECPKG",Not Useful
/*Allocate our new context handle*/,"-10.     resp_buf.BufferType = SECBUFFER_TOKEN;
-9.     resp_buf.pvBuffer   = output_token;
-8.     resp_buf.cbBuffer   = curlx_uztoul(token_max);
-7.     spn = curlx_convert_UTF8_to_tchar((char *) uripath);
-6.     if(!spn) {
-5.       s_pSecFn->FreeCred",Not Useful
/*Free the input token*/,"-10.  *
-9.  * This is used to clean up the digest specific data.
-8.  *
-7.  * Parameters:
-6.  *
-5.  * digest    [in/out] - The digest data struct being cleaned up.
-4.  *
-3.  */
-2. void Curl_auth_digest_cleanup(struct digestdata *digest)
-1. {

/*Fr",Not Useful
/*Delete security context*/,"-1.   digest->input_token_len = 0;

/*Delete security context*/

1.   if(digest->http_context) {
2.     s_pSecFn->DeleteSecurityContext(digest->http_context);
3.     Curl_safefree(digest->http_context);
4.   }",Not Useful
/*The last 3 #include files should be in this order*/,"-10. #include ""urldata.h""
-9. #include ""curl_base64.h""
-8. #include ""curl_md5.h""
-7. #include ""vauth/vauth.h""
-6. #include ""vtls/vtls.h""
-5. #include ""curl_hmac.h""
-4. #include ""curl_sasl.h""
-3. #include ""warnless.h""
-2. #include ""strtok.h""
-1. #include """,Not Useful
/*Name*/,"-1. static const struct {

/*Name*/

111",Not Useful
"/** state()
 *
 * This is the ONLY way to change SASL state!*/","-10.       sasl->prefmech |= SASL_MECH_DIGEST_MD5;
-9.     if(auth & CURLAUTH_NTLM)
-8.       sasl->prefmech |= SASL_MECH_NTLM;
-7.     if(auth & CURLAUTH_BEARER)
-6.       sasl->prefmech |= SASL_MECH_OAUTHBEARER | SASL_MECH_XOAUTH2;
-5.     if(auth & CUR",Not Useful
/*Create the type-1 message*/,"-4.     break;
-3. #endif
-2. #ifdef USE_NTLM
-1.   case SASL_NTLM:

/*Create the type-1 message*/

1.     result = Curl_auth_create_ntlm_type1_message(data,
2.                                                  conn->user, conn->passwd,
3.                 ",Not Useful
/*Decode the type-2 message*/,"-7.     result = Curl_auth_create_ntlm_type1_message(data,
-6.                                                  conn->user, conn->passwd,
-5.                                                  service, hostname,
-4.                                          ",Not Useful
/*Should not happen*/,"-3.     return Curl_sasl_start(sasl, data, sasl->force_ir, progress);
-2.   default:
-1.     failf(data, ""Unsupported SASL authentication mechanism"");

/*Should not happen*/

1.     break;
2.   }
3.   Curl_bufref_free(&serverdata);
4.   switch(result) {
5",Not Useful
/*The last 3 #include files should be in this order*/,"-2. #include ""warnless.h""
-1. #include ""curl_range.h""

/*The last 3 #include files should be in this order*/

1. #include ""curl_printf.h""
2. #include ""curl_memory.h""
3. #include ""memdebug.h""
4. #if defined(WIN32) || defined(MSDOS) || defined(__EMX__)
5. #",Not Useful
/** Forward declarations.*/,"-10. #include ""memdebug.h""
-9. #if defined(WIN32) || defined(MSDOS) || defined(__EMX__)
-8. #define DOS_FILESYSTEM 1
-7. #endif
-6. #ifdef OPEN_NEEDS_ARG3
-5. #  define open_readonly(p,f) open((p),(f),(0))
-4. #else
-3. #  define open_readonly(p,f) open((",Not Useful
/*setup_connection*/,"-7. static CURLcode file_do(struct Curl_easy *data, bool *done);
-6. static CURLcode file_done(struct Curl_easy *data,
-5.                           CURLcode status, bool premature);
-4. static CURLcode file_connect(struct Curl_easy *data, bool *done);
-3",Not Useful
/*do_it*/,"-3. const struct Curl_handler Curl_handler_file = {

/*do_it*/

111",Not Useful
/*done*/,"
static CURLcode file_do(struct Curl_easy *data, bool *done);



/*done*/

1. static CURLcode file_done(struct Curl_easy *data,
2.                           CURLcode status, bool premature);
3. static CURLcode file_connect(struct Curl_easy *data, bool *done);
4. static CURLcode file_disconnect(struct Curl_easy *data,
5.                                 struct connectdata *conn,
6.                                 bool dead_connection);
7. static CURLcode file_setup_connection(struct Curl_easy *data,
8.                                       struct connectdata *conn);
9. /*
10.  * FILE scheme handler.",Not Useful
/*connect_it*/,"-6. const struct Curl_handler Curl_handler_file = {

/*connect_it*/

111",Not Useful
/*disconnect*/,"-4. static CURLcode file_do(struct Curl_easy *data, bool *done);
-3. static CURLcode file_done(struct Curl_easy *data,
-2.                           CURLcode status, bool premature);
-1. static CURLcode file_connect(struct Curl_easy *data, bool *done);
st",Not Useful
/*protocol*/,"-10.   ZERO_NULL,                            /* doing */
-9.   ZERO_NULL,                            /* proto_getsock */
-8.   ZERO_NULL,                            /* doing_getsock */
-7.   ZERO_NULL,                            /* domore_getsock */
-6.  ",Not Useful
"/*known size of data to ""upload""*/","-10.   if(data->state.resume_from)
-9.     mode = MODE_DEFAULT|O_APPEND;
-8.   else
-7.     mode = MODE_DEFAULT|O_TRUNC;
-6.   fd = open(file->path, mode, data->set.new_file_perms);
-5.   if(fd < 0) {
-4.     failf(data, ""Can't open %s for writing"", file-",Not Useful
"/*transfer"");*/","-3.     if(data->state.resume_from <= expected_size)
-2.       expected_size -= data->state.resume_from;
-1.     else {

/*transfer"");*/

1.       return CURLE_BAD_DOWNLOAD_RESUME;
2.     }
3.   }",Not Useful
/*The last 3 #include files should be in this order*/,"-10. #include ""sendf.h""
-9. #include ""multiif.h""
-8. #include ""http.h""
-7. #include ""url.h""
-6. #include ""progress.h""
-5. #include ""rtsp.h""
-4. #include ""strcase.h""
-3. #include ""select.h""
-2. #include ""connect.h""
-1. #include ""strdup.h""

/*The last 3 #in",Not Useful
/*most requests don't contain a body*/,"-10.   const char *p_uagent = NULL;
-9.   const char *p_proxyuserpwd = NULL;
-8.   const char *p_userpwd = NULL;
-7.   *done = TRUE;
-6.   rtsp->CSeq_sent = data->state.rtsp_next_client_CSeq;
-5.   rtsp->CSeq_recv = 0;

/*most requests don't contain a bod",Not Useful
/*GET_PARAMETER's no_body status is determined later*/,"-10.   case RTSPREQ_PLAY:
-9.     p_request = ""PLAY"";
-8.     break;
-7.   case RTSPREQ_PAUSE:
-6.     p_request = ""PAUSE"";
-5.     break;
-4.   case RTSPREQ_TEARDOWN:
-3.     p_request = ""TEARDOWN"";
-2.     break;
-1.   case RTSPREQ_GET_PARAMETER:

/*GET",Not Useful
/*Transport Header for SETUP requests*/,"-6.   if(data->set.str[STRING_RTSP_STREAM_URI]) {
-5.     p_stream_uri = data->set.str[STRING_RTSP_STREAM_URI];
-4.   }
-3.   else {
-2.     p_stream_uri = ""*"";
-1.   }

/*Transport Header for SETUP requests*/

1.   p_transport = Curl_checkheaders(data, S",Not Useful
/*Accept Headers for DESCRIBE requests*/,"-10.       if(!data->state.aptr.rtsp_transport)
-9.         return CURLE_OUT_OF_MEMORY;
-8.     }
-7.     else {
-6.       failf(data,
-5.             ""Refusing to issue an RTSP SETUP without a Transport: header."");
-4.       return CURLE_BAD_FUNCTION_ARG",Not Useful
/*Accept Header*/,"-10.       if(!data->state.aptr.rtsp_transport)
-9.         return CURLE_OUT_OF_MEMORY;
-8.     }
-7.     else {
-6.       failf(data,
-5.             ""Refusing to issue an RTSP SETUP without a Transport: header."");
-4.       return CURLE_BAD_FUNCTION_ARG",Not Useful
/*Accept-Encoding header*/,"-2.     p_accept = Curl_checkheaders(data, STRCONST(""Accept""))?
-1.       NULL:""Accept: application/sdp\r\n"";

/*Accept-Encoding header*/

1.     if(!Curl_checkheaders(data, STRCONST(""Accept-Encoding"")) &&
2.        data->set.str[STRING_ENCODING]) {
3.   ",Not Useful
/*Referrer*/,"-6.   result = Curl_http_output_auth(data, conn, p_request, HTTPREQ_GET,
-5.                                  p_stream_uri, FALSE);
-4.   if(result)
-3.     return result;
-2.   p_proxyuserpwd = data->state.aptr.proxyuserpwd;
-1.   p_userpwd = data->state",Not Useful
/*CSeq*/,"-10.   if(checks_to_perform & CONNCHECK_ISDEAD) {
-9.     if(rtsp_connisdead(conn))
-8.       ret_val |= CONNRESULT_DEAD;
-7.   }
-6.   return ret_val;
-5. }
-4. static CURLcode rtsp_connect(struct Curl_easy *data, bool *done)
-3. {
-2.   CURLcode httpSta",Not Useful
/*transport*/,"-7.   const char *p_request = NULL;
-6.   const char *p_session_id = NULL;
-5.   const char *p_accept = NULL;
-4.   const char *p_accept_encoding = NULL;
-3.   const char *p_range = NULL;
-2.   const char *p_referrer = NULL;
-1.   const char *p_stream_uri",Not Useful
/*accept*/,"-2.   const char *p_request = NULL;
-1.   const char *p_session_id = NULL;
  const char *p_accept = NULL;

/*accept*/

1.   const char *p_accept_encoding = NULL;
2.   const char *p_range = NULL;
3.   const char *p_referrer = NULL;
4.   const char *p_strea",Not Useful
/*accept-encoding*/,"-3.   result = Curl_dyn_addf(&req_buffer,

/*accept-encoding*/

111",Not Useful
/*range*/,"-4.   const char *p_request = NULL;
-3.   const char *p_session_id = NULL;
-2.   const char *p_accept = NULL;
-1.   const char *p_accept_encoding = NULL;
  const char *p_range = NULL;

/*range*/

1.   const char *p_referrer = NULL;
2.   const char *p_stre",Not Useful
/*referrer*/,"-5.   const char *p_request = NULL;
-4.   const char *p_session_id = NULL;
-3.   const char *p_accept = NULL;
-2.   const char *p_accept_encoding = NULL;
-1.   const char *p_range = NULL;
  const char *p_referrer = NULL;

/*referrer*/

1.   const char *p_",Not Useful
/*user-agent*/,"-10.       Curl_safefree(data->state.aptr.accept_encoding);
-9.       data->state.aptr.accept_encoding =
-8.         aprintf(""Accept-Encoding: %s\r\n"", data->set.str[STRING_ENCODING]);
-7.       if(!data->state.aptr.accept_encoding)
-6.         return CUR",Not Useful
/*proxyuserpwd*/,"-9.   const char *p_request = NULL;
-8.   const char *p_session_id = NULL;
-7.   const char *p_accept = NULL;
-6.   const char *p_accept_encoding = NULL;
-5.   const char *p_range = NULL;
-4.   const char *p_referrer = NULL;
-3.   const char *p_stream_uri",Not Useful
/*userpwd*/,"-9.   const char *p_request = NULL;
-8.   const char *p_session_id = NULL;
-7.   const char *p_accept = NULL;
-6.   const char *p_accept_encoding = NULL;
-5.   const char *p_range = NULL;
-4.   const char *p_referrer = NULL;
-3.   const char *p_stream_uri",Not Useful
/*moving pointer to rtp data*/,"-10.       result = CURLE_ABORTED_BY_CALLBACK;
-9.   }
-8.   return result;
-7. }
-6. static CURLcode rtsp_rtp_readwrite(struct Curl_easy *data,
-5.                                    struct connectdata *conn,
-4.                                    ssize_",Not Useful
/*The length is two bytes*/,"-1.       rtspc->rtp_channel = RTP_PKT_CHANNEL(rtp);

/*The length is two bytes*/

1.       rtp_length = RTP_PKT_LENGTH(rtp);
2.       if(rtp_dataleft < rtp_length + 4) {",Not Useful
/*USER*/,"-6. #define FTP_BUFFER_ALLOCSIZE 160
-5. typedef enum {
-4.   PL_UNIX_TOTALSIZE = 0,
-3.   PL_UNIX_FILETYPE,
-2.   PL_UNIX_PERMISSION,
-1.   PL_UNIX_HLINKS,
  PL_UNIX_USER,

/*USER*/

1.   PL_UNIX_GROUP,
2.   PL_UNIX_SIZE,
3.   PL_UNIX_TIME,
4.   PL_UNIX_",Not Useful
/*GROUP*/,"-7. #define FTP_BUFFER_ALLOCSIZE 160
-6. typedef enum {
-5.   PL_UNIX_TOTALSIZE = 0,
-4.   PL_UNIX_FILETYPE,
-3.   PL_UNIX_PERMISSION,
-2.   PL_UNIX_HLINKS,
-1.   PL_UNIX_USER,
  PL_UNIX_GROUP,

/*GROUP*/

1.   PL_UNIX_SIZE,
2.   PL_UNIX_TIME,
3.   PL_UNI",Not Useful
/*others*/,"-10.   if(str[5] == 'x')
-9.     permissions |= 1 << 3;
-8.   else if(str[5] == 's') {
-7.     permissions |= 1 << 3;
-6.     permissions |= 1 << 10;
-5.   }
-4.   else if(str[5] == 'S')
-3.     permissions |= 1 << 10;
-2.   else if(str[5] != '-')
-1.    ",Not Useful
/*move finfo pointers to b_data*/,"-10. static CURLcode ftp_pl_insert_finfo(struct Curl_easy *data,
-9.                                     struct fileinfo *infop)
-8. {
-7.   curl_fnmatch_callback compare;
-6.   struct WildcardData *wc = &data->wildcard;
-5.   struct ftp_wc *ftpwc = wc->p",Not Useful
/*FSM*/,"-3.     parser->os_type = (buffer[0] >= '0' && buffer[0] <= '9') ?
-2.                        OS_TYPE_WIN_NT : OS_TYPE_UNIX;
-1.   }

/*FSM*/

1.     char c = buffer[i];",Not Useful
"/*if(ftp_pl_gettime(parser, finfo->b_data + parser->item_offset)) {
                parser->file_data->flags |= CURLFINFOFLAG_KNOWN_TIME;
              }*/","parser->error = CURLE_FTP_BAD_FILE_LIST;
            goto fail;
          }
        }
        else if(parser->item_length == 9) {
          if(c == ' ') {
            parser->state.NT.main = PL_WINNT_TIME;
            parser->state.NT.sub.time = PL_WINNT_TIME_PRESPACE;
          }
          else {
            parser->error = CURLE_FTP_BAD_FILE_LIST;
            goto fail;
          }
        }
        else {
          parser->error = CURLE_FTP_BAD_FILE_LIST;
          goto fail;
        }
        break;
      case PL_WINNT_TIME:
        parser->item_length++;
        switch(parser->state.NT.sub.time) {
        case PL_WINNT_TIME_PRESPACE:
          if(!ISSPACE(c)) {
            parser->state.NT.sub.time = PL_WINNT_TIME_TIME;
          }
          break;
        case PL_WINNT_TIME_TIME:
          if(c == ' ') {
            parser->offsets.time = parser->item_offset;
            finfo->b_data[parser->item_offset + parser->item_length -1] = 0;
            parser->state.NT.main = PL_WINNT_DIRORSIZE;
            parser->state.NT.sub.dirorsize = PL_WINNT_DIRORSIZE_PRESPACE;
            parser->item_length = 0;
          }
          else if(!strchr(""APM0123456789:"", c)) {
            parser->error = CURLE_FTP_BAD_FILE_LIST;
            goto fail;
          }
          break;
        }
        break;
      case PL_WINNT_DIRORSIZE:
        switch(parser->state.NT.sub.dirorsize) {
        case PL_WINNT_DIRORSIZE_PRESPACE:
          if(c != ' ') {
            parser->item_offset = finfo->b_used - 1;
            parser->item_length = 1;
            parser->state.NT.sub.dirorsize = PL_WINNT_DIRORSIZE_CONTENT;
          }
          break;
        case PL_WINNT_DIRORSIZE_CONTENT:
          parser->item_length ++;
          if(c == ' ') {
            finfo->b_data[parser->item_offset + parser->item_length - 1] = 0;
            if(strcmp(""<DIR>"", finfo->b_data + parser->item_offset) == 0) {
              finfo->filetype = CURLFILETYPE_DIRECTORY;
              finfo->size = 0;
            }
            else {
              char *endptr;
              if(curlx_strtoofft(finfo->b_data +
                                 parser->item_offset,
                                 &endptr, 10, &finfo->size)) {
                parser->error = CURLE_FTP_BAD_FILE_LIST;
                goto fail;
              }

/*if(ftp_pl_gettime(parser, finfo->b_data + parser->item_offset)) {
                parser->file_data->flags |= CURLFINFOFLAG_KNOWN_TIME;
              }*/

111",Not Useful
/*Query the security package for NTLM*/,"-10.  * This is used to evaluate if NTLM is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if NTLM is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_ntlm_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURI",Not Useful
/*Query the security package for NTLM*/,"-10.  * This is used to evaluate if NTLM is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if NTLM is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_ntlm_supported(void)
-3. {
-2.   PSecPkgInfo SecurityPackage;
-1.   SECURI",Not Useful
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_NTLM),
-1.                                               &SecurityPackage);

/*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_pSec",Not Useful
/*Allocate our credentials handle*/,"-1.     ntlm->p_identity = NULL;

/*Allocate our credentials handle*/

1.   ntlm->credentials = calloc(1, sizeof(CredHandle));
2.   if(!ntlm->credentials)
3.     return CURLE_OUT_OF_MEMORY;",Not Useful
/*Acquire our credentials handle*/,"-3.   ntlm->credentials = calloc(1, sizeof(CredHandle));
-2.   if(!ntlm->credentials)
-1.     return CURLE_OUT_OF_MEMORY;

/*Acquire our credentials handle*/

1.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                                       ",Not Useful
/*Allocate our new context handle*/,"-7.   status = s_pSecFn->AcquireCredentialsHandle(NULL,
-6.                                               (TCHAR *) TEXT(SP_NAME_NTLM),
-5.                                               SECPKG_CRED_OUTBOUND, NULL,
-4.                                      ",Not Useful
/*Free our identity*/,"-5.   if(ntlm->credentials) {
-4.     s_pSecFn->FreeCredentialsHandle(ntlm->credentials);
-3.     free(ntlm->credentials);
-2.     ntlm->credentials = NULL;
-1.   }

/*Free our identity*/

1.   Curl_sspi_free_identity(ntlm->p_identity);
2.   ntlm->p_ident",Not Useful
/** Cancel all possibly still on-going resolves for this connection.*/,"-10.  * Called from curl_easy_duphandle() to duplicate resolver URL state-specific
-9.  * environment ('resolver' member of the UrlState structure).
-8.  */
-7. CURLcode Curl_resolver_duphandle(struct Curl_easy *easy, void **to, void *from)
-6. {
-5.   (v",Not Useful
/*This function is used to init a threaded resolve*/,"-4. void Curl_resolver_cancel(struct Curl_easy *data)
-3. {
-2.   destroy_async_data(&data->state.async);
-1. }

/*This function is used to init a threaded resolve*/

1. static bool init_resolve_thread(struct Curl_easy *data,
2.                           ",Not Useful
/*socket pair*/,"-2. #ifndef CURL_DISABLE_SOCKETPAIR
-1.   struct Curl_easy *data;

/*socket pair*/

1. #endif
2.   int sock_error;
3.   struct Curl_addrinfo *res;
4. #ifdef HAVE_GETADDRINFO
5.   struct addrinfo hints;
6. #endif",Not Useful
/*should be fine even if this converts to 32 bit*/,"-10.     if(!data->state.async.dns) {
-9.       CURLcode result = Curl_resolver_error(data);
-8.       destroy_async_data(&data->state.async);
-7.       return result;
-6.     }
-5.     destroy_async_data(&data->state.async);
-4.     *entry = data->state.",Not Useful
/*Start at 1ms poll interval*/,"-5.     timediff_t elapsed = Curl_timediff(Curl_now(),
-4.                                        data->progress.t_startsingle);
-3.     if(elapsed < 0)
-2.       elapsed = 0;
-1.     if(td->poll_interval == 0)

/*Start at 1ms poll interval*/

1.       td",Not Useful
/** Curl_resolver_getaddrinfo() - for getaddrinfo*/,"-1. /*
 * Curl_resolver_getaddrinfo() - for getaddrinfo

/** Curl_resolver_getaddrinfo() - for getaddrinfo*/

1.  */
2. struct Curl_addrinfo *Curl_resolver_getaddrinfo(struct Curl_easy *data,
3.                                                 const char *",Not Useful
/*32 bytes/256 bits*/,"-10.                   const char *passwdp,
-9.                   const unsigned char *request,
-8.                   const unsigned char *uripath,
-7.                   struct digestdata *digest,
-6.                   char **outptr, size_t *outlen,
-5.  ",Not Useful
/*64 digits and 1 zero byte*/,"-1.   unsigned char request_digest[65];

/*64 digits and 1 zero byte*/

111",Not Useful
/*64 digits and 1 zero byte*/,"-1.   unsigned char request_digest[65];

/*64 digits and 1 zero byte*/

111",Not Useful
/*Ignore leading whitespace*/,"-10.   char quot;
-9.   unsigned int i, j;
-8.   size_t fullPathLength, pathLength;
-7.   bool relativePath = false;
-6.   static const char WHITESPACE[] = "" \t\r\n"";
-5.   if(!*cp) {
-4.     *cpp = NULL;
-3.     *path = NULL;
-2.     return CURLE_QUOTE_E",Not Useful
/*Found quote*/,"-1.     for(i = j = 0; i <= strlen(cp); i++) {

/*Found quote*/

1.         i++;
2.         (*path)[j] = '\0';
3.         break;
4.       }",Not Useful
/*End of string*/,"-4.         i++;
-3.         (*path)[j] = '\0';
-2.         break;
-1.       }

/*End of string*/

111",Not Useful
/*The last 3 #include files should be in this order*/,"-10. #include <curl/curl.h>
-9. #include ""urldata.h""
-8. #include ""strcase.h""
-7. #include ""hostcheck.h""
-6. #include ""vtls/vtls.h""
-5. #include ""sendf.h""
-4. #include ""inet_pton.h""
-3. #include ""curl_base64.h""
-2. #include ""x509asn1.h""
-1. #include ""dynb",Not Useful
/*Too big.*/,"-1.   if(inlength / size > (SIZE_T_MAX - 1) / 4)

/*Too big.*/

1.   buf = malloc(4 * (inlength / size) + 1);
2.   if(!buf)",Not Useful
/*Just copy.*/,"-1.   if(type == CURL_ASN1_UTF8_STRING) {

/*Just copy.*/

1.     outlength = inlength;
2.     if(outlength)
3.       memcpy(buf, from, outlength);
4.   }
5.   else {
6.     for(outlength = 0; from < end;) {
7.       int charsize;
8.       unsigned int wc",Not Useful
/*Store a terminator if possible.*/,"-10.   size_t i = 0;
-9.   unsigned int y = x / 10;
-8.   if(y) {
-7.     i = encodeUint(buf, buflen, y);
-6.     x -= y * 10;
-5.   }
-4.   if(i < buflen)
-3.     buf[i] = (char) ('0' + x);
-2.   i++;
-1.   if(i < buflen)

/*Store a terminator if possibl",Not Useful
/*Nothing to do.*/,"-1.   if(tzp >= end)

/*Nothing to do.*/

1.   else if(*tzp == 'Z') {
2.     tzp = "" GMT"";
3.     end = tzp + 4;
4.   }
5.   else {
6.     sep = "" "";
7.     tzp++;
8.   }
9.   tzl = end - tzp;
10.   return curl_maprintf(""%.4s-%.2s-%.2s %.2s:%.2s:%c%c%s%.*",Not Useful
/*No conversion of structured elements.*/,"-3. static const char *ASN1tostr(struct Curl_asn1Element *elem, int type)
-2. {
-1.   if(elem->constructed)

/*No conversion of structured elements.*/

1.   if(!type)",Not Useful
/*Type not forced: use element tag as type.*/,"-1.   if(!type)

/*Type not forced: use element tag as type.*/

1.   switch(type) {
2.   case CURL_ASN1_BOOLEAN:
3.     return bool2str(elem->beg, elem->end);
4.   case CURL_ASN1_INTEGER:
5.   case CURL_ASN1_ENUMERATED:
6.     return int2str(elem->beg, el",Not Useful
/*Get tbsCertificate.*/,"-2.   beg = elem.beg;
-1.   end = elem.end;

/*Get tbsCertificate.*/

1.   beg = getASN1Element(&tbsCertificate, beg, end);
2.   if(!beg)
3.     return -1;",Not Useful
"/** Copy at most 64-characters, terminate with a newline and returns the
 * effective number of stored characters.*/","-2. #ifdef WANT_EXTRACT_CERTINFO
-1. /*
 * Copy at most 64-characters, terminate with a newline and returns the
 * effective number of stored characters.

/** Copy at most 64-characters, terminate with a newline and returns the
 * effective number of stor",Not Useful
/*Subject.*/,"-2.   if(Curl_parseX509(&cert, beg, end))
-1.     return CURLE_PEER_FAILED_VERIFICATION;

/*Subject.*/

1.   ccp = DNtostr(&cert.subject);
2.   if(!ccp)
3.     return CURLE_OUT_OF_MEMORY;
4.   if(data->set.ssl.certinfo) {
5.     result = Curl_ssl_push_cer",Not Useful
/*Issuer.*/,"-10.   if(!ccp)
-9.     return CURLE_OUT_OF_MEMORY;
-8.   if(data->set.ssl.certinfo) {
-7.     result = Curl_ssl_push_certinfo(data, certnum, ""Subject"", ccp);
-6.     if(result)
-5.       return result;
-4.   }
-3.   if(!certnum)
-2.     infof(data, ""%2d ",Not Useful
/*Serial number.*/,"-10.     ccp = curl_maprintf(""%lx"", version);
-9.     if(!ccp)
-8.       return CURLE_OUT_OF_MEMORY;
-7.     result = Curl_ssl_push_certinfo(data, certnum, ""Version"", ccp);
-6.     free((char *) ccp);
-5.     if(result)
-4.       return result;
-3.   }
-2",Not Useful
/*Signature algorithm .*/,"-10.   ccp = ASN1tostr(&cert.serialNumber, 0);
-9.   if(!ccp)
-8.     return CURLE_OUT_OF_MEMORY;
-7.   if(data->set.ssl.certinfo)
-6.     result = Curl_ssl_push_certinfo(data, certnum, ""Serial Number"", ccp);
-5.   if(!certnum)
-4.     infof(data, ""   Ser",Not Useful
/*Public Key Algorithm.*/,"-10.   ccp = ASN1tostr(&cert.notAfter, 0);
-9.   if(!ccp)
-8.     return CURLE_OUT_OF_MEMORY;
-7.   if(data->set.ssl.certinfo)
-6.     result = Curl_ssl_push_certinfo(data, certnum, ""Expire Date"", ccp);
-5.   if(!certnum)
-4.     infof(data, ""   Expire Da",Not Useful
/*Signature.*/,"-4.   }
-3.   free((char *) ccp);
-2.   if(result)
-1.     return result;

/*Signature.*/

1.   ccp = ASN1tostr(&cert.signature, 0);
2.   if(!ccp)
3.     return CURLE_OUT_OF_MEMORY;
4.   if(data->set.ssl.certinfo)
5.     result = Curl_ssl_push_certinfo(da",Not Useful
/*DNS name.*/,"-5.       for(q = elem.beg; matched != 1 && q < elem.end;) {
-4.         q = getASN1Element(&name, q, elem.end);
-3.         if(!q)
-2.           break;
-1.         switch(name.tag) {

/*DNS name.*/

1.           len = utf8asn1str(&dnsname, CURL_ASN1_IA5_",Not Useful
/*Nul byte in string ?*/,"-8.   if(!getASN1Element(&elem, name.beg, name.end))
-7.     failf(data, ""SSL: unable to obtain common name from peer certificate"");
-6.   else {
-5.     len = utf8asn1str(&dnsname, elem.tag, elem.beg, elem.end);
-4.     if(len < 0) {
-3.       free(dnsna",Not Useful
/*chunks coming our way.*/,"-1.     if(maybechunked && namelen == 7 && strncasecompare(name, ""chunked"", 7)) {

/*chunks coming our way.*/

111",Not Useful
/*Stack the unencoding stage.*/,"-10.     else if(namelen) {
-9.       const struct content_encoding *encoding = find_encoding(name, namelen);
-8.       struct contenc_writer *writer;
-7.       if(!k->writer_stack) {
-6.         k->writer_stack = new_unencoding_writer(data, &client_encod",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*PREAUTH*/,"-5.   PROTOPT_URLOPTIONS
-4. };
-3. #endif
-2. #define IMAP_RESP_OK       1
-1. #define IMAP_RESP_NOT_OK   2
#define IMAP_RESP_PREAUTH  3

/*PREAUTH*/

111",Not Useful
/*For CAPABILITY responses*/,"-10.     struct imap_conn *imapc = &conn->proto.imapc;
-9.     imapc->preauth = TRUE;
-8.     infof(data, ""PREAUTH connection, already authenticated"");
-7.   }
-6.   else if(imapcode != IMAP_RESP_OK) {
-5.     failf(data, ""Got unexpected imap-server respo",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*Do we have a untagged response?*/,"-9. static CURLcode imap_state_capability_resp(struct Curl_easy *data,
-8.                                            int imapcode,
-7.                                            imapstate instate)
-6. {
-5.   CURLcode result = CURLE_OK;
-4.   struct conn",Not Useful
/*Switch to TLS connection now*/,"-1.     if(imapcode == IMAP_RESP_OK && imapc->tls_supported && !imapc->preauth) {

/*Switch to TLS connection now*/

1.       result = imap_perform_starttls(data);
2.     }
3.     else if(data->set.use_ssl <= CURLUSESSL_TRY)
4.       result = imap_perform",Not Useful
/*For STARTTLS responses*/,"-10.       result = imap_perform_authentication(data, conn);
-9.     else {
-8.       failf(data, ""STARTTLS not available."");
-7.       result = CURLE_USE_SSL_FAILED;
-6.     }
-5.   }
-4.   else
-3.     result = imap_perform_authentication(data, conn);
-",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*For LOGIN responses*/,"-10.       else {
-9.         failf(data, ""Authentication cancelled"");
-8.         result = CURLE_LOGIN_DENIED;
-7.       }
-6.       break;
-5.     default:
-4.       break;
-3.     }
-2.   return result;
-1. }

/*For LOGIN responses*/

1. static CURLcod",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*For LIST and SEARCH responses*/,"-3.     state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For LIST and SEARCH responses*/

1. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
2.                                            int imapcode,
3.                            ",Not Useful
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line ",Not Useful
/*For SELECT responses*/,"-3.     state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For SELECT responses*/

1. static CURLcode imap_state_select_resp(struct Curl_easy *data, int imapcode,
2.                                        imapstate instate)
3. {
4.   CURLcode result = ",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*Check if the UIDVALIDITY has been specified and matches*/,"-7.     char tmp[20];
-6.     if(sscanf(line + 2, ""OK [UIDVALIDITY %19[0123456789]]"", tmp) == 1) {
-5.       Curl_safefree(imapc->mailbox_uidvalidity);
-4.       imapc->mailbox_uidvalidity = strdup(tmp);
-3.     }
-2.   }
-1.   else if(imapcode == IMAP_RE",Not Useful
/*For the (first line of the) FETCH responses*/,"-10.       else
-9.         result = imap_perform_fetch(data);
-8.     }
-7.   }
-6.   else {
-5.     failf(data, ""Select failed"");
-4.     result = CURLE_LOGIN_DENIED;
-3.   }
-2.   return result;
-1. }

/*For the (first line of the) FETCH responses*/

1",Not Useful
/*no use for this yet*/,"-5. static CURLcode imap_state_servergreet_resp(struct Curl_easy *data,
-4.                                             int imapcode,
-3.                                             imapstate instate)
-2. {
-1.   struct connectdata *conn = data->conn;

/*",Not Useful
/*Free the cache*/,"-4.         memmove(pp->cache, pp->cache + chunk, pp->cache_size - chunk);
-3.         pp->cache_size -= chunk;
-2.       }
-1.       else {

/*Free the cache*/

1.         Curl_safefree(pp->cache);",Not Useful
/*The entire data is already transferred!*/,"-4.         pp->cache_size = 0;
-3.       }
-2.     }
-1.     if(data->req.bytecount == size)

/*The entire data is already transferred!*/

1.       Curl_setup_transfer(data, -1, -1, FALSE, -1);
2.     else {",Not Useful
/*We don't know how to parse this line*/,"-5.       data->conn->cselect_bits = CURL_CSELECT_IN;
-4.       Curl_setup_transfer(data, FIRSTSOCKET, size, FALSE, -1);
-3.     }
-2.   }
-1.   else {

/*We don't know how to parse this line*/

1.     failf(data, ""Failed to parse FETCH response."");
2.   ",Not Useful
/*For final FETCH responses performed after the download*/,"-3.   state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For final FETCH responses performed after the download*/

1. static CURLcode imap_state_fetch_final_resp(struct Curl_easy *data,
2.                                             int imapcode,
3.   ",Not Useful
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line ",Not Useful
/*For APPEND responses*/,"-3.     state(data, IMAP_STOP);
-2.   return result;
-1. }

/*For APPEND responses*/

1. static CURLcode imap_state_append_resp(struct Curl_easy *data, int imapcode,
2.                                        imapstate instate)
3. {
4.   CURLcode result = ",Not Useful
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line ",Not Useful
/*Set the progress upload size*/,"-4.   if(imapcode != '+') {
-3.     result = CURLE_UPLOAD_FAILED;
-2.   }
-1.   else {

/*Set the progress upload size*/

1.     Curl_pgrsSetUploadSize(data, data->state.infilesize);",Not Useful
/*For final APPEND responses performed after the upload*/,"-4.     state(data, IMAP_STOP);
-3.   }
-2.   return result;
-1. }

/*For final APPEND responses performed after the upload*/

1. static CURLcode imap_state_append_final_resp(struct Curl_easy *data,
2.                                              int imap",Not Useful
/*No use for this yet*/,"-7. static CURLcode imap_state_listsearch_resp(struct Curl_easy *data,
-6.                                            int imapcode,
-5.                                            imapstate instate)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   char *line ",Not Useful
/*Flush any data that needs to be sent*/,"-2.   if(imapc->state == IMAP_UPGRADETLS)
-1.     return imap_perform_upgrade_tls(data, conn);

/*Flush any data that needs to be sent*/

1.   if(pp->sendleft)
2.     return Curl_pp_flushsend(data, pp);
3.   do {",Not Useful
"/*Allocate and initialize the struct IMAP for the current Curl_easy if
   required*/","-10. static CURLcode imap_block_statemach(struct Curl_easy *data,
-9.                                      struct connectdata *conn,
-8.                                      bool disconnecting)
-7. {
-6.   CURLcode result = CURLE_OK;
-5.   struct imap_con",Not Useful
/*default to not done yet*/,"-10.  *
-9.  * The variable 'done' points to will be TRUE if the protocol-layer connect
-8.  * phase is done when this function returns, or FALSE if not.
-7.  */
-6. static CURLcode imap_connect(struct Curl_easy *data, bool *done)
-5. {
-4.   CURLcode res",Not Useful
/*Parse the URL options*/,"-2.   Curl_pp_setup(pp);
-1.   Curl_pp_init(data, pp);

/*Parse the URL options*/

1.   result = imap_parse_url_options(conn);
2.   if(result)
3.     return result;",Not Useful
/*Run the state-machine*/,"-4.       result = Curl_pp_sendf(data, &conn->proto.imapc.pp, ""%s"", """");
-3.       if(!result)
-2.         state(data, IMAP_APPEND_FINAL);
-1.     }

/*Run the state-machine*/

1.     if(!result)
2.       result = imap_block_statemach(data, conn, FALSE);
",Not Useful
"/***********************************************************************
 *
 * imap_perform()
 *
 * This is the actual DO function for IMAP. Fetch or append a message, or do
 * other things according to the options previously setup.*/","-3.   imap->transfer = PPTRANSFER_BODY;
-2.   return result;
-1. }
/***********************************************************************
 *
 * imap_perform()
 *
 * This is the actual DO function for IMAP. Fetch or append a message, or do
 * other thing",Not Useful
/*APPEND can be executed directly*/,"-1.   if(data->set.upload || data->set.mimepost.kind != MIMEKIND_NONE)

/*APPEND can be executed directly*/

1.     result = imap_perform_append(data);
2.   else if(imap->custom && (selected || !imap->mailbox))",Not Useful
/*LIST*/,"-4.       case IMAP_CAPABILITY:
-3.         if(!imap_matchresp(line, len, ""CAPABILITY""))
-2.           return FALSE;
-1.         break;
      case IMAP_LIST:

/*LIST*/

1.         if((!imap->custom && !imap_matchresp(line, len, ""LIST"")) ||
2.           (i",Not Useful
/*Run the state-machine*/,"-4.       result = Curl_pp_sendf(data, &conn->proto.imapc.pp, ""%s"", """");
-3.       if(!result)
-2.         state(data, IMAP_APPEND_FINAL);
-1.     }

/*Run the state-machine*/

1.     if(!result)
2.       result = imap_block_statemach(data, conn, FALSE);
",Not Useful
/*default to false*/,"-10.  * imap_do()
-9.  *
-8.  * This function is registered as 'curl_do' function. It decodes the path
-7.  * parts etc as a wrapper to the actual DO function (imap_perform).
-6.  *
-5.  * The input argument is already checked for validity.
-4.  */
-3. st",Not Useful
/*Parse the URL path*/,"-10.  *
-9.  * This function is registered as 'curl_do' function. It decodes the path
-8.  * parts etc as a wrapper to the actual DO function (imap_perform).
-7.  *
-6.  * The input argument is already checked for validity.
-5.  */
-4. static CURLcode ima",Not Useful
/*Parse the custom request*/,"-3.   result = imap_parse_url_path(data);
-2.   if(result)
-1.     return result;

/*Parse the custom request*/

1.   result = imap_parse_custom_request(data);
2.   if(result)
3.     return result;
4.   result = imap_regular_transfer(data, done);
5.   ret",Not Useful
/*Call this when the DO phase has completed*/,"-4.   Curl_safefree(imapc->mailbox);
-3.   Curl_safefree(imapc->mailbox_uidvalidity);
-2.   return CURLE_OK;
-1. }

/*Call this when the DO phase has completed*/

1. static CURLcode imap_dophase_done(struct Curl_easy *data, bool connected)
2. {
3.   struc",Not Useful
/*no data to transfer*/,"-5. static CURLcode imap_dophase_done(struct Curl_easy *data, bool connected)
-4. {
-3.   struct IMAP *imap = data->req.p.imap;
-2.   (void)connected;
-1.   if(imap->transfer != PPTRANSFER_BODY)

/*no data to transfer*/

1.     Curl_setup_transfer(data, -",Not Useful
/*Set the progress data*/,"-1.   data->req.size = -1;

/*Set the progress data*/

1.   Curl_pgrsSetUploadCounter(data, 0);
2.   Curl_pgrsSetDownloadCounter(data, 0);
3.   Curl_pgrsSetUploadSize(data, -1);
4.   Curl_pgrsSetDownloadSize(data, -1);",Not Useful
/*Carry out the perform*/,"-4.   Curl_pgrsSetUploadCounter(data, 0);
-3.   Curl_pgrsSetDownloadCounter(data, 0);
-2.   Curl_pgrsSetUploadSize(data, -1);
-1.   Curl_pgrsSetDownloadSize(data, -1);

/*Carry out the perform*/

1.   result = imap_perform(data, &connected, dophase_done);",Not Useful
/*Calculate the tag based on the connection ID and command ID*/,"-10.  *
-9.  * Sends the formatted string as an IMAP command to the server.
-8.  *
-7.  * Designed to never block.
-6.  */
-5. static CURLcode imap_sendf(struct Curl_easy *data, const char *fmt, ...)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   struct im",Not Useful
/*Allocate the new string*/,"-1.   newlen = strlen(str) + backsp_count + quote_count + (escape_only ? 0 : 2);

/*Allocate the new string*/

1.   newstr = (char *) malloc((newlen + 1) * sizeof(char));
2.   if(!newstr)
3.     return NULL;",Not Useful
/*Surround the string in quotes if necessary*/,"-3.   newstr = (char *) malloc((newlen + 1) * sizeof(char));
-2.   if(!newstr)
-1.     return NULL;

/*Surround the string in quotes if necessary*/

1.   p2 = newstr;
2.   if(!escape_only) {
3.     newstr[0] = '""';
4.     newstr[newlen - 1] = '""';
5.     ",Not Useful
"/*Copy the string, escaping backslash and quote characters along the way*/","-6.   p2 = newstr;
-5.   if(!escape_only) {
-4.     newstr[0] = '""';
-3.     newstr[newlen - 1] = '""';
-2.     p2++;
-1.   }

/*Copy the string, escaping backslash and quote characters along the way*/

1.   p1 = str;
2.   while(*p1) {
3.     if(*p1 == '\\",Not Useful
/*Terminate the string*/,"-10.   p1 = str;
-9.   while(*p1) {
-8.     if(*p1 == '\\' || *p1 == '""') {
-7.       *p2 = '\\';
-6.       p2++;
-5.     }
-4.    *p2 = *p1;
-3.     p1++;
-2.     p2++;
-1.   }

/*Terminate the string*/

1.   newstr[newlen] = '\0';
2.   return newstr;
3.",Not Useful
/*Remove the trailing slash if present*/,"-3.   while(imap_is_bchar(*ptr))
-2.     ptr++;
-1.   if(ptr != begin) {

/*Remove the trailing slash if present*/

1.     const char *end = ptr;
2.     if(end > begin && end[-1] == '/')
3.       end--;
4.     result = Curl_urldecode(begin, end - begin, &",Not Useful
"/*There can be any number of parameters in the form "";NAME=VALUE""*/","-10.     const char *end = ptr;
-9.     if(end > begin && end[-1] == '/')
-8.       end--;
-7.     result = Curl_urldecode(begin, end - begin, &imap->mailbox, NULL,
-6.                             REJECT_CTRL);
-5.     if(result)
-4.       return result;
",Not Useful
"/***********************************************************************
 *
 * imap_parse_custom_request()
 *
 * Parse the custom request.*/","-4.   if(*ptr)
-3.     return CURLE_URL_MALFORMAT;
-2.   return CURLE_OK;
-1. }
/***********************************************************************
 *
 * imap_parse_custom_request()
 *
 * Parse the custom request.

/**********************************",Not Useful
/*Extract the parameters if specified*/,"-1.     result = Curl_urldecode(custom, 0, &imap->custom, NULL, REJECT_CTRL);

/*Extract the parameters if specified*/

1.     if(!result) {
2.       const char *params = imap->custom;
3.       while(*params && *params != ' ')
4.         params++;
5.     ",Not Useful
/*The last #include file should be:*/,"-10. #include <netinet/in.h>
-9. #endif
-8. #ifdef HAVE_NETINET_IN6_H
-7. #include <netinet/in6.h>
-6. #endif
-5. #include ""curl_memrchr.h""
-4. #include ""hostcheck.h""
-3. #include ""strcase.h""
-2. #include ""hostip.h""
-1. #include ""curl_memory.h""

/*The las",Not Useful
/*The last 3 #include files should be in this order*/,"-10.  ***************************************************************************/
-9. #include ""curl_setup.h""
-8. #if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_PROXY)
-7. #include ""curl_gssapi.h""
-6. #include ""urldata.h""
-5. #include ""sendf.h""
-4. #i",Not Useful
/*force for the moment to no data protection*/,"-4.   else if(gss_ret_flags & GSS_C_INTEG_FLAG)
-3.     gss_enc = 1;
-2.   infof(data, ""SOCKS5 server supports GSS-API %s data protection."",
-1.         (gss_enc == 0)?""no"":((gss_enc==1)?""integrity"":""confidentiality""));

/*force for the moment to no data ",Not Useful
/*Query the security package for Kerberos*/,"-10.  * This is used to evaluate if GSSAPI (Kerberos V5) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Kerberos V5 is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_gssapi_supported(void)
-3. {
-2.   PSecPkgInfo Secu",Not Useful
/*Release the package buffer as it is not required anymore*/,"-3.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
-2.                                               TEXT(SP_NAME_KERBEROS),
-1.                                               &SecurityPackage);

/*Release the package buffer as it is not required ",Not Useful
/*Query the security package for Kerberos*/,"-10.  * This is used to evaluate if GSSAPI (Kerberos V5) is supported.
-9.  *
-8.  * Parameters: None
-7.  *
-6.  * Returns TRUE if Kerberos V5 is supported by Windows SSPI.
-5.  */
-4. bool Curl_auth_is_gssapi_supported(void)
-3. {
-2.   PSecPkgInfo Secu",Not Useful
/*Allocate our credentials handle*/,"-1.       krb5->p_identity = NULL;

/*Allocate our credentials handle*/

1.     krb5->credentials = calloc(1, sizeof(CredHandle));
2.     if(!krb5->credentials)
3.       return CURLE_OUT_OF_MEMORY;",Not Useful
/*Acquire our credentials handle*/,"-3.     krb5->credentials = calloc(1, sizeof(CredHandle));
-2.     if(!krb5->credentials)
-1.       return CURLE_OUT_OF_MEMORY;

/*Acquire our credentials handle*/

1.     status = s_pSecFn->AcquireCredentialsHandle(NULL,
2.                               ",Not Useful
/*Allocate our new context handle*/,"-8.     status = s_pSecFn->AcquireCredentialsHandle(NULL,
-7.                                                 (TCHAR *)
-6.                                                 TEXT(SP_NAME_KERBEROS),
-5.                                                 SECPKG_",Not Useful
/*Extract the security layer*/,"-4.   if(input_buf[1].cbBuffer != 4) {
-3.     infof(data, ""GSSAPI handshake failure (invalid security data)"");
-2.     return CURLE_BAD_CONTENT_ENCODING;
-1.   }

/*Extract the security layer*/

1.   indata = input_buf[1].pvBuffer;
2.   sec_layer = indat",Not Useful
/*Allocate the trailer*/,"-2.     max_size = 0;
-1.   }

/*Allocate the trailer*/

1.   trailer = malloc(sizes.cbSecurityTrailer);
2.   if(!trailer)
3.     return CURLE_OUT_OF_MEMORY;",Not Useful
/*Allocate our message*/,"-3.   trailer = malloc(sizes.cbSecurityTrailer);
-2.   if(!trailer)
-1.     return CURLE_OUT_OF_MEMORY;

/*Allocate our message*/

1.   messagelen = 4;
2.   if(authzid)
3.     messagelen += strlen(authzid);
4.   message = malloc(messagelen);
5.   if(!mess",Not Useful
/*Allocate the padding*/,"-2.   if(authzid && *authzid)
-1.     memcpy(message + 4, authzid, messagelen - 4);

/*Allocate the padding*/

1.   padding = malloc(sizes.cbBlockSize);
2.   if(!padding) {
3.     free(message);
4.     free(trailer);
5.     return CURLE_OUT_OF_MEMORY;
6. ",Not Useful
"/** Curl_auth_cleanup_gssapi()
 *
 * This is used to clean up the GSSAPI (Kerberos V5) specific data.
 *
 * Parameters:
 *
 * krb5     [in/out] - The Kerberos 5 data struct being cleaned up.
 **/","Curl_sspi_free_identity(krb5->p_identity);
  krb5->p_identity = NULL;

/** Curl_auth_cleanup_gssapi()
 *
 * This is used to clean up the GSSAPI (Kerberos V5) specific data.
 *
 * Parameters:
 *
 * krb5     [in/out] - The Kerberos 5 data struct being cleaned up.
 **/

1.   krb5->token_max = 0;
2. }",Not Useful
/*enable uploading*/,"-10.     fprintf(stderr, ""ERROR: cannot open file (%s)\n"", libtest_arg2);
-9.     fclose(hd_src);
-8.     return TEST_ERR_FSTAT;
-7.   }
-6.   res_global_init(CURL_GLOBAL_ALL);
-5.   if(res) {
-4.     fclose(hd_src);
-3.     return res;
-2.   }
-1.   easy",Not Useful
/*go verbose*/,"-1.   easy_setopt(curl, CURLOPT_URL, URL);

/*go verbose*/

1.   easy_setopt(curl, CURLOPT_VERBOSE, 1L);",Not Useful
/*done*/,"-10.   multi_add_handle(m, curl);
-9.   for(;;) {
-8.     struct timeval interval;
-7.     fd_set rd, wr, exc;
-6.     int maxfd = -99;
-5.     interval.tv_sec = 1;
-4.     interval.tv_usec = 0;
-3.     multi_perform(m, &running);
-2.     abort_on_test_ti",Not Useful
"/*3x download!
 * 1. normal
 * 2. dup handle
 * 3. with multi interface*/","-10.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-9.  * KIND, either express or implied.
-8.  *
-7.  ***************************************************************************/
-6. #include ""test.h""
-5. #include <fcntl.h>",Not Useful
/*100 ms*/,"-10.   multi_add_handle(mhandle, handle);
-9.   multi_perform(mhandle, &still_running);
-8.   abort_on_test_timeout();
-7.   while(still_running) {
-6.     struct timeval timeout;
-5.     fd_set fdread;
-4.     fd_set fdwrite;
-3.     fd_set fdexcep;
-2. ",Not Useful
/*(rl.rlim_cur != rl.rlim_max)*/,"
  if(rl.rlim_cur != rl.rlim_max) {



/*(rl.rlim_cur != rl.rlim_max)*/

1. #ifdef OPEN_MAX
2.     if((rl.rlim_cur > 0) &&
3.         (rl.rlim_cur < OPEN_MAX)) {
4.       fprintf(stderr, ""raising soft limit up to OPEN_MAX\n"");
5.       rl.rlim_cur = OPEN_MAX;
6.       if(setrlimit(RLIMIT_NOFILE, &rl) != 0) {",Not Useful
"/** test 537 is all about testing libcurl functionality
   * when the system has nearly exhausted the number of
   * available file descriptors. Test 537 will try to run
   * with a very small number of file descriptors available.
   * This implies that any file descriptor which is open
   * when the test runs will have a number in the high range
   * of whatever the system supports.*/","-1.   /*
   * test 537 is all about testing libcurl functionality
   * when the system has nearly exhausted the number of
   * available file descriptors. Test 537 will try to run
   * with a very small number of file descriptors available.
   * This impl",Not Useful
/*soft limit minus SAFETY_MARGIN*/,"-5. #ifdef RLIM_INFINITY
-4.   if((rl.rlim_cur > 0) && (rl.rlim_cur != RLIM_INFINITY)) {
-3. #else
-2.   if(rl.rlim_cur > 0) {
-1. #endif

/*soft limit minus SAFETY_MARGIN*/

1.     num_open.rlim_max = rl.rlim_cur - SAFETY_MARGIN;
2.   }
3.   else {",Not Useful
/*open a dummy descriptor*/,"-7.   fprintf(stderr, ""initializing fd array\n"");
-6.   for(num_open.rlim_cur = 0;
-5.       num_open.rlim_cur < num_open.rlim_max;
-4.       num_open.rlim_cur++)
-3.     fd[num_open.rlim_cur] = -1;
-2.   msnprintf(strbuff, sizeof(strbuff), fmt, num_open.",Not Useful
/*close file descriptors unless instructed to keep them*/,"-1.   free(memchunk);

/*close file descriptors unless instructed to keep them*/

1.   if(!keep_open) {
2.     close_file_descriptors();
3.   }
4.   return 0;
5. }
6. int test(char *URL)
7. {
8.   CURLcode res;
9.   CURL *curl;
10.   if(!strcmp(URL, ""chec",Not Useful
"/*sure, run this!*/","-4.     if(rlimit(FALSE)) {
-3.       fprintf(stdout, ""rlimit problem: %s\n"", msgbuff);
-2.       return 1;
-1.     }

/*sure, run this!*/

1.   }
2.   if(rlimit(TRUE)) {",Not Useful
/*failure*/,"-10.    * point the resulting soft limit is our limit. Trying to
-9.    * open more than soft limit file descriptors will fail.
-8.    */
-7.   if(rl.rlim_cur != rl.rlim_max) {
-6. #ifdef OPEN_MAX
-5.     if((rl.rlim_cur > 0) &&
-4.         (rl.rlim_cur <",Not Useful
/*defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT)*/,"-10.     !defined(USE_WINSOCK)       && \
-9.     !defined(FD_SETSIZE)
-8. #error ""this test requires FD_SETSIZE""
-7. #endif
-6. #define SAFETY_MARGIN (11)
-5. #if defined(WIN32) || defined(_WIN32) || defined(MSDOS)
-4. #define DEV_NULL ""NUL""
-3. #else
-2",Not Useful
/*defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT)*/,"-10.     !defined(USE_WINSOCK)       && \
-9.     !defined(FD_SETSIZE)
-8. #error ""this test requires FD_SETSIZE""
-7. #endif
-6. #define SAFETY_MARGIN (11)
-5. #if defined(WIN32) || defined(_WIN32) || defined(MSDOS)
-4. #define DEV_NULL ""NUL""
-3. #else
-2",Not Useful
/*always cleanup*/,"-2.   res = curl_easy_perform(curl);
-1. test_cleanup:

/*always cleanup*/

1.   curl_easy_cleanup(curl);",Not Useful
/*that should have failed*/,"-10.   CURLcode a1 = curl_mime_subparts(part, mime);
-9.   if(a1 == CURLE_BAD_FUNCTION_ARGUMENT) {
-8.     curl_mime *submime = curl_mime_init(easy);
-7.     curl_mimepart *subpart = curl_mime_addpart(submime);
-6.     curl_mime_subparts(part, submime);
-",Not Useful
/*old*/,"-2. #endif
-1. }
static int once(char *URL, bool oldstyle)

/*old*/

1. {
2.   CURL *curl;
3.   CURLcode res = CURLE_OK;
4.   curl_mime *mime = NULL;
5.   curl_mimepart *part = NULL;
6.   struct WriteThis pooh;
7.   struct WriteThis pooh2;
8.   curl_off_t",Not Useful
"/*example.com/the-moo"");*/","-10.     return TEST_ERR_MAJOR_BAD;
-9.   }
-8.   curl = curl_easy_init();
-7.   if(!curl) {
-6.     fprintf(stderr, ""curl_easy_init() failed\n"");
-5.     curl_global_cleanup();
-4.     return TEST_ERR_MAJOR_BAD;
-3.   }
-2.   test_setopt(curl, CURLOPT_UR",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
/*unused*/,"-5. #define RUN_FOR_SECONDS 7
-4. static pthread_mutex_t connlock;
-3. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-2. {

/*unused*/

111",Not Useful
"/** Use global DNS cache (while deprecated it should still work), populate it
 * with CURLOPT_RESOLVE in the first request and then make sure a subsequent
 * easy transfer finds and uses the populated stuff.*/",#NAME?,Not Useful
/*specify target*/,"-1.     easy_init(curl[i]);

/*specify target*/

1.     msnprintf(target_url, sizeof(target_url),",Not Useful
/*go verbose*/,"-3.               port, i + 1);
-2.     target_url[sizeof(target_url) - 1] = '\0';
-1.     easy_setopt(curl[i], CURLOPT_URL, target_url);

/*go verbose*/

1.     easy_setopt(curl[i], CURLOPT_VERBOSE, 1L);",Not Useful
/*run NUM_HANDLES transfers*/,"-1.   easy_setopt(curl[0], CURLOPT_RESOLVE, slist);

/*run NUM_HANDLES transfers*/

1.   for(i = 0; (i < NUM_HANDLES) && !res; i++)
2.     res = curl_easy_perform(curl[i]);
3. test_cleanup:
4.   curl_easy_cleanup(curl[0]);
5.   curl_easy_cleanup(curl[1]);",Not Useful
/*bump*/,"-3.     fprintf(stderr, ""READ ALREADY DONE!\n"");
-2.     return 0;
-1.   }

/*bump*/

1.   if(size * nmemb > strlen(UPLOADTHIS)) {
2.     fprintf(stderr, ""READ!\n"");
3.     strcpy(ptr, UPLOADTHIS);
4.     return strlen(UPLOADTHIS);
5.   }
6.   fprintf(std",Not Useful
/*unused*/,"-10.     return strlen(UPLOADTHIS);
-9.   }
-8.   fprintf(stderr, ""READ NOT FINE!\n"");
-7.   return 0;
-6. }
-5. static curlioerr ioctlcallback(CURL *handle,
-4.                                int cmd,
-3.                                void *clientp)
-2.",Not Useful
/*we want to use our own read function*/,"-1.   test_setopt(curl, CURLOPT_POSTFIELDSIZE, 1L);

/*we want to use our own read function*/

1.   test_setopt(curl, CURLOPT_READFUNCTION, read_callback);",Not Useful
/*always cleanup*/,"-2.   res = curl_easy_perform(curl);
-1. test_cleanup:

/*always cleanup*/

1.   curl_easy_cleanup(curl);
2.   curl_global_cleanup();
3.   return (int)res;
4. }",Not Useful
/*from the private lib dir*/,"-10. #endif
-9. #ifdef HAVE_ARPA_INET_H
-8. #include <arpa/inet.h>
-7. #endif
-6. #ifdef HAVE_NETDB_H
-5. #include <netdb.h>
-4. #endif
-3. #define ENABLE_CURLX_PRINTF

/*from the private lib dir*/

1. #include ""getpart.h""
2. #include ""inet_pton.h""
3. #in",Not Useful
/*launch waiting thread*/,"-6.   data = malloc(sizeof(struct select_ws_wait_data));
-5.   if(data) {
-4.     data->handle = handle;
-3.     data->signal = signal;
-2.     data->abort = abort;
-1.     data->mutex = mutex;

/*launch waiting thread*/

1.     thread = CreateThread(NULL",Not Useful
/*free data if thread failed to launch*/,"-3.     thread = CreateThread(NULL, 0,
-2.                           &select_ws_wait_thread,
-1.                           data, 0, NULL);

/*free data if thread failed to launch*/

1.     if(!thread) {
2.       free(data);
3.     }
4.   }
5.   return thr",Not Useful
/*USE_WINSOCK*/,"-1. #include ""memdebug.h""
#ifdef USE_WINSOCK

/*USE_WINSOCK*/

1. #undef  EINTR",Not Useful
/*switch(*mode)*/,"-10.     logmsg(""process becomes orphan, exiting"");
-9.     return FALSE;
-8.   }
-7. #endif
-6.   timeout.tv_sec = 120;
-5.   timeout.tv_usec = 0;
-4.   FD_ZERO(&fds_read);
-3.   FD_ZERO(&fds_write);
-2.   FD_ZERO(&fds_err);
-1.   FD_SET((curl_socket_t)f",Not Useful
"/*Question asking us what PORT number we are listening to.
         Replies to PORT with ""IPv[num]/[port]""*/","-4.       if(!write_stdout(""PONG\n"", 5))
-3.         return FALSE;
-2.     }
-1.     else if(!memcmp(""PORT"", buffer, 4)) {

/*Question asking us what PORT number we are listening to.
         Replies to PORT with ""IPv[num]/[port]""*/

1.       msnprintf((c",Not Useful
/*just die*/,"-10.          Replies to PORT with ""IPv[num]/[port]"" */
-9.       msnprintf((char *)buffer, sizeof(buffer), ""%s/%hu\n"", ipv_inuse, port);
-8.       buffer_len = (ssize_t)strlen((char *)buffer);
-7.       msnprintf(data, sizeof(data), ""PORT\n%04zx\n"", buff",Not Useful
/*disconnect!*/,"-8.         ssize_t bytes_written = swrite(sockfd, buffer, buffer_len);
-7.         if(bytes_written != buffer_len) {
-6.           logmsg(""Not all data was sent. Bytes to send: %zd sent: %zd"",
-5.                  buffer_len, bytes_written);
-4.         ",Not Useful
/*passive daemon style*/,"-10.       else
-9.         *mode = ACTIVE_DISCONNECT;
-8.       return TRUE;
-7.     }
-6.   }
-5.   return TRUE;
-4. }
-3. static curl_socket_t sockdaemon(curl_socket_t sock,
-2.                                 unsigned short *listenport)
-1. {

/*passi",Not Useful
/*should not happen*/,"-10.     flag = 1;
-9.     rc = setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
-8.          (void *)&flag, sizeof(flag));
-7.     if(rc) {
-6.       error = SOCKERRNO;
-5.       logmsg(""setsockopt(SO_REUSEADDR) failed with error: (%d) %s"",
-4.              er",Not Useful
"/*When the specified listener port is zero, it is actually a
     request to let the system choose a non-zero available port.*/","-8.       }
-7.     }
-6.   } while(rc && maxretr--);
-5.   if(rc) {
-4.     logmsg(""setsockopt(SO_REUSEADDR) failed %d times in %d ms. Error: (%d) %s"",
-3.            attempt, totdelay, error, strerror(error));
-2.     logmsg(""Continuing anyway..."");
-1.",Not Useful
/*ENABLE_IPV6*/,"-8. #endif
-7. #define DEFAULT_PORT 8999
-6. #ifndef DEFAULT_LOGFILE
-5. #define DEFAULT_LOGFILE ""log/sockfilt.log""
-4. #endif
-3. const char *serverlogfile = DEFAULT_LOGFILE;
-2. static bool verbose = FALSE;
-1. static bool bind_only = FALSE;
#ifdef ENAB",Not Useful
"/*The system was supposed to choose a port number, figure out which
       port we actually got and update the listener port value with it.*/","-8.   if(rc) {
-7.     error = SOCKERRNO;
-6.     logmsg(""Error binding socket on port %hu: (%d) %s"",
-5.            *listenport, error, strerror(error));
-4.     sclose(sock);
-3.     return CURL_SOCKET_BAD;
-2.   }
-1.   if(!*listenport) {

/*The system",Not Useful
/*ENABLE_IPV6*/,"-8. #endif
-7. #define DEFAULT_PORT 8999
-6. #ifndef DEFAULT_LOGFILE
-5. #define DEFAULT_LOGFILE ""log/sockfilt.log""
-4. #endif
-3. const char *serverlogfile = DEFAULT_LOGFILE;
-2. static bool verbose = FALSE;
-1. static bool bind_only = FALSE;
#ifdef ENAB",Not Useful
/*passive daemon style*/,"-10.       else
-9.         *mode = ACTIVE_DISCONNECT;
-8.       return TRUE;
-7.     }
-6.   }
-5.   return TRUE;
-4. }
-3. static curl_socket_t sockdaemon(curl_socket_t sock,
-2.                                 unsigned short *listenport)
-1. {

/*passi",Not Useful
/*Already cleaned up.*/,"-1.   curl_mime_free(mime);

/*Already cleaned up.*/

111",Not Useful
/*Already cleaned up.*/,"-1.   curl_mime_free(mime);

/*Already cleaned up.*/

111",Not Useful
/*Test CURLINFO_SCHEME*/,#NAME?,Not Useful
/*unused*/,"-4. static int curlSocketCallback(CURL *easy, curl_socket_t s, int action,
-3.                               void *userp, void *socketp)
-2. {
-1.   struct ReadWriteSockets *sockets = userp;

/*unused*/

111",Not Useful
/*unused*/,"-4. static int curlSocketCallback(CURL *easy, curl_socket_t s, int action,
-3.                               void *userp, void *socketp)
-2. {
-1.   struct ReadWriteSockets *sockets = userp;

/*unused*/

111",Not Useful
/*unused*/,"-4. static int curlSocketCallback(CURL *easy, curl_socket_t s, int action,
-3.                               void *userp, void *socketp)
-2. {
-1.   struct ReadWriteSockets *sockets = userp;

/*unused*/

111",Not Useful
/*enable uploading*/,"-10.     fclose(hd_src);
-9.     return TEST_ERR_FSTAT;
-8.   }
-7.   fprintf(stderr, ""Set to upload %d bytes\n"", (int)file_info.st_size);
-6.   res_global_init(CURL_GLOBAL_ALL);
-5.   if(res) {
-4.     fclose(hd_src);
-3.     return res;
-2.   }
-1.   ea",Not Useful
/*go verbose*/,"-1.   easy_setopt(curl, CURLOPT_URL, URL);

/*go verbose*/

1.   easy_setopt(curl, CURLOPT_VERBOSE, 1L);",Not Useful
/*we don't use this*/,"-10. #include ""memdebug.h""
-9. int test(char *URL)
-8. {
-7.   const unsigned char a[] = {0x2f, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
-6.                              0x91, 0xa2, 0xb3, 0xc4, 0xd5, 0xe6, 0xf7};
-5.   CURLcode res = CURLE_OK;
-4.   char *ptr ",Not Useful
/*unused*/,"-10. int test(char *URL)
-9. {
-8.   CURLM *handle;
-7.   int res = CURLE_OK;
-6.   static const char * const bl_servers[] =
-5.      {""Microsoft-IIS/6.0"", ""nginx/0.8.54"", NULL};
-4.   static const char * const bl_sites[] =
-3.      {""curl.se:443"", ""examp",Not Useful
/*done*/,"-10.       easy_setopt(easy[num_handles], CURLOPT_HEADER, 1L);
-9.       multi_add_handle(multi, easy[num_handles]);
-8.       num_handles += 1;
-7.       state = NeedSocketForNewHandle;
-6.     }
-5.     multi_perform(multi, &running);
-4.     fprintf(st",Not Useful
/** This is the list of basic details you need to tweak to get things right.*/,"-10.  * copies of the Software, and permit persons to whom the Software is
-9.  * furnished to do so, under the terms of the COPYING file.
-8.  *
-7.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-6.  * KIND, either express ",Not Useful
/*we want to use our own read function*/,"-1.   test_setopt(curl, CURLOPT_POSTFIELDSIZE, (long)pooh.sizeleft);

/*we want to use our own read function*/

1.   test_setopt(curl, CURLOPT_READFUNCTION, read_callback);",Not Useful
/*always cleanup*/,"-2.   res = curl_easy_perform(curl);
-1. test_cleanup:

/*always cleanup*/

1.   curl_easy_cleanup(curl);",Not Useful
/*old*/,"-2. #endif
-1. }
static int once(char *URL, bool oldstyle)

/*old*/

1. {
2.   CURL *curl;
3.   CURLcode res = CURLE_OK;
4.   CURLFORMcode formrc;
5.   struct curl_httppost *formpost = NULL;
6.   struct curl_httppost *lastptr = NULL;
7.   struct WriteThis",Not Useful
/*provide this to the rest*/,"-10.   if(argc< 2) {
-9.     fprintf(stderr, ""Pass URL as argument please\n"");
-8.     return 1;
-7.   }
-6.   test_argc = argc;
-5.   test_argv = argv;
-4.   if(argc>2)
-3.     libtest_arg2 = argv[2];
-2.   if(argc>3)
-1.     libtest_arg3 = argv[3];

/*p",Not Useful
"/*Check range/resume returned error codes and data presence.

  The input parameters are:
  - CURLOPT_RANGE/CURLOPT_RESUME_FROM
  - CURLOPT_FAILONERROR
  - Returned http code (2xx/416)
  - Content-Range header present in reply.*/",#NAME?,Not Useful
/*resume/range.*/,"-1. #include ""memdebug.h""

/*resume/range.*/

111",Not Useful
/*ORed flags as above.*/,"-1. struct testparams {

/*ORed flags as above.*/

111",Not Useful
/*TIMEVALUE in the future*/,"-10. int test(char *URL)
-9. {
-8.   long unmet;
-7.   CURL *curl = NULL;
-6.   int res = 0;
-5.   global_init(CURL_GLOBAL_ALL);
-4.   easy_init(curl);
-3.   easy_setopt(curl, CURLOPT_URL, URL);
-2.   easy_setopt(curl, CURLOPT_HEADER, 1L);
-1.   easy_seto",Not Useful
/*not correct*/,"-6.   easy_setopt(curl, CURLOPT_TIMEVALUE, 1566210680L);
-5.   res = curl_easy_perform(curl);
-4.   if(res)
-3.     goto test_cleanup;
-2.   curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &unmet);
-1.   if(unmet != 1L) {

/*not correct*/

1.     goto t",Not Useful
/*TIMEVALUE in the past*/,"-2.     goto test_cleanup;
-1.   }

/*TIMEVALUE in the past*/

1.   easy_setopt(curl, CURLOPT_TIMEVALUE, 1L);
2.   res = curl_easy_perform(curl);
3.   if(res)
4.     goto test_cleanup;
5.   curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &unmet);
6.   i",Not Useful
/*not correct*/,"-6.   easy_setopt(curl, CURLOPT_TIMEVALUE, 1566210680L);
-5.   res = curl_easy_perform(curl);
-4.   if(res)
-3.     goto test_cleanup;
-2.   curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &unmet);
-1.   if(unmet != 1L) {

/*not correct*/

1.     goto t",Not Useful
/*this is where we should be*/,"-2.     goto test_cleanup;
-1.   }

/*this is where we should be*/

1. test_cleanup:",Not Useful
/*always cleanup*/,"-1. test_cleanup:

/*always cleanup*/

1.   curl_easy_cleanup(curl);
2.   curl_global_cleanup();
3.   return res;
4. }",Not Useful
"/** This test sends data with CURLOPT_KEEP_SENDING_ON_ERROR.
 * The server responds with an early error response.
 * The test is successful if the connection can be reused for the next request,
 * because this implies that the data has been sent completely to the server.*/",#NAME?,Not Useful
/*we don't use this*/,"-10.  ***************************************************************************/
-9. #include ""test.h""
-8. #include ""memdebug.h""
-7. int test(char *URL)
-6. {
-5.   unsigned char a[] = {0x2f, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
-4.                      ",Not Useful
/*test function*/,"-10.   (void)useptr;
-9.   printf(""-> Mutex lock\n"");
-8. }
-7. static void my_unlock(CURL *handle, curl_lock_data data, void *useptr)
-6. {
-5.   (void)handle;
-4.   (void)data;
-3.   (void)useptr;
-2.   printf(""<- Mutex unlock\n"");
-1. }

/*test functio",Not Useful
/*always cleanup*/,"-3.       if(res != CURLE_OK)
-2.         fprintf(stderr, ""curl_easy_perform() failed: %s\n"",
-1.                 curl_easy_strerror(res));

/*always cleanup*/

1.       curl_easy_cleanup(curl);
2.     }
3.   }
4.   curl_share_cleanup(share);
5.   curl_gl",Not Useful
/*we want to use our own progress function*/,"-1.   test_setopt(curl, CURLOPT_URL, URL);

/*we want to use our own progress function*/

1.   test_setopt(curl, CURLOPT_NOPROGRESS, 0L);
2.   test_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_callback);",Not Useful
/*always cleanup*/,"-10.     FILE *moo;
-9.     res = curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD,
-8.                             &content_length);
-7.     moo = fopen(libtest_arg2, ""wb"");
-6.     if(moo) {
-5.       fprintf(moo, ""CL %.0f\n"", content_length);
-",Not Useful
"/** This unit test PUT http data over proxy. Proxy header will be different
 * from server http header*/",#NAME?,Not Useful
/*the smallest!*/,"-10.     return TEST_ERR_MAJOR_BAD;
-9.   }
-8.   curl = curl_easy_init();
-7.   if(!curl) {
-6.     fprintf(stderr, ""curl_easy_init() failed\n"");
-5.     curl_global_cleanup();
-4.     return TEST_ERR_MAJOR_BAD;
-3.   }
-2.   test_setopt(curl, CURLOPT_UR",Not Useful
/*specify target*/,"-1.     easy_init(curl[i]);

/*specify target*/

1.     msnprintf(target_url, sizeof(target_url),",Not Useful
/*go verbose*/,"-3.               i + 1, port, i + 1);
-2.     target_url[sizeof(target_url) - 1] = '\0';
-1.     easy_setopt(curl[i], CURLOPT_URL, target_url);

/*go verbose*/

1.     easy_setopt(curl[i], CURLOPT_VERBOSE, 1L);",Not Useful
/*add handle to multi*/,"-5.     easy_setopt(curl[i], CURLOPT_HEADER, 1L);
-4.     easy_setopt(curl[i], CURLOPT_RESOLVE, slist);
-3.   }
-2.   fprintf(stderr, ""Start at URL 0\n"");
-1.   for(i = 0; i < NUM_HANDLES; i++) {

/*add handle to multi*/

1.     multi_add_handle(m, curl[i",Not Useful
/*done*/,"-10.     multi_add_handle(m, curl[i]);
-9.     for(;;) {
-8.       struct timeval interval;
-7.       fd_set rd, wr, exc;
-6.       int maxfd = -99;
-5.       interval.tv_sec = 1;
-4.       interval.tv_usec = 0;
-3.       multi_perform(m, &running);
-2.  ",Not Useful
"/*mag01[x] = x * MATRIX_A  for x=0,1*/","-4. unsigned long genrand_int32( void )
-3. {
-2.     unsigned long        y;
-1.     static unsigned long mag01[2] = { 0x0UL, MATRIX_A };

/*mag01[x] = x * MATRIX_A  for x=0,1*/

111",Not Useful
"/*if init_genrand() has not been called,*/","-2.     {
-1.         int kk;

/*if init_genrand() has not been called,*/

111",Not Useful
/*divided by 2^32-1*/,"-3. double genrand_real1( void )
-2. {
-1.     return (double) genrand_int32() * ( 1.0 / 4294967295.0 );

/*divided by 2^32-1*/

1. }",Not Useful
/*divided by 2^32*/,"-3. double genrand_real1( void )
-2. {
-1.     return (double) genrand_int32() * ( 1.0 / 4294967295.0 );

/*divided by 2^32*/

1. }",Not Useful
/*divided by 2^32*/,"-3. double genrand_real1( void )
-2. {
-1.     return (double) genrand_int32() * ( 1.0 / 4294967295.0 );

/*divided by 2^32*/

1. }",Not Useful
/*normalize: 1 = si*si + ci*ci*/,"-6.     for ( k = 0; k < plsc->nps; k++ )
-5.     {
-4.         bufferleng = 0;
-3.         temp = DTOR * plsc->inclin[k] * 0.1;
-2.         si   = sin( temp ) * plsc->ypmm;
-1.         ci   = cos( temp ) * plsc->xpmm;

/*normalize: 1 = si*si + ci*ci*/

1",Not Useful
/*Must have at least 3 points and draw() specified*/,"-10.             PLINT xmin, PLINT xmax, PLINT ymin, PLINT ymax,
-9.             void ( *draw )( short *, short *, PLINT ) )
-8. {
-7. #ifdef USE_FILL_INTERSECTION_POLYGON
-6.     PLINT *x10, *y10, *x1, *y1, *if1, i1start = 0, i, im1, n1, n1m1,
-5.       ",Not Useful
/*USE_FILL_INTERSECTION_POLYGON*/,"-10. static void
-9. addcoord( PLINT, PLINT );
-8. static void
-7. tran( PLINT *, PLINT *, PLFLT, PLFLT );
-6. static void
-5. buildlist( PLINT, PLINT, PLINT, PLINT, PLINT, PLINT, PLINT );
-4. static int
-3. notpointinpolygon( PLINT n, PLINT_VECTOR x, PLI",Not Useful
/*Boundary crossing condition -- coming in.*/,"-10.     for ( i = 0; i < npts - 1; i++ )
-9.     {
-8.         x1 = x[i]; x2 = x[i + 1];
-7.         y1 = y[i]; y2 = y[i + 1];
-6.         drawable = ( INSIDE( x1, y1 ) && INSIDE( x2, y2 ) );
-5.         if ( !drawable )
-4.             drawable = !plP_c",Not Useful
"/*If the first segment, just add it.*/","-7.             crossed_xmin2 = ( x1 == xmin ); crossed_xmax2 = ( x1 == xmax );
-6.             crossed_ymin2 = ( y1 == ymin ); crossed_ymax2 = ( y1 == ymax );
-5.             crossed_left  = ( crossed_left || crossed_xmin2 );
-4.             crossed_righ",Not Useful
"/*Not first point.  If first point of this segment matches up to the
previous point, just add it.*/","-5.             if ( iclp == 0 )
-4.             {
-3.                 xclp[iclp] = (short) x1; yclp[iclp] = (short) y1; iclp++;
-2.                 xclp[iclp] = (short) x2; yclp[iclp] = (short) y2; iclp++;
-1.             }

/*Not first point.  If first ",Not Useful
/*Upper two*/,"-3.                 xclp[iclp + 1] = (short) x2; yclp[iclp + 1] = (short) y2;
-2.                 xclp[iclp + 2] = (short) x1; yclp[iclp + 2] = (short) y1;
-1.                 iout           = iout - iclp + 1;

/*Upper two*/

1.                 if ( ( ( c",Not Useful
/*Lower two*/,"-10.                     {
-9.                         xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymax; iclp++;
-8.                         xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymax; iclp++;
-7.                     }
-6.                   ",Not Useful
/*Left two*/,"-10.                     {
-9.                         xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymin; iclp++;
-8.                         xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymin; iclp++;
-7.                     }
-6.                   ",Not Useful
/*Right two*/,"-10.                     {
-9.                         xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymin; iclp++;
-8.                         xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymax; iclp++;
-7.                     }
-6.                   ",Not Useful
"/*Now the case where we encircled one corner
Lower left*/","-10.                     {
-9.                         xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymin; iclp++;
-8.                         xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymax; iclp++;
-7.                     }
-6.                   ",Not Useful
/*Lower right*/,"-5.                 else if ( ( crossed_xmin1 && crossed_ymin2 ) ||
-4.                           ( crossed_ymin1 && crossed_xmin2 ) )
-3.                 {
-2.                     xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymin; iclp++;
-1.         ",Not Useful
/*Upper left*/,"-5.                 else if ( ( crossed_xmax1 && crossed_ymin2 ) ||
-4.                           ( crossed_ymin1 && crossed_xmax2 ) )
-3.                 {
-2.                     xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymin; iclp++;
-1.         ",Not Useful
/*Upper right*/,"-5.                 else if ( ( crossed_xmin1 && crossed_ymax2 ) ||
-4.                           ( crossed_ymax1 && crossed_xmin2 ) )
-3.                 {
-2.                     xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymax; iclp++;
-1.         ",Not Useful
/*Now add current segment.*/,"-5.                 else if ( ( crossed_xmax1 && crossed_ymax2 ) ||
-4.                           ( crossed_ymax1 && crossed_xmax2 ) )
-3.                 {
-2.                     xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymax; iclp++;
-1.         ",Not Useful
/*Boundary crossing condition -- going out.*/,"-3.                 xclp[iclp] = (short) x1; yclp[iclp] = (short) y1; iclp++;
-2.                 xclp[iclp] = (short) x2; yclp[iclp] = (short) y2; iclp++;
-1.             }

/*Boundary crossing condition -- going out.*/

1.             crossed_xmin1 = ( ",Not Useful
/*Divided vertically*/,"-10.             {
-9.                 xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymin; iclp++;
-8.                 xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymin; iclp++;
-7.             }
-6.             else
-5.             {
-4.            ",Not Useful
/*Draw the sucker*/,"-10.             xclp[iclp] = (short) xlim[insert];
-9.             yclp[iclp] = (short) ylim[insert];
-8.             iclp++;
-7.             insert += incr;
-6.             if ( insert > 3 )
-5.                 insert = 0;
-4.             if ( insert < ",Not Useful
/*USE_FILL_INTERSECTION_POLYGON*/,"-10. static void
-9. addcoord( PLINT, PLINT );
-8. static void
-7. tran( PLINT *, PLINT *, PLFLT, PLFLT );
-6. static void
-5. buildlist( PLINT, PLINT, PLINT, PLINT, PLINT, PLINT, PLINT );
-4. static int
-3. notpointinpolygon( PLINT n, PLINT_VECTOR x, PLI",Not Useful
/*Temporary until get rid of old code altogether.*/,"-10. // int notpointinpolygon()
-9. //
-8. // Returns 0, 1, or 2 depending on whether the test point is definitely
-7. // inside, near the border, or definitely outside the polygon.
-6. // Notes:
-5. // This ""Ray casting algorithm"" has been described in
-",Not Useful
/*NEW_NOTPOINTINPOLYGON_CODE*/,"-10. //
-9. // Returns 0, 1, or 2 depending on whether the test point is definitely
-8. // inside, near the border, or definitely outside the polygon.
-7. // Notes:
-6. // This ""Ray casting algorithm"" has been described in
-5. // http://en.wikipedia.org/w",Not Useful
/*Skip zero-length segments*/,"-10.         if ( i < n - 1 )
-9.         {
-8.             x2 = (PLFLT) x[i + 1];
-7.             y2 = (PLFLT) y[i + 1];
-6.         }
-5.         else
-4.         {
-3.             x2 = (PLFLT) x[0];
-2.             y2 = (PLFLT) y[0];
-1.         }

/*S",Not Useful
/*No crossing possible!*/,"-3.         inprod2 = xv2 * yvp - yv2 * xvp;
-2.         if ( inprod1 * inprod2 >= 0.0 )
-1.         {

/*No crossing possible!*/

1.             continue;
2.         }",Not Useful
/*No crossing possible!*/,"-3.         inprod2 = xv2 * yvp - yv2 * xvp;
-2.         if ( inprod1 * inprod2 >= 0.0 )
-1.         {

/*No crossing possible!*/

1.             continue;
2.         }",Not Useful
/*We do have a crossing*/,"-2.             continue;
-1.         }

/*We do have a crossing*/

1.         count_crossings++;
2.     }",Not Useful
/*NEW_NOTPOINTINPOLYGON_CODE*/,"-10. //
-9. // Returns 0, 1, or 2 depending on whether the test point is definitely
-8. // inside, near the border, or definitely outside the polygon.
-7. // Notes:
-6. // This ""Ray casting algorithm"" has been described in
-5. // http://en.wikipedia.org/w",Not Useful
"/*Finish off collecting split1 using ascending kk
values.*/","-10.                     xsplit2[nsplit2m1 - k] = x1[kk];
-9.                     ysplit2[nsplit2m1 - k] = y1[kk++];
-8.                     ifsplit2[nsplit2m1 - k] = 2;
-7.                 }
-6.                 xsplit1[k] = xintersect[1];
-5.            ",Not Useful
"/*Finish off collecting split2 using descending kk
values.*/","-7.                 fill_intersection_polygon(
-6.                     recursion_depth + 1, ifextrapolygon, 1, fill,
-5.                     x1, y1, i1start_new, n1,
-4.                     xsplit1, ysplit1, ifsplit1, nsplit1 );
-3.                 free( ",Not Useful
"/*If a fill_status of +/- 1 is known, use that to fill or not since
+1 corresponds to all of polygon 2 inside polygon 1 and -1
corresponds to none of polygon 2 inside polygon 1.*/","-10.             }
-9.         }
-8.         i1m1 = i1;
-7.     }
-6.     if ( ncrossed != 0 )
-5.     {
-4.         plwarn( ""fill_intersection_polygon: Internal error; ncrossed != 0."" );
-3.         return;
-2.     }

/*If a fill_status of +/- 1 is known",Not Useful
/*else if ( 1 )*/,"-9.     if ( fill_status == -1 )
-8.         return;
-7.     else if ( fill_status == 1 )
-6.     {
-5.         nfill = n2;
-4.         xfiller = x2;
-3.         yfiller = y2;
-2.     }
-1.     else if ( fill_status == 0 )

/*else if ( 1 )*/

1.     {
2. ",Not Useful
"/*These variables are PLFLT not for precision, but to
avoid integer overflows if they were typed as PLINT.*/","-6. int
-5. notcrossed( PLINT * xintersect, PLINT * yintersect,
-4.             PLINT xA1, PLINT yA1, PLINT xA2, PLINT yA2,
-3.             PLINT xB1, PLINT yB1, PLINT xB2, PLINT yB2 )
-2. {
-1.     PLFLT factor, factor_NBCC, fxintersect, fyintersect;

/*",Not Useful
"/*Use PLFLT for all calculations to avoid integer overflows.  Also,
the normal PLFLT has 64-bits which means you get exact integer
arithmetic well beyond the normal integer overflow limits.*/","-4. int
-3. positive_orientation( PLINT n, PLINT_VECTOR x, PLINT_VECTOR y )
-2. {
-1.     PLINT i, im1;

/*Use PLFLT for all calculations to avoid integer overflows.  Also,
the normal PLFLT has 64-bits which means you get exact integer
arithmetic well bey",Not Useful
"/*plc2eval, (PLPointer) &cgrid,*/","-10. plshade_null( PLFLT_MATRIX a, PLINT nx, PLINT ny, PLDEFINED_callback defined,
-9.               PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-8.               PLFLT shade_min, PLFLT shade_max,
-7.               PLINT sh_cmap, PLFLT sh_color, PLFLT",Not Useful
/*PL_DEPRECATED*/,"-6.         defined, nx, ny, xmin,
-5.         xmax, ymin, ymax, shade_min, shade_max,
-4.         sh_cmap, sh_color, sh_width,
-3.         min_color, min_width, max_color, max_width,
-2.         fill, rectangular, pltr, pltr_data );
-1. }
#ifdef PL_DEPRE",Not Useful
"/*plc2eval, (PLPointer) &cgrid,*/","-10. plshade_null( PLFLT_MATRIX a, PLINT nx, PLINT ny, PLDEFINED_callback defined,
-9.               PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-8.               PLFLT shade_min, PLFLT shade_max,
-7.               PLINT sh_cmap, PLFLT sh_color, PLFLT",Not Useful
/*c2eval is unused.*/,"-10. //     set min_width == 0 and max_width == 0 for no contours
-9. // fill: fill function, set to NULL for no shading (contour plot)
-8. // rectangular: flag set to 1 if pltr() maps rectangles to rectangles
-7. //     this helps optimize the plotting
-",Not Useful
/*Cast to void to silence compiler warning about unused parameter*/,"-10.              PLINT min_color, PLFLT min_width,
-9.              PLINT max_color, PLFLT max_width,
-8.              PLFILL_callback fill, PLINT rectangular,
-7.              PLTRANSFORM_callback pltr, PLPointer pltr_data )
-6. {
-5.     PLINT n, slope",Not Useful
"/*alloc space for value array, and initialize
This is only a temporary kludge*/","-10.             plcol0( (PLINT) sh_color );
-9.             break;
-8.         case 1:
-7.             plcol1( sh_color );
-6.             break;
-5.         default:
-4.             plabort( ""plfshade: invalid color map selection"" );
-3.             ret",Not Useful
/*alloc space for condition codes*/,"-9.     nxny = nx * ny;
-8.     if ( ( a = (PLFLT *) malloc( (size_t) nxny * sizeof ( PLFLT ) ) ) == NULL )
-7.     {
-6.         plabort( ""plfshade: unable to allocate memory for value array"" );
-5.         return;
-4.     }
-3.     for ( ix = 0; ix < nx",Not Useful
/*No filling needs to be done for these cases*/,"-10.     dy = ( ymax - ymin ) / ( ny - 1 );
-9.     a0 = a;
-8.     a1 = a + ny;
-7.     c0 = c;
-6.     c1 = c + ny;
-5.     for ( ix = 0; ix < nx - 1; ix++ )
-4.     {
-3.         for ( iy = 0; iy < ny - 1; iy++ )
-2.         {
-1.             count = c",Not Useful
"/*x[i], y[i] known to be in defined region so add this
point to xx, yy.*/","-5.                     bisect( defined, NUMBER_BISECTIONS,
-4.                         x[i], y[i], x[im1], y[im1], &xb, &yb );
-3.                     xx[count]   = xb;
-2.                     yy[count++] = yb;
-1.                 }

/*x[i], y[i] known t",Not Useful
"/*Cross from defined (at im1) to undefined region.
Bisect for the last point in the defined region and
add it to xx, yy.*/","-8.                 xx[count]   = x[i];
-7.                 yy[count++] = y[i];
-6.                 is_defined  = 1;
-5.             }
-4.             else
-3.             {
-2.                 if ( is_defined )
-1.                 {

/*Cross from defined",Not Useful
/*sorted[0] == min*/,"-10.     {
-9.         temp = sorted[j];
-8.         i    = j - 1;
-7.         while ( i >= 0 && sorted[i] > temp )
-6.         {
-5.             sorted[i + 1] = sorted[i];
-4.             i--;
-3.         }
-2.         sorted[i + 1] = temp;
-1.     }

/*",Not Useful
/*Internal constants*/,"-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Not Useful
"/*static void plxyindexlimits( PLINT instart, PLINT inn,
PLINT *inarray_min, PLINT *inarray_max,
PLINT *outstart, PLINT *outn, PLINT outnmax,
PLINT *outarray_min, PLINT *outarray_max );*/","-10. static void swaphiview( void );
-9. static void swaploview( void );
-8. static void myexit( PLCHAR_VECTOR );
-7. static void myabort( PLCHAR_VECTOR );
-6. static void freework( void );
-5. static int  plabv( PLINT, PLINT, PLINT, PLINT, PLINT, PLINT )",Not Useful
/*#define MJL_HACK 1*/,"-10. static void freework( void );
-9. static int  plabv( PLINT, PLINT, PLINT, PLINT, PLINT, PLINT );
-8. static void pl3cut( PLINT, PLINT, PLINT, PLINT, PLINT,
-7.                     PLINT, PLINT, PLINT, PLINT *, PLINT * );
-6. static PLFLT plGetAngleTo",Not Useful
/*none out*/,"-10.         in   = _in;
-9.         T[0] = &_T[0][0];
-8.         T[1] = &_T[1][0];
-7.         T[2] = &_T[2][0];
-6.     }
-5.     for ( i = 0; i < Ni; i++ )
-4.     {
-3.         in[i]   = Vi[axis][i] * dir + offset;
-2.         anyout += in[i] < 0;
-1",Not Useful
/*all out*/,"-2.     if ( anyout == 0 )
-1.         return Ni;

/*all out*/

1.     if ( anyout == Ni )
2.     {
3.         return 0;
4.     }",Not Useful
"/*some out
copy over to a temp vector*/","-4.     if ( anyout == Ni )
-3.     {
-2.         return 0;
-1.     }

/*some out
copy over to a temp vector*/

1.     for ( i = 0; i < 3; i++ )
2.     {
3.         for ( j = 0; j < Ni; j++ )
4.         {
5.             T[i][j] = Vi[i][j];
6.         }
7.",Not Useful
/*copy back selectively*/,"-7.     for ( i = 0; i < 3; i++ )
-6.     {
-5.         for ( j = 0; j < Ni; j++ )
-4.         {
-3.             T[i][j] = Vi[i][j];
-2.         }
-1.     }

/*copy back selectively*/

1.     for ( i = 0; i < Ni; i++ )
2.     {
3.         j = ( i + 1 ) % ",Not Useful
"/*helper for plsurf3d, similar to c_plfill3()*/","-10.             No++;
-9.         }
-8.     }
-7.     if ( Ni > PL_MAXPOLY )
-6.     {
-5.         free( in );
-4.         free( TT );
-3.     }
-2.     return No;
-1. }

/*helper for plsurf3d, similar to c_plfill3()*/

1. static void
2. shade_triangle( ",Not Useful
/*Check that points in x and in y are strictly increasing  and in range*/,"-10.     else
-9.         falsecolor = 0;
-8.     plP_gdom( &xmin, &xmax, &ymin, &ymax );
-7.     plP_grange( &zscale, &zmin, &zmax );
-6.     if ( zmin > zmax )
-5.     {
-4.         PLFLT t = zmin;
-3.         zmin = zmax;
-2.         zmax = t;
-1.     ",Not Useful
"/*we've got to draw the background grid first, hidden line code has to draw it last*/","-10.         ixFast = ixDir; ixSlow = 0;
-9.         iyFast = 0;     iySlow = iyDir;
-8.     }
-7.     else
-6.     {
-5.         nFast = iymax - iymin;
-4.         nSlow = ixmax - ixmin;
-3.         ixFast = 0;     ixSlow = ixDir;
-2.         iyFast = iy",Not Useful
/*follow the contour levels and lines*/,"-3.         plFree2dGrid( zstore, nx, ny );
-2.         plFree2dGrid( cgrid2.xg, nx, ny );
-1.         plFree2dGrid( cgrid2.yg, nx, ny );

/*follow the contour levels and lines*/

1.         clev = cont;",Not Useful
/*now release the memory*/,"-10.                 {
-9.                     plcol1( ( clev->level - fc_minz ) / ( fc_maxz - fc_minz ) );
-8.                     plline3( cline->npts, cline->x, cline->y, zzloc );
-7.                 }
-6.                 cline = cline->next;
-5.      ",Not Useful
"/*After shading completed for a quad, render surface contours.*/","-7.             for ( i = 1; i < 3; i++ )
-6.             {
-5.                 for ( j = 0; j < 4; j += 3 )
-4.                 {
-3.                     shade_triangle( px[j], py[j], pz[j], xm, ym, zm, px[i], py[i], pz[i] );
-2.                 }
-1.   ",Not Useful
/*p0-pm*/,"-10.                 {
-9.                     for ( j = 0; j < 4; j += 3 )
-8. #define min3( a, b, c )    ( MIN( ( MIN( a, b ) ), c ) )
-7. #define max3( a, b, c )    ( MAX( ( MAX( a, b ) ), c ) )
-6.                     {
-5.                         for",Not Useful
/*p0-p1*/,"-5.                                 {
-4.                                     xx[ct] = ( ( clevel[k] - pz[i] ) * ( xm - px[i] ) ) / ( zm - pz[i] ) + px[i];
-3.                                     yy[ct] = ( ( clevel[k] - pz[i] ) * ( ym - py[i] ) ) / ( zm ",Not Useful
/*p1-pm*/,"-5.                                 {
-4.                                     xx[ct] = ( ( clevel[k] - pz[i] ) * ( px[j] - px[i] ) ) / ( pz[j] - pz[i] ) + px[i];
-3.                                     yy[ct] = ( ( clevel[k] - pz[i] ) * ( py[j] - py[i] ) ",Not Useful
/*figure out the part of the data to use*/,"-10.         if ( y[i] >= y[i + 1] )
-9.         {
-8.             myabort( ""plot3dcl: Y array must be strictly increasing"" );
-7.             return;
-6.         }
-5.     }
-4.     if ( opt & MESH )
-3.         pl3mode = 1;
-2.     if ( opt & DRAW_SIDES",Not Useful
"/*fprintf(stderr, ""(%d,%d) %d %d %d %d\n"", nx, ny, ixmin, ixmax, iymin, iymax);
do we need to clip?*/","-10.     }
-9.     for ( ixmax = nx - 1; ixmax > 0 && x[ixmax - 1] > xmax; ixmax-- )
-8.     {
-7.     }
-6.     for ( iymin = 0; iymin < ny - 1 && y[iymin + 1] < ymin; iymin++ )
-5.     {
-4.     }
-3.     for ( iymax = ny - 1; iymax > 0 && y[iymax - 1] ",Not Useful
/*adjust the input so it stays within bounds*/,"-2.     if ( ixmin > 0 || ixmax < nx - 1 || iymin > 0 || iymax < ny - 1 )
-1.     {

/*adjust the input so it stays within bounds*/

1.         int _nx = ixmax - ixmin + 1;
2.         int _ny = iymax - iymin + 1;
3.         PLFLT ty0, ty1, tx0, tx1;
4.   ",Not Useful
/*allocate storage for new versions of the input vectors*/,"-9.         int _nx = ixmax - ixmin + 1;
-8.         int _ny = iymax - iymin + 1;
-7.         PLFLT ty0, ty1, tx0, tx1;
-6.         int j;
-5.         if ( _nx <= 1 || _ny <= 1 )
-4.         {
-3.             myabort( ""plot3dcl: selected x or y range has ",Not Useful
/*copy over the independent variables*/,"-7.         if ( ( ( _x = (PLFLT *) malloc( (size_t) _nx * sizeof ( PLFLT ) ) ) == NULL ) ||
-6.              ( ( _y = (PLFLT *) malloc( (size_t) _ny * sizeof ( PLFLT ) ) ) == NULL ) ||
-5.              ( ( _z = (PLFLT **) malloc( (size_t) _nx * sizeof ( ",Not Useful
/*Do not want to modify input x and y (const modifier)*/,"-4.         zp   = (PLPointer) _z;
-3.         getz = plf2ops_c()->get;
-2.         nx   = _nx;
-1.         ny   = _ny;

/*Do not want to modify input x and y (const modifier)*/

1.         x_modified = (PLFLT_VECTOR) _x;
2.         y_modified = (PLFLT_VE",Not Useful
"/*From here on must use x_modified and y_modified rather than
x and y.*/","-8.         x_modified = (PLFLT_VECTOR) _x;
-7.         y_modified = (PLFLT_VECTOR) _y;
-6.     }
-5.     else
-4.     {
-3.         x_modified = x;
-2.         y_modified = y;
-1.     }

/*From here on must use x_modified and y_modified rather than
x and",Not Useful
"/*next logic only knows opt = 1 | 2 | 3, make sure that it only gets that*/","-8.     {
-7.         if ( ( ctmp = (PLFLT *) malloc( (size_t) ( 2 * MAX( nx, ny ) ) * sizeof ( PLFLT ) ) ) == NULL )
-6.         {
-5.             plexit( ""c_plot3dcl: Insufficient memory"" );
-4.         }
-3.     }
-2.     else
-1.         ctmp = NULL;
",Not Useful
/*Allocate work arrays*/,"-1.     opt &= DRAW_LINEXY;

/*Allocate work arrays*/

1.     utmp = (PLINT *) malloc( (size_t) ( 2 * MAX( nx, ny ) ) * sizeof ( PLINT ) );
2.     vtmp = (PLINT *) malloc( (size_t) ( 2 * MAX( nx, ny ) ) * sizeof ( PLINT ) );
3.     if ( !utmp || !vtmp )
4",Not Useful
/*draw contour at the base. Not 100%! Why?*/,"-10.                 plt3zz( ix, 1, 1, 1, opt, &init, x_modified, y_modified, zops, zp, nx, ny, utmp, vtmp, ctmp );
-9.         }
-8.         if ( opt == DRAW_LINEY )
-7.             plt3zz( 1, 1, 1, 1, -opt, &init, x_modified, y_modified, zops, zp, nx, n",Not Useful
/*prepare cont_store input*/,"-10.     if ( clevel != NULL && opt & BASE_CONT )
-9.     {
-8. #define NPTS    100
-7.         int      np = NPTS;
-6.         PLFLT    **zstore;
-5.         PLcGrid2 cgrid2;
-4.         PLFLT    *zzloc = (PLFLT *) malloc( (size_t) NPTS * sizeof ( PLFLT ",Not Useful
/*Free the 2D input arrays to cont_store since not needed any more.*/,"-2.         cont_store( (PLFLT_MATRIX) zstore, nx, ny, indexxmin + 1, indexxmax, 1, ny,
-1.             clevel, nlevel, pltr2, (void *) &cgrid2, &cont );

/*Free the 2D input arrays to cont_store since not needed any more.*/

1.         plFree2dGrid( zsto",Not Useful
/*follow the contour levels and lines*/,"-3.         plFree2dGrid( zstore, nx, ny );
-2.         plFree2dGrid( cgrid2.xg, nx, ny );
-1.         plFree2dGrid( cgrid2.yg, nx, ny );

/*follow the contour levels and lines*/

1.         clev = cont;",Not Useful
/*there are several lines that make up each contour*/,"-2.         {
-1.             cline = clev->line;

/*there are several lines that make up each contour*/

1.             {
2.                 int cx, k, l, m, start, end;
3.                 PLFLT tx, ty;
4.                 if ( cline->npts > np )
5.      ",Not Useful
/*restart where it was left*/,"-2.                             cline->x[end] = cline->x[start];
-1.                             cline->y[end] = cline->y[start];

/*restart where it was left*/

1.                         }
2.                     } while ( j < cline->npts && i < cline->n",Not Useful
/*In case of numerical rounding*/,"-1.     cosangle = fabs( ( vlx * px + vly * py + vlz * pz ) / sqrt( mag1 * mag2 ) );

/*In case of numerical rounding*/

1.     if ( cosangle > 1 )
2.         cosangle = 1;
3.     return cosangle;
4. }",Not Useful
/*All the setup is done.  Time to do the work.*/,"-10.         {
-9.             x2d  = plP_w3wcx( x[x0 - 1], y[y0 - 1], getz( zp, x0 - 1, y0 - 1 ) );
-8.             y2d  = plP_w3wcy( x[x0 - 1], y[y0 - 1], getz( zp, x0 - 1, y0 - 1 ) );
-7.             u[n] = plP_wcpcx( x2d );
-6.             v[n] = plP_",Not Useful
/*allocate additional space*/,"-5. static void
-4. savehipoint( PLINT px, PLINT py )
-3. {
-2.     if ( pl3upv == 0 )
-1.         return;

/*allocate additional space*/

1.     {
2.         newhisize += 2 * BINC;
3.         newhiview  = (PLINT *) realloc( (void *) newhiview,
4.        ",Not Useful
/*allocate additional space*/,"-5. static void
-4. savehipoint( PLINT px, PLINT py )
-3. {
-2.     if ( pl3upv == 0 )
-1.         return;

/*allocate additional space*/

1.     {
2.         newhisize += 2 * BINC;
3.         newhiview  = (PLINT *) realloc( (void *) newhiview,
4.        ",Not Useful
/*Bottom axis.*/,"-10.                   ( vpwxma - tn ) / ( vpwxma - vpwxmi );
-9.             if ( plsc->if_boxbb )
-8.             {
-7.                 string_length_mm = plstrl( string );
-6.                 pos_mm           = ( plsc->vppxmi + pos *
-5.               ",Not Useful
/*Line pattern defaults*/,"-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Not Useful
/*PLPLOT_NONN not #defined or tested for more than a decade.*/,"-6. #include ""plplotP.h""
-5. #ifdef WITH_CSA
-4. #include ""../lib/csa/csa.h""
-3. #endif
-2. #ifdef PL_HAVE_QHULL
-1. #include ""../lib/nn/nn.h""

/*PLPLOT_NONN not #defined or tested for more than a decade.*/

111",Not Useful
"/*another DTLI, based only on QHULL, not nn*/","-7. #include ""plplotP.h""
-6. #ifdef WITH_CSA
-5. #include ""../lib/csa/csa.h""
-4. #endif
-3. #ifdef PL_HAVE_QHULL
-2. #include ""../lib/nn/nn.h""

/*another DTLI, based only on QHULL, not nn*/

1. #include <libqhull_r/qhull_ra.h>",Not Useful
/*#ifdef PLPLOT_NONN*/,"-7. #include ""plplotP.h""
-6. #ifdef WITH_CSA
-5. #include ""../lib/csa/csa.h""
-4. #endif
-3. #ifdef PL_HAVE_QHULL
-2. #include ""../lib/nn/nn.h""

/*#ifdef PLPLOT_NONN*/

1. #include <libqhull_r/qhull_ra.h>",Not Useful
/*#ifdef PL_HAVE_QHUL*/,"-4. #include ""plplotP.h""
-3. #ifdef WITH_CSA
-2. #include ""../lib/csa/csa.h""
-1. #endif
#ifdef PL_HAVE_QHULL

/*#ifdef PL_HAVE_QHUL*/

1. #include ""../lib/nn/nn.h""",Not Useful
/*WITH_CSA*/,"-10. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-9. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-8. // GNU Library General Public License for more details.
-7. //
-6. // You should have received a copy of the GN",Not Useful
/*make sure it is smaller that KNN_MAX_ORDER*/,"-9. static void
-8. grid_nnidw( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
-7.             PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy,
-6.             PLF2OPS zops, PLPointer zgp, int knn_order )
-5. {
-4.     int   i, j, k;
-3.",Not Useful
/*make d1 < d2*/,"-4.             {
-3.                 zops->set( zgp, i, j, NAN );
-2.                 continue;
-1.             }

/*make d1 < d2*/

1.             if ( d1 > d2 )
2.             {
3.                 t = d1; d1 = d2; d2 = t;
4.             }",Not Useful
/*and d2 < d3*/,"-4.             if ( d1 > d2 )
-3.             {
-2.                 t = d1; d1 = d2; d2 = t;
-1.             }

/*and d2 < d3*/

1.             if ( d2 > d3 )
2.             {
3.                 t = d2; d2 = d3; d3 = t;
4.             }",Not Useful
/*was found*/,"-10.     int   i, j, k;
-9.     for ( i = 0; i < nptsx; i++ )
-8.     {
-7.         for ( j = 0; j < nptsy; j++ )
-6.         {
-5.             dist2( xg[i], yg[j], x, y, npts );
-4.             zops->set( zgp, i, j, 0. );
-3.             nt = 0.;
-2.    ",Not Useful
/*1/square distance*/,"-1.                 {

/*1/square distance*/

1.                     zops->add( zgp, i, j, d * z[items[k].item] );
2.                     nt += d;
3.                 }
4.             }",Not Useful
/*PL_HAVE_QHULL*/,"-4. #include ""plplotP.h""
-3. #ifdef WITH_CSA
-2. #include ""../lib/csa/csa.h""
-1. #endif
#ifdef PL_HAVE_QHULL

/*PL_HAVE_QHULL*/

1. #include ""../lib/nn/nn.h""",Not Useful
/*easy way*/,"-10.     {
-9.         plexit( ""grid_adtli: Insufficient memory"" );
-8.     }
-7.     for ( i = 0; i < npts; i++ )
-6.     {
-5.         points[i * dim]     = x[i];
-4.         points[i * dim + 1] = y[i];
-3.     }
-2.     qhT context = { 0 };
-1.     qhT",Not Useful
/*if no error*/,"-10.     qh_init_A( stdin, stdout, stderr, 0, NULL );
-9.     exitcode = setjmp( qh errexit );
-8.     if ( !exitcode )
-7.     {
-6.         qh_initflags( flags );
-5.         qh PROJECTdelaunay = True;
-4.         qh_init_B( points, npts, dim, ismalloc ",Not Useful
/*qh_ALL*/,"-2.         printf( ""Neigbors\n"" );
-1.         qh_findgood_all( qh facet_list );
        qh_countfacets( qh facet_list, NULL, !qh_ALL, &numfacets, &numsimplicial,

/*qh_ALL*/

1.             &totneighbors, &numridges, &numcoplanars, &numtricoplanars );
2",Not Useful
/*and interpolate*/,"-5.             {
-4.                 A = yy[0] * ( zz[1] - zz[2] ) + yy[1] * ( zz[2] - zz[0] ) + yy[2] * ( zz[0] - zz[1] );
-3.                 B = zz[0] * ( xx[1] - xx[2] ) + zz[1] * ( xx[2] - xx[0] ) + zz[2] * ( xx[0] - xx[1] );
-2.                 C =",Not Useful
/*PLPLOT_NONN*/,"-6. #include ""plplotP.h""
-5. #ifdef WITH_CSA
-4. #include ""../lib/csa/csa.h""
-3. #endif
-2. #ifdef PL_HAVE_QHULL
-1. #include ""../lib/nn/nn.h""

/*PLPLOT_NONN*/

111",Not Useful
"/*! @file
!
! Part 1: Color map routines.
! Part 2: ""A grab-bag of various control routines"".
!*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Not Useful
/*dos386/djgpp*/,"-1. #endif

/*dos386/djgpp*/

1. #ifdef __unix
2. #undef __unix
3. #endif
4. #endif
5. #ifdef __unix
6. #include <sys/types.h>
7. #include <sys/stat.h>
8. #ifdef PL_HAVE_UNISTD_H
9. #include <unistd.h>
10. #endif",Not Useful
"/*small epsilon for fuzzy range checks that is still large enough to
work even in the single precision floating point case.*/","-5. #include ""mt19937ar.h""
-4. #define BUFFER_SIZE    256
-3. #define COLLEN         30
-2. #define PALLEN         160
-1. #define MSGLEN         1024

/*small epsilon for fuzzy range checks that is still large enough to
work even in the single precision ",Not Useful
/*Used by any external init code to suggest a path*/,"-1. #define FUZZ_EPSILON    1.e-4

/*Used by any external init code to suggest a path*/

1. char PLDLLIMPEXP * plplotLibDir = 0;",Not Useful
/*Anything else is assumed to be Unix*/,"-9. #if defined ( DJGPP )
-8. #ifndef PLLIBDEV
-7. #define PLLIBDEV    ""c:/plplot/lib""
-6. #endif
-5. #elif defined ( MSDOS )
-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""c:\\plplot\\lib""
-2. #endif
-1. #else

/*Anything else is assumed to be Unix*/

1. ",Not Useful
/*--------------------------------------------------------------------------*/,"-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

/*--------------------------------------------------------------------------*/

111",Not Useful
"/*Need these assignments so that r[i], g[i], and b[i] remain
unchanged as per their PLINT_VECTOR types.*/","-8. void
-7. c_plscmap0( PLINT_VECTOR r, PLINT_VECTOR g, PLINT_VECTOR b, PLINT ncol0 )
-6. {
-5.     int   i;
-4.     PLINT nc_r, nc_g, nc_b;
-3.     plscmap0n( ncol0 );
-2.     for ( i = 0; i < plsc->ncol0; i++ )
-1.     {

/*Need these assignments so th",Not Useful
"/*Need these assignments so that r[i], g[i], b[i], and
alpha[i] remain unchanged as per their PLINT_VECTOR and
PLFLT_VECTOR types.*/","-9. void
-8. c_plscmap0a( PLINT_VECTOR r, PLINT_VECTOR g, PLINT_VECTOR b, PLFLT_VECTOR alpha, PLINT ncol0 )
-7. {
-6.     int   i;
-5.     PLINT nc_r, nc_g, nc_b;
-4.     PLFLT nc_alpha;
-3.     plscmap0n( ncol0 );
-2.     for ( i = 0; i < plsc->ncol0; i+",Not Useful
"/*Need these assignments so that r[i], g[i], and b[i] remain
unchanged as per their PLINT_VECTOR PLINT_VECTOR types.*/","-8. void
-7. c_plscmap1( PLINT_VECTOR r, PLINT_VECTOR g, PLINT_VECTOR b, PLINT ncol1 )
-6. {
-5.     int   i;
-4.     PLINT nc_r, nc_g, nc_b;
-3.     plscmap1n( ncol1 );
-2.     for ( i = 0; i < plsc->ncol1; i++ )
-1.     {

/*Need these assignments so th",Not Useful
"/*Need these assignments so that r[i], g[i], b[i], and
alpha[i] remain unchanged as per their PLINT_VECTOR and
PLFLT_VECTOR types.*/","-9. void
-8. c_plscmap0a( PLINT_VECTOR r, PLINT_VECTOR g, PLINT_VECTOR b, PLFLT_VECTOR alpha, PLINT ncol0 )
-7. {
-6.     int   i;
-5.     PLINT nc_r, nc_g, nc_b;
-4.     PLFLT nc_alpha;
-3.     plscmap0n( ncol0 );
-2.     for ( i = 0; i < plsc->ncol0; i+",Not Useful
/*Allocate if not done yet*/,"-10.     if ( ( intensity[0] != MIN_PLFLT_CMAP1 ) || ( intensity[npts - 1] != MAX_PLFLT_CMAP1 ) )
-9.     {
-8.         plabort( ""plscmap1l: First and last control points must correspond to minimum and maximum cmap1 color index"" );
-7.         return;
-6.",Not Useful
"/*Note final element is unused, so we set to zero for completeness.*/","-10.         plsc->cmap1cp[n].c1 = coord1[n];
-9.         plsc->cmap1cp[n].c2 = coord2[n];
-8.         plsc->cmap1cp[n].c3 = coord3[n];
-7.         plsc->cmap1cp[n].p  = intensity[n];
-6.         plsc->cmap1cp[n].a  = MAX_PLFLT_ALPHA;
-5.         if ( alt",Not Useful
/*Allocate if not done yet*/,"-10.     if ( ( intensity[0] != MIN_PLFLT_CMAP1 ) || ( intensity[npts - 1] != MAX_PLFLT_CMAP1 ) )
-9.     {
-8.         plabort( ""plscmap1l: First and last control points must correspond to minimum and maximum cmap1 color index"" );
-7.         return;
-6.",Not Useful
"/*Note final element is unused, so we set to zero for completeness.*/","-10.         plsc->cmap1cp[n].c1 = coord1[n];
-9.         plsc->cmap1cp[n].c2 = coord2[n];
-8.         plsc->cmap1cp[n].c3 = coord3[n];
-7.         plsc->cmap1cp[n].p  = intensity[n];
-6.         plsc->cmap1cp[n].a  = MAX_PLFLT_ALPHA;
-5.         if ( alt",Not Useful
"/*Adjust dh if we are to go around ""the back side""*/","-5.             dp = plsc->cmap1cp[n + 1].p - plsc->cmap1cp[n].p;
-4.             dh = plsc->cmap1cp[n + 1].c1 - plsc->cmap1cp[n].c1;
-3.             dl = plsc->cmap1cp[n + 1].c2 - plsc->cmap1cp[n].c2;
-2.             ds = plsc->cmap1cp[n + 1].c3 - plsc->",Not Useful
/*No change*/,"-4. void
-3. c_plscmap0n( PLINT ncol0 )
-2. {
-1.     int ncol, size, imin, imax;

/*No change*/

1.     if ( ncol0 > 0 && plsc->ncol0 == ncol0 )
2.         return;",Not Useful
/*Allocate the space*/,"-8.     if ( plsc->ncol0 <= 0 && ncol0 <= 0 )
-7.         ncol = PL_DEFAULT_NCOL0;
-6.     else if ( ncol0 <= 0 )
-5.         ncol = plsc->ncol0;
-4.     else
-3.         ncol = ncol0;
-2.     imax = ncol - 1;
-1.     size = ncol * (int) sizeof ( PLColor ",Not Useful
/*Fill in default entries*/,"-10.         imin = 0;
-9.     }
-8.     else
-7.     {
-6.         if ( ( plsc->cmap0 = (PLColor *) realloc( plsc->cmap0, (size_t) size ) ) == NULL )
-5.         {
-4.             plexit( ""c_plscmap0n: Insufficient memory"" );
-3.         }
-2.         im",Not Useful
/*No change*/,"-4. void
-3. c_plscmap0n( PLINT ncol0 )
-2. {
-1.     int ncol, size, imin, imax;

/*No change*/

1.     if ( ncol0 > 0 && plsc->ncol0 == ncol0 )
2.         return;",Not Useful
/*Handle all possible startup conditions*/,"-2.     if ( ncol0 > 0 && plsc->ncol0 == ncol0 )
-1.         return;

/*Handle all possible startup conditions*/

1.     if ( plsc->ncol0 <= 0 && ncol0 <= 0 )
2.         ncol = PL_DEFAULT_NCOL0;
3.     else if ( ncol0 <= 0 )
4.         ncol = plsc->ncol0;",Not Useful
/*Allocate the space*/,"-8.     if ( plsc->ncol0 <= 0 && ncol0 <= 0 )
-7.         ncol = PL_DEFAULT_NCOL0;
-6.     else if ( ncol0 <= 0 )
-5.         ncol = plsc->ncol0;
-4.     else
-3.         ncol = ncol0;
-2.     imax = ncol - 1;
-1.     size = ncol * (int) sizeof ( PLColor ",Not Useful
/*Fill in default entries*/,"-10.         imin = 0;
-9.     }
-8.     else
-7.     {
-6.         if ( ( plsc->cmap0 = (PLColor *) realloc( plsc->cmap0, (size_t) size ) ) == NULL )
-5.         {
-4.             plexit( ""c_plscmap0n: Insufficient memory"" );
-3.         }
-2.         im",Not Useful
/*high*/,"-10. //! intensity.  Any number of control points may be specified, located at
-9. //! arbitrary positions (intensities), although typically 2 - 4 are enough.
-8. //! Another way of stating this is that we are traversing a given number of
-7. //! lines th",Not Useful
/*Read the string*/,"-4. static char *
-3. read_line( char *buffer, int length, FILE *fp )
-2. {
-1.     char *pchr;

/*Read the string*/

1.     if ( fgets( buffer, length, fp ) == NULL )
2.     {
3.         return NULL;
4.     }",Not Useful
"/*Sanitize the string we read - it may contain EOL characters
Make sure file reading starts at the next line*/","-4.     if ( fgets( buffer, length, fp ) == NULL )
-3.     {
-2.         return NULL;
-1.     }

/*Sanitize the string we read - it may contain EOL characters
Make sure file reading starts at the next line*/

1.     pchr = strchr( buffer, '\n' );
2.     i",Not Useful
/*Remove trailing blanks*/,"-10.         if ( fscanf( fp, ""%*[^\n]\n"" ) == EOF && ferror( fp ) )
-9.         {
-8.             return NULL;
-7.         }
-6.     }
-5.     pchr = strchr( buffer, '\r' );
-4.     if ( pchr != NULL )
-3.     {
-2.         *pchr = '\0';
-1.     }

/*Rem",Not Useful
/*Check for new file format*/,"-10.     else
-9.     {
-8.         fp = plLibOpen( filename );
-7.         if ( fp == NULL )
-6.         {
-5.             snprintf( msgbuf, MSGLEN, ""Unable to open cmap1 .pal file %s\n"", filename );
-4.             plwarn( msgbuf );
-3.             goto",Not Useful
/*Old tk file format*/,"-10.     b            = (PLFLT *) malloc( (size_t) number_colors * sizeof ( PLFLT ) );
-9.     ri           = (PLINT *) malloc( (size_t) number_colors * sizeof ( PLINT ) );
-8.     gi           = (PLINT *) malloc( (size_t) number_colors * sizeof ( PLINT )",Not Useful
/*Ensure string is null terminated if > 160 characters*/,"-9.         for ( i = 0; i < number_colors; i++ )
-8.         {
-7.             if ( read_line( color_info, PALLEN, fp ) == NULL )
-6.             {
-5.                 snprintf( msgbuf, MSGLEN, ""Error reading cmap1 .pal file %s\n"", filename );
-4.       ",Not Useful
/*what IS set?*/,"-6. #if defined ( PLPLOT_BIN_ENV )
-5.     if ( ( dn = getenv( PLPLOT_BIN_ENV ) ) != NULL )
-4.     {
-3.         plGetName( dn, """", fn, &fs );
-2.         if ( !plFindName( fs ) )
-1.             return fs;

/*what IS set?*/

1.     }",Not Useful
/*PLPLOT_BIN_ENV*/,"-10.         plP_esc( op, ptr );
-9. }

/*PLPLOT_BIN_ENV*/

111",Not Useful
/*Current directory*/,"-2.     }

/*Current directory*/

1.     plGetName( ""."", """", fn, &fs );
2.     if ( !plFindName( fs ) )
3.         return fs;",Not Useful
/*what IS set?*/,"-6. #if defined ( PLPLOT_BIN_ENV )
-5.     if ( ( dn = getenv( PLPLOT_BIN_ENV ) ) != NULL )
-4.     {
-3.         plGetName( dn, """", fn, &fs );
-2.         if ( !plFindName( fs ) )
-1.             return fs;

/*what IS set?*/

1.     }",Not Useful
/*PLPLOT_HOME_ENV*/,"-10. //--------------------------------------------------------------------------
-9. // char *plFindCommand
-8. //
-7. //! Looks for the specified executable file.  Search path:
-6. //!      if command invoked in the build tree:
-5. //!         build_tre",Not Useful
/*BIN_DIR*/,"-10. // char *plFindCommand
-9. //
-8. //! Looks for the specified executable file.  Search path:
-7. //!      if command invoked in the build tree:
-6. //!         build_tree/tk (plserver lies there - needed for the tk driver)
-5. //!         source_tree",Not Useful
/*Crapped out*/,"-5. #if defined ( BIN_DIR )
-4.     plGetName( BIN_DIR, """", fn, &fs );
-3.     if ( !plFindName( fs ) )
-2.         return fs;
-1. #endif

/*Crapped out*/

1.     free_mem( fs );
2.     fprintf( stderr, ""plFindCommand: cannot locate command: %s\n"", fn );
",Not Useful
/*what WAS set?*/,"-3.     free_mem( fs );
-2.     fprintf( stderr, ""plFindCommand: cannot locate command: %s\n"", fn );
-1. #if defined ( BIN_DIR )

/*what WAS set?*/

111",Not Useful
/*BIN_DIR*/,"-10. // char *plFindCommand
-9. //
-8. //! Looks for the specified executable file.  Search path:
-7. //!      if command invoked in the build tree:
-6. //!         build_tree/tk (plserver lies there - needed for the tk driver)
-5. //!         source_tree",Not Useful
"/****	search PLPLOT_LIB_ENV = ","1. #if defined ( PLPLOT_LIB_ENV )
2.     if ( ( dn = getenv( PLPLOT_LIB_ENV ) ) != NULL )
3.     {
4.         plGetName( dn, """", fn, &fs );
5.         if ( ( file = pdf_fopen( fs, ""rb"" ) ) != NULL )
6.             goto done;",Not Useful
/*what IS set?*/,"-6. #if defined ( PLPLOT_BIN_ENV )
-5.     if ( ( dn = getenv( PLPLOT_BIN_ENV ) ) != NULL )
-4.     {
-3.         plGetName( dn, """", fn, &fs );
-2.         if ( !plFindName( fs ) )
-1.             return fs;

/*what IS set?*/

1.     }",Not Useful
/*PLPLOT_LIB_ENV*/,"-7.     return NULL;
-6. }

/*PLPLOT_LIB_ENV*/

111",Not Useful
"/****	search current directory	****/","-2.     }

/****	search current directory	****/

1.     if ( ( file = pdf_fopen( fn, ""rb"" ) ) != NULL )
2.     {
3.         pldebug( ""plLibOpenPdfstr"", ""Found file %s in current directory.\n"", fn );
4.         free_mem( fs );
5.         return ( file );
6",Not Useful
"/****	search PLPLOT_HOME_ENV/lib = ","1. #if defined ( PLPLOT_HOME_ENV )
2.     if ( ( dn = getenv( PLPLOT_HOME_ENV ) ) != NULL )
3.     {
4.         plGetName( dn, ""lib"", fn, &fs );
5.         if ( ( file = pdf_fopen( fs, ""rb"" ) ) != NULL )
6.             goto done;",Not Useful
/*what IS set?*/,"-6. #if defined ( PLPLOT_BIN_ENV )
-5.     if ( ( dn = getenv( PLPLOT_BIN_ENV ) ) != NULL )
-4.     {
-3.         plGetName( dn, """", fn, &fs );
-2.         if ( !plFindName( fs ) )
-1.             return fs;

/*what IS set?*/

1.     }",Not Useful
/*PLPLOT_HOME_ENV/lib*/,"-9.     return NULL;
-8. }

/*PLPLOT_HOME_ENV/lib*/

111",Not Useful
"/****   search installed location	****/","-2.     }

/****   search installed location	****/

1. #if defined ( DATA_DIR )
2.     plGetName( DATA_DIR, """", fn, &fs );
3.     if ( ( file = pdf_fopen( fs, ""rb"" ) ) != NULL )
4.         goto done;",Not Useful
/*DATA_DIR*/,"-10.     return NULL;
-9. }

/*DATA_DIR*/

111",Not Useful
"/****   search hardwired location	****/","-5. #if defined ( DATA_DIR )
-4.     plGetName( DATA_DIR, """", fn, &fs );
-3.     if ( ( file = pdf_fopen( fs, ""rb"" ) ) != NULL )
-2.         goto done;

/****   search hardwired location	****/

1. #ifdef PLLIBDEV
2.     plGetName( PLLIBDEV, """", fn, &fs );",Not Useful
/*PLLIBDEV*/,"-1. #if defined ( DJGPP )
#ifndef PLLIBDEV

/*PLLIBDEV*/

1. #define PLLIBDEV    ""c:/plplot/lib""
2. #endif
3. #elif defined ( MSDOS )
4. #ifndef PLLIBDEV
5. #define PLLIBDEV    ""c:\\plplot\\lib""
6. #endif
7. #else",Not Useful
/*macintosh*/,"-10. //
-9. //
-8. //! @file
-7. //!
-6. //! Part 1: Color map routines.
-5. //! Part 2: ""A grab-bag of various control routines"".
-4. //!
-3. #define DEBUG
-2. #define NEED_PLDEBUG
-1. #include ""plplotP.h""
#ifdef macintosh

/*macintosh*/

1. #include ""ma",Not Useful
"/****   not found, give up      ****/","-6.     if ( plplotLibDir != NULL )
-5.     {
-4.         plGetName( plplotLibDir, """", fn, &fs );
-3.         if ( ( file = pdf_fopen( fs, ""rb"" ) ) != NULL )
-2.             goto done;
-1.     }

/****   not found, give up      ****/

1.     pldebug( ""plL",Not Useful
/*Link is an absolute path*/,"-10. {
-9.     ssize_t     n;
-8.     char        buf[PLPLOT_MAX_PATH], *cp;
-7.     struct stat sbuf;
-6.     pldebug( ""plFindName"", ""Trying to find %s\n"", p );
-5.     while ( ( n = readlink( p, buf, PLPLOT_MAX_PATH ) ) > 0 )
-4.     {
-3.         pldeb",Not Useful
/*Link is relative to its directory; make it absolute*/,"-6.             strncpy( p, buf, (size_t) n );
-5.             p[n] = '\0';
-4.             pldebug( ""plFindName"", ""Link is absolute: %s\n"", p );
-3.         }
-2.         else
-1.         {

/*Link is relative to its directory; make it absolute*/

1.    ",Not Useful
/*This macro not defined on the NEC SX-3*/,"-7.             cp = 1 + strrchr( p, '/' );
-6.             strncpy( cp, buf, (size_t) n );
-5.             cp[n] = '\0';
-4.             pldebug( ""plFindName"",
-3.                 ""Link is relative: %s\n\tTotal path:%s\n"", cp, p );
-2.         }
-1.     ",Not Useful
/*SGI machines return ENXIO instead of EINVAL Dubois 11/92*/,"-3. #ifdef SX
-2. #define S_ISREG( mode )    ( mode & S_IFREG )
-1. #endif

/*SGI machines return ENXIO instead of EINVAL Dubois 11/92*/

1.     if ( errno == EINVAL || errno == ENXIO )
2.     {
3.         pldebug( ""plFindName"", ""%s may be the one...\n"", ",Not Useful
"/*According to http://msdn.microsoft.com/en-us/library/vstudio/tcxf1dw6.aspx
and also Wine tests, Microsoft does not support the c99 standard %zu
format.  Instead, %lu is recommended for size_t.*/","-10.     {
-9.         strcat_delim( *filespec );
-8.         strcat( *filespec, subdir );
-7.     }
-6.     if ( *filename != '\0' )
-5.     {
-4.         strcat_delim( *filespec );
-3.         strcat( *filespec, filename );
-2.     }
-1. #ifdef _WIN32

",Not Useful
/*unix is the default*/,"-10. static void
-9. strcat_delim( char *dirspec )
-8. {
-7.     size_t ldirspec = strlen( dirspec );
-6. #if defined ( MSDOS ) || defined ( _WIN32 )
-5.     if ( dirspec[ldirspec - 1] != '\\' )
-4.         strcat( dirspec, ""\\"" );
-3. #elif defined ( mac",Not Useful
/*Prompt if filename still not known*/,"-2.         if ( pls->family && pls->BaseName != NULL )
-1.             plP_getmember( pls );

/*Prompt if filename still not known*/

1.         if ( pls->FileName == NULL )
2.         {
3.             do
4.             {
5.                 fprintf( stdo",Not Useful
/*count zero entries*/,"-10.         if ( pls->FileName == NULL )
-9.         {
-8.             do
-7.             {
-6.                 fprintf( stdout, ""Enter graphics output file name: "" );
-5.                 plio_fgets( line, sizeof ( line ), stdin );
-4.                 le",Not Useful
"/*Restore page status (normally AT_BOP) that was changed
to AT_EOP by plP_init.*/","-10.     PLFLT xpmm_loc, ypmm_loc;
-9.     if ( pls->family )
-8.     {
-7.         if ( pls->bytecnt > pls->bytemax || pls->famadv )
-6.         {
-5.             PLINT local_page_status = pls->page_status;
-4.             plP_tidy();
-3.             pls",Not Useful
/*do nothing*/,"-10.         break;
-9.     case 2:
-8.         *px = xmin + ( xmax - x );
-7.         *py = ymin + ( ymax - y );
-6.         break;
-5.     case 3:
-4.         *px = xmin + ( ymax - y );
-3.         *py = ymin + ( x - xmin );
-2.         break;
-1.     d",Not Useful
/*Check if overrun occured*/,"-8. int
-7. plsnprintf( char *buffer, int n, PLCHAR_VECTOR format, ... )
-6. {
-5.     int     ret;
-4.     va_list args;
-3.     va_start( args, format );
-2.     ret = vsprintf( buffer, format, args );
-1.     va_end( args );

/*Check if overrun occured",Not Useful
/*PL_HAVE_SNPRINTF*/,"-10. char PLDLLIMPEXP *
-9. plstrdup( PLCHAR_VECTOR src )
-8. {
-7.     char *dest = (char *) malloc( ( strlen( src ) + 1 ) * sizeof ( char ) );
-6.     if ( dest != NULL )
-5.         strcpy( dest, src );
-4.     else
-3.         plabort( ""Out of memory""",Not Useful
"/*This is used when looping through the image array, checking to
make sure the values are within an acceptable range.*/","-1.     PLFLT *z;

/*This is used when looping through the image array, checking to
make sure the values are within an acceptable range.*/

1.     PLFLT datum;",Not Useful
"/*Go through the image values and scale them to fit in
the COLOR_MIN to COLOR_MAX range.
Any values greater than valuemax are set to valuemax,
and values less than valuemin are set to valuemin.
Any values outside of zmin to zmax are flagged so they
are not plotted.*/","-3.     color_min   = plsc->cmap1_min;
-2.     color_max   = plsc->cmap1_max;
-1.     color_range = color_max - color_min;

/*Go through the image values and scale them to fit in
the COLOR_MIN to COLOR_MAX range.
Any values greater than valuemax are set t",Not Useful
"/*printf(""plvect: %f %f %f %f %f %f %f\n"",scale, x,0.5*uu, y,0.5*vv, xt, yt);*/","-10.     if ( ( ( a_x = (PLINT *) malloc( sizeof ( PLINT ) * (size_t) ( plsc->arrow_npts ) ) ) == NULL ) ||
-9.          ( ( a_y = (PLINT *) malloc( sizeof ( PLINT ) * (size_t) ( plsc->arrow_npts ) ) ) == NULL ) )
-8.     {
-7.         plexit( ""plP_plotve",Not Useful
"/*If pltr is undefined, abort with an error.*/","-9. void plfvect( PLF2EVAL_callback getuv, PLPointer up, PLPointer vp,
-8.               PLINT nx, PLINT ny, PLFLT scale,
-7.               PLTRANSFORM_callback pltr, PLPointer pltr_data )
-6. {
-5.     PLINT i, j, i1, j1;
-4.     PLFLT **u, **v, **x, **y",Not Useful
"/*--------------------------------------------------------------------------
plMergeOpts()

! Merge user option table info structure with internal one.
!
! @param options ?
! @param name ?
! @param notes ?
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Not Useful
/*Check to make sure option table has been terminated correctly*/,"-5. PLINT
-4. plMergeOpts( PLOptionTable *options, PLCHAR_VECTOR name, PLCHAR_VECTOR *notes )
-3. {
-2.     PLOptionTable *tab;
-1.     pllib_init();

/*Check to make sure option table has been terminated correctly*/

1.     for ( tab = (PLOptionTable *) ",Not Useful
/*We've reached the last table entry.  All the subentries must be NULL or 0*/,"-2.     for ( tab = (PLOptionTable *) options; tab->opt; tab++ )
-1.         ;

/*We've reached the last table entry.  All the subentries must be NULL or 0*/

1.     if ( ( tab->handler != NULL ) ||
2.          ( tab->client_data != NULL ) ||
3.          ",Not Useful
/*No room for more tables*/,"-10.     if ( ( tab->handler != NULL ) ||
-9.          ( tab->client_data != NULL ) ||
-8.          ( tab->var != NULL ) ||
-7.          ( tab->mode != 0 ) ||
-6.          ( tab->syntax != NULL ) ||
-5.          ( tab->desc != NULL ) )
-4.     {
-3.      ",Not Useful
"/*If program name is first argument, save and advance*/","-9.     mode_full      = mode & PL_PARSE_FULL;
-8.     mode_quiet     = mode & PL_PARSE_QUIET;
-7.     mode_nodelete  = mode & PL_PARSE_NODELETE;
-6.     mode_showall   = mode & PL_PARSE_SHOWALL;
-5.     mode_noprogram = mode & PL_PARSE_NOPROGRAM;
-4.    ",Not Useful
/*Process the command line*/,"-6.         plsc->program = plstrdup( argv[0] );
-5.         program       = (PLCHAR_VECTOR) plsc->program;
-4.         --myargc; ++argv;
-3.     }
-2.     if ( myargc == 0 )
-1.         return 0;

/*Process the command line*/

111",Not Useful
"/*Special hack to deal with -debug option before
pllib_init() is called.*/","-7.         plsc->program = plstrdup( argv[0] );
-6.         program       = (PLCHAR_VECTOR) plsc->program;
-5.         --myargc; ++argv;
-4.     }
-3.     if ( myargc == 0 )
-2.         return 0;

/*Special hack to deal with -debug option before
pllib_in",Not Useful
"/*Allow for ""holes"" in argv list*/","-4.     argsave    = argv;
-3.     myargcsave = myargc;
-2.     for (; myargc > 0; --myargc, ++argv )
-1.     {

/*Allow for ""holes"" in argv list*/

1.         if ( *argv == NULL || *argv[0] == '\0' )
2.             continue;
3.         if ( ( !mode_nodas",Not Useful
"/*fprintf(stderr, ""Found debug option in argv\n"");
Loop over all options tables, starting with the last*/","-4.         if ( *argv == NULL || *argv[0] == '\0' )
-3.             continue;
-2.         if ( ( !mode_nodash && !strcmp( *argv, ""-debug"" ) ) || ( mode_nodash && !strcmp( *argv, ""debug"" ) ) )
-1.         {

/*fprintf(stderr, ""Found debug option in argv\n",Not Useful
/*Check option table for option*/,"-2.             for ( i = tables - 1; i >= 0; i-- )
-1.             {

/*Check option table for option*/

1.                 status = ParseOpt( &myargc, &argv, p_argc, &argsave,
2.                     ploption_info[i].options );
3.                 if ( !s",Not Useful
"/*Restore pointers to condition before the above loop
Although array length and content stored in those pointers
is likely changed.*/","-8.                 status = ParseOpt( &myargc, &argv, p_argc, &argsave,
-7.                     ploption_info[i].options );
-6.                 if ( !status )
-5.                     break;
-4.             }
-3.             break;
-2.         }
-1.     }",Not Useful
"/*Allow for ""holes"" in argv list*/","-4.     argsave    = argv;
-3.     myargcsave = myargc;
-2.     for (; myargc > 0; --myargc, ++argv )
-1.     {

/*Allow for ""holes"" in argv list*/

1.         if ( *argv == NULL || *argv[0] == '\0' )
2.             continue;
3.         if ( ( !mode_nodas",Not Useful
"/*Loop over all options tables, starting with the last*/","-5.         if ( *argv == NULL || *argv[0] == '\0' )
-4.             continue;
-3.         if ( ( !mode_nodash && !strcmp( *argv, ""-debug"" ) ) || ( mode_nodash && !strcmp( *argv, ""debug"" ) ) )
-2.         {

/*Loop over all options tables, starting with t",Not Useful
/*Handle error return as specified by the mode flag*/,"-5.             status = ParseOpt( &myargc, &argv, p_argc, &argsave,
-4.                 ploption_info[i].options );
-3.             if ( !status )
-2.                 break;
-1.         }

/*Handle error return as specified by the mode flag*/

1.        ",Not Useful
/*Illegal or badly formed*/,"-10.             {
-9.                 fprintf( stderr, ""\nBad command line option \""%s\""\n"", argv[0] );
-8.                 plOptUsage();
-7.             }
-6.             if ( mode_full )
-5.                 exit( 1 );
-4.             break;
-3.        ",Not Useful
/*Only handle actual flags and their arguments*/,"-6. static int
-5. ParseOpt( int *p_myargc, char ***p_argv, int *p_argc, char ***p_argsave,
-4.           PLOptionTable *option_table )
-3. {
-2.     PLOptionTable *tab;
-1.     char          *opt;

/*Only handle actual flags and their arguments*/

1.    ",Not Useful
/*Skip if option not enabled*/,"-7.     if ( mode_nodash || ( *p_argv )[0][0] == '-' )
-6.     {
-5.         opt = ( *p_argv )[0];
-4.         if ( *opt == '-' )
-3.             opt++;
-2.         for ( tab = option_table; tab->opt; tab++ )
-1.         {

/*Skip if option not enabled*/
",Not Useful
/*Try to match it*/,"-2.             if ( tab->mode & PL_OPT_DISABLED )
-1.                 continue;

/*Try to match it*/

1.             if ( *opt == *tab->opt && !strcmp( opt, tab->opt ) )
2.             {",Not Useful
"/*Option matched, so remove from argv list if applicable.*/","-2.             if ( *opt == *tab->opt && !strcmp( opt, tab->opt ) )
-1.             {

/*Option matched, so remove from argv list if applicable.*/

1.                 if ( !mode_nodelete )
2.                 {
3.                     if ( tab->mode & PL_O",Not Useful
/*Process option (and argument if applicable)*/,"-7.                 if ( !mode_nodelete )
-6.                 {
-5.                     if ( tab->mode & PL_OPT_NODELETE )
-4.                         ( *( *p_argsave )++ ) = ( **p_argv );
-3.                     else
-2.                         --( *p_ar",Not Useful
/*Get option argument if necessary*/,"-6. static int
-5. ProcessOpt( char * opt, PLOptionTable *tab, int *p_myargc, char ***p_argv,
-4.             int *p_argc )
-3. {
-2.     int  need_arg, res;
-1.     char *opt_arg = NULL;

/*Get option argument if necessary*/

1.     need_arg = PL_OPT_ARG",Not Useful
/*Process argument*/,"-6.     need_arg = PL_OPT_ARG | PL_OPT_INT | PL_OPT_FLOAT | PL_OPT_STRING;
-5.     if ( tab->mode & need_arg )
-4.     {
-3.         if ( GetOptarg( &opt_arg, p_myargc, p_argv, p_argc ) )
-2.             return 1;
-1.     }

/*Process argument*/

1.     s",Not Useful
/*Call function handler to do the job*/,"-3.     switch ( tab->mode & 0xFF00 )
-2.     {
-1.     case PL_OPT_FUNC:

/*Call function handler to do the job*/

1.         if ( tab->handler == NULL )
2.         {
3.             fprintf( stderr,
4.                 ""ProcessOpt: no handler specified fo",Not Useful
"/*Make a copy, since handler may mung opt_arg with strtok()*/","-9.         if ( tab->handler == NULL )
-8.         {
-7.             fprintf( stderr,
-6.                 ""ProcessOpt: no handler specified for option %s\n"",
-5.                 tab->opt );
-4.             return 1;
-3.         }
-2.         if ( mode_no",Not Useful
/*Set *var as a boolean*/,"-10.             strcpy( copy, opt_arg );
-9.             res = ( ( *tab->handler )( opt, copy, tab->client_data ) );
-8.             free( (void *) copy );
-7.             return res;
-6.         }
-5.         else
-4.         {
-3.             return ( ",Not Useful
/*Set *var as an int*/,"-10.         if ( tab->var == NULL )
-9.         {
-8.             fprintf( stderr,
-7.                 ""ProcessOpt: no variable specified for option %s\n"",
-6.                 tab->opt );
-5.             return 1;
-4.         }
-3.         *(int *) tab->",Not Useful
/*Set *var as a float*/,"-10.         if ( tab->var == NULL )
-9.         {
-8.             fprintf( stderr,
-7.                 ""ProcessOpt: no variable specified for option %s\n"",
-6.                 tab->opt );
-5.             return 1;
-4.         }
-3.         *(int *) tab->",Not Useful
/*Set var (can be NULL initially) to point to opt_arg string*/,"-10.         if ( tab->var == NULL )
-9.         {
-8.             fprintf( stderr,
-7.                 ""ProcessOpt: no variable specified for option %s\n"",
-6.                 tab->opt );
-5.             return 1;
-4.         }
-3.         *(PLFLT *) tab",Not Useful
/*Somebody messed up..*/,"-3.         *(char **) tab->var = opt_arg;
-2.         break;
-1.     default:

/*Somebody messed up..*/

1.         fprintf( stderr,
2.             ""ProcessOpt: invalid processing mode for option %s\n"",
3.             tab->opt );
4.         return 1;
5. ",Not Useful
"/*--------------------------------------------------------------------------
GetOptarg()

! Retrieves an option argument.
! If an error occurs here it is a true syntax error.
!
! @param popt_arg ?
! @param p_myargc ?
! @param p_argv ?
! @param p_argc pointer to a value that ONLY keeps track of number of arguments after processing.
!
! @returns 0 if successful.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Not Useful
"/*oops, no more arguments*/","-5. static int
-4. GetOptarg( char **popt_arg, int *p_myargc, char ***p_argv, int *p_argc )
-3. {
-2.     int result = 0;
-1.     --( *p_myargc );

/*oops, no more arguments*/

1.         result = 1;
2.     if ( !result )
3.     {
4.         ( *p_argv )++",Not Useful
"/*oops, next arg is a flag*/","-2.         if ( strstr( ( ( *p_argv ) - 1 )[0], ""-bg"" ) != ( ( *p_argv ) - 1 )[0] && ( *p_argv )[0][0] == '-' && isalpha( ( *p_argv )[0][1] ) )
-1.         {

/*oops, next arg is a flag*/

1.             result = 1;
2.         }
3.     }",Not Useful
"/*yeah, the user got it right*/","-3.             result = 1;
-2.         }
-1.     }

/*yeah, the user got it right*/

1.     {
2.         if ( !mode_nodelete )
3.             ( *p_argc )--;
4.         *popt_arg = ( *p_argv )[0];
5.     }
6.     else
7.     {
8.         if ( !mode_quiet ",Not Useful
"/*--------------------------------------------------------------------------
plSetUsage()

! Set the strings used in usage and syntax messages.
!
! @param program_string The program name.
! @param usage_string String describing how to use the program.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Not Useful
/*Introducer*/,"-2.     for ( i = tables - 1; i >= 0; i-- )
-1.     {

/*Introducer*/

1.         if ( ploption_info[i].name )
2.             fprintf( stderr, ""\n%s:"", ploption_info[i].name );
3.         else
4.             fputs( ""\nUser options:"", stderr );",Not Useful
/*Print syntax for each option*/,"-4.         if ( ploption_info[i].name )
-3.             fprintf( stderr, ""\n%s:"", ploption_info[i].name );
-2.         else
-1.             fputs( ""\nUser options:"", stderr );

/*Print syntax for each option*/

1.         col = 80;
2.         for ( tab =",Not Useful
/*space [ string ]*/,"-9.         col = 80;
-8.         for ( tab = ploption_info[i].options; tab->opt; tab++ )
-7.         {
-6.             if ( tab->mode & PL_OPT_DISABLED )
-5.                 continue;
-4.             if ( !mode_showall && ( tab->mode & PL_OPT_INVISIBLE )",Not Useful
/*3 spaces*/,"-2.             if ( col + len > 79 )
-1.             {

/*3 spaces*/

1.                 col = 3;
2.             }
3.             fprintf( stderr, "" [%s]"", tab->syntax );
4.             col += len;
5.         }
6.         fprintf( stderr, ""\n"" );
7.     ",Not Useful
/*Loop over all options tables*/,"-5.         if ( *argv == NULL || *argv[0] == '\0' )
-4.             continue;
-3.         if ( ( !mode_nodash && !strcmp( *argv, ""-debug"" ) ) || ( mode_nodash && !strcmp( *argv, ""debug"" ) ) )
-2.         {

/*Loop over all options tables*/

1.           ",Not Useful
/*Introducer*/,"-2.     for ( i = tables - 1; i >= 0; i-- )
-1.     {

/*Introducer*/

1.         if ( ploption_info[i].name )
2.             fprintf( stderr, ""\n%s:"", ploption_info[i].name );
3.         else
4.             fputs( ""\nUser options:"", stderr );",Not Useful
/*Print description for each option*/,"-4.         if ( ploption_info[i].name )
-3.             fprintf( outfile, ""\n%s:\n"", ploption_info[i].name );
-2.         else
-1.             fputs( ""\nUser options:\n"", outfile );

/*Print description for each option*/

1.         for ( tab = ploption_",Not Useful
/*Usage notes*/,"-10.                 continue;
-9.             if ( !mode_showall && ( tab->mode & PL_OPT_INVISIBLE ) )
-8.                 continue;
-7.             if ( tab->desc == NULL )
-6.                 continue;
-5.             if ( tab->mode & PL_OPT_INVISIBLE ",Not Useful
"/*Strip off leading ""#"" (TK-ism) if present.*/","-10. static int
-9. opt_bg( PLCHAR_VECTOR PL_UNUSED( opt ), PLCHAR_VECTOR opt_arg, void * PL_UNUSED( client_data ) )
-8. {
-7.     PLCHAR_VECTOR rgb;
-6.     char          *color_field, *color_field_wp, *color_field_wp_alt, *alpha_field;
-5.     char     ",Not Useful
"/*fprintf( stderr, ""-bg option = %s\n"", opttmp );*/","-6.     if ( *opt_arg == '#' )
-5.         rgb = opt_arg + 1;
-4.     else
-3.         rgb = opt_arg;
-2.     strncpy( opttmp, rgb, OPTMAX - 1 );
-1.     opttmp[OPTMAX - 1] = '\0';

/*fprintf( stderr, ""-bg option = %s\n"", opttmp );*/

1.     color_field =",Not Useful
/*null-terminate color_field at the position of the delimiter.*/,"-4.     color_field = opttmp;
-3.     alpha_field = strchr( opttmp, '_' );
-2.     if ( alpha_field != NULL )
-1.     {

/*null-terminate color_field at the position of the delimiter.*/

1.         *alpha_field = '\0';",Not Useful
/*point alpha_field at the position one beyond the delimiter.*/,"-1.         *alpha_field = '\0';

/*point alpha_field at the position one beyond the delimiter.*/

1.         alpha_field++;
2.     }
3.     else
4.     {",Not Useful
"/*fprintf( stderr, ""color_field = %s\n"", color_field );
fprintf( stderr, ""alpha_field = %s\n"", alpha_field );*/","-2.         alpha_field = ""MAX_PLFLT_ALPHA"";
-1.     }

/*fprintf( stderr, ""color_field = %s\n"", color_field );
fprintf( stderr, ""alpha_field = %s\n"", alpha_field );*/

111",Not Useful
/*To distinguish success/failure after call*/,"-5.         alpha_field = ""MAX_PLFLT_ALPHA"";
-4.     }

/*To distinguish success/failure after call*/

1.     bgcolor    = strtol( color_field, &endptr, 16 );
2.     save_errno = errno;",Not Useful
/*Check for various possible errors*/,"-2.     bgcolor    = strtol( color_field, &endptr, 16 );
-1.     save_errno = errno;

/*Check for various possible errors*/

1.     if ( ( errno == ERANGE && ( bgcolor == LONG_MIN || bgcolor == LONG_MAX ) ) || ( errno != 0 && bgcolor == 0 ) )
2.     {
3. ",Not Useful
/*Trim trailing garbage off of color_field.*/,"-10.         color_field = ""ff0000"";
-9.         fprintf( stderr, ""derived color_field = %s\n"", color_field );
-8.         bgcolor = strtol( color_field, &endptr, 16 );
-7.         fprintf( stderr, ""derived bgcolor = %#lx\n"", bgcolor );
-6.     }
-5.     ",Not Useful
"/*If bgcolor has 3 digits, each is ""doubled"" (i.e. ABC becomes AABBCC).*/","-4.         *endptr = '\0';
-3.         fprintf( stderr, ""derived color_field = %s\n"", color_field );
-2.         fprintf( stderr, ""derived bgcolor = %#lx\n"", bgcolor );
-1.     }

/*If bgcolor has 3 digits, each is ""doubled"" (i.e. ABC becomes AABBCC).*/
",Not Useful
/*doubling*/,"-10.     if ( ( color_field_wp_alt = strstr( color_field_wp, ""0x"" ) ) == color_field_wp ||
-9.          ( color_field_wp_alt = strstr( color_field_wp, ""0X"" ) ) == color_field_wp )
-8.         color_field_wp += 2;
-7.     switch ( strlen( color_field_wp ) ",Not Useful
/*Parse alpha_field using strtod and checking for all potential issues.*/,"-10.         plwarn( ""opt_bg: color_field without prefix is not of the correct form.  Therefore use (warning) red"" );
-9.         fprintf( stderr, ""%s\n"", ""Further information relevant to this warning:"" );
-8.         fprintf( stderr, ""color_field = %s\n""",Not Useful
/*To distinguish success/failure after call*/,"-5.         alpha_field = ""MAX_PLFLT_ALPHA"";
-4.     }

/*To distinguish success/failure after call*/

1.     bgcolor    = strtol( color_field, &endptr, 16 );
2.     save_errno = errno;",Not Useful
/*Check for various possible errors*/,"-2.     bgcolor    = strtol( color_field, &endptr, 16 );
-1.     save_errno = errno;

/*Check for various possible errors*/

1.     if ( ( errno == ERANGE && ( bgcolor == LONG_MIN || bgcolor == LONG_MAX ) ) || ( errno != 0 && bgcolor == 0 ) )
2.     {
3. ",Not Useful
"/*fprintf( stderr, ""r, g, b, alpha = %d, %d, %d, %e\n"", r, g, b, a );*/","-10.         a = MAX_PLFLT_ALPHA;
-9.         fprintf( stderr, ""derived alpha value = %e\n"", a );
-8.     }
-7.     else if ( *endptr != '\0' )
-6.     {
-5.         plwarn( ""opt_bg: alpha_field could be parsed to a double but there was trailing garbage w",Not Useful
"/*fprintf( stderr, ""xwid, ywid, xoff, yoff = %d, %d, %d, %d\n"", xwid, ywid, xoff, yoff );*/","-10.                 fprintf( stderr, ""?invalid xoff in -geometry %s\n"", opt_arg );
-9.             if ( abs( yoff ) == 0 )
-8.                 fprintf( stderr, ""?invalid yoff in -geometry %s\n"", opt_arg );
-7.         }
-6.         else
-5.         {
-4.",Not Useful
/*Fill up the struct with all relevant info*/,"-10.     {
-9.         sid        = *id = i;
-8.         strip[sid] = (PLStrip *) calloc( 1, (size_t) sizeof ( PLStrip ) );
-7.         if ( strip[sid] == NULL )
-6.         {
-5.             plabort( ""plstripc: Out of memory."" );
-4.             *id = -1",Not Useful
/*jump x step(%) when x attains xmax (xmax is then set to xmax+xjump)*/,"-3.     stripc->xmax   = xmax;
-2.     stripc->ymin   = ymin;
-1.     stripc->ymax   = ymax;

/*jump x step(%) when x attains xmax (xmax is then set to xmax+xjump)*/

111",Not Useful
/*Font lookup table that is constructed in plD_FreeType_init*/,"-10.   #include <unistd.h>
-9. #endif
-8. #define makeunixslash( b )    do { char *I; for ( I = b; *I != 0; *I++ ) if ( *I == '\\' ) * I = '/'; } while ( 0 )
-7. #include ""plDevs.h""
-6. #include ""plplotP.h""
-5. #include ""drivers.h""
-4. #ifdef PL_HAVE_FREE",Not Useful
/*TOP LEVEL DEFINES*/,"-1. PLDLLIMPEXP_DATA( FCI_to_FontName_Table ) FontLookup[N_TrueTypeLookup];

/*TOP LEVEL DEFINES*/

111",Not Useful
"/*--------------------------------------------------------------------------
Some debugging macros
--------------------------------------------------------------------------*/","-4. #define TEXT_SCALING_FACTOR    .7

/*--------------------------------------------------------------------------
Some debugging macros
--------------------------------------------------------------------------*/

111",Not Useful
/*note height is negative!*/,"-2.     y        -= (int) FT->face->size->metrics.height;
-1.     startingy = y;

/*note height is negative!*/

1.     *overyy   = 0;
2.     *underyy  = 0;
3.     adjust.x  = 0;
4.     adjust.y  = 0;",Not Useful
/*walk through the text character by character*/,"-4.     *overyy   = 0;
-3.     *underyy  = 0;
-2.     adjust.x  = 0;
-1.     adjust.y  = 0;

/*walk through the text character by character*/

1.     for ( i = 0; i < len; i++ )
2.     {
3.         if ( ( text[i] == (PLUNICODE) esc ) && ( text[i - 1] != (",Not Useful
/*super script*/,"-8.     for ( i = 0; i < len; i++ )
-7.     {
-6.         if ( ( text[i] == (PLUNICODE) esc ) && ( text[i - 1] != (PLUNICODE) esc ) )
-5.         {
-4.             if ( text[i + 1] == (PLUNICODE) esc )
-3.                 continue;
-2.             switch ",Not Useful
/*super script*/,"-8.     for ( i = 0; i < len; i++ )
-7.     {
-6.         if ( ( text[i] == (PLUNICODE) esc ) && ( text[i - 1] != (PLUNICODE) esc ) )
-5.         {
-4.             if ( text[i + 1] == (PLUNICODE) esc )
-3.                 continue;
-2.             switch ",Not Useful
"/*calculate excess height from superscripts, this will need changing if scale of sub/superscripts changes*/","-5.                 adjust.y = FT->face->size->metrics.height / 2;
-4.                 adjust.x = 0;
-3.                 FT_Vector_Transform( &adjust, &FT->matrix );
-2.                 x += (int) adjust.x;
-1.                 y -= (int) adjust.y;

/*calc",Not Useful
/*subscript*/,"-3.                 *overyy = y - startingy < *overyy ? y - startingy : *overyy;
-2.                 i++;
-1.                 break;

/*subscript*/

111",Not Useful
/*subscript*/,"-3.                 *overyy = y - startingy < *overyy ? y - startingy : *overyy;
-2.                 i++;
-1.                 break;

/*subscript*/

111",Not Useful
"/*calculate excess depth from subscripts, this will need changing if scale of sub/superscripts changes*/","-5.                 adjust.y = -FT->face->size->metrics.height / 2;
-4.                 adjust.x = 0;
-3.                 FT_Vector_Transform( &adjust, &FT->matrix );
-2.                 x += (int) adjust.x;
-1.                 y -= (int) adjust.y;

/*cal",Not Useful
/*walk through the text character by character*/,"-4.     *overyy   = 0;
-3.     *underyy  = 0;
-2.     adjust.x  = 0;
-1.     adjust.y  = 0;

/*walk through the text character by character*/

1.     for ( i = 0; i < len; i++ )
2.     {
3.         if ( ( text[i] == (PLUNICODE) esc ) && ( text[i - 1] != (",Not Useful
/*super script*/,"-8.     for ( i = 0; i < len; i++ )
-7.     {
-6.         if ( ( text[i] == (PLUNICODE) esc ) && ( text[i - 1] != (PLUNICODE) esc ) )
-5.         {
-4.             if ( text[i + 1] == (PLUNICODE) esc )
-3.                 continue;
-2.             switch ",Not Useful
/*super script*/,"-8.     for ( i = 0; i < len; i++ )
-7.     {
-6.         if ( ( text[i] == (PLUNICODE) esc ) && ( text[i - 1] != (PLUNICODE) esc ) )
-5.         {
-4.             if ( text[i + 1] == (PLUNICODE) esc )
-3.                 continue;
-2.             switch ",Not Useful
/*subscript*/,"-3.                 *overyy = y - startingy < *overyy ? y - startingy : *overyy;
-2.                 i++;
-1.                 break;

/*subscript*/

111",Not Useful
/*subscript*/,"-3.                 *overyy = y - startingy < *overyy ? y - startingy : *overyy;
-2.                 i++;
-1.                 break;

/*subscript*/

111",Not Useful
/*end for*/,"-4.             x += (int) FT->face->glyph->advance.x;
-3.             y -= (int) FT->face->glyph->advance.y;
-2.             last_char = i;
-1.         }

/*end for*/

1. }",Not Useful
/*PLFLT         alpha_b;*/,"-10. void
-9. FT_PlotChar( PLStream *pls, FT_Data *FT, FT_GlyphSlot slot,
-8.              int x, int y )
-7. {
-6.     unsigned char bittest;
-5.     short         i, k, j;
-4.     int           n = slot->bitmap.pitch;
-3.     int           current_pixel",Not Useful
/*Corners of the clipping rectangle*/,"-2.     int           xx;
-1.     short         imin, imax, kmin, kmax;

/*Corners of the clipping rectangle*/

1.     PLINT clipxmin, clipymin, clipxmax, clipymax, tmp;
2.     PLINT clpxmi, clpxma, clpymi, clpyma;",Not Useful
/*Convert clipping box into normal coordinates*/,"-2.     PLINT clipxmin, clipymin, clipxmax, clipymax, tmp;
-1.     PLINT clpxmi, clpxma, clpymi, clpyma;

/*Convert clipping box into normal coordinates*/

1.     clipxmin = pls->clpxmi;
2.     clipxmax = pls->clpxma;
3.     clipymin = pls->clpymi;
4.    ",Not Useful
/*scale was set*/,"-9.     clipxmin = pls->clpxmi;
-8.     clipxmax = pls->clpxma;
-7.     clipymin = pls->clpymi;
-6.     clipymax = pls->clpyma;
-5.     if ( plsc->difilt )
-4.     {
-3.         difilt( &clipxmin, &clipymin, 1, &clpxmi, &clpxma, &clpymi, &clpyma );
-2.   ",Not Useful
"/*alpha_b=1.0-alpha_a;
R=(plsc->curcolor.r*alpha_a)+(R*alpha_b);
G=(plsc->curcolor.g*alpha_a)+(G*alpha_b);
B=(plsc->curcolor.b*alpha_a)+(B*alpha_b);*/","-10.                         {
-9.                             FT->pixel( pls, x + k, y + i );
-8.                         }
-7.                         else
-6.                         {
-5.                             current_pixel_colour = FT->read_pix",Not Useful
"/*First check for a user customised location and if
the fonts aren't found there try the default Windows
locations*/","-2.     FT->fci = PL_FCI_IMPOSSIBLE;
-1. #if defined ( MSDOS ) || defined ( _WIN32 )

/*First check for a user customised location and if
the fonts aren't found there try the default Windows
locations*/

1.     if ( ( a = getenv( ""PLPLOT_FREETYPE_FONT_DIR",Not Useful
"/*
The driver looks for N_TrueTypeLookup  environmental variables
where the path and name of these fonts can be OPTIONALLY set,
overriding the configured default values.
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

/*
The driver looks for N_TrueTypeLookup  environmental variables
where the path and name of these fonts can be OPTIONALLY set,
overriding the configured default values.
*/

111",Not Useful
/*check for MS-DOS absolute path*/,"-10.         {

/*check for MS-DOS absolute path*/

1. #else",Not Useful
/*check for unix abs path*/,"-10. //  Work out if we have been given an absolute path to a font name, or just
-9. //  a font name sans-path. To do this we will look for a directory separator
-8. //  character, which means some system specific junk. DJGPP is all wise, and
-7. //  unde",Not Useful
"/*
Next, we check to see if -drvopt has been used on the command line to
over-ride any settings
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

/*
Next, we check to see if -drvopt has been used on the command line to
over-ride any settings
*/

111",Not Useful
/*save a copy of character height and resolution*/,"-4. void FT_SetFace( PLStream *pls, PLUNICODE fci )
-3. {
-2.     FT_Data *FT       = (FT_Data *) pls->FT;

/*save a copy of character height and resolution*/

1.     FT->chrht = pls->chrht;
2.     FT->xdpi  = pls->xdpi;
3.     FT->ydpi  = pls->ydpi;
4.  ",Not Useful
"/*difilt(&args->x, &args->y, 1, &clxmin, &clxmax, &clymin, &clymax);*/","-6.             FT_Set_Transform( FT->face, &FT->matrix, &FT->pos );

/*difilt(&args->x, &args->y, 1, &clxmin, &clxmax, &clymin, &clymax);*/

111",Not Useful
"/*
Convert into normal coordinates from virtual coordinates
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

/*
Convert into normal coordinates from virtual coordinates
*/

111",Not Useful
/*write it out*/,"-2.             x -= (int) adjust.x;
-1.             y += (int) adjust.y;

/*write it out*/

111",Not Useful
"/*
Move to the next line
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

/*
Move to the next line
*/

111",Not Useful
/*extern int FT_Done_Library( FT_Library library );*/,"-10. //--------------------------------------------------------------------------
-9. // plD_FreeType_Destroy()
-8. //
-7. // Restores cmap0 if it had been modifed for anti-aliasing
-6. // closes the freetype library.
-5. // Deallocates memory to the Free",Not Useful
/*Declarations*/,"-8. #ifndef __PLSYM_H__
-7. #define __PLSYM_H__
-6. #define DEBUG
-5. #define NEED_PLDEBUG
-4. #include ""plplotP.h""
-3. #include <float.h>
-2. #include <ctype.h>
-1. #include ""plhershey-unicode.h""

/*Declarations*/

1. static short int   *fntlkup;
2. stat",Not Useful
/*Static function prototypes*/,"-6. #define PLMAXSTR    300
-5. #define STLEN       250
-4. static const char  font_types[] = ""nris"";
-3. static short       symbol_buffer[PLMAXSTR];
-2. static signed char xygrid[STLEN];
-1. int hershey2unicode( int in );

/*Static function prototypes*/
",Not Useful
"/*One-time diagnostic output.
fprintf(stdout, ""plploin code, sym = %d, %d\n"", code, sym);*/","-10.         {
-9.             TRANSFORM( x[i], y[i], &xt, &yt );
-8.             pljoin( xt, yt, xt, yt );
-7.         }
-6.     }
-5.     else
-4.     {
-3.         if ( ifont > numberfonts )
-2.             ifont = 1;
-1.         sym = *( fntlkup + ( i",Not Useful
/*Setup to render a unicode character*/,"-1.             plgesc( &esc );

/*Setup to render a unicode character*/

1.             args.text_type    = PL_STRING_SYMBOL;
2.             args.unicode_char = unicode_char;
3.             if ( 0 <= idx && idx <= number_of_entries_in_hershey_to_unicode_",Not Useful
"/*watch out for escape character and unescape it by appending
one extra.*/","-3.             args.unicode_array       = &plhrsh_unicode_buffer[0];
-2.             args.unicode_array_len   = 1;
-1.             plhrsh_unicode_buffer[0] = unicode_char;

/*watch out for escape character and unescape it by appending
one extra.*/

1.   ",Not Useful
/*No need to change font back since only one character.*/,"-5.             if ( unicode_char == (PLUNICODE) esc )
-4.             {
-3.                 args.unicode_array_len   = 2;
-2.                 plhrsh_unicode_buffer[1] = unicode_char;
-1.             }

/*No need to change font back since only one charact",Not Useful
"/*Swap the sym and chr information so that the text
rendering (which uses chrht and chrdef) will
render the symbol correctly*/","-6.             if ( unicode_char == (PLUNICODE) esc )
-5.             {
-4.                 args.unicode_array_len   = 2;
-3.                 plhrsh_unicode_buffer[1] = unicode_char;
-2.             }

/*Swap the sym and chr information so that the text
",Not Useful
/*Character at a time method*/,"-6.             plsc->original_chrht  = plsc->chrht;
-5.             plsc->original_chrdef = plsc->chrdef;
-4.             plsc->chrht           = plsc->symht;
-3.             plsc->chrdef          = plsc->symdef;
-2.             if ( plsc->alt_unicode )
",Not Useful
/*Line style must be continuous*/,"-10.     signed char *vxygrid = 0;
-9.     PLFLT       scale, xscale, yscale;
-8.     PLINT       llx[STLEN], lly[STLEN], l = 0;
-7.     penup = 1;
-6.     scale = 0.05 * plsc->symht;
-5.     if ( !plcvec( ch, &vxygrid ) )
-4.     {
-3.         plP_movphy",Not Useful
/*Compute how many physical pixels correspond to a character pixel*/,"-2.     style     = plsc->nms;
-1.     plsc->nms = 0;

/*Compute how many physical pixels correspond to a character pixel*/

1.     xscale = scale * plsc->xpmm;
2.     yscale = scale * plsc->ypmm;
3.     k = 4;
4.     for (;; )
5.     {
6.         cx = vx",Not Useful
/*Open clip limits to subpage limits*/,"-10.     PLINT clpxmi, clpxma, clpymi, clpyma;
-9.     PLINT vert, refx, refy, x, y;
-8.     PLFLT xdv, ydv, xmm, ymm, refxmm, refymm, shift, xform[4];
-7.     PLFLT chrdef, chrht;
-6.     PLFLT dispx, dispy;
-5.     if ( plsc->level < 2 )
-4.     {
-3.  ",Not Useful
/*get and store current clip limits*/,"-10.     PLINT vert, refx, refy, x, y;
-9.     PLFLT xdv, ydv, xmm, ymm, refxmm, refymm, shift, xform[4];
-8.     PLFLT chrdef, chrht;
-7.     PLFLT dispx, dispy;
-6.     if ( plsc->level < 2 )
-5.     {
-4.         plabort( ""plmtex: Please set up viewpor",Not Useful
/*restore initial clip limits*/,"-10.     else if ( plP_stsearch( side, 'r' ) )
-9.     {
-8.         vert  = 1;
-7.         xdv   = plsc->vpdxma;
-6.         ydv   = plsc->vpdymi + ( plsc->vpdyma - plsc->vpdymi ) * pos;
-5.         dispx = disp;
-4.         dispy = 0;
-3.     }
-2.     ",Not Useful
/*Transformation matrix*/,"-2.         return;
-1.     }

/*Transformation matrix*/

1.     if ( vert != 0 )
2.     {
3.         xform[0] = 0.0;
4.         xform[1] = -1.0;
5.         xform[2] = 1.0;
6.         xform[3] = 0.0;
7.     }
8.     else
9.     {
10.         xform[0] = 1.",Not Useful
/*Convert to physical units (mm) and compute shifts*/,"-10.         xform[2] = 1.0;
-9.         xform[3] = 0.0;
-8.     }
-7.     else
-6.     {
-5.         xform[0] = 1.0;
-4.         xform[1] = 0.0;
-3.         xform[2] = 0.0;
-2.         xform[3] = 1.0;
-1.     }

/*Convert to physical units (mm) and compu",Not Useful
/*Convert to device units (pixels) and call text plotter*/,"-6.     plgchr( &chrdef, &chrht );
-5.     shift = ( just == 0.0 ) ? 0.0 : plstrl( text ) * just;
-4.     xmm    = plP_dcmmx( xdv ) + dispx * chrht;
-3.     ymm    = plP_dcmmy( ydv ) + dispy * chrht;
-2.     refxmm = xmm - shift * xform[0];
-1.     refymm",Not Useful
/*restore clip limits*/,"-5.     x    = plP_mmpcx( xmm );
-4.     y    = plP_mmpcy( ymm );
-3.     refx = plP_mmpcx( refxmm );
-2.     refy = plP_mmpcy( refymm );
-1.     plP_text( 0, just, xform, x, y, refx, refy, text );

/*restore clip limits*/

1. }",Not Useful
/*Transform both the origin and offset values*/,"-10.     PLFLT xdv, ydv, xmm, ymm, refxmm, refymm, shift, cc, ss;
-9.     PLFLT xform[4], diag;
-8.     PLFLT chrdef, chrht;
-7.     PLFLT dispx, dispy;
-6.     PLFLT wxt, wyt, dxt, dyt;
-5.     if ( plsc->level < 3 )
-4.     {
-3.         plabort( ""plpte",Not Useful
/*Convert to physical units (mm) and compute shifts*/,"-10.         xform[2] = 1.0;
-9.         xform[3] = 0.0;
-8.     }
-7.     else
-6.     {
-5.         xform[0] = 1.0;
-4.         xform[1] = 0.0;
-3.         xform[2] = 0.0;
-2.         xform[3] = 1.0;
-1.     }

/*Convert to physical units (mm) and compu",Not Useful
/*Line style must be continuous*/,"-10.     signed char *vxygrid = 0;
-9.     PLFLT       scale, xscale, yscale;
-8.     PLINT       llx[STLEN], lly[STLEN], l = 0;
-7.     penup = 1;
-6.     scale = 0.05 * plsc->symht;
-5.     if ( !plcvec( ch, &vxygrid ) )
-4.     {
-3.         plP_movphy",Not Useful
/*superscript*/,"-6.     style     = plsc->nms;
-5.     plsc->nms = 0;
-4.     pldeco( &symbol, &length, string );
-3.     for ( i = 0; i < length; i++ )
-2.     {
-1.         ch = symbol[i];

/*superscript*/

1.         {
2.             plP_script_scale( TRUE, &level,
3.",Not Useful
/*subscript*/,"-6.         {
-5.             plP_script_scale( TRUE, &level,
-4.                 &old_sscale, &sscale, &old_soffset, &soffset );
-3.             yorg  = 16.0 * dscale * soffset;
-2.             scale = dscale * sscale;
-1.         }

/*subscript*/

1.   ",Not Useful
/*back-char*/,"-6.         {
-5.             plP_script_scale( FALSE, &level,
-4.                 &old_sscale, &sscale, &old_soffset, &soffset );
-3.             yorg  = -16.0 * dscale * soffset;
-2.             scale = dscale * sscale;
-1.         }

/*back-char*/

1. ",Not Useful
/*toogle overline*/,"-1.             xorg -= width * scale;

/*toogle overline*/

1.             oline = !oline;",Not Useful
/*toogle underline*/,"-1.             oline = !oline;

/*toogle underline*/

1.             uline = !uline;
2.         else
3.         {
4.             if ( plcvec( ch, &vxygrid ) )
5.                 plchar( vxygrid, xform, base, oline, uline, refx, refy, scale,
6.           ",Not Useful
/*store 1st point !*/,"-10.             lx = refx + ROUND( xpmm * ( xform[0] * x + xform[1] * y ) );
-9.             ly = refy + ROUND( ypmm * ( xform[2] * x + xform[3] * y ) );
-8.             if ( penup == 1 )
-7.             {
-6.                 if ( l )
-5.                ",Not Useful
/*This is bad if we get here*/,"-10.     do
-9.     {
-8.         ib++;
-7.         x           = fntbffr[2 * ib];
-6.         y           = fntbffr[2 * ib + 1];
-5.         xygrid[k++] = x;
-4.         xygrid[k++] = y;
-3.     } while ( ( x != 64 || y != 64 ) && k <= ( STLEN - 2 ) );
-",Not Useful
/*search failed*/,"-10. {
-9.     PLINT base, str1ind, str2ind;
-8.     for ( base = 0; *( str1 + base ) != '\0'; base++ )
-7.     {
-6.         for ( str1ind = base, str2ind = 0; *( str2 + str2ind ) != '\0' &&
-5.               *( str2 + str2ind ) == *( str1 + str1ind ); s",Not Useful
/*Read fntlkup[]*/,"-10.     plfontrel();
-9.     fontloaded = 1;
-8.     charset    = fnt;
-7.     failed     = 0;
-6.     if ( fnt )
-5.         pdfs = plLibOpenPdfstrm( PL_XFONT );
-4.     else
-3.         pdfs = plLibOpenPdfstrm( PL_SFONT );
-2.     if ( pdfs == NULL )
-",Not Useful
/*Read fntindx[]*/,"-10.         pdf_rd_2bytes( pdfs, (U_SHORT *) &bffrleng );
-9.         numberfonts = bffrleng / 256;
-8.         numberchars = bffrleng & 0xff;
-7.         bffrleng    = (short) ( numberfonts * numberchars );
-6.         fntlkup     = (short int *) malloc",Not Useful
"/*Read fntbffr[]
Since this is an array of char, there are no endian problems*/","-9.     if ( !failed )
-8.     {
-7.         pdf_rd_2bytes( pdfs, (U_SHORT *) &indxleng );
-6.         fntindx = (short int *) malloc( (size_t) indxleng * sizeof ( short int ) );
-5.         if ( !fntindx )
-4.             failed = 1;
-3.         else
-2.",Not Useful
/*Done*/,"-10.         if ( !fntbffr )
-9.             failed = 1;
-8.         else
-7. #if PLPLOT_USE_TCL_CHANNELS
-6.             pdf_rdx( fntbffr, sizeof ( signed char ) * (size_t) ( 2 * bffrleng ), pdfs );
-5. #else
-4.             plio_fread( (void *) fntbffr,",Not Useful
/*local storage*/,"-10. //	just = 0.0 => left hand edge of string is at reference
-9. //	just = 1.0 => right hand edge of string is at reference
-8. //	just = 0.5 => center of string is at reference
-7. //
-6. // All calculations are done in physical coordinates.
-5. //
-4.",Not Useful
/*calculated*/,"-2.     PLFLT xmin, xmax, ymin, ymax, zmin, zmax, zscale;
-1.     PLFLT chrdef, chrht;

/*calculated*/

1.     PLFLT xpc, ypc, xrefpc, yrefpc;
2.     PLFLT epx1 = 0.0, epy1 = 0.0, epx2 = 0.0, epy2 = 0.0, epx3 = 0.0, epy3 = 0.0;
3.     PLFLT dispx, dispy, ",Not Useful
/*Static function prototypes.*/,"-4. #include ""plplotP.h""
-3. #ifdef MSDOS
-2. #pragma optimize("""",off)
-1. #endif

/*Static function prototypes.*/

1. static void
2. plcntr( PLF2EVAL_callback plf2eval, PLPointer plf2eval_data,
3.         PLINT nx, PLINT ny, PLINT kx, PLINT lx,
4.       ",Not Useful
"/*If pltr is undefined, abort with an error.*/","-9. void
-8. plfcont( PLF2EVAL_callback f2eval, PLPointer f2eval_data,
-7.          PLINT nx, PLINT ny, PLINT kx, PLINT lx,
-6.          PLINT ky, PLINT ly, PLFLT_VECTOR clevel, PLINT nlevel,
-5.          PLTRANSFORM_callback pltr, PLPointer pltr_data )
-",Not Useful
/*Mark this square as done*/,"-4.         sfi      = ( f[i] > 0.0 ) ? 1 : ( ( f[i] < 0.0 ) ? -1 : 0 );
-3.         sfj      = ( f[j] > 0.0 ) ? 1 : ( ( f[j] < 0.0 ) ? -1 : 0 );
-2.         iedge[i] = ( sfi * sfj > 0 ) ? -1 : ( ( sfi * sfj < 0 ) ? 1 : 0 );
-1.     }

/*Mark this square ",Not Useful
/*Global variables*/,"-8. #include ""plplotP.h""
-7. #include <float.h>
-6. #define NEG                  1
-5. #define POS                  8
-4. #define OK                   0
-3. #define UNDEF                64
-2. #define NUMBER_BISECTIONS    10
-1. #define linear( val1, val2",Not Useful
/*Function prototypes*/,"-6. static PLFLT sh_max, sh_min;
-5. static int   min_points, max_points, n_point;
-4. static int   min_pts[4], max_pts[4];
-3. static PLINT pen_col_min, pen_col_max;
-2. static PLFLT pen_wd_min, pen_wd_max;
-1. static PLFLT int_val;

/*Function prototype",Not Useful
/*Color range to use*/,"-10.            PLDEFINED_callback defined,
-9.            PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-8.            PLFLT_VECTOR clevel, PLINT nlevel, PLFLT fill_width,
-7.            PLINT cont_color, PLFLT cont_width,
-6.            PLFILL_callbac",Not Useful
/*c2eval is unused.*/,"-10. //     set min_width == 0 and max_width == 0 for no contours
-9. // fill: fill function, set to NULL for no shading (contour plot)
-8. // rectangular: flag set to 1 if pltr() maps rectangles to rectangles
-7. //     this helps optimize the plotting
-",Not Useful
/*alloc space for condition codes*/,"-9.     nxny = nx * ny;
-8.     if ( ( a = (PLFLT *) malloc( (size_t) nxny * sizeof ( PLFLT ) ) ) == NULL )
-7.     {
-6.         plabort( ""plfshade: unable to allocate memory for value array"" );
-5.         return;
-4.     }
-3.     for ( ix = 0; ix < nx",Not Useful
"/*Slightly less than 2 n points are required for xx, yy, but
allocate room for 2 n to be safe.*/","-10.         ( *fill )( n, x, y );
-9.     else
-8.     {
-7.         PLFLT *xx;
-6.         PLFLT *yy;
-5.         PLFLT xb, yb;
-4.         PLINT count      = 0;
-3.         PLINT im1        = n - 1;
-2.         PLINT is_defined = defined( x[im1], y[im1",Not Useful
/*swap points 1 and 3*/,"-10. static void
-9. draw_boundary( PLINT slope, PLFLT *x, PLFLT *y )
-8. {
-7.     int i;
-6.     if ( pen_col_min != 0 && pen_wd_min != 0 && min_points != 0 )
-5.     {
-4.         plcol0( pen_col_min );
-3.         plwidth( pen_wd_min );
-2.         if",Not Useful
/*swap points 1 and 3*/,"-10. static void
-9. draw_boundary( PLINT slope, PLFLT *x, PLFLT *y )
-8. {
-7.     int i;
-6.     if ( pen_col_min != 0 && pen_wd_min != 0 && min_points != 0 )
-5.     {
-4.         plcol0( pen_col_min );
-3.         plwidth( pen_wd_min );
-2.         if",Not Useful
/*Go to level 3*/,"-9.     w.dxmi = plsc->vpdxmi;
-8.     w.dxma = plsc->vpdxma;
-7.     w.dymi = plsc->vpdymi;
-6.     w.dyma = plsc->vpdyma;
-5.     w.wxmi = xvpwxmin;
-4.     w.wxma = xvpwxmax;
-3.     w.wymi = xvpwymin;
-2.     w.wyma = xvpwymax;
-1.     plP_swin( &w );",Not Useful
/*Static function prototypes*/,"-10. #include ""plplotP.h""
-9. #define STRING_LEN         40
-8. #define FORMAT_LEN         10
-7. #define TEMP_LEN           30
-6. #define N_EDGE_SEGMENTS    50
-5. static PLFLT xlog[8] =
-4. {
-3.     0.301030, 0.477121, 0.602060, 0.698970,
-2.     0.77",Not Useful
"/*vpwxmi always numerically less than vpwxma, and
similarly for vpwymi*/","-9.     xmajor = MAX( ROUND( plsc->majht * plsc->ypmm ), 1 );
-8.     ymajor = MAX( ROUND( plsc->majht * plsc->xpmm ), 1 );
-7.     xminor = MAX( ROUND( plsc->minht * plsc->ypmm ), 1 );
-6.     yminor = MAX( ROUND( plsc->minht * plsc->xpmm ), 1 );
-5.    ",Not Useful
"/*n.b. large change; xtick1, nxsub1, ytick1, nysub1 always positive.*/","-4.     if ( ltx || lgx || lxx )
-3.         pldtik( vpwxmi, vpwxma, &xtick1, &nxsub1, ldx );
-2.     if ( lty || lgy || lxy )
-1.         pldtik( vpwymi, vpwyma, &ytick1, &nysub1, ldy );

/*n.b. large change; xtick1, nxsub1, ytick1, nysub1 always positiv",Not Useful
"/*n.b. large change; vpwxmi always numerically less than vpwxma, and
similarly for vpwymi*/","-10.     lfy = plP_stsearch( yopt, 'f' );
-9.     liy = plP_stsearch( yopt, 'i' );
-8.     lly = plP_stsearch( yopt, 'l' );
-7.     lmy = plP_stsearch( yopt, 'm' );
-6.     lny = plP_stsearch( yopt, 'n' );
-5.     lty = plP_stsearch( yopt, 't' );
-4.     ",Not Useful
"/*vpwxmi always numerically less than vpwxma, and
similarly for vpwymi*/","-9.     xmajor = MAX( ROUND( plsc->majht * plsc->ypmm ), 1 );
-8.     ymajor = MAX( ROUND( plsc->majht * plsc->xpmm ), 1 );
-7.     xminor = MAX( ROUND( plsc->minht * plsc->ypmm ), 1 );
-6.     yminor = MAX( ROUND( plsc->minht * plsc->xpmm ), 1 );
-5.    ",Not Useful
/*Bottom axis exponent.*/,"-10.             }
-9.             else
-8.             {
-7.                 height = 3.2;
-6.                 pos    = 1.0;
-5.                 just   = 0.5;
-4.             }
-3.             snprintf( string, STRING_LEN, ""(x10%su%d%sd)"", esc_string, (i",Not Useful
/*Top axis exponent.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""b"", height, pos, just, ",Not Useful
"/*Assume label data is for placement of exponents if no custom
label function is provided.*/","-10.     static char   string[STRING_LEN];
-9.     PLBOOL        ldx, lfx, lix, llx, lmx, lnx, ltx, lox, lxx;
-8.     PLBOOL        ldy, lfy, liy, lly, lmy, lny, lty, lvy, loy, lxy;
-7.     PLFLT         vpwxmi, vpwxma, vpwymi, vpwyma;
-6.     PLFLT      ",Not Useful
/*Save some parameters*/,"-3.     PLFLT         pos = 0.0, height = 0.0, just = 0.0;
-2.     PLCHAR_VECTOR esc_string = plgesc_string();
-1.     plgchr( &default_mm, &char_height_mm );

/*Save some parameters*/

1.     plgxax( &xdigmax, &xdigits );
2.     plgyax( &ydigmax, &ydigit",Not Useful
"/*n.b. large change; vpwxmi always numerically less than vpwxma, and
similarly for vpwymi*/","-10.     lfy = plP_stsearch( yopt, 'f' );
-9.     liy = plP_stsearch( yopt, 'i' );
-8.     lly = plP_stsearch( yopt, 'l' );
-7.     lmy = plP_stsearch( yopt, 'm' );
-6.     lny = plP_stsearch( yopt, 'n' );
-5.     lty = plP_stsearch( yopt, 't' );
-4.     ",Not Useful
/*Loop through all of the tick marks*/,"-8.             height_mm = ( height + 0.7 ) * char_height_mm;
-7.             if ( lnx )
-6.                 plsc->boxbb_ymin = MIN( plsc->boxbb_ymin, plsc->vppymi /
-5.                     plsc->ypmm - height_mm );
-4.             if ( lmx )
-3.        ",Not Useful
/*Bottom axis exponent.*/,"-10.             }
-9.             else
-8.             {
-7.                 height = 3.2;
-6.                 pos    = 1.0;
-5.                 just   = 0.5;
-4.             }
-3.             snprintf( string, STRING_LEN, ""(x10%su%d%sd)"", esc_string, (i",Not Useful
/*Top axis exponent.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""b"", height, pos, just, ",Not Useful
/*Left axis exponent.*/,"-5.             }
-4.             else
-3.             {
-2.                 offset = 0.02;
-1.             }

/*Left axis exponent.*/

1.             if ( lny )
2.             {
3.                 if ( !custom_exponent_placement )
4.                 {
5.",Not Useful
/*Right axis exponent.*/,"-10.                     if ( lvy )
-9.                     {
-8.                         plmtex( ""lv"", height, pos, just, string );
-7.                     }
-6.                     else
-5.                     {
-4.                         plmtex( ""l"", ",Not Useful
/*forward declarations*/,"-3. #include <libqhull_r/qhull_ra.h>

/*forward declarations*/

1. static void
2. grid_nnaidw( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
3.              PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy,
4.              PLF2OPS zops, ",Not Useful
/*make sure it is smaller that KNN_MAX_ORDER*/,"-9. static void
-8. grid_nnidw( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
-7.             PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy,
-6.             PLF2OPS zops, PLPointer zgp, int knn_order )
-5. {
-4.     int   i, j, k;
-3.",Not Useful
/*deal with it later*/,"-1.             {

/*deal with it later*/

1.             }",Not Useful
/*find new maximum distance*/,"-2.             items[max_slot].dist = d;
-1.             items[max_slot].item = i;

/*find new maximum distance*/

1.             max_dist = items[0].dist;
2.             max_slot = 0;
3.             for ( j = 1; j < knn_order; j++ )
4.             {
5. ",Not Useful
/*qh_ALL*/,"-2.         printf( ""Neigbors\n"" );
-1.         qh_findgood_all( qh facet_list );
        qh_countfacets( qh facet_list, NULL, !qh_ALL, &numfacets, &numsimplicial,

/*qh_ALL*/

1.             &totneighbors, &numridges, &numcoplanars, &numtricoplanars );
2",Not Useful
"/*z holds the subimage (Dxmin, Dymin) - (Dxmax, Dymax)*/","-10.         xmin, xmax, ymin, ymax, zmin, zmax,
-9.         Dxmin, Dxmax, Dymin, Dymax );
-8. }
-7. void
-6. plfimage( PLF2OPS idataops, PLPointer idatap, PLINT nx, PLINT ny,
-5.           PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax, PLFLT zmin, PLFLT",Not Useful
/*Static function prototypes*/,"-4. #define NEED_PLDEBUG
-3. #include ""plplotP.h""
-2. #include <float.h>
-1. #include <ctype.h>

/*Static function prototypes*/

1. static void plP_plotvect( PLFLT x, PLFLT y, PLFLT u, PLFLT v, PLFLT scale );",Not Useful
/*Reset default arrow if null pointers are passed.*/,"-10. void
-9. c_plsvect( PLFLT_VECTOR arrowx, PLFLT_VECTOR arrowy, PLINT npts, PLBOOL fill )
-8. {
-7.     int   i;
-6.     PLFLT def_arrow_x[6] = { -0.5, 0.5, 0.3, 0.5, 0.3, 0.5 };
-5.     PLFLT def_arrow_y[6] = { 0.0, 0.0, 0.2, 0.0, -0.2, 0.0 };
-4.    ",Not Useful
/*Function prototypes*/,"-4. #include ""plplotP.h""
-3. #define INSIDE( ix, iy )    ( BETW( ix, xmin, xmax ) && BETW( iy, ymin, ymax ) )
-2. static PLINT xline[PL_MAXPOLY], yline[PL_MAXPOLY];
-1. static PLINT lastx = PL_UNDEFINED, lasty = PL_UNDEFINED;

/*Function prototypes*/

111",Not Useful
/*Now figure out which side this is.*/,"-10.     if ( plsc->level < 3 )
-9.     {
-8.         plabort( ""plpoly3: Please set up window first"" );
-7.         return;
-6.     }
-5.     if ( n < 3 )
-4.     {
-3.         plabort( ""plpoly3: Must specify at least 3 points"" );
-2.         return;
-1. ",Not Useful
/*Global variables*/,"-10. static int opt_plwindow( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-9. static int opt_portrait( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-8. static int opt_px( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-7. static int opt_py( PLCHAR_VECTOR, PLCHAR_VECTOR, ",Not Useful
/*Be more verbose than usual*/,"-8.         opt_v,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-v"",
-3.         ""Print out the PLplot library version number""
-2.     },
-1.     {

/*Be more verbose than usual*/

1.         opt_verbose,
2.         NULL,
3.  ",Not Useful
/*Print debugging info*/,"-8.         opt_verbose,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-verbose"",
-3.         ""Be more verbose than usual""
-2.     },
-1.     {

/*Print debugging info*/

1.         opt_debug,
2.         NULL,
3.         NULL,
",Not Useful
/*Enable driver-specific hack(s)*/,"-8.         opt_debug,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-debug"",
-3.         ""Print debugging info (implies -verbose)""
-2.     },
-1.     {

/*Enable driver-specific hack(s)*/

1.         opt_hack,
2.         NULL,",Not Useful
/*Output device*/,"-8.         opt_hack,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_INVISIBLE,
-4.         ""-hack"",
-3.         ""Enable driver-specific hack(s)""
-2.     },
-1.     {

/*Output device*/

1.         opt_dev,
2.         NULL,
3.       ",Not Useful
/*Output filename*/,"-8.         opt_dev,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-dev name"",
-3.         ""Output device name""
-2.     },
-1.     {

/*Output filename*/

1.         opt_o,
2.         NULL,
3.         NULL,
4.     ",Not Useful
/*X server*/,"-8.         opt_o,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-o name"",
-3.         ""Output filename""
-2.     },
-1.     {

/*X server*/

1.         opt_o,
2.         NULL,
3.         NULL,
4.         PL_OPT_FUN",Not Useful
/*Plots per page in x*/,"-8.         opt_o,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-display name"",
-3.         ""X server to contact""
-2.     },
-1.     {

/*Plots per page in x*/

1.         opt_px,
2.         NULL,
3.         NULL,",Not Useful
/*Plots per page in y*/,"-8.         opt_px,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-px number"",
-3.         ""Plots per page in x""
-2.     },
-1.     {

/*Plots per page in y*/

1.         opt_py,
2.         NULL,
3.         NULL,
4",Not Useful
/*Geometry*/,"-8.         opt_py,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-py number"",
-3.         ""Plots per page in y""
-2.     },
-1.     {

/*Geometry*/

1.         opt_geo,
2.         NULL,
3.         NULL,
4.         ",Not Useful
/*Plot window*/,"-8.         opt_geo,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-geo geom"",
-3.         ""Window size/position specified as in X, e.g., 400x300, 400x300-100+200, +100-200, etc.""
-2.     },
-1. ",Not Useful
/*Margin*/,"-8.         opt_wplt,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-wplt xl,yl,xr,yr"",
-3.         ""Relative coordinates [0-1] of window into plot""
-2.     },
-1.     {

/*Margin*/

1.         opt_mar,
2.         ",Not Useful
/*Aspect ratio*/,"-8.         opt_mar,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-mar margin"",
-3.         ""Margin space in relative coordinates (0 to 0.5, def 0)""
-2.     },
-1.     {

/*Aspect ratio*/

1.         opt_a,
2.    ",Not Useful
/*Justification in x*/,"-8.         opt_a,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-a aspect"",
-3.         ""Page aspect ratio (def: same as output device)""
-2.     },
-1.     {

/*Justification in x*/

1.         opt_jx,
2.         ",Not Useful
/*Justification in y*/,"-8.         opt_jx,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-jx justx"",
-3.         ""Page justification in x (-0.5 to 0.5, def 0)""
-2.     },
-1.     {

/*Justification in y*/

1.         opt_jy,
2.         N",Not Useful
/*Orientation*/,"-8.         opt_jy,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-jy justy"",
-3.         ""Page justification in y (-0.5 to 0.5, def 0)""
-2.     },
-1.     {

/*Orientation*/

1.         opt_ori,
2.         NULL,
3",Not Useful
/*Pen width*/,"-8.         opt_portrait,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-portrait"",
-3.         ""Sets portrait mode (both orientation and aspect ratio)""
-2.     },
-1.     {

/*Pen width*/

1.         opt_width,
2.         NULL",Not Useful
/*Background color*/,"-8.         opt_width,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-width width"",
-3.         ""Sets pen width (0 <= width)""
-2.     },
-1.     {

/*Background color*/

1.         opt_bg,
2.         NULL,
3.      ",Not Useful
/*Allocated colors in cmap 0*/,"-8.         opt_bg,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-bg color"",
-3.         ""Background color (e.g., FF0000=opaque red, 0000FF_0.1=blue with alpha of 0.1)""
-2.     },
-1.     {

/*Allocated colors in ",Not Useful
/*Allocated colors in cmap 1*/,"-8.         opt_ncol0,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-ncol0 n"",
-3.         ""Number of colors to allocate in cmap 0 (upper bound)""
-2.     },
-1.     {

/*Allocated colors in cmap 1*/

1.         op",Not Useful
/*Familying on switch*/,"-8.         opt_ncol1,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-ncol1 n"",
-3.         ""Number of colors to allocate in cmap 1 (upper bound)""
-2.     },
-1.     {

/*Familying on switch*/

1.         opt_fam,
",Not Useful
/*Family file size*/,"-8.         opt_fam,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-fam"",
-3.         ""Create a family of output files""
-2.     },
-1.     {

/*Family file size*/

1.         opt_fsiz,
2.         NULL,
3.         NULL,
4.      ",Not Useful
/*Family starting member*/,"-8.         opt_fsiz,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-fsiz size[kKmMgG]"",
-3.         ""Output family file size (e.g. -fsiz 0.5G, def MB)""
-2.     },
-1.     {

/*Family starting member*/

1.         ",Not Useful
/*Family member increment*/,"-8.         opt_fbeg,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-fbeg number"",
-3.         ""First family member number on output""
-2.     },
-1.     {

/*Family member increment*/

1.         opt_finc,
2.      ",Not Useful
/*Family member min field width*/,"-8.         opt_finc,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-finc number"",
-3.         ""Increment between family members""
-2.     },
-1.     {

/*Family member min field width*/

1.         opt_fflen,
2.   ",Not Useful
/*Do not use pixmaps*/,"-8.         opt_fflen,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-fflen length"",
-3.         ""Family member number minimum field width""
-2.     },
-1.     {

/*Do not use pixmaps*/

1.         opt_nopixmap,
2. ",Not Useful
/*# bytes sent before flushing output*/,"-8.         opt_np,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-np"",
-3.         ""No pause between pages""
-2.     },
-1.     {

/*# bytes sent before flushing output*/

1.         opt_bufmax,
2.         NULL,
3.         NULL",Not Useful
/*Main window name of server*/,"-8.         opt_bufmax,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-bufmax"",
-3.         ""bytes sent before flushing output""
-2.     },
-1.     {

/*Main window name of server*/

1.         op",Not Useful
/*PLplot server name*/,"-8.         opt_server_name,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-server_name name"",
-3.         ""Main window name of PLplot server (tk driver)""
-2.     },
-1.     {

/*PLplot server name*/

1.         op",Not Useful
/*PLplot container window name*/,"-8.         opt_plserver,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-plserver name"",
-3.         ""Invoked name of PLplot server (tk driver)""
-2.     },
-1.     {

/*PLplot container window na",Not Useful
/*Additional directory(s) to autoload*/,"-8.         opt_plwindow,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-plwindow name"",
-3.         ""Name of PLplot container window (tk driver)""
-2.     },
-1.     {

/*Additional directory(s) ",Not Useful
/*-file option for plserver*/,"-8.         opt_auto_path,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-auto_path dir"",
-3.         ""Additional directory(s) to autoload (tk driver)""
-2.     },
-1.     {

/*-file option for pl",Not Useful
/*Dots per inch*/,"-8.         opt_tk_file,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-tk_file file"",
-3.         ""file for plserver (tk driver)""
-2.     },
-1.     {

/*Dots per inch*/

1.         opt_dpi,
2. ",Not Useful
/*compression*/,"-10. static int opt_a( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-9. static int opt_auto_path( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-8. static int opt_bg( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-7. static int opt_bufmax( PLCHAR_VECTOR, PLCHAR_VECTOR, vo",Not Useful
/*Driver specific options*/,"-10.     {
-9.         ""eofill"",
-8.         opt_eofill,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-eofill"",
-3.         ""For the case where the boundary of the filled region is self-intersecting, use the even-odd fill rule",Not Useful
/*handler*/,"-10. //                      All Rights Reserved
-9. //
-8. //  The full permission notice is given in the PLplot documentation.
-7. //
-6. //--------------------------------------------------------------------------
-5. //
-4. //! @file
-3. //!  This fil",Not Useful
/*Try to match it*/,"-2.             if ( tab->mode & PL_OPT_DISABLED )
-1.                 continue;

/*Try to match it*/

1.             if ( *opt == *tab->opt && !strcmp( opt, tab->opt ) )
2.             {",Not Useful
/*Process argument*/,"-6.     need_arg = PL_OPT_ARG | PL_OPT_INT | PL_OPT_FLOAT | PL_OPT_STRING;
-5.     if ( tab->mode & need_arg )
-4.     {
-3.         if ( GetOptarg( &opt_arg, p_myargc, p_argv, p_argc ) )
-2.             return 1;
-1.     }

/*Process argument*/

1.     s",Not Useful
/*Set *var as a boolean*/,"-10.             strcpy( copy, opt_arg );
-9.             res = ( ( *tab->handler )( opt, copy, tab->client_data ) );
-8.             free( (void *) copy );
-7.             return res;
-6.         }
-5.         else
-4.         {
-3.             return ( ",Not Useful
/*Set *var as an int*/,"-10.         if ( tab->var == NULL )
-9.         {
-8.             fprintf( stderr,
-7.                 ""ProcessOpt: no variable specified for option %s\n"",
-6.                 tab->opt );
-5.             return 1;
-4.         }
-3.         *(int *) tab->",Not Useful
/*Set *var as a float*/,"-10.         if ( tab->var == NULL )
-9.         {
-8.             fprintf( stderr,
-7.                 ""ProcessOpt: no variable specified for option %s\n"",
-6.                 tab->opt );
-5.             return 1;
-4.         }
-3.         *(int *) tab->",Not Useful
/*Set var (can be NULL initially) to point to opt_arg string*/,"-10.         if ( tab->var == NULL )
-9.         {
-8.             fprintf( stderr,
-7.                 ""ProcessOpt: no variable specified for option %s\n"",
-6.                 tab->opt );
-5.             return 1;
-4.         }
-3.         *(PLFLT *) tab",Not Useful
/*Somebody messed up..*/,"-3.         *(char **) tab->var = opt_arg;
-2.         break;
-1.     default:

/*Somebody messed up..*/

1.         fprintf( stderr,
2.             ""ProcessOpt: invalid processing mode for option %s\n"",
3.             tab->opt );
4.         return 1;
5. ",Not Useful
"/*--------------------------------------------------------------------------
plOptUsage()

! Print usage & syntax message.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Not Useful
"/*--------------------------------------------------------------------------
Syntax()

! Print short syntax message.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Not Useful
/*Loop over all options tables*/,"-5.         if ( *argv == NULL || *argv[0] == '\0' )
-4.             continue;
-3.         if ( ( !mode_nodash && !strcmp( *argv, ""-debug"" ) ) || ( mode_nodash && !strcmp( *argv, ""debug"" ) ) )
-2.         {

/*Loop over all options tables*/

1.           ",Not Useful
/*Print syntax for each option*/,"-4.         if ( ploption_info[i].name )
-3.             fprintf( stderr, ""\n%s:"", ploption_info[i].name );
-2.         else
-1.             fputs( ""\nUser options:"", stderr );

/*Print syntax for each option*/

1.         col = 80;
2.         for ( tab =",Not Useful
/*3 spaces*/,"-2.             if ( col + len > 79 )
-1.             {

/*3 spaces*/

1.                 col = 3;
2.             }
3.             fprintf( stderr, "" [%s]"", tab->syntax );
4.             col += len;
5.         }
6.         fprintf( stderr, ""\n"" );
7.     ",Not Useful
"/*--------------------------------------------------------------------------
Help()

! Print long help message.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Not Useful
/*Loop over all options tables*/,"-5.         if ( *argv == NULL || *argv[0] == '\0' )
-4.             continue;
-3.         if ( ( !mode_nodash && !strcmp( *argv, ""-debug"" ) ) || ( mode_nodash && !strcmp( *argv, ""debug"" ) ) )
-2.         {

/*Loop over all options tables*/

1.           ",Not Useful
/*doubling*/,"-10.     if ( ( color_field_wp_alt = strstr( color_field_wp, ""0x"" ) ) == color_field_wp ||
-9.          ( color_field_wp_alt = strstr( color_field_wp, ""0X"" ) ) == color_field_wp )
-8.         color_field_wp += 2;
-7.     switch ( strlen( color_field_wp ) ",Not Useful
/*Declarations*/,"-8. #ifndef __PLSYM_H__
-7. #define __PLSYM_H__
-6. #define DEBUG
-5. #define NEED_PLDEBUG
-4. #include ""plplotP.h""
-3. #include <float.h>
-2. #include <ctype.h>
-1. #include ""plhershey-unicode.h""

/*Declarations*/

1. static short int   *fntlkup;
2. stat",Not Useful
/*Static function prototypes*/,"-6. #define PLMAXSTR    300
-5. #define STLEN       250
-4. static const char  font_types[] = ""nris"";
-3. static short       symbol_buffer[PLMAXSTR];
-2. static signed char xygrid[STLEN];
-1. int hershey2unicode( int in );

/*Static function prototypes*/
",Not Useful
/*Get the index in the lookup table and the unicode character*/,"-2.     if ( ( plsc->dev_text ) && ( plsc->dev_unicode ) && ( !plsc->dev_hrshsym ) )
-1.     {

/*Get the index in the lookup table and the unicode character*/

1.         idx = plhershey2unicode( ch );
2.         if ( 0 <= idx && idx <= number_of_entries",Not Useful
/*store 1st point !*/,"-10.             lx = refx + ROUND( xpmm * ( xform[0] * x + xform[1] * y ) );
-9.             ly = refy + ROUND( ypmm * ( xform[2] * x + xform[3] * y ) );
-8.             if ( penup == 1 )
-7.             {
-6.                 if ( l )
-5.                ",Not Useful
/*Initialize parameters.*/,"-6. static void
-5. pldeco( short int **symbol, PLINT *length, PLCHAR_VECTOR text )
-4. {
-3.     PLINT     ch, ifont = plsc->cfont, ig, j = 0, lentxt = (PLINT) strlen( text );
-2.     char      test, esc;
-1.     short int *sym = symbol_buffer;

/*Initia",Not Useful
/*search failed*/,"-10. {
-9.     PLINT base, str1ind, str2ind;
-8.     for ( base = 0; *( str1 + base ) != '\0'; base++ )
-7.     {
-6.         for ( str1ind = base, str2ind = 0; *( str2 + str2ind ) != '\0' &&
-5.               *( str2 + str2ind ) == *( str1 + str1ind ); s",Not Useful
"/*--------------------------------------------------------------------------
void plfontrel()

Release memory for fonts.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Not Useful
/*calculated*/,"-2.     PLFLT xmin, xmax, ymin, ymax, zmin, zmax, zscale;
-1.     PLFLT chrdef, chrht;

/*calculated*/

1.     PLFLT xpc, ypc, xrefpc, yrefpc;
2.     PLFLT epx1 = 0.0, epy1 = 0.0, epx2 = 0.0, epy2 = 0.0, epx3 = 0.0, epy3 = 0.0;
3.     PLFLT dispx, dispy, ",Not Useful
/*primary*/,"-10.     return ( NULL );
-9. }

/*primary*/

111",Not Useful
/*Static function prototypes.*/,"-4. #include ""plplotP.h""
-3. #ifdef MSDOS
-2. #pragma optimize("""",off)
-1. #endif

/*Static function prototypes.*/

1. static void
2. plcntr( PLF2EVAL_callback plf2eval, PLPointer plf2eval_data,
3.         PLINT nx, PLINT ny, PLINT kx, PLINT lx,
4.       ",Not Useful
/*Number of significant digits*/,"-2. static PLINT
-1.     limexp = 4;

/*Number of significant digits*/

1. static PLINT
2.     sigprec = 2;",Not Useful
/*new contour level*/,"-10. }
-9. static void
-8. realloc_line( CONT_LINE *line )
-7. {
-6.     if ( ( ( line->x = (PLFLT *) realloc( line->x,
-5.         (size_t) ( line->npts + LINE_ITEMS ) * sizeof ( PLFLT ) ) ) == NULL ) ||
-4.          ( ( line->y = (PLFLT *) realloc( line",Not Useful
/*and fill first element*/,"-4.         {
-3.             currline->next = alloc_line( );
-2.             currline       = currline->next;
-1.         }

/*and fill first element*/

1.         currline->x[0] = xx;
2.         currline->y[0] = yy;
3.         currline->npts = 1;
4.    ",Not Useful
/*Clear array for traversed squares*/,"-2.     plfloatlabel( flev, flabel, 30 );
-1.     plschr( 0.0, contlabel_size );

/*Clear array for traversed squares*/

1.     for ( kcol = kx; kcol < lx; kcol++ )
2.     {
3.         for ( krow = ky; krow < ly; krow++ )
4.         {
5.             ipts[",Not Useful
"/*Backwards compatibility, now that savestring has been removed from
   all `public' readline header files.*/","-10.    The GNU General Public License is often shipped with GNU software, and
-9.    is generally kept in a file called COPYING or LICENSE.  If you do not
-8.    have a copy of the license, write to the Free Software Foundation,
-7.    51 Franklin Street",Not Useful
"/*The list of alternate characters that can delimit a history search
   string.*/","-8. #if defined (HAVE_UNISTD_H)
-7. #  ifdef _MINIX
-6. #    include <sys/types.h>
-5. #  endif
-4. #  include <unistd.h>
-3. #endif
-2. #include ""history.h""
-1. #include ""histlib.h""

/*The list of alternate characters that can delimit a history search
  ",Not Useful
"/*Search the history for STRING, starting at history_offset.
   If DIRECTION < 0, then the search is through previous entries, else
   through subsequent.  If ANCHORED is non-zero, the string must
   appear at the beginning of a history line, otherwise, the string
   may appear anywhere in the line.  If the string is found, then
   current_history () is the history entry, and the value of this
   function is the offset in the line of that history entry that the
   string was found in.  Otherwise, nothing is changed, and a -1 is
   returned.*/","-2. char *history_search_delimiter_chars = (char *)NULL;
-1. static int history_search_internal PARAMS((const char *, int, int));

/*Search the history for STRING, starting at history_offset.
   If DIRECTION < 0, then the search is through previous entrie",Not Useful
/*Handle anchored searches first.*/,"-5.       if (string_len > line_index)
-4. 	{
-3. 	  NEXT_LINE ();
-2. 	  continue;
-1. 	}

/*Handle anchored searches first.*/

1.       if (anchored == ANCHORED_SEARCH)
2. 	{
3. 	  if (STREQN (string, line, string_len))
4. 	    {
5. 	      history_offse",Not Useful
"/*Search for STRING in the history list.  DIR is < 0 for searching
   backwards.  POS is an absolute index into the history list at
   which point to begin searching.*/","-7. int
-6. history_search_prefix (string, direction)
-5.      const char *string;
-4.      int direction;
-3. {
-2.   return (history_search_internal (string, direction, ANCHORED_SEARCH));
-1. }

/*Search for STRING in the history list.  DIR is < 0 for s",Not Useful
/*|| !string[i]*/,"-10. tilde_find_suffix (string)
-9.      const char *string;
-8. {
-7.   register int i, j, string_len;
-6.   register char **suffixes;
-5.   suffixes = tilde_additional_suffixes;
-4.   string_len = strlen (string);
-3.   for (i = 0; i < string_len; i++)
",Not Useful
/*Advance STRING to the starting tilde.*/,"-4.       if ((result_index + start + 1) > result_size)
-3. 	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));
-2.       strncpy (result + result_index, string, start);
-1.       result_index += start;

/*Advance STRING to the startin",Not Useful
"/*Make END be the index of one after the last character of the
	 username.*/","-1.       string += start;

/*Make END be the index of one after the last character of the
	 username.*/

1.       end = tilde_find_suffix (string);",Not Useful
"/*If both START and END are zero, we are all done.*/","-1.       end = tilde_find_suffix (string);

/*If both START and END are zero, we are all done.*/

1.       if (!start && !end)
2. 	break;",Not Useful
/*text.c -- text handling commands for readline.*/,"
/* text.c -- text handling commands for readline. */


/*text.c -- text handling commands for readline.*/

1. /* Copyright (C) 1987-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
"/*Fix up point so that it is within the line boundaries after killing
   text.  If FIX_MARK_TOO is non-zero, the mark is forced within line
   boundaries also.*/","-8.   if (_rl_doing_an_undo == 0)
-7.     rl_add_undo (UNDO_DELETE, from, to, text);
-6.   else
-5.     free (text);
-4.   rl_end -= diff;
-3.   rl_line_buffer[rl_end] = '\0';
-2.   return (diff);
-1. }

/*Fix up point so that it is within the line bounda",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*Move forward COUNT bytes.*/,"-10. */

/*Move forward COUNT bytes.*/

1. int
2. rl_forward_byte (count, key)
3.      int count, key;
4. {
5.   if (count < 0)
6.     return (rl_backward_byte (-count, key));
7.   if (count > 0)
8.     {
9.       int end = rl_point + count;
10. #if defin",Not Useful
/*Move forward COUNT characters.*/,"-10. 	  rl_ding ();
-9. 	}
-8.       else
-7. 	rl_point = end;
-6.     }
-5.   if (rl_end < 0)
-4.     rl_end = 0;
-3.   return 0;
-2. }
-1. #if defined (HANDLE_MULTIBYTE)

/*Move forward COUNT characters.*/

1. int
2. rl_forward_char (count, key)
3.     ",Not Useful
/*Move backward COUNT bytes.*/,"-6. int
-5. rl_forward (count, key)
-4.      int count, key;
-3. {
-2.   return (rl_forward_char (count, key));
-1. }

/*Move backward COUNT bytes.*/

1. int
2. rl_backward_byte (count, key)
3.      int count, key;
4. {
5.   if (count < 0)
6.     return (",Not Useful
/*Move backward COUNT characters.*/,"-10. 	  rl_ding ();
-9. 	}
-8.       else
-7. 	rl_point -= count;
-6.     }
-5.   if (rl_point < 0)
-4.     rl_point = 0;
-3.   return 0;
-2. }
-1. #if defined (HANDLE_MULTIBYTE)

/*Move backward COUNT characters.*/

1. int
2. rl_backward_char (count, key",Not Useful
/*Backwards compatibility.*/,"-7. int
-6. rl_forward_char (count, key)
-5.      int count, key;
-4. {
-3.   return (rl_forward_byte (count, key));
-2. }

/*Backwards compatibility.*/

1. int
2. rl_forward (count, key)
3.      int count, key;
4. {
5.   return (rl_forward_char (count, k",Not Useful
/*Move to the end of the line.*/,"-7. int
-6. rl_beg_of_line (count, key)
-5.      int count __attribute__((unused)), key __attribute__((unused));
-4. {
-3.   rl_point = 0;
-2.   return 0;
-1. }

/*Move to the end of the line.*/

1. int
2. rl_end_of_line (count, key)
3.      int count __a",Not Useful
/*Move forward a word.  We do what Emacs does.  Handles multibyte chars.*/,"-7. int
-6. rl_end_of_line (count, key)
-5.      int count __attribute__((unused)), key __attribute__((unused));
-4. {
-3.   rl_point = rl_end;
-2.   return 0;
-1. }

/*Move forward a word.  We do what Emacs does.  Handles multibyte chars.*/

1. int
2. rl",Not Useful
/*Move backward a word.  We do what Emacs does.  Handles multibyte chars.*/,"-10. 	{
-9. 	  c = _rl_char_value (rl_line_buffer, rl_point);
-8. 	  if (_rl_walphabetic (c) == 0)
-7. 	    break;
-6. 	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
-5. 	}
-4.       --count;
-3.     }
-2.   return 0;
-1. }

/*M",Not Useful
/*calls termcap function to clear screen*/,"-10.    the current line. */
-9. int
-8. rl_clear_screen (count, key)
-7.      int count, key;
-6. {
-5.   if (rl_explicit_arg)
-4.     {
-3.       rl_refresh_line (count, key);
-2.       return 0;
-1.     }

/*calls termcap function to clear screen*/

1.",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
"/*Insert the character C at the current location, moving point forward.
   If C introduces a multibyte sequence, we read the whole sequence and
   then insert the multibyte char into the line buffer.*/","-5. #ifdef HANDLE_MULTIBYTE
-4. static char pending_bytes[MB_LEN_MAX];
-3. static int pending_bytes_length = 0;
-2. static mbstate_t ps;
-1. #endif

/*Insert the character C at the current location, moving point forward.
   If C introduces a multibyte seq",Not Useful
"/*Overwrite the character at point (or next COUNT characters) with C.
   If C introduces a multibyte character sequence, read the entire sequence
   before starting the overwrite loop.*/","-10.     }
-9. #if defined (HANDLE_MULTIBYTE)
-8.   else
-7.     {
-6.       rl_insert_text (incoming);
-5.       stored_count = 0;
-4.     }
-3. #endif
-2.   return 0;
-1. }

/*Overwrite the character at point (or next COUNT characters) with C.
   If C i",Not Useful
/*Insert the next typed character verbatim.*/,"-10.   rl_end_undo_group ();
-9.   return 0;
-8. }
-7. int
-6. rl_insert (count, c)
-5.      int count, c;
-4. {
-3.   return (rl_insert_mode == RL_IM_INSERT ? _rl_insert_char (count, c)
-2.   					 : _rl_overwrite_char (count, c));
-1. }

/*Insert the ne",Not Useful
/*Insert a tab character.*/,"-10. #if defined (READLINE_CALLBACKS)
-9.   if (RL_ISSTATE (RL_STATE_CALLBACK))
-8.     {
-7.       _rl_callback_data = _rl_callback_data_alloc (count);
-6.       _rl_callback_func = _rl_insert_next_callback;
-5.       return (0);
-4.     }
-3. #endif
-2.",Not Useful
/*XXX*/,"-7. int
-6. rl_refresh_line (ignore1, ignore2)
-5.      int ignore1 __attribute__((unused)), ignore2 __attribute__((unused));
-4. {
-3.   int curr_line;
-2.   curr_line = _rl_current_display_line ();
-1.   _rl_move_vert (curr_line);

/*XXX*/

111",Not Useful
/*Rubout the character behind point.*/,"-9.   if (rl_point < rl_end)
-8.     {
-7.       opoint = rl_point;
-6.       _rl_insert_char (l, ' ');
-5.       rl_point = opoint;
-4.     }
-3.   rl_end_undo_group ();
-2.   return 0;
-1. }

/*Rubout the character behind point.*/

1. int
2. rl_rubout (",Not Useful
/*The erase-at-end-of-line hack is of questionable merit now.*/,"-10.   orig_point = rl_point;
-9.   if (count > 1 || rl_explicit_arg)
-8.     {
-7.       rl_backward_char (count, key);
-6.       rl_kill_text (orig_point, rl_point);
-5.     }
-4.   else if (MB_CUR_MAX == 1 || rl_byte_oriented)
-3.     {
-2.       c = r",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*I think that does it.*/,"-1.   rl_point = w2_end;

/*I think that does it.*/

1.   rl_end_undo_group ();
2.   free (word1);
3.   free (word2);
4.   return 0;
5. }",Not Useful
"/*Transpose the characters at point.  If point is at the end of the line,
   then transpose the characters before point.*/","-5.   rl_end_undo_group ();
-4.   free (word1);
-3.   free (word2);
-2.   return 0;
-1. }

/*Transpose the characters at point.  If point is at the end of the line,
   then transpose the characters before point.*/

1. int
2. rl_transpose_chars (count, key",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*A bindable command to set the mark.*/,"-9. int
-8. _rl_set_mark_at_pos (position)
-7.      int position;
-6. {
-5.   if (position > rl_end)
-4.     return -1;
-3.   rl_mark = position;
-2.   return 0;
-1. }

/*A bindable command to set the mark.*/

1. int
2. rl_set_mark (count, key)
3.      in",Not Useful
/******************************************************************/,"-2. _rl_callback_func_t *_rl_callback_func = 0;
-1. _rl_callback_generic_arg *_rl_callback_data = 0;

/******************************************************************/

111",Not Useful
/*Callback Readline Functions*/,"-4. _rl_callback_func_t *_rl_callback_func = 0;
-3. _rl_callback_generic_arg *_rl_callback_data = 0;

/*Callback Readline Functions*/

111",Not Useful
/******************************************************************/,"-2. _rl_callback_func_t *_rl_callback_func = 0;
-1. _rl_callback_generic_arg *_rl_callback_data = 0;

/******************************************************************/

111",Not Useful
"/*Allow using readline in situations where a program may have multiple
   things to handle at once, and dispatches them via select().  Call
   rl_callback_handler_install() with the prompt and a function to call
   whenever a complete line of input is ready.  The user must then
   call rl_callback_read_char() every time some input is available, and 
   rl_callback_read_char() will call the user's function with the complete
   text read in at each end of line.  The terminal is kept prepped and
   signals handled all the time, except during calls to the user's function.*/","-7. _rl_callback_func_t *_rl_callback_func = 0;
-6. _rl_callback_generic_arg *_rl_callback_data = 0;

/*Allow using readline in situations where a program may have multiple
   things to handle at once, and dispatches them via select().  Call
   rl_callbac",Not Useful
"/*This allows functions that simply need to read an additional
	     character (like quoted-insert) to register a function to be
	     called when input is available.  _rl_callback_data is simply a
	     pointer to a struct that has the argument count originally
	     passed to the registering function and space for any additional
	     parameters.*/","-10. 	  while ((eof == -1 || eof == -2) && RL_ISSTATE (RL_STATE_MULTIKEY) && _rl_kscxt && (_rl_kscxt->flags & KSEQ_DISPATCHED))
-9. 	    eof = _rl_dispatch_callback (_rl_kscxt);
-8. 	  if (RL_ISSTATE (RL_STATE_MULTIKEY) == 0)
-7. 	    {
-6. 	      _rl_int",Not Useful
/******************************************************************/,"
/* **************************************************************** */


/******************************************************************/

111",Not Useful
/*I-Search and Searching*/,"-2. /* **************************************************************** */
-1. /*								    */
/*			I-Search and Searching			    */

/*I-Search and Searching*/

111",Not Useful
/******************************************************************/,"
/* **************************************************************** */


/******************************************************************/

111",Not Useful
/*Normalize DIRECTION into 1 or -1.*/,"-2.   cxt->search_string = (char *)xmalloc (cxt->search_string_size = 128);
-1.   cxt->search_string[cxt->search_string_index = 0] = '\0';

/*Normalize DIRECTION into 1 or -1.*/

1.   cxt->direction = (direction >= 0) ? 1 : -1;
2.   cxt->sline = rl_line_b",Not Useful
/*Save the search string for possible later use.*/,"-2.   strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
-1.   rl_restore_prompt ();

/*Save the search string for possible later use.*/

1.   FREE (last_isearch_string);
2.   last_isearch_string = cxt->search_string;
3.   last_isearch_string_len = cxt-",Not Useful
/*Read a key and decide how to proceed.*/,"-7.   rl_clear_message ();
-6. }
-5. int
-4. _rl_search_getchar (cxt)
-3.      _rl_search_cxt *cxt;
-2. {
-1.   int c;

/*Read a key and decide how to proceed.*/

1.   RL_SETSTATE(RL_STATE_MOREINPUT);
2.   c = cxt->lastc = rl_read_key ();
3.   RL_UNSETSTA",Not Useful
/*XXX*/,"-10.     {
-9.       f = _rl_keymap[c].function;
-8.       if (f == rl_reverse_search_history)
-7. 	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -1 : -2;
-6.       else if (f == rl_forward_search_history)
-5. 	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -2 : -",Not Useful
"/*The characters in isearch_terminators (set from the user-settable
     variable isearch-terminators) are used to terminate the search but
     not subsequently execute the character as a command.  The default
     value is ""\033\012"" (ESC and C-J).*/","-2. 	cxt->lastc = -6;
-1.     }

/*The characters in isearch_terminators (set from the user-settable
     variable isearch-terminators) are used to terminate the search but
     not subsequently execute the character as a command.  The default
     value ",Not Useful
"/*C-H, DEL*/","-8.     case -2:
-7.       cxt->direction = -cxt->direction;
-6.       if (cxt->direction < 0)
-5. 	cxt->sflags |= SF_REVERSE;
-4.       else
-3. 	cxt->sflags &= ~SF_REVERSE;
-2.       break;

/*C-H, DEL*/

111",Not Useful
/*C-W*/,"-6.       rl_replace_line (cxt->lines[cxt->save_line], 0);
-5.       rl_point = cxt->save_point;
-4.       rl_mark = cxt->save_mark;
-3.       rl_restore_prompt();
-2.       rl_clear_message ();
-1.       return -1;

/*C-W*/

111",Not Useful
/*C-Y*/,"-10.       wlen = n - wstart + 1;
-9.       if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)
-8. 	{
-7. 	  cxt->search_string_size += wlen + 1;
-6. 	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
",Not Useful
/*Search the current line.*/,"-10. 	}
-9.       else
-8. #endif
-7. 	cxt->search_string[cxt->search_string_index++] = c;
-6.       cxt->search_string[cxt->search_string_index] = '\0';
-5.       break;
-4.     }
-3.   for (cxt->sflags &= ~(SF_FOUND|SF_FAILED);; )
-2.     {
-1.       li",Not Useful
"/*Search through the history looking for an interactively typed string.
   This is analogous to i-search.  We start the search in the current line.
   DIRECTION is which direction to search; >= 0 means forward, < 0 means
   backwards.*/","-10.      _rl_search_cxt *cxt;
-9.      int r;
-8. {
-7.   if (r >= 0)
-6.     _rl_isearch_fini (cxt);
-5.   _rl_scxt_dispose (cxt, 0);
-4.   _rl_iscxt = 0;
-3.   RL_UNSETSTATE(RL_STATE_ISEARCH);
-2.   return (r != 0);
-1. }

/*Search through the history ",Not Useful
/*Unix version of a hidden file.  Could be different on other systems.*/,"-10. #ifdef __STDC__
-9. typedef int QSFUNC (const void *, const void *);
-8. #else
-7. typedef int QSFUNC ();
-6. #endif
-5. #ifdef HAVE_LSTAT
-4. #  define LSTAT lstat
-3. #else
-2. #  define LSTAT stat
-1. #endif

/*Unix version of a hidden file.  Coul",Not Useful
/******************************************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
"/*Completion matching, from readline's point of view.*/","-10. static char **remove_duplicate_matches PARAMS((char **));
-9. static void insert_match PARAMS((char *, int, int, char *));
-8. static int append_to_match PARAMS((char *, int, int, int));
-7. static void insert_all_matches PARAMS((char **, int, char *",Not Useful
/******************************************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
"/*If non-zero, completions are printed horizontally in alphabetical order,
   like `ls -x'.*/","-1. int _rl_complete_mark_symlink_dirs = 0;

/*If non-zero, completions are printed horizontally in alphabetical order,
   like `ls -x'.*/

1. int _rl_print_completions_horizontally;",Not Useful
"/*If non-zero, don't match hidden files (filenames beginning with a `.' on
   Unix) when doing filename completion.*/","-5. #if defined (__MSDOS__) && !defined (__DJGPP__)
-4. int _rl_completion_case_fold = 1;
-3. #else
-2. int _rl_completion_case_fold;
-1. #endif

/*If non-zero, don't match hidden files (filenames beginning with a `.' on
   Unix) when doing filename compl",Not Useful
/*Non-zero means readline completion functions perform tilde expansion.*/,"-2. rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;
-1. rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;

/*Non-zero means readline completion functions perform tilde expansion.*/

1. int rl_complete_with_tilde_expans",Not Useful
"/*The basic list of characters that signal a break between words for the
   completer routine.  The contents of this variable is what breaks words
   in the shell, i.e. "" \t\n\""\\'`@$><=""*/","-2. int rl_completion_query_items = 100;
-1. int _rl_page_completions = 1;

/*The basic list of characters that signal a break between words for the
   completer routine.  The contents of this variable is what breaks words
   in the shell, i.e. "" \t\n\""\\",Not Useful
/*})*/,"-5. int rl_completion_query_items = 100;
-4. int _rl_page_completions = 1;

/*})*/

111",Not Useful
/*List of basic quoting characters.*/,"-6. int rl_completion_query_items = 100;
-5. int _rl_page_completions = 1;

/*List of basic quoting characters.*/

111",Not Useful
"/*Function to call to decide whether or not a word break character is
   quoted.  If a character is quoted, it does not break words for the
   completer.*/","-1. rl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;

/*Function to call to decide whether or not a word break character is
   quoted.  If a character is quoted, it does not break words for the
   completer.*/

1. rl_linebuf_",Not Useful
"/*Character appended to completed words when at the end of the line.  The
   default is a space.*/","-1. int rl_completion_suppress_append = 0;

/*Character appended to completed words when at the end of the line.  The
   default is a space.*/

1. int rl_completion_append_character = ' ';",Not Useful
"/*If non-zero, inhibit completion (temporarily).*/","-1. int rl_completion_mark_symlink_dirs;

/*If non-zero, inhibit completion (temporarily).*/

1. int rl_inhibit_completion;",Not Useful
/*************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
/*Bindable completion functions*/,"-3. static int completion_changed_buffer;

/*Bindable completion functions*/

111",Not Useful
/*************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
"/*Complete the word at or before point.  You have supplied the function
   that does the initial simple matching selection algorithm (see
   rl_completion_matches ()).  The default is to do filename completion.*/","-6. static int completion_changed_buffer;

/*Complete the word at or before point.  You have supplied the function
   that does the initial simple matching selection algorithm (see
   rl_completion_matches ()).  The default is to do filename completion.*/",Not Useful
/*List the possible completions.  See description of rl_complete ().*/,"-10.     return (_rl_insert_char (ignore, invoking_key));
-9.   else if (rl_last_func == rl_complete && !completion_changed_buffer)
-8.     return (rl_complete_internal ('?'));
-7.   else if (_rl_complete_show_all)
-6.     return (rl_complete_internal ('!",Not Useful
/************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
/*Completion utility functions*/,"-10.     return '?';
-9.   else if (_rl_complete_show_all)
-8.     return '!';
-7.   else if (_rl_complete_show_unmodified)
-6.     return '@';
-5.   else
-4.     return TAB;
-3. }

/*Completion utility functions*/

111",Not Useful
/************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
"/*Set default values for readline word completion.  These are the variables
   that application completion functions can change or inspect.*/","-10.   else if (_rl_complete_show_unmodified)
-9.     return '@';
-8.   else
-7.     return TAB;
-6. }

/*Set default values for readline word completion.  These are the variables
   that application completion functions can change or inspect.*/

1. stati",Not Useful
"/*If the user wants to TRY to complete, but then wants to give
     up and use the default completion function, they set the
     variable rl_attempted_completion_function.*/","-10. static char **
-9. gen_completion_matches (text, start, end, our_func, found_quote, quote_char)
-8.      char *text;
-7.      int start, end;
-6.      rl_compentry_func_t *our_func;
-5.      int found_quote, quote_char;
-4. {
-3.   char **matches;
-2",Not Useful
"/*Filter out duplicates in MATCHES.  This frees up the strings in
   MATCHES.*/","-3.   matches = rl_completion_matches (text, our_func);
-2.   return matches;  
-1. }

/*Filter out duplicates in MATCHES.  This frees up the strings in
   MATCHES.*/

1. static char **
2. remove_duplicate_matches (matches)
3.      char **matches;
4. {
5.",Not Useful
/*Sort the items.*/,"-8. static char **
-7. remove_duplicate_matches (matches)
-6.      char **matches;
-5. {
-4.   char *lowest_common;
-3.   int i, j, newlen;
-2.   char dead_slot;
-1.   char **temp_array;

/*Sort the items.*/

1.   for (i = 0; matches[i]; i++)
2.     ;",Not Useful
"/*Sort the array without matches[0], since we need it to
     stay in place no matter what.*/","-2.   for (i = 0; matches[i]; i++)
-1.     ;

/*Sort the array without matches[0], since we need it to
     stay in place no matter what.*/

1.   if (i)
2.     qsort (matches+1, i-1, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);",Not Useful
/*Remember the lowest common denominator for it may be unique.*/,"-2.   if (i)
-1.     qsort (matches+1, i-1, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);

/*Remember the lowest common denominator for it may be unique.*/

1.   lowest_common = savestring (matches[0]);
2.   for (i = newlen = 0; matches[i + 1]; i+",Not Useful
/*Place the lowest common denominator back in [0].*/,"-10.      Copy all the non-dead entries into a new array. */
-9.   temp_array = (char **)xmalloc ((3 + newlen) * sizeof (char *));
-8.   for (i = j = 1; matches[i]; i++)
-7.     {
-6.       if (matches[i] != (char *)&dead_slot)
-5. 	temp_array[j++] = matc",Not Useful
"/*If there were multiple matches, but none matched up to even the
     first character, and the user typed something, use that as the
     value of matches[0].*/","-10. 		  si += v - 1;
-9. 	      }
-8. 	    else
-7. #endif
-6. 	    if (c1 != c2)
-5. 	      break;
-4. 	}
-3.       if (low > si)
-2. 	low = si;
-1.     }

/*If there were multiple matches, but none matched up to even the
     first character, and the u",Not Useful
"/*If we removed some matches, recompute the common prefix.*/","-10. 	;
-9.       (void)(*rl_ignore_some_completions_function) (matches);
-8.       if (matches == 0 || matches[0] == 0)
-7. 	{
-6. 	  FREE (matches);
-5. 	  *matchesp = (char **)0;
-4. 	  return 0;
-3.         }
-2.       else
-1. 	{

/*If we removed som",Not Useful
/*How many items of MAX length can we fit in the screen window?*/,"-10.    of strings, in argv format, LEN is the number of strings in MATCHES,
-9.    and MAX is the length of the longest string in MATCHES. */
-8. void
-7. rl_display_match_list (matches, len, max)
-6.      char **matches;
-5.      int len, max;
-4. {
-3.",Not Useful
"/*Display MATCHES, a list of matching filenames in argv format.  This
   handles the simple case -- a single match -- first.  If there is more
   than one match, we compute the number of strings in the list and the
   length of the longest string, which will be needed by the display
   function.  If the application wants to handle displaying the list of
   matches itself, it sets RL_COMPLETION_DISPLAY_MATCHES_HOOK to the
   address of a function, and we just call it.  If we're handling the
   display ourselves, we just call rl_display_match_list.  We also check
   that the list of matches doesn't exceed the user-settable threshold,
   and ask the user if he wants to see the list if there are more matches
   than RL_COMPLETION_QUERY_ITEMS.*/","-10. 		    }
-9. 		}
-8. 	      else
-7. 		for (k = 0; k < max - printed_len; k++)
-6. 		  putc (' ', rl_outstream);
-5. 	    }
-4. 	}
-3.       rl_crlf ();
-2.     }
-1. }

/*Display MATCHES, a list of matching filenames in argv format.  This
   handles ",Not Useful
/*&& rl_completion_suppress_append == 0*/,"-10.     temp_string[temp_string_index++] = rl_completion_append_character;
-9.   temp_string[temp_string_index++] = '\0';
-8.   if (rl_filename_completion_desired)
-7.     {
-6.       filename = tilde_expand (text);
-5.       s = (nontrivial_match && rl_",Not Useful
"/*nontrivial_lcd is set if the common prefix adds something to the word
     being completed.*/","-5.     quote_char = _rl_find_completion_word (&found_quote, &delimiter);
-4.   start = rl_point;
-3.   rl_point = end;
-2.   text = rl_copy_text (start, end);
-1.   matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);

",Not Useful
"/*If we are matching filenames, the attempted completion function will
     have set rl_filename_completion_desired to a non-zero value.  The basic
     rl_filename_completion_function does this.*/","-10.   nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
-9.   free (text);
-8.   if (matches == 0)
-7.     {
-6.       rl_ding ();
-5.       FREE (saved_line_buffer);
-4.       completion_changed_buffer = 0;
-3.       RL_UNSETSTATE(RL_STATE_COM",Not Useful
/*Insert the first match with proper quoting.*/,"-10.       FREE (saved_line_buffer);
-9.       completion_changed_buffer = 0;
-8.       RL_UNSETSTATE(RL_STATE_COMPLETING);
-7.       return (0);
-6.     }
-5.   switch (what_to_do)
-4.     {
-3.     case TAB:
-2.     case '!':
-1.     case '@':

/*Insert",Not Useful
/***************************************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
/*The list of matches.*/,"-1.   int match_list_size;

/*The list of matches.*/

1.   char **match_list;",Not Useful
/*Number of matches actually found.*/,"-1.   char **match_list;

/*Number of matches actually found.*/

1.   int matches;",Not Useful
/*Temporary string binder.*/,"-1.   int matches;

/*Temporary string binder.*/

1.   char *string;
2.   matches = 0;
3.   match_list_size = 10;
4.   match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
5.   match_list[1] = (char *)NULL;
6.   while ((string = (*entr",Not Useful
"/*A completion function for usernames.
   TEXT contains a partial username preceded by a random
   character (usually `~').*/","-6.     {
-5.       free (match_list);
-4.       match_list = (char **)NULL;
-3.     }
-2.   return (match_list);
-1. }

/*A completion function for usernames.
   TEXT contains a partial username preceded by a random
   character (usually `~').*/

1. char",Not Useful
"/*Okay, now we write the entry_function for filename completion.  In the
   general case.  Note that completion in the shell is a little different
   because of all the pathnames that must be followed when looking up the
   completion for a command.*/","-1. }

/*Okay, now we write the entry_function for filename completion.  In the
   general case.  Note that completion in the shell is a little different
   because of all the pathnames that must be followed when looking up the
   completion for a command",Not Useful
"/*If we don't have any state, then do some initialization.*/","-10.      int state;
-9. {
-8.   static DIR *directory = (DIR *)NULL;
-7.   static char *filename = (char *)NULL;
-6.   static char *dirname = (char *)NULL;
-5.   static char *users_dirname = (char *)NULL;
-4.   static int filename_len;
-3.   char *temp;
",Not Useful
"/*If we were interrupted before closing the directory or reading
	 all of its contents, close it.*/","-2.   if (state == 0)
-1.     {

/*If we were interrupted before closing the directory or reading
	 all of its contents, close it.*/

1.       if (directory)
2. 	{
3. 	  closedir (directory);
4. 	  directory = (DIR *)NULL;
5. 	}
6.       FREE (dirname);
7",Not Useful
"/*The directory completion hook should perform any necessary
	 dequoting.*/","-9.       users_dirname = savestring (dirname);
-8.       if (*dirname == '~')
-7. 	{
-6. 	  temp = tilde_expand (dirname);
-5. 	  free (dirname);
-4. 	  dirname = temp;
-3. 	}
-2.       if (rl_directory_rewrite_hook)
-1. 	(*rl_directory_rewrite_hook) (&d",Not Useful
/*Now dequote a non-null filename.*/,"-5. 	  temp = (*rl_filename_dequoting_function) (users_dirname, rl_completion_quote_character);
-4. 	  free (users_dirname);
-3. 	  users_dirname = temp;
-2. 	}
-1.       directory = opendir (dirname);

/*Now dequote a non-null filename.*/

1.       if (f",Not Useful
"/*Now that we have some state, we can read the directory.*/","-10. 	  filename = temp;
-9. 	}
-8.       filename_len = strlen (filename);
-7.       rl_filename_completion_desired = 1;
-6.     }

/*Now that we have some state, we can read the directory.*/

1.   entry = (struct dirent *)NULL;
2.   while (directory && ",Not Useful
"/*Special case for no filename.  If the user has disabled the
         `match-hidden-files' variable, skip filenames beginning with `.'.
	 All other entries except ""."" and "".."" match.*/","-3.   entry = (struct dirent *)NULL;
-2.   while (directory && (entry = readdir (directory)))
-1.     {

/*Special case for no filename.  If the user has disabled the
         `match-hidden-files' variable, skip filenames beginning with `.'.
	 All other e",Not Useful
"/*Otherwise, if these match up to the length of filename, then
	     it is a match.*/","-10. 	{
-9. 	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (entry->d_name))
-8. 	    continue;
-7. 	  if (entry->d_name[0] != '.' ||
-6. 	       (entry->d_name[1] &&
-5. 		 (entry->d_name[1] != '.' || entry->d_name[2])))
-4. 	    break;
-3. 	}
-2.     ",Not Useful
/*Make sure that temp has a trailing slash here.*/,"-10. 	        {
-9. 	          temp[dirlen++] = '/';
-8. 	          temp[dirlen] = '\0';
-7. 	        }
-6. 	    }
-5. 	  else
-4. 	    {
-3. 	      dirlen = strlen (users_dirname);
-2. 	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
-1. 	 ",Not Useful
"/*An initial implementation of a menu completion function a la tcsh.  The
   first time (if the last readline command was not rl_menu_complete), we
   generate the list of matches.  This code is very similar to the code in
   rl_complete_internal -- there should be a way to combine the two.  Then,
   for each item in the list of matches, we insert the match in an undoable
   fashion, with the appropriate character appended (this happens on the
   second and subsequent consecutive calls to rl_menu_complete).  When we
   hit the end of the match list, we restore the original unmatched text,
   ring the bell, and reset the counter to zero.*/","-10. 	      if (users_dirname[dirlen - 1] != '/')
-9. 		temp[dirlen++] = '/';
-8. 	    }
-7. 	  strcpy (temp + dirlen, entry->d_name);
-6. 	}
-5.       else
-4. 	temp = savestring (entry->d_name);
-3.       return (temp);
-2.     }
-1. }

/*An initial imp",Not Useful
"/*Clean up from previous call, if any.*/","-2.   if (rl_last_func != rl_menu_complete)
-1.     {

/*Clean up from previous call, if any.*/

1.       FREE (orig_text);
2.       if (matches)
3. 	_rl_free_match_list (matches);
4.       match_list_index = match_list_size = 0;
5.       matches = (char ",Not Useful
"/*matches[0] is lcd if match_list_size > 1, but the circular buffer
	 code below should take care of it.*/","-10.     	  rl_ding ();
-9. 	  FREE (matches);
-8. 	  matches = (char **)0;
-7. 	  FREE (orig_text);
-6. 	  orig_text = (char *)0;
-5.     	  completion_changed_buffer = 0;
-4.           return (0);
-3. 	}
-2.       for (match_list_size = 0; matches[match",Not Useful
"/*Now we have the list of matches.  Replace the text between
     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
     matches[match_list_index], and add any necessary closing char.*/","-1.     }

/*Now we have the list of matches.  Replace the text between
     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
     matches[match_list_index], and add any necessary closing char.*/

1.   if (matches == 0 || match_list_size == 0)",Not Useful
/*kill.c -- kill ring management.*/,"
/* kill.c -- kill ring management. */


/*kill.c -- kill ring management.*/

1. /* Copyright (C) 1994 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Not Useful
/*HAVE_UNISTD_H*/,"-10.    GNU General Public License for more details.
-9.    The GNU General Public License is often shipped with GNU software, and
-8.    is generally kept in a file called COPYING or LICENSE.  If you do not
-7.    have a copy of the license, write to the",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/******************************************************************/,"-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/*Killing Mechanism*/,"-6. #include ""readline.h""
-5. #include ""history.h""
-4. #include ""rlprivate.h""
-3. #include ""xmalloc.h""

/*Killing Mechanism*/

111",Not Useful
/******************************************************************/,"-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/*What we assume for a max number of kills.*/,"-9. #include ""readline.h""
-8. #include ""history.h""
-7. #include ""rlprivate.h""
-6. #include ""xmalloc.h""

/*What we assume for a max number of kills.*/

1. #define DEFAULT_MAX_KILLS 10",Not Useful
"/*How to say that you only want to save a certain amount
   of kill material.*/","-5. static int rl_kill_ring_length;
-4. static int _rl_copy_to_kill_ring PARAMS((char *, int));
-3. static int region_kill_internal PARAMS((int));
-2. static int _rl_copy_word_as_kill PARAMS((int, int));
-1. static int rl_yank_nth_arg_internal PARAMS((int",Not Useful
"/*First, find the slot to work with.*/","-10.    This uses TEXT directly, so the caller must not free it.  If APPEND is
-9.    non-zero, and the last command was a kill, the text is appended to the
-8.    current kill ring slot, otherwise prepended. */
-7. static int
-6. _rl_copy_to_kill_ring (t",Not Useful
/*Get a new slot.*/,"-2.   if (_rl_last_command_was_kill == 0)
-1.     {

/*Get a new slot.*/

1.       if (rl_kill_ring == 0)
2. 	{",Not Useful
"/*We have to add a new slot on the end, unless we have
	     exceeded the max limit for remembering kills.*/","-6. 	  rl_kill_ring = (char **)
-5. 	    xmalloc (((rl_kill_ring_length = 1) + 1) * sizeof (char *));
-4. 	  rl_kill_ring[slot = 0] = (char *)NULL;
-3. 	}
-2.       else
-1. 	{

/*We have to add a new slot on the end, unless we have
	     exceeded the max",Not Useful
"/*If the last command was a kill, prepend or append.*/","-10. 	  else
-9. 	    {
-8. 	      slot = rl_kill_ring_length += 1;
-7. 	      rl_kill_ring = (char **)xrealloc (rl_kill_ring, slot * sizeof (char *));
-6. 	    }
-5. 	  rl_kill_ring[--slot] = (char *)NULL;
-4. 	}
-3.     }
-2.   else
-1.     slot = rl_ki",Not Useful
"/*Now REMEMBER!  In order to do prepending or appending correctly, kill
   commands always make rl_point's original position be the FROM argument,
   and rl_point's extent be the TO argument.*/","-5.   rl_delete_text (from, to);
-4.   _rl_copy_to_kill_ring (text, from < to);
-3.   _rl_last_command_was_kill++;
-2.   return 0;
-1. }

/*Now REMEMBER!  In order to do prepending or appending correctly, kill
   commands always make rl_point's original p",Not Useful
/******************************************************************/,"-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/*Killing Commands*/,"-10.   rl_delete_text (from, to);
-9.   _rl_copy_to_kill_ring (text, from < to);
-8.   _rl_last_command_was_kill++;
-7.   return 0;
-6. }

/*Killing Commands*/

111",Not Useful
/******************************************************************/,"-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
"/*Vi mode always inserts a space before yanking the argument, and it
     inserts it right *after* rl_point.*/","-10.   arg = history_arg_extract (count, count, entry->line);
-9.   if (!arg || !*arg)
-8.     {
-7.       rl_ding ();
-6.       FREE (arg);
-5.       return -1;
-4.     }
-3.   rl_begin_undo_group ();
-2.   _rl_set_mark_at_pos (rl_point);
-1. #if defined",Not Useful
/*VI_MODE*/,"-10.     }
-9.   arg = history_arg_extract (count, count, entry->line);
-8.   if (!arg || !*arg)
-7.     {
-6.       rl_ding ();
-5.       FREE (arg);
-4.       return -1;
-3.     }
-2.   rl_begin_undo_group ();
-1.   _rl_set_mark_at_pos (rl_point);
#if d",Not Useful
"/*Yank the last argument from the previous history line.  This `knows'
   how rl_yank_nth_arg treats a count of `$'.  With an argument, this
   behaves the same as rl_yank_nth_arg.*/","-6. int
-5. rl_yank_nth_arg (count, ignore)
-4.      int count, ignore;
-3. {
-2.   return (rl_yank_nth_arg_internal (count, ignore, 0));
-1. }

/*Yank the last argument from the previous history line.  This `knows'
   how rl_yank_nth_arg treats a count o",Not Useful
/*__CYGWIN__*/,"
#if defined (__CYGWIN__)



/*__CYGWIN__*/

1. #include <windows.h>
2. int
3. rl_paste_from_clipboard (count, key)
4.      int count, key;
5. {
6.   char *data, *ptr;
7.   int len;
8.   if (OpenClipboard (NULL) == 0)
9.     return (0);
10.   data = (char *)GetClipboardData (CF_TEXT);",Not Useful
/*used only in this file*/,"-9. Keymap rl_binding_keymap;
-8. static char *_rl_read_file PARAMS((char *, size_t *));
-7. static void _rl_init_file_error PARAMS((const char *));
-6. static int _rl_read_init_file PARAMS((const char *, int));
-5. static int glean_key_from_name PARAMS((",Not Useful
/*Unbind all keys bound to FUNCTION in MAP.*/,"-7. int
-6. rl_unbind_key_in_map (key, map)
-5.      int key;
-4.      Keymap map;
-3. {
-2.   return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
-1. }

/*Unbind all keys bound to FUNCTION in MAP.*/

1. int
2. rl_unbind_function_in_map (fu",Not Useful
/*Handle \C- and \M- prefixes.*/,"-10.      int *len;
-9. {
-8.   register int i, c, l, temp;
-7.   for (i = l = 0; (c = seq[i]); i++)
-6.     {
-5.       if (c == '\\')
-4. 	{
-3. 	  c = seq[++i];
-2. 	  if (c == 0)
-1. 	    break;

/*Handle \C- and \M- prefixes.*/

1. 	  if ((c == 'C' |",Not Useful
/*ESC is meta-prefix*/,"-2. 	      if (strncmp (&seq[i], ""C-\\M-"", 5) == 0)
-1. 		{

/*ESC is meta-prefix*/

1. 		  i += 5;
2. 		  array[l++] = CTRL (_rl_to_upper (seq[i]));
3. 		  if (seq[i] == '\0')
4. 		    i--;
5. 		}
6. 	      else if (c == 'M')
7. 		{",Not Useful
/*seq[i] == '-'*/,"-7. 		  i += 5;
-6. 		  array[l++] = CTRL (_rl_to_upper (seq[i]));
-5. 		  if (seq[i] == '\0')
-4. 		    i--;
-3. 		}
-2. 	      else if (c == 'M')
-1. 		{

/*seq[i] == '-'*/

111",Not Useful
/*ESC is meta-prefix*/,"-2. 	      if (strncmp (&seq[i], ""C-\\M-"", 5) == 0)
-1. 		{

/*ESC is meta-prefix*/

1. 		  i += 5;
2. 		  array[l++] = CTRL (_rl_to_upper (seq[i]));
3. 		  if (seq[i] == '\0')
4. 		    i--;
5. 		}
6. 	      else if (c == 'M')
7. 		{",Not Useful
"/*Translate other backslash-escaped characters.  These are the
	     same escape sequences that bash's `echo' and `printf' builtins
	     handle, with the addition of \d -> RUBOUT.  A backslash
	     preceding a character that is not special is stripped.*/","-4. 		  array[l++] = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
-3. 		}
-2. 	      continue;
-1. 	    }

/*Translate other backslash-escaped characters.  These are the
	     same escape sequences that bash's `echo' and `printf' builtins
	   ",Not Useful
/*auto-increment in for loop*/,"-10. 	      array[l++] = 0x0B;
-9. 	      break;
-8. 	    case '\\':
-7. 	      array[l++] = '\\';
-6. 	      break;
-5. 	    case '0': case '1': case '2': case '3':
-4. 	    case '4': case '5': case '6': case '7':
-3. 	      i++;
-2. 	      for (temp = 2",Not Useful
/*auto-increment in for loop*/,"-10. 	      array[l++] = 0x0B;
-9. 	      break;
-8. 	    case '\\':
-7. 	      array[l++] = '\\';
-6. 	      break;
-5. 	    case '0': case '1': case '2': case '3':
-4. 	    case '4': case '5': case '6': case '7':
-3. 	      i++;
-2. 	      for (temp = 2",Not Useful
/*Default the filename.*/,"-10.      1. the filename used for the previous call
-9.      2. the value of the shell variable `INPUTRC'
-8.      3. ~/.inputrc
-7.      4. /etc/inputrc
-6.    If the file existed and could be opened and read, 0 is returned,
-5.    otherwise errno is re",Not Useful
/*Try to read DEFAULT_INPUTRC; fall back to SYS_INPUTRC on failure*/,"-7.   if (filename == 0)
-6.     filename = last_readline_init_file;
-5.   if (filename == 0)
-4.     filename = sh_get_env_value (""INPUTRC"");
-3.   if (filename == 0 || *filename == 0)
-2.     {
-1.       filename = DEFAULT_INPUTRC;

/*Try to read DEFAUL",Not Useful
/*Find the end of this line.*/,"-5.   current_readline_init_lineno = 1;
-4.   line = buffer;
-3.   end = buffer + file_size;
-2.   while (line < end)
-1.     {

/*Find the end of this line.*/

1.       for (i = 0; line + i != end && line[i] != '\n'; i++);
2. #if defined (__CYGWIN__)",Not Useful
/*``Be liberal in what you accept.''*/,"-2.       for (i = 0; line + i != end && line[i] != '\n'; i++);
-1. #if defined (__CYGWIN__)

/*``Be liberal in what you accept.''*/

1.       if (line[i] == '\n' && line[i-1] == '\r')
2. 	line[i - 1] = '\0';
3. #endif",Not Useful
/*Mark end of line.*/,"-3.       if (line[i] == '\n' && line[i-1] == '\r')
-2. 	line[i - 1] = '\0';
-1. #endif

/*Mark end of line.*/

1.       line[i] = '\0';",Not Useful
/*Skip leading whitespace.*/,"-1.       line[i] = '\0';

/*Skip leading whitespace.*/

1.       while (*line && whitespace (*line))
2.         {
3. 	  line++;
4. 	  i--;
5.         }",Not Useful
"/*If the line is not a comment, then parse it.*/","-5.       while (*line && whitespace (*line))
-4.         {
-3. 	  line++;
-2. 	  i--;
-1.         }

/*If the line is not a comment, then parse it.*/

1.       if (*line && *line != '#')
2. 	rl_parse_and_bind (line);",Not Useful
/*Move to the next line.*/,"-2.       if (*line && *line != '#')
-1. 	rl_parse_and_bind (line);

/*Move to the next line.*/

1.       line += i + 1;
2.       current_readline_init_lineno++;
3.     }
4.   free (buffer);
5.   currently_reading_init_file = 0;
6.   return (0);
7. }
8. s",Not Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

/******************************************************************/

111",Not Useful
/*Isolate first argument.*/,"-2.   if (_rl_parsing_conditionalized_out)
-1.     return 0;

/*Isolate first argument.*/

1.   for (i = 0; args[i] && !whitespace (args[i]); i++);
2.   if (args[i])
3.     args[i++] = '\0';",Not Useful
"/*Check to see if the first word in ARGS is the same as the
     value stored in rl_readline_name.*/","-10.       int mode;
-9.       if (_rl_stricmp (args + 5, ""emacs"") == 0)
-8. 	mode = emacs_mode;
-7.       else if (_rl_stricmp (args + 5, ""vi"") == 0)
-6. 	mode = vi_mode;
-5.       else
-4. 	mode = no_mode;
-3.       _rl_parsing_conditionalized_out = mod",Not Useful
"/*Terminate a conditional, popping the value of
   _rl_parsing_conditionalized_out from the stack.*/","-3.   _rl_parsing_conditionalized_out = !_rl_parsing_conditionalized_out;
-2.   return 0;
-1. }

/*Terminate a conditional, popping the value of
   _rl_parsing_conditionalized_out from the stack.*/

1. static int
2. parser_endif (args)
3.      char *args ",Not Useful
"/*Handle a parser directive.  STATEMENT is the line of the directive
   without any leading `$'.*/","-10. static struct {
-9.   const char *name;
-8.   _rl_parser_func_t *function;
-7. } parser_directives [] = {
-6.   { ""if"", parser_if },
-5.   { ""endif"", parser_endif },
-4.   { ""else"", parser_else },
-3.   { ""include"", parser_include },
-2.   { (char *)",Not Useful
/*Skip whitespace.*/,"-7. static int
-6. handle_parser_directive (statement)
-5.      char *statement;
-4. {
-3.   register int i;
-2.   char *directive, *args;

/*Skip whitespace.*/

1.   for (i = 0; whitespace (statement[i]); i++);
2.   directive = &statement[i];
3.   for (;",Not Useful
/*Mark the end of the command (or keyname).*/,"-2.   for (; (c = string[i]) && c != ':' && c != ' ' && c != '\t'; i++ );
-1.   equivalency = (c == ':' && string[i + 1] == '=');

/*Mark the end of the command (or keyname).*/

1.   if (string[i])
2.     string[i++] = '\0';",Not Useful
/*Make VAR point to start of variable name.*/,"-4.   if (_rl_stricmp (string, ""set"") == 0)
-3.     {
-2.       char *var, *value, *e;
-1.       var = string + i;

/*Make VAR point to start of variable name.*/

1.       while (*var && whitespace (*var)) var++;",Not Useful
/*Make VALUE point to start of value string.*/,"-1.       while (*var && whitespace (*var)) var++;

/*Make VALUE point to start of value string.*/

1.       value = var;
2.       while (*value && !whitespace (*value)) value++;
3.       if (*value)
4. 	*value++ = '\0';
5.       while (*value && whitespa",Not Useful
/*Skip any whitespace between keyname and funname.*/,"-6. 	  if (*e && e >= value)
-5. 	    *e = '\0';
-4. 	}
-3.       rl_variable_bind (var, value);
-2.       return 0;
-1.     }

/*Skip any whitespace between keyname and funname.*/

1.   for (; string[i] && whitespace (string[i]); i++);
2.   funname = &st",Not Useful
"/*Now isolate funname.
     For straight function names just look for whitespace, since
     that will signify the end of the string.  But this could be a
     macro definition.  In that case, the string is quoted, so skip
     to the matching delimiter.  We allow the backslash to quote the
     delimiter characters in the macro body.*/","-2.   for (; string[i] && whitespace (string[i]); i++);
-1.   funname = &string[i];

/*Now isolate funname.
     For straight function names just look for whitespace, since
     that will signify the end of the string.  But this could be a
     macro defi",Not Useful
/*Advance to the end of the string.*/,"-10. 	    {
-9. 	      passc = 1;
-8. 	      continue;
-7. 	    }
-6. 	  if (c == delimiter)
-5. 	    break;
-4. 	}
-3.       if (c)
-2. 	i++;
-1.     }

/*Advance to the end of the string.*/

1.   for (; string[i] && !whitespace (string[i]); i++);",Not Useful
/*No extra whitespace at the end of the string.*/,"-1.   for (; string[i] && !whitespace (string[i]); i++);

/*No extra whitespace at the end of the string.*/

1.   string[i] = '\0';",Not Useful
"/*Handle equivalency bindings here.  Make the left-hand side be exactly
     whatever the right-hand evaluates to, including keymaps.*/","-1.   string[i] = '\0';

/*Handle equivalency bindings here.  Make the left-hand side be exactly
     whatever the right-hand evaluates to, including keymaps.*/

1.   if (equivalency)
2.     {
3.       return 0;
4.     }",Not Useful
/*Remove the delimiting quotes from each end of FUNNAME.*/,"-3.       if (*funname == '\'' || *funname == '""')
-2. 	{
-1. 	  j = strlen (funname);

/*Remove the delimiting quotes from each end of FUNNAME.*/

1. 	  if (j && funname[j - 1] == *funname)
2. 	    funname[j - 1] = '\0';
3. 	  rl_macro_bind (seq, &funnam",Not Useful
"/*Ugly, but working hack to keep prefix-meta around.*/","-10.   if (*funname == '\'' || *funname == '""')
-9.     {
-8.       char useq[2];
-7.       int fl = strlen (funname);
-6.       useq[0] = key; useq[1] = '\0';
-5.       if (fl && funname[fl - 1] == *funname)
-4. 	funname[fl - 1] = '\0';
-3.       rl_macr",Not Useful
"/*Simple structure for boolean readline variables (i.e., those that can
   have one of two values; either ""On"" or 1 for truth, or ""Off"" or 0 for
   false.*/","-4.   else
-3.     rl_bind_key (key, rl_named_function (funname));
-2.   return 0;
-1. }

/*Simple structure for boolean readline variables (i.e., those that can
   have one of two values; either ""On"" or 1 for truth, or ""Off"" or 0 for
   false.*/

1. #def",Not Useful
"/*Hooks for handling special boolean variables, where a
   function needs to be called or another variable needs
   to be changed when they're changed.*/","-10. static int
-9. find_boolean_var (name)
-8.      const char *name;
-7. {
-6.   register int i;
-5.   for (i = 0; boolean_varlist[i].name; i++)
-4.     if (_rl_stricmp (name, boolean_varlist[i].name) == 0)
-3.       return i;
-2.   return -1;
-1. }

/*",Not Useful
/*Isolate the value and translate it into a character string.*/,"-10.   return 0;
-9. }
-8. static int
-7. sv_isrchterm (value)
-6.      const char *value;
-5. {
-4.   int beg, end, delim;
-3.   char *v;
-2.   if (value == 0)
-1.     return 1;

/*Isolate the value and translate it into a character string.*/

1.   v = s",Not Useful
/*Auxiliary functions to manage keymaps.*/,"-1. }

/*Auxiliary functions to manage keymaps.*/

1. static struct {
2.   const char *name;
3.   Keymap map;
4. } keymap_names[] = {
5.   { ""emacs"", emacs_standard_keymap },
6.   { ""emacs-standard"", emacs_standard_keymap },
7.   { ""emacs-meta"", emacs_met",Not Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

/******************************************************************/

111",Not Useful
"/*If this is an escape character, we don't want to do any more processing.
     Just add the special ESC key sequence and return.*/","-3. #if 1

/*If this is an escape character, we don't want to do any more processing.
     Just add the special ESC key sequence and return.*/

1.   if (c == ESC)
2.     {
3.       keyname[0] = '\\';
4.       keyname[1] = 'e';
5.       keyname[2] = '\0';
",Not Useful
/*RUBOUT is translated directly into \C-?*/,"-8.   if (c == ESC)
-7.     {
-6.       keyname[0] = '\\';
-5.       keyname[1] = 'e';
-4.       keyname[2] = '\0';
-3.       return keyname;
-2.     }
-1. #endif

/*RUBOUT is translated directly into \C-?*/

1.   if (key == RUBOUT)
2.     {
3.       keyn",Not Useful
"/*If the function in the keymap is the one we are looking for,
	     then add the current KEY to the list of invoking keys.*/","-1. 	case ISFUNC:

/*If the function in the keymap is the one we are looking for,
	     then add the current KEY to the list of invoking keys.*/

1. 	  if (map[key].function == function)
2. 	    {
3. 	      char *keyname;
4. 	      keyname = _rl_get_keyna",Not Useful
"/*Find the list of keyseqs in this map which have FUNCTION as
	       their target.  Add the key sequences found to RESULT.*/","-10. 		  result = (char **)xrealloc (result, result_size * sizeof (char *));
-9. 	        }
-8. 	      result[result_index++] = keyname;
-7. 	      result[result_index] = (char *)NULL;
-6. 	    }
-5. 	  break;
-4. 	case ISKMAP:
-3. 	  {
-2. 	    char **se",Not Useful
"/*If ESC is the meta prefix and we're converting chars
		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC.*/","-10. 	        rl_invoking_keyseqs_in_map (function, FUNCTION_TO_KEYMAP (map, key));
-9. 	    else
-8. 	      break;
-7. 	    if (seqs == 0)
-6. 	      break;
-5. 	    for (i = 0; seqs[i]; i++)
-4. 	      {
-3. 		char *keyname = (char *)xmalloc (6 + strlen",Not Useful
/******************************************************************/,"-5. #if defined (HANDLE_MULTIBYTE)
-4. int rl_byte_oriented = 0;
-3. #else
-2. int rl_byte_oriented = 1;
-1. #endif

/******************************************************************/

111",Not Useful
/*Multibyte Character Utility Functions*/,"-7. #if defined (HANDLE_MULTIBYTE)
-6. int rl_byte_oriented = 0;
-5. #else
-4. int rl_byte_oriented = 1;
-3. #endif

/*Multibyte Character Utility Functions*/

111",Not Useful
/******************************************************************/,"-5. #if defined (HANDLE_MULTIBYTE)
-4. int rl_byte_oriented = 0;
-3. #else
-2. int rl_byte_oriented = 1;
-1. #endif

/******************************************************************/

111",Not Useful
"/*if this is true, means that seed was not pointed character
     started byte.  So correct the point and consume count*/","-10.   mbstate_t ps;
-9.   int point;
-8.   wchar_t wc;
-7.   tmp = 0;
-6.   memset(&ps, 0, sizeof (mbstate_t));
-5.   if (seed < 0)
-4.     seed = 0;
-3.   if (count <= 0)
-2.     return seed;
-1.   point = seed + _rl_adjust_point (string, seed, &ps);

/",Not Useful
/*reset states.*/,"-2. 	  point++;
-1. 	  count--;

/*reset states.*/

1. 	  memset(&ps, 0, sizeof(mbstate_t));
2. 	}
3.       else if (MB_NULLWCH (tmp))",Not Useful
/******************************************************************/,"-7. #include ""readline.h""
-6. #include ""rlconf.h""
-5. #include ""emacs_keymap.c""
-4. #if defined (VI_MODE)
-3. #include ""vi_keymap.c""
-2. #endif
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/*Functions for manipulating Keymaps.*/,"-9. #include ""readline.h""
-8. #include ""rlconf.h""
-7. #include ""emacs_keymap.c""
-6. #if defined (VI_MODE)
-5. #include ""vi_keymap.c""
-4. #endif
-3. #include ""xmalloc.h""

/*Functions for manipulating Keymaps.*/

111",Not Useful
/******************************************************************/,"-7. #include ""readline.h""
-6. #include ""rlconf.h""
-5. #include ""emacs_keymap.c""
-4. #if defined (VI_MODE)
-3. #include ""vi_keymap.c""
-2. #endif
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/*RUBOUT == 127*/,"-3.   for (i = ' '; i < 127; i++)
-2.     newmap[i].function = rl_insert;
-1.   newmap[TAB].function = rl_insert;

/*RUBOUT == 127*/

1.   newmap[CTRL('H')].function = rl_rubout;
2. #if KEYMAP_SIZE > 128",Not Useful
/*The current undo list for THE_LINE.*/,"-1. int _rl_undo_group_level = 0;

/*The current undo list for THE_LINE.*/

1. UNDO_LIST *rl_undo_list = (UNDO_LIST *)NULL;",Not Useful
/******************************************************************/,"-1. UNDO_LIST *rl_undo_list = (UNDO_LIST *)NULL;

/******************************************************************/

111",Not Useful
"/*Undo, and Undoing*/","-3. UNDO_LIST *rl_undo_list = (UNDO_LIST *)NULL;

/*Undo, and Undoing*/

111",Not Useful
/******************************************************************/,"-1. UNDO_LIST *rl_undo_list = (UNDO_LIST *)NULL;

/******************************************************************/

111",Not Useful
/*Begin a group.  Subsequent undos are undone as an atomic operation.*/,"-10.     {
-9.       if (rl->what == type)
-8. 	{
-7. 	  rl->start = start;
-6. 	  rl->end = end;
-5. 	  return 0;
-4. 	}
-3.     }
-2.   return 1;
-1. }

/*Begin a group.  Subsequent undos are undone as an atomic operation.*/

1. int
2. rl_begin_undo_gro",Not Useful
/*End an undo group started with rl_begin_undo_group ().*/,"-7. int
-6. rl_begin_undo_group ()
-5. {
-4.   rl_add_undo (UNDO_BEGIN, 0, 0, 0);
-3.   _rl_undo_group_level++;
-2.   return 0;
-1. }

/*End an undo group started with rl_begin_undo_group ().*/

1. int
2. rl_end_undo_group ()
3. {
4.   rl_add_undo (UNDO_E",Not Useful
/*Revert the current line to its previous state.*/,"-10.   if (start != end)
-9.     {
-8.       char *temp = rl_copy_text (start, end);
-7.       rl_begin_undo_group ();
-6.       rl_add_undo (UNDO_DELETE, start, end, temp);
-5.       rl_add_undo (UNDO_INSERT, start, end, (char *)NULL);
-4.       rl_end_u",Not Useful
/*signals.c -- signal handling support for readline.*/,"
/* signals.c -- signal handling support for readline. */


/*signals.c -- signal handling support for readline.*/

1. /* Copyright (C) 1987-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Not Useful
/*HAVE_UNISTD_H*/,"-2. #include <sys/types.h>
-1. #include <signal.h>
#if defined (HAVE_UNISTD_H)

/*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Not Useful
/*GWINSZ_IN_SYS_IOCTL*/,"-1. #include ""rldefs.h""
#if defined (GWINSZ_IN_SYS_IOCTL)

/*GWINSZ_IN_SYS_IOCTL*/

1. #  include <sys/ioctl.h>",Not Useful
/*!VOID_SIGHANDLER*/,"-8. #include ""readline.h""
-7. #include ""history.h""
-6. #include ""rlprivate.h""
-5. #if !defined (RETSIGTYPE)
-4. #  if defined (VOID_SIGHANDLER)
-3. #    define RETSIGTYPE void
-2. #  else
-1. #    define RETSIGTYPE int

/*!VOID_SIGHANDLER*/

111",Not Useful
/*!RETSIGTYPE*/,"-9. #include ""readline.h""
-8. #include ""history.h""
-7. #include ""rlprivate.h""
-6. #if !defined (RETSIGTYPE)
-5. #  if defined (VOID_SIGHANDLER)
-4. #    define RETSIGTYPE void
-3. #  else
-2. #    define RETSIGTYPE int

/*!RETSIGTYPE*/

1. #if defined (VO",Not Useful
"/*This typedef is equivalent to the one for Function; it allows us
   to say SigHandler *foo = signal (SIGKILL, SIG_IGN);*/","-5. #if defined (VOID_SIGHANDLER)
-4. #  define SIGHANDLER_RETURN return
-3. #else
-2. #  define SIGHANDLER_RETURN return (0)
-1. #endif

/*This typedef is equivalent to the one for Function; it allows us
   to say SigHandler *foo = signal (SIGKILL, SIG_I",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*Exported variables for use by applications.*/,"-5. #ifndef SA_RESTART
-4. #  define SA_RESTART 0
-3. #endif
-2. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-1. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*Exported variabl",Not Useful
/******************************************************************/,"-3. #endif
-2. static int signals_set_flag;
-1. static int sigwinch_set_flag;

/******************************************************************/

111",Not Useful
/*Signal Handling*/,"-5. #endif
-4. static int signals_set_flag;
-3. static int sigwinch_set_flag;

/*Signal Handling*/

111",Not Useful
/******************************************************************/,"-3. #endif
-2. static int signals_set_flag;
-1. static int sigwinch_set_flag;

/******************************************************************/

111",Not Useful
/*Readline signal handler functions.*/,"-7. static sighandler_cxt old_int, old_term, old_alrm, old_quit;
-6. #if defined (SIGTSTP)
-5. static sighandler_cxt old_tstp, old_ttou, old_ttin;
-4. #endif
-3. #if defined (SIGWINCH)
-2. static sighandler_cxt old_winch;
-1. #endif

/*Readline signal han",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*!HAVE_BSD_SIGNALS*/,"-2. #  if defined (HAVE_BSD_SIGNALS)
-1.   long omask;

/*!HAVE_BSD_SIGNALS*/

111",Not Useful
/*!HAVE_BSD_SIGNALS*/,"-2. #  if defined (HAVE_BSD_SIGNALS)
-1.   long omask;

/*!HAVE_BSD_SIGNALS*/

111",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*!HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS*/,"-6. #  if defined (SIGALRM)
-5.   if (sig == SIGINT || sig == SIGALRM)
-4. #  else
-3.   if (sig == SIGINT)
-2. #  endif
-1.     rl_set_sighandler (sig, SIG_IGN, &dummy_cxt);

/*!HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS*/

1.   switch (sig)
2.     {
3.    ",Not Useful
/*FALLTHROUGH*/,"-4.   switch (sig)
-3.     {
-2.     case SIGINT:
-1.       rl_free_line_state ();

/*FALLTHROUGH*/

1.     case SIGTERM:
2. #if defined (SIGTSTP)
3.     case SIGTSTP:
4.     case SIGTTOU:
5.     case SIGTTIN:",Not Useful
/*SIGTSTP*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTSTP*/

1. in",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*HAVE_BSD_SIGNALS*/,"
#  if defined (HAVE_BSD_SIGNALS)



/*HAVE_BSD_SIGNALS*/

1.   long omask;",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*HAVE_BSD_SIGNALS*/,"
#  if defined (HAVE_BSD_SIGNALS)



/*HAVE_BSD_SIGNALS*/

1.   long omask;",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
"/*We don't want to change old_winch -- it holds the state of SIGWINCH
     disposition set by the calling application.  We need this state
     because we call the application's SIGWINCH handler after updating
     our own idea of the screen size.*/","-10.   SIGHANDLER_RETURN;
-9. }
-8. #if defined (SIGWINCH)
-7. static RETSIGTYPE
-6. rl_sigwinch_handler (sig)
-5.      int sig;
-4. {
-3.   SigHandler *oh;
-2. #if defined (MUST_REINSTALL_SIGHANDLERS)
-1.   sighandler_cxt dummy_winch;

/*We don't want to",Not Useful
/*SIGWINCH*/,"-1. int rl_catch_signals = 1;

/*SIGWINCH*/

1. #ifdef SIGWINCH
2. int rl_catch_sigwinch = 1;
3. #else",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*HAVE_POSIX_SIGNALS*/,"-1. typedef RETSIGTYPE SigHandler ();
#if defined (HAVE_POSIX_SIGNALS)

/*HAVE_POSIX_SIGNALS*/

1. typedef struct sigaction sighandler_cxt;
2. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
3. #else
4. typedef struct { SigHandler *sa_handler; int ",Not Useful
/*HAVE_POSIX_SIGNALS*/,"-1. typedef RETSIGTYPE SigHandler ();
#if defined (HAVE_POSIX_SIGNALS)

/*HAVE_POSIX_SIGNALS*/

1. typedef struct sigaction sighandler_cxt;
2. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
3. #else
4. typedef struct { SigHandler *sa_handler; int ",Not Useful
/*SIGALRM*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGALRM*/

1. in",Not Useful
/*SIGTSTP*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTSTP*/

1. in",Not Useful
/*SIGTTOU*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTTOU*/

1. in",Not Useful
/*SIGTTIN*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTTIN*/

1. in",Not Useful
/*SIGWINCH*/,"-1. int rl_catch_signals = 1;

/*SIGWINCH*/

1. #ifdef SIGWINCH
2. int rl_catch_sigwinch = 1;
3. #else",Not Useful
/*SIGTSTP*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTSTP*/

1. in",Not Useful
/*SIGTTOU*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTTOU*/

1. in",Not Useful
/*SIGTTIN*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTTIN*/

1. in",Not Useful
"/*Clean up the terminal and readline state after catching a signal, before
   resending it to the calling application.*/","-10. #if defined (SIGWINCH)
-9.   if (rl_catch_sigwinch && sigwinch_set_flag == 1)
-8.     {
-7.       sigemptyset (&dummy.sa_mask);
-6.       rl_sigaction (SIGWINCH, &old_winch, &dummy);
-5.       sigwinch_set_flag = 0;
-4.     }
-3. #endif
-2.   return ",Not Useful
/*Reset the terminal and readline state after a signal handler returns.*/,"-10.    resending it to the calling application. */
-9. void
-8. rl_cleanup_after_signal ()
-7. {
-6.   _rl_clean_up_for_exit ();
-5.   if (rl_deprep_term_function)
-4.     (*rl_deprep_term_function) ();
-3.   rl_clear_pending_input ();
-2.   rl_clear_sig",Not Useful
"/*Free up the readline variable line state for the current line (undo list,
   any partial history entry, any keyboard macros in progress, and any
   numeric arguments in process) after catching a signal, before calling
   rl_cleanup_after_signal().*/","-7. void
-6. rl_reset_after_signal ()
-5. {
-4.   if (rl_prep_term_function)
-3.     (*rl_prep_term_function) (_rl_meta_flag);
-2.   rl_set_signals ();
-1. }

/*Free up the readline variable line state for the current line (undo list,
   any partial histo",Not Useful
/*HANDLE_SIGNALS*/,"
#if defined (HANDLE_SIGNALS)



/*HANDLE_SIGNALS*/

111",Not Useful
/*histfile.c - functions to manipulate the history file.*/,"
/* histfile.c - functions to manipulate the history file. */


/*histfile.c - functions to manipulate the history file.*/

1. /* Copyright (C) 1989-2003 Free Software Foundation, Inc.
2.    This file contains the GNU History Library (the Library), a set of
3.    routines for managing the text of previously typed lines.
4.    The Library is free software; you can redistribute it and/or modify
5.    it under the terms of the GNU General Public License as published by
6.    the Free Software Foundation; either version 2, or (at your option)
7.    any later version.
8.    The Library is distributed in the hope that it will be useful, but
9.    WITHOUT ANY WARRANTY; without even the implied warranty of
10.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",Not Useful
"/*The goal is to make the implementation transparent, so that you
   don't have to know what data types are used, just what functions
   you can call.  I think I have done that.*/","-10.    the Free Software Foundation; either version 2, or (at your option)
-9.    any later version.
-8.    The Library is distributed in the hope that it will be useful, but
-7.    WITHOUT ANY WARRANTY; without even the implied warranty of
-6.    MERCHA",Not Useful
/*HAVE_STDLIB_H*/,"-10. #if defined (HAVE_CONFIG_H)
-9. #  include ""config_readline.h""
-8. #endif
-7. #include <stdio.h>
-6. #include <sys/types.h>
-5. #if ! defined (_MINIX) && defined (HAVE_SYS_FILE_H)
-4. #  include <sys/file.h>
-3. #endif
-2. #include ""posixstat.h""
-1. ",Not Useful
/*HISTORY_USE_MMAP*/,"-6. #if defined (HAVE_UNISTD_H)
-5. #  include <unistd.h>
-4. #endif
-3. #if defined (__EMX__) || defined (__CYGWIN__)
-2. #  undef HAVE_MMAP
-1. #endif
#ifdef HISTORY_USE_MMAP

/*HISTORY_USE_MMAP*/

1. #  include <sys/mman.h>
2. #  ifdef MAP_FILE
3. #   ",Not Useful
"/*If we're compiling for __EMX__ (OS/2) or __CYGWIN__ (cygwin32 environment
   on win 95/98/nt), we want to open files with O_BINARY mode so that there
   is no \n -> \r\n conversion performed.  On other systems, we don't want to
   mess around with O_BINARY at all, so we ensure that it's defined to 0.*/","-10. #    define MAP_RFLAGS	(MAP_FILE|MAP_PRIVATE)
-9. #    define MAP_WFLAGS	(MAP_FILE|MAP_SHARED)
-8. #  else
-7. #    define MAP_RFLAGS	MAP_PRIVATE
-6. #    define MAP_WFLAGS	MAP_SHARED
-5. #  endif
-4. #  ifndef MAP_FAILED
-3. #    define MAP_FAILED	(",Not Useful
/*!__EMX__ && !__CYGWIN__*/,"-4. #if defined (__EMX__) || defined (__CYGWIN__)
-3. #  ifndef O_BINARY
-2. #    define O_BINARY 0
-1. #  endif

/*!__EMX__ && !__CYGWIN__*/

1. #  undef O_BINARY
2. #  define O_BINARY 0",Not Useful
/*!__EMX__ && !__CYGWIN__*/,"-4. #if defined (__EMX__) || defined (__CYGWIN__)
-3. #  ifndef O_BINARY
-2. #    define O_BINARY 0
-1. #  endif

/*!__EMX__ && !__CYGWIN__*/

1. #  undef O_BINARY
2. #  define O_BINARY 0",Not Useful
/*!errno*/,"-3. #include <errno.h>
-2. #if !defined (errno)
-1. extern int errno;

/*!errno*/

1. #include ""history.h""
2. #include ""histlib.h""
3. #include ""rlshell.h""
4. #include ""xmalloc.h""",Not Useful
"/*strlen("".history"") == 8*/","-10.   if (return_val)
-9.     return (return_val);
-8.   home = sh_get_env_value (""HOME"");
-7.   if (home == 0)
-6.     {
-5.       home = ""."";
-4.       home_len = 1;
-3.     }
-2.   else
-1.     home_len = strlen (home);

/*strlen("".history"") == 8*/

1",Not Useful
/*Set TO to larger than end of file if negative.*/,"-10. 	chars_read = EIO;
-9.       if (file >= 0)
-8. 	close (file);
-7.       FREE (input);
-6. #ifndef HISTORY_USE_MMAP
-5.       FREE (buffer);
-4. #endif
-3.       return (chars_read);
-2.     }
-1.   close (file);

/*Set TO to larger than end of file ",Not Useful
/*bp1 == bp+1*/,"-5. int
-4. history_truncate_file (fname, lines)
-3.      const char *fname;
-2.      int lines;
-1. {

/*bp1 == bp+1*/

1.   int file, chars_read, rv;
2.   struct stat finfo;
3.   size_t file_size;
4.   size_t bytes_written;
5.   buffer = (char *)NULL;
6",Not Useful
"/*Count backwards from the end of buffer until we have passed
     LINES lines.  bp1 is set funny initially.  But since bp[1] can't
     be a comment character (since it's off the end) and *bp can't be
     both a newline and the history comment character, it should be OK.*/","-10.       close (file);
-9.       goto truncate_exit;
-8.     }
-7.   chars_read = read (file, buffer, file_size);
-6.   close (file);
-5.   if (chars_read <= 0)
-4.     {
-3.       rv = (chars_read < 0) ? errno : 0;
-2.       goto truncate_exit;
-1.    ",Not Useful
/*local*/,"-1.   {

/*local*/

1.     register int j;
2.     int buffer_size;
3.     char *buffer;
4.     the_history = history_list ();",Not Useful
"/*Allocate the buffer, and fill it.*/","-10.     for (buffer_size = 0, i = history_length - nelements; i < history_length; i++)
-9. #if 0
-8.       buffer_size += 2 + HISTENT_BYTES (the_history[i]);
-7. #else
-6.       {
-5. 	if (history_write_timestamps && the_history[i]->timestamp && the_hist",Not Useful
/*histexpand.c -- history expansion.*/,"
/* histexpand.c -- history expansion. */


/*histexpand.c -- history expansion.*/

1. /* Copyright (C) 1989-2004 Free Software Foundation, Inc.
2.    This file contains the GNU History Library (the Library), a set of
3.    routines for managing the text of previously typed lines.
4.    The Library is free software; you can redistribute it and/or modify
5.    it under the terms of the GNU General Public License as published by
6.    the Free Software Foundation; either version 2, or (at your option)
7.    any later version.
8.    The Library is distributed in the hope that it will be useful, but
9.    WITHOUT ANY WARRANTY; without even the implied warranty of
10.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",Not Useful
"/*The character that represents the start of a history expansion
   request.  This is usually `!'.*/","-10. static char *subst_lhs;
-9. static char *subst_rhs;
-8. static int subst_lhs_len;
-7. static int subst_rhs_len;
-6. static char *get_history_word_specifier PARAMS((char *, char *, int *));
-5. static char *history_find_word PARAMS((char *, int));
-4.",Not Useful
"/*The character that invokes word substitution if found at the start of
   a line.  This is usually `^'.*/","-1. char history_expansion_char = '!';

/*The character that invokes word substitution if found at the start of
   a line.  This is usually `^'.*/

1. char history_subst_char = '^';",Not Useful
"/*During tokenization, if this character is seen as the first character
   of a word, then it, and all subsequent characters upto a newline are
   ignored.  For a Bourne shell, this should be '#'.  Bash special cases
   the interactive comment character to not be a comment delimiter.*/","-1. char history_subst_char = '^';

/*During tokenization, if this character is seen as the first character
   of a word, then it, and all subsequent characters upto a newline are
   ignored.  For a Bourne shell, this should be '#'.  Bash special cases
  ",Not Useful
"/*If set to a non-zero value, single quotes inhibit history expansion.
   The default is 0.*/","-1. const char *history_no_expand_chars = "" \t\n\r="";

/*If set to a non-zero value, single quotes inhibit history expansion.
   The default is 0.*/

1. int history_quotes_inhibit_expansion = 0;",Not Useful
/******************************************************************/,"-1. rl_linebuf_func_t *history_inhibit_expansion_function;

/******************************************************************/

111",Not Useful
/*History Expansion*/,"-3. rl_linebuf_func_t *history_inhibit_expansion_function;

/*History Expansion*/

111",Not Useful
/******************************************************************/,"-1. rl_linebuf_func_t *history_inhibit_expansion_function;

/******************************************************************/

111",Not Useful
/*The last string searched for by a !?string? search.*/,"-8. rl_linebuf_func_t *history_inhibit_expansion_function;

/*The last string searched for by a !?string? search.*/

1. static char *search_string;",Not Useful
/*The last string matched by a !?string? search.*/,"-10. rl_linebuf_func_t *history_inhibit_expansion_function;

/*The last string matched by a !?string? search.*/

1. static char *search_match;
2. /* Return the event specified at TEXT + OFFSET modifying OFFSET to
3.    point to after the event specifier. ",Not Useful
/*Only a closing `?' or a newline delimit a substring search string.*/,"-5.   if (string[i] == '?')
-4.     {
-3.       substring_okay++;
-2.       i++;
-1.     }

/*Only a closing `?' or a newline delimit a substring search string.*/

1.   for (local_index = i; (c = string[i]); i++)
2.     {
3. #if defined (HANDLE_MULTIBYTE)",Not Useful
"/*If there is no search string, try to use the previous search string,
     if one exists.  If not, fail immediately.*/","-10.   if (which)
-9.     strncpy (temp, string + local_index, which);
-8.   temp[which] = '\0';
-7.   if (substring_okay && string[i] == '?')
-6.     i++;
-5.   *caller_index = i;
-4. #define FAIL_SEARCH() \
-3.   do { \
-2.     history_offset = history_",Not Useful
"/*Function for extracting single-quoted strings.  Used for inhibiting
   history expansion within single quotes.*/","-10. 	  return (entry->line);
-9. 	}
-8.       if (history_offset)
-7. 	history_offset--;
-6.       else
-5. 	FAIL_SEARCH ();
-4.     }
-3. #undef FAIL_SEARCH
-2. #undef RETURN_ENTRY
-1. }

/*Function for extracting single-quoted strings.  Used for inhibi",Not Useful
/*a single backslash protects the `&' from lhs interpolation*/,"-10.     {
-9.       if (subst_rhs[i] == '&')
-8. 	{
-7. 	  if (j + subst_lhs_len >= new_size)
-6. 	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
-5. 	  strcpy (new + j, subst_lhs);
-4. 	  j += subst_lhs_len;
-3. 	}
-2.     ",Not Useful
"/*If the character before this `!' is a double or single
	 quote, then this expansion takes place inside of the
	 quoted string.  If we have to search for some text (""!foo""),
	 allow the delimiter to end the search string.*/","-10.       event = get_history_event (fake_s, &fake_i, 0);
-9.     }
-8.   else if (string[i + 1] == '#')
-7.     {
-6.       i += 2;
-5.       event = current_line;
-4.     }
-3.   else
-2.     {
-1.       int quoted_search_delimiter = 0;

/*If the chara",Not Useful
"/*If no word specifier, than the thing of interest was the event.*/","-6.   if (word_spec == (char *)&error_pointer)
-5.     {
-4.       *ret_string = hist_error (string, starting_index, i, BAD_WORD_SPEC);
-3.       free (result);
-2.       return (-1);
-1.     }

/*If no word specifier, than the thing of interest was the e",Not Useful
/*:r discards the suffix.*/,"-5. 	case 'h':
-4. 	  tstr = strrchr (temp, '/');
-3. 	  if (tstr)
-2. 	    *tstr = '\0';
-1. 	  break;

/*:r discards the suffix.*/

1. 	case 'r':
2. 	  tstr = strrchr (temp, '.');
3. 	  if (tstr)
4. 	    *tstr = '\0';
5. 	  break;",Not Useful
/*:e discards everything but the suffix.*/,"-5. 	case 'r':
-4. 	  tstr = strrchr (temp, '.');
-3. 	  if (tstr)
-2. 	    *tstr = '\0';
-1. 	  break;

/*:e discards everything but the suffix.*/

1. 	case 'e':
2. 	  tstr = strrchr (temp, '.');
3. 	  if (tstr)
4. 	    {
5. 	      t = savestring (tstr);",Not Useful
/*Find the first occurrence of THIS in TEMP.*/,"-7. 	    if (subst_lhs_len > l_temp)
-6. 	      {
-5. 		*ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
-4. 		free (result);
-3. 		free (temp);
-2. 		return (-1);
-1. 	      }

/*Find the first occurrence of THIS in TEMP.*/

111",Not Useful
/*Done with modfiers.*/,"-8. 	    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
-7. 	    free (result);
-6. 	    free (temp);
-5. 	    return (-1);
-4. 	  }
-3. 	}
-2.       i += 2;
-1.     }

/*Done with modfiers.*/

111",Not Useful
"/*Setting the history expansion character to 0 inhibits all
     history expansion.*/","-3.   char *temp;
-2.   if (output == 0)
-1.     return 0;

/*Setting the history expansion character to 0 inhibits all
     history expansion.*/

1.   if (history_expansion_char == 0)
2.     {
3.       *output = savestring (hstring);
4.       return (0);",Not Useful
"/*The history_comment_char, if set, appearing at the beginning
	     of a word signifies that the rest of the line should not have
	     history expansion performed on it.
	     Skip the rest of the line and break out of the loop.*/","-1. 	  cc = string[i + 1];

/*The history_comment_char, if set, appearing at the beginning
	     of a word signifies that the rest of the line should not have
	     history expansion performed on it.
	     Skip the rest of the line and break out of the lo",Not Useful
"/*If this is bash, allow backslashes to quote single
		 quotes and the history expansion character.*/","-5. 	      i++;
-4. 	      hist_string_extract_single_quoted (string, &i);
-3. 	    }
-2. 	  else if (history_quotes_inhibit_expansion && string[i] == '\\')
-1. 	    {

/*If this is bash, allow backslashes to quote single
		 quotes and the history expansi",Not Useful
"/*If history_quotes_inhibit_expansion is set, single quotes
	       inhibit history expansion.*/","-10. 	case '\\':
-9. 	  passc++;
-8. 	  ADD_CHAR (tchar);
-7. 	  break;
-6. 	case '""':
-5. 	  dquote = 1 - dquote;
-4. 	  ADD_CHAR (tchar);
-3. 	  break;
-2. 	case '\'':
-1. 	  {

/*If history_quotes_inhibit_expansion is set, single quotes
	       inhibit",Not Useful
/*history_comment_char*/,"char history_comment_char = '\0';

/*history_comment_char*/

111",Not Useful
/*history_expansion_char*/,"
char history_expansion_char = '!';



/*history_expansion_char*/

111",Not Useful
/*Handle special cases first.*/,"-5.   if (spec[i] == ':')
-4.     {
-3.       i++;
-2.       expecting_word_spec++;
-1.     }

/*Handle special cases first.*/

111",Not Useful
/*Try to get FIRST and LAST figured out.*/,"-5.   if (spec[i] == '$')
-4.     {
-3.       *caller_index = i + 1;
-2.       return (history_arg_extract ('$', '$', from));
-1.     }

/*Try to get FIRST and LAST figured out.*/

1.   if (spec[i] == '-')
2.     first = 0;
3.   else if (spec[i] == '^')
4",Not Useful
/*check against `:' because there could be a modifier separator*/,"-10. 	  for (last = 0; _rl_digit_p (spec[i]); i++)
-9. 	    last = (last * 10) + _rl_digit_value (spec[i]);
-8. 	}
-7.       else if (spec[i] == '$')
-6. 	{
-5. 	  i++;
-4. 	  last = '$';
-3. 	}
-2. #if 0
-1.       else if (!spec[i] || spec[i] == ':')

/*",Not Useful
"/*XXX - think about making history_tokenize return a struct array,
     each struct in array being a string and a length to avoid the
     calls to strlen below.*/","-10.    If LAST is `$' the last arg from STRING is used. */
-9. char *
-8. history_arg_extract (first, last, string)
-7.      int first, last;
-6.      const char *string;
-5. {
-4.   register int i, len;
-3.   char *result;
-2.   int size, offset;
-1.   ",Not Useful
/*)*/,"/* Copyright (C) 1989-2004 Free Software Foundation, Inc.

/*)*/

1.    This file contains the GNU History Library (the Library), a set of
2.    routines for managing the text of previously typed lines.
3.    The Library is free software; you can redistribute it and/or modify
4.    it under the terms of the GNU General Public License as published by
5.    the Free Software Foundation; either version 2, or (at your option)
6.    any later version.
7.    The Library is distributed in the hope that it will be useful, but
8.    WITHOUT ANY WARRANTY; without even the implied warranty of
9.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
10.    General Public License for more details.",Not Useful
/*)*/,"/* Copyright (C) 1989-2004 Free Software Foundation, Inc.

/*)*/

1.    This file contains the GNU History Library (the Library), a set of
2.    routines for managing the text of previously typed lines.
3.    The Library is free software; you can redistribute it and/or modify
4.    it under the terms of the GNU General Public License as published by
5.    the Free Software Foundation; either version 2, or (at your option)
6.    any later version.
7.    The Library is distributed in the hope that it will be useful, but
8.    WITHOUT ANY WARRANTY; without even the implied warranty of
9.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
10.    General Public License for more details.",Not Useful
/*Get word from string + i;*/,"-10. 	      i += 2;
-9. 	      return i;
-8. 	    }
-7. 	}
-6.       if (string[i] != '$')
-5. 	{
-4. 	  i++;
-3. 	  return i;
-2. 	}
-1.     }

/*Get word from string + i;*/

1.   if (member (string[i], HISTORY_QUOTE_CHARACTERS))
2.     delimiter = strin",Not Useful
/*Skip leading whitespace.*/,"-2.   for (i = result_index = size = 0, result = (char **)NULL; string[i]; )
-1.     {

/*Skip leading whitespace.*/

1.       for (; string[i] && whitespace (string[i]); i++)
2. 	;
3.       if (string[i] == 0 || string[i] == history_comment_char)
4. 	ret",Not Useful
/*What kind of non-blocking I/O do we have?*/,"-4. #include ""readline.h""
-3. #include ""rlprivate.h""
-2. #include ""rlshell.h""
-1. #include ""xmalloc.h""

/*What kind of non-blocking I/O do we have?*/

1. #if !defined (O_NDELAY) && defined (O_NONBLOCK)",Not Useful
/******************************************************************/,"-3. static int ibuffer_space PARAMS((void));
-2. static int rl_get_char PARAMS((int *));
-1. static int rl_gather_tyi PARAMS((void));

/******************************************************************/

111",Not Useful
/*Character Input Buffering*/,"-5. static int ibuffer_space PARAMS((void));
-4. static int rl_get_char PARAMS((int *));
-3. static int rl_gather_tyi PARAMS((void));

/*Character Input Buffering*/

111",Not Useful
/******************************************************************/,"-3. static int ibuffer_space PARAMS((void));
-2. static int rl_get_char PARAMS((int *));
-1. static int rl_gather_tyi PARAMS((void));

/******************************************************************/

111",Not Useful
/*EOF*/,"-10. #endif
-9. #if defined (O_NDELAY)
-8.   if (result == -1)
-7.     {
-6.       tem = fcntl (tty, F_GETFL, 0);
-5.       fcntl (tty, F_SETFL, (tem | O_NDELAY));
-4.       chars_avail = read (tty, &input, 1);
-3.       fcntl (tty, F_SETFL, tem);
-2.    ",Not Useful
"/*Is there input available to be read on the readline input file
   descriptor?  Only works if the system has select(2) or FIONREAD.
   Uses the value of _keyboard_input_timeout as the timeout; if another
   readline function wants to specify a timeout and not leave it up to
   the user, it should use _rl_input_queued(timeout_value_in_microseconds)
   instead.*/","-10. int
-9. rl_set_keyboard_input_timeout (u)
-8.      int u;
-7. {
-6.   int o;
-5.   o = _keyboard_input_timeout;
-4.   if (u >= 0)
-3.     _keyboard_input_timeout = u;
-2.   return (o);
-1. }

/*Is there input available to be read on the readline inpu",Not Useful
/*Make C be the next command to be executed.*/,"-10.     {
-9.       key = NEWLINE;
-8.       rl_pending_input = EOF;
-7.       RL_SETSTATE (RL_STATE_INPUTPENDING);
-6.     }
-5.   ibuffer[push_index++] = key;
-4.   if (push_index >= ibuffer_len)
-3.     push_index = 0;
-2.   return 1;
-1. }

/*Make C ",Not Useful
/*Clear any pending input pushed with rl_execute_next()*/,"-8. int
-7. rl_execute_next (c)
-6.      int c;
-5. {
-4.   rl_pending_input = c;
-3.   RL_SETSTATE (RL_STATE_INPUTPENDING);
-2.   return 0;
-1. }

/*Clear any pending input pushed with rl_execute_next()*/

1. int
2. rl_clear_pending_input ()
3. {
4.   rl",Not Useful
/******************************************************************/,"-3. static int ibuffer_space PARAMS((void));
-2. static int rl_get_char PARAMS((int *));
-1. static int rl_gather_tyi PARAMS((void));

/******************************************************************/

111",Not Useful
/*Character Input*/,"-5. static int ibuffer_space PARAMS((void));
-4. static int rl_get_char PARAMS((int *));
-3. static int rl_gather_tyi PARAMS((void));

/*Character Input*/

111",Not Useful
/******************************************************************/,"-3. static int ibuffer_space PARAMS((void));
-2. static int rl_get_char PARAMS((int *));
-1. static int rl_gather_tyi PARAMS((void));

/******************************************************************/

111",Not Useful
"/*Read a key, including pending input.*/","-10. {
-9.   rl_pending_input = 0;
-8.   RL_UNSETSTATE (RL_STATE_INPUTPENDING);
-7.   return 0;
-6. }

/*Read a key, including pending input.*/

1. int
2. rl_read_key ()
3. {
4.   int c;
5.   rl_key_sequence_length++;
6.   if (rl_pending_input)
7.     {
8",Not Useful
/*options*/,"-10. #include <set>
-9. #include ""common.h""
-8. #include ""innobackupex.h""
-7. #include ""xtrabackup.h""
-6. #include ""xbstream.h""
-5. #include ""fil_cur.h""
-4. #include ""write_filt.h""
-3. #include ""backup_copy.h""
-2. using std::min;
-1. using std::max;

/*op",Not Useful
/*********************************************************************/,"-4. 	--(*argv);
-3. 	++(*argc);
-2. 	return(true);
-1. }

/*********************************************************************/

1. Parse command-line options, connect to MySQL server,
2. detect server capabilities, etc.
3. @return	true on success. */
4",Not Useful
/*Change the current directory if -C is specified*/,"-10. main(int argc, char **argv)
-9. {
-8. 	MY_INIT(argv[0]);
-7. 	if (get_options(&argc, &argv)) {
-6. 		goto err;
-5. 	}
-4. 	if (opt_mode == RUN_MODE_NONE) {
-3. 		msg(""%s: either -c or -x must be specified."", my_progname);
-2. 		goto err;
-1. 	}

/*Ch",Not Useful
"/*If unknown type and ignorable flag is set, skip this chunk*/","-10. 	extract_ctxt_t *ctxt = (extract_ctxt_t *) arg;
-9. 	my_thread_init();
-8. 	memset(&chunk, 0, sizeof(chunk));
-7. 	while (1) {
-6. 		pthread_mutex_lock(ctxt->mutex);
-5. 		res = xb_stream_read_chunk(ctxt->stream, &chunk);
-4. 		if (res != XB_STREAM_R",Not Useful
/*See if we already have this file open*/,"-5. 		if (chunk.type == XB_CHUNK_TYPE_UNKNOWN && \
-4. 		    !(chunk.flags & XB_STREAM_FLAG_IGNORABLE)) {
-3. 			pthread_mutex_unlock(ctxt->mutex);
-2. 			continue;
-1. 		}

/*See if we already have this file open*/

1. 		entry = (file_entry_t *) my_hash_",Not Useful
/*Compression options*/,"-10. } comp_thread_ctxt_t;
-9. typedef struct {
-8. 	comp_thread_ctxt_t	*threads;
-7. 	uint			nthreads;
-6. } ds_compress_ctxt_t;
-5. typedef struct {
-4. 	ds_file_t		*dest_file;
-3. 	ds_compress_ctxt_t	*comp_ctxt;
-2. 	size_t			bytes_processed;
-1. } ds_",Not Useful
/*Create and initialize the worker threads*/,"-10. static comp_thread_ctxt_t *create_worker_threads(uint n);
-9. static void destroy_worker_threads(comp_thread_ctxt_t *threads, uint n);
-8. static void *compress_worker_thread_func(void *arg);
-7. static
-6. ds_ctxt_t *
-5. compress_init(const char *r",Not Useful
/*Append the .qp extension to the filename*/,"-10. 	ds_compress_ctxt_t	*comp_ctxt;
-9. 	ds_ctxt_t		*dest_ctxt;
-8.  	ds_file_t		*dest_file;
-7. 	char			new_name[FN_REFLEN];
-6. 	size_t			name_len;
-5. 	ds_file_t		*file;
-4. 	ds_compress_file_t	*comp_file;
-3. 	xb_ad(ctxt->pipe_ctxt != NULL);
-2. 	des",Not Useful
/*history.c -- standalone history library*/,"
/* history.c -- standalone history library */


/*history.c -- standalone history library*/

1. /* Copyright (C) 1989-2005 Free Software Foundation, Inc.
2.    This file contains the GNU History Library (the Library), a set of
3.    routines for managing the text of previously typed lines.
4.    The Library is free software; you can redistribute it and/or modify
5.    it under the terms of the GNU General Public License as published by
6.    the Free Software Foundation; either version 2, or (at your option)
7.    any later version.
8.    The Library is distributed in the hope that it will be useful, but
9.    WITHOUT ANY WARRANTY; without even the implied warranty of
10.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",Not Useful
"/*The goal is to make the implementation transparent, so that you
   don't have to know what data types are used, just what functions
   you can call.  I think I have done that.*/","-10.    the Free Software Foundation; either version 2, or (at your option)
-9.    any later version.
-8.    The Library is distributed in the hope that it will be useful, but
-7.    WITHOUT ANY WARRANTY; without even the implied warranty of
-6.    MERCHA",Not Useful
/*HAVE_STDLIB_H*/,"-5. #define READLINE_LIBRARY
-4. #if defined (HAVE_CONFIG_H)
-3. #  include ""config_readline.h""
-2. #endif
-1. #include <stdio.h>
#if defined (HAVE_STDLIB_H)

/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/******************************************************************/,"-2. #define DEFAULT_HISTORY_GROW_SIZE 50
-1. static char *hist_inittime PARAMS((void));

/******************************************************************/

111",Not Useful
/*History Functions*/,"-4. #define DEFAULT_HISTORY_GROW_SIZE 50
-3. static char *hist_inittime PARAMS((void));

/*History Functions*/

111",Not Useful
/******************************************************************/,"-2. #define DEFAULT_HISTORY_GROW_SIZE 50
-1. static char *hist_inittime PARAMS((void));

/******************************************************************/

111",Not Useful
/*assume snprintf if vsnprintf exists*/,"-8.   return t;
-7. }
-6. static char *
-5. hist_inittime ()
-4. {
-3.   time_t t;
-2.   char ts[64], *ret;
-1.   t = (time_t) time ((time_t *)0);

/*assume snprintf if vsnprintf exists*/

1.   snprintf (ts, sizeof (ts) - 1, ""X%lu"", (unsigned long) t);
2.",Not Useful
/*Change the time stamp of the most recent history entry to STRING.*/,"-10. 	      the_history = (HIST_ENTRY **)
-9. 		xrealloc (the_history, history_size * sizeof (HIST_ENTRY *));
-8. 	    }
-7. 	  history_length++;
-6. 	}
-5.     }
-4.   temp = alloc_history_entry ((char*) string, hist_inittime ());
-3.   the_history[histo",Not Useful
/*This loses because we cannot free the data.*/,"-9. void
-8. stifle_history (max)
-7.      int max;
-6. {
-5.   register int i, j;
-4.   if (max < 0)
-3.     max = 0;
-2.   if (history_length > max)
-1.     {

/*This loses because we cannot free the data.*/

1.       for (i = 0, j = history_length - ma",Not Useful
/*write delta meta info*/,"-7. 	cp->delta_buf_size = (cursor->page_size / 4) * cursor->page_size;
-6. 	cp->delta_buf = (unsigned char *)my_large_malloc(&cp->delta_buf_size, MYF(0));
-5. 	if (!cp->delta_buf) {
-4. 		msg(cursor->thread_n,""Can't allocate %zu bytes"",
-3. 			(size_t) cp",Not Useful
"/*change the target file name, since we are only going to write
	delta pages*/","-10. 	snprintf(meta_name, sizeof(meta_name), ""%s%s"", dst_name,
-9. 		 XB_DELTA_INFO_SUFFIX);
-8. 	const xb_delta_info_t	info(cursor->page_size, cursor->zip_size,
-7. 				     cursor->space_id);
-6. 	if (!xb_write_delta_metadata(meta_name, &info)) {
-5. 		",Not Useful
"/*""xtra""*/","-1. 	strcat(dst_name, "".delta"");

/*""xtra""*/

1. 	cp->npages = 1;
2. 	cp->corrupted_pages = corrupted_pages;
3. 	return(TRUE);
4. }",Not Useful
"/*""xtra""*/","-1. 	strcat(dst_name, "".delta"");

/*""xtra""*/

1. 	cp->npages = 1;
2. 	cp->corrupted_pages = corrupted_pages;
3. 	return(TRUE);
4. }",Not Useful
"/*""XTRA""*/","-10. static my_bool
-9. wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt, ds_file_t *dstfile)
-8. {
-7. 	xb_fil_cur_t			*cursor = ctxt->cursor;
-6. 	const ulint			page_size = cursor->page_size;
-5. 	xb_wf_incremental_ctxt_t	*cp = &(ctxt->wf_incremental_",Not Useful
"/*readline.c -- a general facility for reading lines of input
   with emacs style editing and completion.*/","
/* readline.c -- a general facility for reading lines of input
   with emacs style editing and completion. */


/*readline.c -- a general facility for reading lines of input
   with emacs style editing and completion.*/

1. /* Copyright (C) 1987-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Not Useful
/*!errno*/,"-8. #if defined (HAVE_LOCALE_H)
-7. #  include <locale.h>
-6. #endif
-5. #include <stdio.h>
-4. #include ""posixjmp.h""
-3. #include <errno.h>
-2. #if !defined (errno)
-1. extern int errno;

/*!errno*/

111",Not Useful
/*System-specific feature definitions and include files.*/,"-9. #if defined (HAVE_LOCALE_H)
-8. #  include <locale.h>
-7. #endif
-6. #include <stdio.h>
-5. #include ""posixjmp.h""
-4. #include <errno.h>
-3. #if !defined (errno)
-2. extern int errno;

/*System-specific feature definitions and include files.*/

1. #in",Not Useful
/*__EMX__*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""
#if defined (__EMX__)

/*__EMX__*/

1. #  define INCL_DOSPROCESS
2. #  include <os2.h>",Not Useful
/*Some standard library routines.*/,"-6. #include ""rldefs.h""
-5. #include ""rlmbutil.h""
-4. #if defined (__EMX__)
-3. #  define INCL_DOSPROCESS
-2. #  include <os2.h>

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include """,Not Useful
/*Forward declarations used in this file.*/,"-10. #include ""rlprivate.h""
-9. #include ""rlshell.h""
-8. #include ""xmalloc.h""
-7. #ifndef RL_LIBRARY_VERSION
-6. #  define RL_LIBRARY_VERSION ""5.1""
-5. #endif
-4. #ifndef RL_READLINE_VERSION
-3. #  define RL_READLINE_VERSION	0x0501
-2. #endif
-1. extern v",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*The current style of editing.*/,"-1. Keymap _rl_keymap = emacs_standard_keymap;

/*The current style of editing.*/

1. int rl_editing_mode = emacs_mode;",Not Useful
/*The current value of the numeric argument specified by the user.*/,"-1. int _rl_last_command_was_kill = 0;

/*The current value of the numeric argument specified by the user.*/

1. int rl_numeric_arg = 1;",Not Useful
/*Non-zero means we have been called at least once before.*/,"-1. int rl_arg_sign = 1;

/*Non-zero means we have been called at least once before.*/

1. static int rl_initialized;
2. #if 0",Not Useful
/*The streams we interact with.*/,"-1. procenv_t readline_top_level;

/*The streams we interact with.*/

1. FILE *_rl_in_stream, *_rl_out_stream;",Not Useful
/*Current prompt.*/,"-1. int readline_echoing_p = 0;

/*Current prompt.*/

1. char *rl_prompt = (char *)NULL;
2. int rl_visible_prompt_length = 0;",Not Useful
/*What we use internally.  You should always refer to RL_LINE_BUFFER.*/,"-1. rl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;

/*What we use internally.  You should always refer to RL_LINE_BUFFER.*/

1. static char *the_line;",Not Useful
/*Keymap holding the function currently being executed.*/,"-1. char *_rl_comment_begin;

/*Keymap holding the function currently being executed.*/

1. Keymap rl_executing_keymap;",Not Useful
/*Keymap we're currently using to dispatch.*/,"-1. Keymap rl_executing_keymap;

/*Keymap we're currently using to dispatch.*/

1. Keymap _rl_dispatching_keymap;",Not Useful
"/*Non-zero means to read only this many characters rather than up to a
   character bound to accept-line.*/","-1. int rl_erase_empty_line = 0;

/*Non-zero means to read only this many characters rather than up to a
   character bound to accept-line.*/

1. int rl_num_chars_to_read;",Not Useful
/*Key sequence `contexts'*/,"-2. char *rl_line_buffer = (char *)NULL;
-1. int rl_line_buffer_len = 0;

/*Key sequence `contexts'*/

1. _rl_keyseq_cxt *_rl_kscxt = 0;",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*`Forward' declarations*/,"-4. _rl_keyseq_cxt *_rl_kscxt = 0;

/*`Forward' declarations*/

111",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*Top Level Functions*/,"-3. int _rl_bind_stty_chars = 1;

/*Top Level Functions*/

111",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*Forward declaration*/,"-10. #include ""rlprivate.h""
-9. #include ""rlshell.h""
-8. #include ""xmalloc.h""
-7. #ifndef RL_LIBRARY_VERSION
-6. #  define RL_LIBRARY_VERSION ""5.1""
-5. #endif
-4. #ifndef RL_READLINE_VERSION
-3. #  define RL_READLINE_VERSION	0x0501
-2. #endif
-1. extern v",Not Useful
/*VI_MODE*/,"-10. 	}
-9.     }
-8.   else
-7.     {
-6.       if (rl_prompt && rl_already_prompted)
-5. 	rl_on_new_line_with_prompt ();
-4.       else
-3. 	rl_on_new_line ();
-2.       (*rl_redisplay_function) ();
-1.     }
#if defined (VI_MODE)

/*VI_MODE*/

1.   if ",Not Useful
"/*Restore the original of this history line, iff the line that we
     are editing was originally in the history, AND the line has changed.*/","-9.   if (rl_pre_input_hook)
-8.     (*rl_pre_input_hook) ();
-7. }
-6. STATIC_CALLBACK char *
-5. readline_internal_teardown (eof)
-4.      int eof;
-3. {
-2.   char *temp;
-1.   HIST_ENTRY *entry;

/*Restore the original of this history line, iff the li",Not Useful
"/*At any rate, it is highly likely that this line has an undo list.  Get
     rid of it now.*/","-10.   entry = current_history ();
-9.   if (entry && rl_undo_list)
-8.     {
-7.       temp = savestring (the_line);
-6.       rl_revert_line (1, 0);
-5.       entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
-4.       _rl_fr",Not Useful
/*VI_MODE*/,"-10. 	}
-9.     }
-8.   else
-7.     {
-6.       if (rl_prompt && rl_already_prompted)
-5. 	rl_on_new_line_with_prompt ();
-4.       else
-3. 	rl_on_new_line ();
-2.       (*rl_redisplay_function) ();
-1.     }
#if defined (VI_MODE)

/*VI_MODE*/

1.   if ",Not Useful
"/*If the application writer has told us to erase the entire line if
     the only character typed was something bound to rl_newline, do so.*/","-10.     {
-9.       (*rl_redisplay_function) ();
-8.       _rl_want_redisplay = 0;
-7.       rl_newline (1, '\n');
-6.     }
-5.   if (rl_done == 0)
-4.     {
-3.       (*rl_redisplay_function) ();
-2.       _rl_want_redisplay = 0;
-1.     }

/*If the ap",Not Useful
/*Then initialize the argument and number of keys read.*/,"-5. 	  if (RL_ISSTATE (RL_STATE_CALLBACK))
-4. 	    return (0);
-3. 	}
-2.       if (rl_pending_input == 0)
-1. 	{

/*Then initialize the argument and number of keys read.*/

1. 	  _rl_reset_argument ();
2. 	  rl_key_sequence_length = 0;
3. 	}
4.       RL",Not Useful
/*READLINE_CALLBACKS*/,"-10.   rl_set_signals ();
-9. #endif
-8.   value = readline_internal ();
-7.   if (rl_deprep_term_function)
-6.     (*rl_deprep_term_function) ();
-5. #if defined (HANDLE_SIGNALS)
-4.   rl_clear_signals ();
-3. #endif
-2.   return (value);
-1. }
#if defin",Not Useful
/*For now*/,"-10.   if (key == ESC)
-9.     RL_UNSETSTATE(RL_STATE_METANEXT);
-8.   return k;
-7. }
-6. #if defined (READLINE_CALLBACKS)
-5. int
-4. _rl_dispatch_callback (cxt)
-3.      _rl_keyseq_cxt *cxt;
-2. {
-1.   int nkey, r;

/*For now*/

1. #if 1",Not Useful
/*For now*/,"-10.   if (key == ESC)
-9.     RL_UNSETSTATE(RL_STATE_METANEXT);
-8.   return k;
-7. }
-6. #if defined (READLINE_CALLBACKS)
-5. int
-4. _rl_dispatch_callback (cxt)
-3.      _rl_keyseq_cxt *cxt;
-2. {
-1.   int nkey, r;

/*For now*/

1. #if 1",Not Useful
/*READLINE_CALLBACKS*/,"-10.   rl_set_signals ();
-9. #endif
-8.   value = readline_internal ();
-7.   if (rl_deprep_term_function)
-6.     (*rl_deprep_term_function) ();
-5. #if defined (HANDLE_SIGNALS)
-4.   rl_clear_signals ();
-3. #endif
-2.   return (value);
-1. }
#if defin",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*Initializations*/,"-8.       _rl_unget_char (key);
-7.       _rl_dispatching_keymap = map;
-6.       return -1;
-5.     }
-4.   return r;
-3. }

/*Initializations*/

111",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*We aren't done yet.  We haven't even gotten started yet!*/,"-1.   _rl_init_line_state ();

/*We aren't done yet.  We haven't even gotten started yet!*/

1.   rl_done = 0;
2.   RL_UNSETSTATE(RL_STATE_DONE);",Not Useful
/*Tell the history routines what is going on.*/,"-2.   rl_done = 0;
-1.   RL_UNSETSTATE(RL_STATE_DONE);

/*Tell the history routines what is going on.*/

1.   _rl_start_using_history ();",Not Useful
/*No such function typed yet.*/,"-1.   rl_reset_line_state ();

/*No such function typed yet.*/

1.   rl_last_func = (rl_command_func_t *)NULL;",Not Useful
/*__EMX__*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""
#if defined (__EMX__)

/*__EMX__*/

1. #  define INCL_DOSPROCESS
2. #  include <os2.h>",Not Useful
/*Find out if we are running in Emacs -- UNUSED.*/,"-10. static void
-9. readline_initialize_everything ()
-8. {
-7. #if 0
-6. #if defined (__EMX__)
-5.   if (environ == 0)
-4.     _emx_build_environ ();
-3. #endif
-2. #endif
-1. #if 0

/*Find out if we are running in Emacs -- UNUSED.*/

1.   running_in_em",Not Useful
/*Initialize the terminal interface.*/,"-2.   if (rl_line_buffer == 0)
-1.     rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);

/*Initialize the terminal interface.*/

1.   if (rl_terminal_name == 0)
2.     rl_terminal_name = sh_get_env_value (""TERM"");
3.   _rl_init",Not Useful
/*Initialize the function names.*/,"-1.   readline_default_bindings ();

/*Initialize the function names.*/

1.   rl_initialize_funmap ();",Not Useful
/*Decide whether we should automatically go into eight-bit mode.*/,"-1.   rl_initialize_funmap ();

/*Decide whether we should automatically go into eight-bit mode.*/

1.   _rl_init_eightbit ();",Not Useful
/*Read in the init file.*/,"-1.   _rl_init_eightbit ();

/*Read in the init file.*/

1.   rl_read_init_file ((char *)NULL);",Not Useful
/*XXX*/,"-1.   rl_read_init_file ((char *)NULL);

/*XXX*/

1.   if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
2.     {
3.       _rl_screenwidth--;
4.       _rl_screenchars -= _rl_screenheight;
5.     }",Not Useful
/*Bind some common arrow key sequences in MAP.*/,"-6. static void
-5. readline_default_bindings ()
-4. {
-3.   if (_rl_bind_stty_chars)
-2.     rl_tty_set_default_bindings (_rl_keymap);
-1. }

/*Bind some common arrow key sequences in MAP.*/

1. static void
2. bind_arrow_keys_internal (map)
3.      Keyma",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
"/**
Initialize the changed page bitmap-based read filter.  Assumes that
the bitmap is already set up in changed_page_bitmap.*/","-10. static
-9. void
-8. rf_pass_through_deinit(
-7. /*===================*/
-6. 	xb_read_filt_ctxt_t*	ctxt __attribute__((unused)))
-5. 					/*!<in: read filter context */
-4. {
-3. }
-2. /****************************************************************/",Not Useful
"/*!<in/out: read filter
						context*/","-4. static
-3. void
-2. rf_pass_through_get_next_batch(

/*!<in/out: read filter
						context*/

111",Not Useful
/*!<in: space id*/,"-1. 	ulint			space_id __attribute__((unused)))

/*!<in: space id*/

111",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
"/**
Get the next batch of pages for the bitmap read filter.*/","-10. 						context */
-9. 	const xb_fil_cur_t*	cursor,		/*!<in: read cursor */
-8. 	ulint			space_id)	/*!<in: space id  */
-7. {
-6. 	common_init(ctxt, cursor);
-5. 	ctxt->bitmap_range = xb_page_bitmap_range_init(changed_page_bitmap,
-4. 						       spac",Not Useful
"/*!<in/out: read filter
							context*/","-4. static
-3. void
-2. rf_pass_through_get_next_batch(

/*!<in/out: read filter
							context*/

111",Not Useful
/*Find the next changed page using the bitmap*/,"-1. 		ulint next_page_id;

/*Find the next changed page using the bitmap*/

1. 		next_page_id = xb_page_bitmap_range_get_next_bit
2. 			(ctxt->bitmap_range, TRUE);
3. 		if (next_page_id == ULINT_UNDEFINED) {
4. 			*read_batch_len = 0;
5. 			return;
6. 		}",Not Useful
"/*No more cleared bits in the bitmap, need to copy all the
		remaining pages.*/","-7. 		ctxt->filter_batch_end
-6. 			= xb_page_bitmap_range_get_next_bit(ctxt->bitmap_range,
-5. 							    FALSE);
-4. 		xb_a(next_page_id < ctxt->filter_batch_end);
-3. 	}
-2. 	*read_batch_start = ctxt->offset;
-1. 	if (ctxt->filter_batch_end == ULINT_UN",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
"/**
Deinitialize the changed page bitmap-based read filter.*/","-10. 	is reached, trigerring the next bitmap query.  */
-9. 	if (*read_batch_len > (ib_int64_t)ctxt->buffer_capacity) {
-8. 		*read_batch_len = ctxt->buffer_capacity;
-7. 	}
-6. 	ctxt->offset += *read_batch_len;
-5. 	xb_a (ctxt->offset % page_size == 0);
",Not Useful
/*terminating '\0'*/,"-10. 		my_strerror(errbuf, sizeof(errbuf), my_errno);
-9. 		my_error(EE_CANT_MKDIR, MYF(ME_BELL),
-8. 			 dirpath, my_errno, errbuf);
-7. 		return NULL;
-6. 	}
-5. 	fd = my_create(fullpath, 0, O_WRONLY | O_BINARY | O_EXCL | O_NOFOLLOW,
-4. 		     MYF(MY_W",Not Useful
"/*Write data to the output file, and punch ""holes"" if needed.*/","-6. static size_t trim_binary_zeros(uchar *buf, size_t pagesize)
-5. {
-4. 	size_t i;
-3. 	for (i = pagesize; (i > 0) && (buf[i - 1] == 0); i--) {};
-2. 	return i;
-1. }

/*Write data to the output file, and punch ""holes"" if needed.*/

1. static int write",Not Useful
"/*This punches a ""hole"" in the file.*/","-10. 	{
-9. 		size_t n_bytes =  MY_MIN(pagesize, len - written);
-8. 		size_t datasize= trim_binary_zeros(ptr,n_bytes);
-7. 		if (datasize > 0) {
-6. 			if (!my_write(fd, ptr, datasize, MYF(MY_WME | MY_NABP)))
-5. 				posix_fadvise(fd, 0, 0, POSIX_FADV_DO",Not Useful
"/*Weird, bail out.*/","-3. static void init_ibd_data(ds_local_file_t *local_file, const uchar *buf, size_t len)
-2. {
-1. 	if (len < FIL_PAGE_DATA + FSP_SPACE_FLAGS) {

/*Weird, bail out.*/

1. 		return;
2. 	}
3. 	auto flags = mach_read_from_4(&buf[FIL_PAGE_DATA + FSP_SPACE_FLA",Not Useful
"/*Do all writes to temporary files first, then pipe them to the specified
datasink in a serialized way in deinit().*/","-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Not Useful
"/*Save a copy of 'path', since it may not be accessible later*/","-5. 	file = (ds_file_t *) my_malloc(PSI_NOT_INSTRUMENTED,
-4.                         sizeof(ds_file_t) + sizeof(ds_tmp_file_t) + path_len, MYF(MY_FAE));
-3. 	tmp_file = (ds_tmp_file_t *) (file + 1);
-2. 	tmp_file->file = file;
-1. 	memcpy(&tmp_file->myst",Not Useful
/*Source file cursor implementation*/,"-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Not Useful
/**********************************************************************/,"-1. #define XB_FIL_CUR_PAGES 640
/***********************************************************************

/**********************************************************************/

1. Extracts the relative path (""database/table.ibd"") of a tablespace from ",Not Useful
/*!< in: file node*/,"-4. static
-3. void
-2. xb_fil_node_close_file(

/*!< in: file node*/

1. {
2. 	ibool	ret;
3. 	mysql_mutex_lock(&fil_system.mutex);
4. 	ut_ad(node);
5. 	ut_a(!node->being_extended);
6. 	if (node->is_open()) {
7. 		ret = os_file_close(node->handle);
8. 		u",Not Useful
/*!< in/out: the read filter*/,"-4. xb_fil_cur_result_t
-3. xb_fil_cur_open(

/*!< in/out: the read filter*/

111",Not Useful
/*!< in/out: source file cursor*/,"-3. void
-2. xb_fil_cur_close(

/*!< in/out: source file cursor*/

1. {
2. 	if (cursor->read_filter) {
3. 		cursor->read_filter->deinit(&cursor->read_filter_ctxt);
4. 	}
5. 	aligned_free(cursor->buf);
6. 	cursor->buf = NULL;
7. 	if (cursor->node != NULL) ",Not Useful
/*!< in/out: source file cursor*/,"-3. void
-2. xb_fil_cur_close(

/*!< in/out: source file cursor*/

1. {
2. 	if (cursor->read_filter) {
3. 		cursor->read_filter->deinit(&cursor->read_filter_ctxt);
4. 	}
5. 	aligned_free(cursor->buf);
6. 	cursor->buf = NULL;
7. 	if (cursor->node != NULL) ",Not Useful
/*Chunk flags*/,"-7. 	if (memcmp(tmpbuf, XB_STREAM_CHUNK_MAGIC, 8)) {
-6. 		msg(""xb_stream_read_chunk(): wrong chunk magic at offset ""
-5. 		    ""0x%llx."", (ulonglong) stream->offset);
-4. 		goto err;
-3. 	}
-2. 	ptr += 8;
-1. 	stream->offset += 8;

/*Chunk flags*/

1. 	c",Not Useful
"/*Chunk type, ignore unknown ones if ignorable flag is set*/","-2. 	chunk->flags = *ptr++;
-1. 	stream->offset++;

/*Chunk type, ignore unknown ones if ignorable flag is set*/

1. 	chunk->type = validate_chunk_type(*ptr);
2. 	if (chunk->type == XB_CHUNK_TYPE_UNKNOWN &&
3. 	    !(chunk->flags & XB_STREAM_FLAG_IGNORABL",Not Useful
/*Path length*/,"-10. 	chunk->type = validate_chunk_type(*ptr);
-9. 	if (chunk->type == XB_CHUNK_TYPE_UNKNOWN &&
-8. 	    !(chunk->flags & XB_STREAM_FLAG_IGNORABLE)) {
-7. 		msg(""xb_stream_read_chunk(): unknown chunk type 0x%lu at ""
-6. 		    ""offset 0x%llx."", (ulong) *pt",Not Useful
/*Path*/,"-10. 	chunk->type = validate_chunk_type(*ptr);
-9. 	if (chunk->type == XB_CHUNK_TYPE_UNKNOWN &&
-8. 	    !(chunk->flags & XB_STREAM_FLAG_IGNORABLE)) {
-7. 		msg(""xb_stream_read_chunk(): unknown chunk type 0x%lu at ""
-6. 		    ""offset 0x%llx."", (ulong) *pt",Not Useful
/*Checksum*/,"-10. 	if (chunk->length > chunk->buflen) {
-9. 		chunk->data = my_realloc(PSI_NOT_INSTRUMENTED, chunk->data, chunk->length,
-8. 					 MYF(MY_WME | MY_ALLOW_ZERO_PTR));
-7. 		if (chunk->data == NULL) {
-6. 			msg(""xb_stream_read_chunk(): failed to increase",Not Useful
/*!__EMX__*/,"-5.       if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-4. 	{
-3. #if defined (__EMX__)
-2. 	  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
-1. 	  _rl_screenwidth--;

/*!__EMX__*/

1. 	  _rl_get_screen_size (tty, 0);",Not Useful
/*!__EMX__*/,"-5.       if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-4. 	{
-3. #if defined (__EMX__)
-2. 	  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
-1. 	  _rl_screenwidth--;

/*!__EMX__*/

1. 	  _rl_get_screen_size (tty, 0);",Not Useful
/*Defaults.*/,"-1. 	}

/*Defaults.*/

1.       if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
2.         {
3. 	  _rl_screenwidth = 79;
4. 	  _rl_screenheight = 24;
5.         }",Not Useful
/*Everything below here is used by the redisplay code (tputs).*/,"-5.       if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-4.         {
-3. 	  _rl_screenwidth = 79;
-2. 	  _rl_screenheight = 24;
-1.         }

/*Everything below here is used by the redisplay code (tputs).*/

1.       _rl_screenchars = _rl_screenwid",Not Useful
"/*Set up the variables that the termcap library expects the application
     to provide.*/","-7.       PC = '\0';
-6.       _rl_term_backspace = _rl_term_backspace_default;
-5.       BC = (char*)_rl_term_backspace;
-4.       UP = (char*)_rl_term_up;
-3.       return 0;
-2.     }
-1.   get_term_capabilities (&buffer);

/*Set up the variables that ",Not Useful
/*VI_MODE*/,"-1.   bind_termcap_arrow_keys (emacs_standard_keymap);
#if defined (VI_MODE)

/*VI_MODE*/

1.   bind_termcap_arrow_keys (vi_movement_keymap);
2.   bind_termcap_arrow_keys (vi_insertion_keymap);",Not Useful
/*Bind the arrow key sequences from the termcap description in MAP.*/,"-2.   return 0;
-1. }

/*Bind the arrow key sequences from the termcap description in MAP.*/

1. static void
2. bind_termcap_arrow_keys (map)
3.      Keymap map;
4. {
5.   Keymap xkeymap;
6.   xkeymap = _rl_keymap;
7.   _rl_keymap = map;
8.   rl_bind_keys",Not Useful
/*Home*/,"-2. static const char *_rl_term_ks;
-1. static const char *_rl_term_ke;

/*Home*/

1. static const char *_rl_term_kh;
2. static const char *_rl_term_kH;",Not Useful
/*End*/,"-2. static const char *_rl_term_ks;
-1. static const char *_rl_term_ke;

/*End*/

1. static const char *_rl_term_kh;
2. static const char *_rl_term_kH;",Not Useful
/*!_MINIX*/,"-7. #ifdef _MINIX
-6. void
-5. _rl_output_character_function (c)
-4.      int c;
-3. {
-2.   putc (c, _rl_out_stream);
-1. }

/*!_MINIX*/

1. int
2. _rl_output_character_function (c)
3.      int c;
4. {
5.   return putc (c, _rl_out_stream);
6. }",Not Useful
/*!_MINIX*/,"-7. #ifdef _MINIX
-6. void
-5. _rl_output_character_function (c)
-4.      int c;
-3. {
-2.   putc (c, _rl_out_stream);
-1. }

/*!_MINIX*/

1. int
2. _rl_output_character_function (c)
3.      int c;
4. {
5.   return putc (c, _rl_out_stream);
6. }",Not Useful
/*NEW_TTY_DRIVER*/,"-3. int
-2. rl_crlf ()
-1. {
#if defined (NEW_TTY_DRIVER)

/*NEW_TTY_DRIVER*/

1.   if (_rl_term_cr)
2.     tputs (_rl_term_cr, 1, _rl_output_character_function);",Not Useful
/*FALLTHROUGH*/,"-10.         {
-9. 	case NO_BELL:
-8. 	default:
-7. 	  break;
-6. 	case VISIBLE_BELL:
-5. 	  if (_rl_visible_bell)
-4. 	    {
-3. 	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
-2. 	      break;
-1. 	    }

/*FALLTHROUGH*/

1. 	case AU",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/*Controlling the Meta Key and Keypad*/,"-10. 	  fprintf (stderr, ""\007"");
-9. 	  fflush (stderr);
-8. 	  break;
-7.         }
-6.       return (0);
-5.     }
-4.   return (-1);
-3. }

/*Controlling the Meta Key and Keypad*/

111",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/*Controlling the Cursor*/,"-10. {
-9. #if !defined (__DJGPP__)
-8.   if (on && _rl_term_ks)
-7.     tputs (_rl_term_ks, 1, _rl_output_character_function);
-6.   else if (!on && _rl_term_ke)
-5.     tputs (_rl_term_ke, 1, _rl_output_character_function);
-4. #endif
-3. }

/*Controlli",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/*funmap.c -- attach names to functions.*/,"
/* funmap.c -- attach names to functions. */


/*funmap.c -- attach names to functions.*/

1. /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Not Useful
/*BUFSIZ*/,"-10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-9.    GNU General Public License for more details.
-8.    The GNU General Public License is often shipped with GNU software, and
-7.    is generally kept in a file called COPYING or",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*VI_MODE*/,"-10.   { ""undo"", rl_undo_command },
-9.   { ""universal-argument"", rl_universal_argument },
-8.   { ""unix-filename-rubout"", rl_unix_filename_rubout },
-7.   { ""unix-line-discard"", rl_unix_line_discard },
-6.   { ""unix-word-rubout"", rl_unix_word_rubout },
-",Not Useful
/*Changed page bitmap implementation*/,"-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Not Useful
"/*TODO: copy-pasted shared definitions from the XtraDB bitmap write code.
Remove these on the first opportunity, i.e. single-binary XtraBackup.*/","-4. #include ""changed_page_bitmap.h""
-3. #include ""common.h""
-2. #include ""xtrabackup.h""
-1. #include ""srv0srv.h""

/*TODO: copy-pasted shared definitions from the XtraDB bitmap write code.
Remove these on the first opportunity, i.e. single-binary XtraBack",Not Useful
/** Single bitmap file information*/,"-7. #include ""changed_page_bitmap.h""
-6. #include ""common.h""
-5. #include ""xtrabackup.h""
-4. #include ""srv0srv.h""

/** Single bitmap file information*/

1. struct log_online_bitmap_file_t {",Not Useful
/*!< Size of the file*/,"-3. struct log_online_bitmap_file_t {

/*!< Size of the file*/

111",Not Useful
/*!< Number of files*/,"-1. struct log_online_bitmap_file_range_t {

/*!< Number of files*/

111",Not Useful
/*!< Name of a file*/,"-1. 	struct files_t {

/*!< Name of a file*/

111",Not Useful
/*The checksum of the current block*/,"-1. 	MODIFIED_PAGE_BLOCK_CHECKSUM = MODIFIED_PAGE_BLOCK_SIZE - 4

/*The checksum of the current block*/

1. };",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/*!<in: 1st key to compare*/,"-4. static
-3. int
-2. log_online_compare_bmp_keys(

/*!<in: 1st key to compare*/

111",Not Useful
/*!<in: 2nd key to compare*/,"-10. Provide a comparisson function for the RB-tree tree (space,
-9. block_start_page) pairs.  Actual implementation does not matter as
-8. long as the ordering is full.
-7. @return -1 if p1 < p2, 0 if p1 == p2, 1 if p1 > p2
-6. */
-5. static
-4. int
-3. ",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
"/*!<in/out: bitmap
							file*/","-4. static
-3. ibool
-2. log_online_read_bitmap_page(

/*!<in/out: bitmap
							file*/

111",Not Useful
/*********************************************************************/,"-10. 		    ""file \'%s\'"", bitmap_file->name);
-9. 		return FALSE;
-8. 	}
-7. 	bitmap_file->offset += MODIFIED_PAGE_BLOCK_SIZE;
-6. 	ut_ad(bitmap_file->offset <= bitmap_file->size);
-5. 	checksum = mach_read_from_4(page + MODIFIED_PAGE_BLOCK_CHECKSUM);
-4.",Not Useful
"/*!<out: bitmap file
							sequence number*/","-10. Check the name of a given file if it's a changed page bitmap file and
-9. return file sequence and start LSN name components if it is.  If is not,
-8. the values of output parameters are undefined.
-7. @return TRUE if a given file is a changed page b",Not Useful
"/*!<out: bitmap file
							start LSN*/","-10. the values of output parameters are undefined.
-9. @return TRUE if a given file is a changed page bitmap file.  */
-8. static
-7. ibool
-6. log_online_is_bitmap_file(

/*!<out: bitmap file
							start LSN*/

1. {
2. 	char	stem[FN_REFLEN];
3. 	ut_ad ",Not Useful
/*********************************************************************/,"-10. 		    ""file \'%s\'"", bitmap_file->name);
-9. 		return FALSE;
-8. 	}
-7. 	bitmap_file->offset += MODIFIED_PAGE_BLOCK_SIZE;
-6. 	ut_ad(bitmap_file->offset <= bitmap_file->size);
-5. 	checksum = mach_read_from_4(page + MODIFIED_PAGE_BLOCK_CHECKSUM);
-4.",Not Useful
"/*!<in/out: bitmap file
							range*/","-10. must free bitmap_files->files when done if bitmap_files set to non-NULL and
-9. this function returned TRUE.  Field bitmap_files->count might be set to a
-8. larger value than the actual count of the files, and space for the unused array
-7. slots wi",Not Useful
/*!<in: start LSN*/,"-10. larger value than the actual count of the files, and space for the unused array
-9. slots will be allocated but cleared to zeroes.
-8. @return TRUE if succeeded
-7. */
-6. static
-5. ibool
-4. log_online_setup_bitmap_file_range(

/*!<in: start LSN*/
",Not Useful
/*!<in: end LSN*/,"-10. slots will be allocated but cleared to zeroes.
-9. @return TRUE if succeeded
-8. */
-7. static
-6. ibool
-5. log_online_setup_bitmap_file_range(

/*!<in: end LSN*/

1. {
2. 	os_file_dir_t	bitmap_dir;
3. 	os_file_stat_t	bitmap_dir_file_info;
4. 	ulong",Not Useful
/*A file that falls into the range*/,"-10. 					       &file_start_lsn)
-9. 		    || file_start_lsn >= range_end) {
-8. 			continue;
-7. 		}
-6. 		if (file_seq_num > last_file_seq_num) {
-5. 			last_file_seq_num = file_seq_num;
-4. 		}
-3. 		if (file_start_lsn >= range_start
-2. 		    || file",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
"/*!<out: opened bitmap
							file*/","
static
ibool
xb_find_lsn_in_bitmap_file(


/*!<out: opened bitmap
							file*/

111",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/*!< in: bitmap file*/,"-10. Diagnose one or both of the following situations if we read close to
-9. the end of bitmap file:
-8. 1) Warn if the remainder of the file is less than one page.
-7. 2) Error if we cannot read any more full pages but the last read page
-6. did not hav",Not Useful
/*End of copy-pasted definitions*/,"-8. 			msg(""InnoDB: Warning: changed page bitmap ""
-7. 			    ""file \'%s\' does not contain a complete run ""
-6. 			    ""at the end."", bitmap_file->name);
-5. 			return FALSE;
-4. 		}
-3. 	}
-2. 	return TRUE;
-1. }

/*End of copy-pasted definitions*/

111",Not Useful
/*Current bitmap page*/,"-7. struct xb_page_bitmap_range_struct {

/*Current bitmap page*/

111",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/*!<in: interval start*/,"-4. static
-3. void
-2. xb_msg_missing_lsn_data(

/*!<in: interval start*/

111",Not Useful
/*!<in: interval end*/,"-5. static
-4. void
-3. xb_msg_missing_lsn_data(

/*!<in: interval end*/

1. {
2. 	msg(""mariabackup: warning: changed page data missing for LSNs between ""
3. 	    LSN_PF "" and "" LSN_PF, missing_interval_start,
4. 	    missing_interval_end);
5. }",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
"/*!<in/out: bitmap
							file*/","-4. static
-3. ibool
-2. log_online_read_bitmap_page(

/*!<in/out: bitmap
							file*/

111",Not Useful
/*!<in: LSN to find*/,"-10. static
-9. ibool
-8. xb_find_lsn_in_bitmap_file(

/*!<in: LSN to find*/

1. {
2. 	ibool		last_page_ok		= TRUE;
3. 	ibool		next_to_last_page_ok	= TRUE;
4. 	xb_ad (bitmap_file->size >= MODIFIED_PAGE_BLOCK_SIZE);
5. 	*page_end_lsn = 0;
6. 	while ((*page",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/*The 1st file does not have the starting LSN data*/,"-5. 		return result;
-4. 	}
-3. 	bmp_i = 0;
-2. 	if (UNIV_UNLIKELY(bitmap_files.files[bmp_i].start_lsn
-1. 			  > bmp_start_lsn)) {

/*The 1st file does not have the starting LSN data*/

1. 		xb_msg_missing_lsn_data(bmp_start_lsn,
2. 					bitmap_files.fil",Not Useful
/*Is the 1st bitmap file missing?*/,"-5. 	while ((bmp_i < bitmap_files.count - 1)
-4. 	       && (bitmap_files.files[bmp_i].start_lsn
-3. 		   == bitmap_files.files[bmp_i + 1].start_lsn)) {
-2. 		bmp_i++;
-1. 	}

/*Is the 1st bitmap file missing?*/

1. 	if (UNIV_UNLIKELY(bitmap_files.files[b",Not Useful
/*Open the 1st bitmap file*/,"-5. 		xb_msg_missing_lsn_data(bmp_start_lsn, bmp_end_lsn);
-4. 		rbt_free(result);
-3. 		free(bitmap_files.files);
-2. 		return NULL;
-1. 	}

/*Open the 1st bitmap file*/

1. 	if (UNIV_UNLIKELY(!log_online_open_bitmap_file_read_only(
2. 				  bitmap_files",Not Useful
/*TODO: this is not the exact missing range*/,"-1. 	if (UNIV_UNLIKELY(bitmap_files.files[bmp_i].name[0] == '\0')) {

/*TODO: this is not the exact missing range*/

1. 		xb_msg_missing_lsn_data(bmp_start_lsn, bmp_end_lsn);
2. 		rbt_free(result);
3. 		free(bitmap_files.files);
4. 		return NULL;
5. 	}",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/*!<in/out: the bitmap range*/,"-4. static
-3. ibool
-2. xb_page_bitmap_setup_next_page(

/*!<in/out: the bitmap range*/

1. {
2. 	ulint	new_space_id;
3. 	ulint	new_1st_page_id;
4. 	if (bitmap_range->bitmap_node == NULL) {
5. 		bitmap_range->current_page_id = ULINT_UNDEFINED;
6. 		retur",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/*!< in: space id*/,"-4. xb_page_bitmap_range*
-3. xb_page_bitmap_range_init(

/*!< in: space id*/

1. {
2. 	byte			search_page[MODIFIED_PAGE_BLOCK_SIZE];
3. 	xb_page_bitmap_range	*result
4. 		= static_cast<xb_page_bitmap_range *>(malloc(sizeof(*result)));
5. 	memset(result, ",Not Useful
"/*This also sets MODIFIED_PAGE_1ST_PAGE_ID to 0, which is what we
	want.*/","-9. {
-8. 	byte			search_page[MODIFIED_PAGE_BLOCK_SIZE];
-7. 	xb_page_bitmap_range	*result
-6. 		= static_cast<xb_page_bitmap_range *>(malloc(sizeof(*result)));
-5. 	memset(result, 0, sizeof(*result));
-4. 	result->bitmap = bitmap;
-3. 	result->space_id =",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
"/*!< in: bitmap
							range*/","-4. static inline
-3. ibool
-2. is_bit_set(

/*!< in: bitmap
							range*/

111",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/*!< in/out: bitmap range*/,"-3. ulint
-2. xb_page_bitmap_range_get_next_bit(

/*!< in/out: bitmap range*/

111",Not Useful
/*!< in: bit value*/,"-4. ulint
-3. xb_page_bitmap_range_get_next_bit(

/*!< in: bit value*/

1. {
2. 	if (UNIV_UNLIKELY(bitmap_range->current_page_id
3. 			  == ULINT_UNDEFINED)) {
4. 		return ULINT_UNDEFINED;
5. 	}
6. 	do {
7. 		while (bitmap_range->bit_i < MODIFIED_PAGE_BLO",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/*! in/out: bitmap range*/,"-3. void
-2. xb_page_bitmap_range_deinit(

/*! in/out: bitmap range*/

1. {
2. 	free(bitmap_range);
3. }",Not Useful
"/*Chunk magic + flags + chunk type + path_len + path + len + offset +
	checksum*/","-10. 		return 1;
-9. 	}
-8. 	file->chunk_ptr = file->chunk;
-7. 	file->chunk_free = XB_STREAM_MIN_CHUNK_SIZE;
-6. 	return 0;
-5. }
-4. static
-3. int
-2. xb_stream_write_chunk(xb_wstream_file_t *file, const void *buf, size_t len)
-1. {

/*Chunk magic + fl",Not Useful
/*Chunk magic*/,"-10. 		return 1;
-9. 	}
-8. 	file->chunk_ptr = file->chunk;
-7. 	file->chunk_free = XB_STREAM_MIN_CHUNK_SIZE;
-6. 	return 0;
-5. }
-4. static
-3. int
-2. xb_stream_write_chunk(xb_wstream_file_t *file, const void *buf, size_t len)
-1. {
	/* Chunk magic + f",Not Useful
/*Chunk type*/,"-3. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-2. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

/*Chunk type*/

111",Not Useful
/*Path*/,"-4. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-3. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

/*Path*/

1. 	ptr += 4;",Not Useful
/*checksum*/,"-10. 	}
-9. 	file->chunk_ptr = file->chunk;
-8. 	file->chunk_free = XB_STREAM_MIN_CHUNK_SIZE;
-7. 	return 0;
-6. }
-5. static
-4. int
-3. xb_stream_write_chunk(xb_wstream_file_t *file, const void *buf, size_t len)
-2. {

/*checksum*/

1. 	uchar		tmpbuf[si",Not Useful
/*Chunk magic*/,"-10. 		return 1;
-9. 	}
-8. 	file->chunk_ptr = file->chunk;
-7. 	file->chunk_free = XB_STREAM_MIN_CHUNK_SIZE;
-6. 	return 0;
-5. }
-4. static
-3. int
-2. xb_stream_write_chunk(xb_wstream_file_t *file, const void *buf, size_t len)
-1. {
	/* Chunk magic + f",Not Useful
/*Chunk type*/,"-3. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-2. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

/*Chunk type*/

111",Not Useful
/*Path*/,"-4. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-3. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

/*Path*/

1. 	ptr += 4;",Not Useful
/*Change the default buffer size*/,"-10. static int buffer_close(ds_file_t *file);
-9. static void buffer_deinit(ds_ctxt_t *ctxt);
-8. datasink_t datasink_buffer = {
-7. 	&buffer_init,
-6. 	&buffer_open,
-5. 	&buffer_write,
-4. 	&buffer_close,
-3. 	&dummy_remove,
-2. 	&buffer_deinit
-1. };
",Not Useful
"/************************************************************************
Create a datasink of the specified type*/","-10. #include <my_global.h>
-9. #include <my_base.h>
-8. #include ""common.h""
-7. #include ""datasink.h""
-6. #include ""ds_compress.h""
-5. #include ""ds_xbstream.h""
-4. #include ""ds_local.h""
-3. #include ""ds_stdout.h""
-2. #include ""ds_tmpfile.h""
-1. #include ",Not Useful
"/************************************************************************
Open a datasink file*/","-10. 		return NULL;
-9. 	}
-8. 	ctxt = ds->init(root);
-7. 	if (ctxt != NULL) {
-6. 		ctxt->datasink = ds;
-5. 	} else {
-4. 		die(""failed to initialize datasink."");
-3. 	}
-2. 	return ctxt;
-1. }

/********************************************************",Not Useful
/*mysql flavor and version*/,"-10. #include ""mysql_version.h""
-9. #include ""backup_copy.h""
-8. #include ""backup_mysql.h""
-7. #include ""mysqld.h""
-6. #include ""xb_plugin.h""
-5. #include <sstream>
-4. #include <sql_error.h>
-3. #include ""page0zip.h""
-2. char *tool_name;
-1. char tool_ar",Not Useful
/*server capabilities*/,"-2. mysql_flavor_t server_flavor = FLAVOR_UNKNOWN;
-1. unsigned long mysql_server_version = 0;

/*server capabilities*/

1. bool have_changed_page_bitmaps = false;
2. bool have_backup_locks = false;
3. bool have_lock_wait_timeout = false;
4. bool have_gal",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
"/**
Execute mysql query.*/","-10. 				opt_socket, 0)) {
-9. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-8. 		mysql_close(connection);
-7. 		return(NULL);
-6. 	}
-5. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*Restart the slave if it was running at start*/,"-10. 	while (open_temp_tables && n_attempts--) {
-9. 		msg(""Starting slave SQL thread, waiting %d seconds, then ""
-8. 		       ""checking Slave_open_temp_tables again (%d attempts ""
-7. 		       ""remaining)..."", sleep_time, n_attempts);
-6. 		xb_mysql_quer",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
"/**
Retrieves MySQL binlog position of the master server in a replication
setup and saves it in a file. It also saves it in mysql_slave_position
variable.*/","-10. 	}
-9. 	msg(""Slave_open_temp_tables did not become zero after ""
-8. 	       ""%d seconds"", opt_safe_slave_backup_timeout);
-7. cleanup:
-6. 	free_mysql_variables(status);
-5. 	return(result);
-4. }
-3. /************************************************",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
"/**
Retrieves MySQL binlog position and
saves it in a file. It also prints it to stdout.*/","-10. 			""master host '%s', filename '%s', position '%s'"",
-9. 			master, filename, position) != -1);
-8. 	}
-7. cleanup:
-6. 	free_mysql_variables(status);
-5. 	free_mysql_variables(variables);
-4. 	return(result);
-3. }
-2. /*****************************",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
"/**
Writes xtrabackup_info file and if backup_history is enable creates
PERCONA_SCHEMA.xtrabackup_history and writes a new history record to the
table containing all the history info particular to the just completed
backup.*/","-10. Copyright (c) 2000, 2011, MySQL AB & Innobase Oy. All Rights Reserved.
-9. This program is free software; you can redistribute it and/or modify it under
-8. the terms of the GNU General Public License as published by the Free Software
-7. Foundation;",Not Useful
/*uuid*/,"-10. 				opt_incremental_history_name,
-9. 				(unsigned long)strlen(opt_incremental_history_name));
-8. 		snprintf(query, sizeof(query),
-7. 			""SELECT innodb_to_lsn ""
-6. 			""FROM PERCONA_SCHEMA.xtrabackup_history ""
-5. 			""WHERE name = '%s' ""
-4. 			""A",Not Useful
/*name*/,"-10. #include ""xtrabackup.h""
-9. #include ""srv0srv.h""
-8. #include ""mysql_version.h""
-7. #include ""backup_copy.h""
-6. #include ""backup_mysql.h""
-5. #include ""mysqld.h""
-4. #include ""xb_plugin.h""
-3. #include <sstream>
-2. #include <sql_error.h>
-1. #inclu",Not Useful
/*tool_name*/,"-10. #include ""xtrabackup.h""
-9. #include ""srv0srv.h""
-8. #include ""mysql_version.h""
-7. #include ""backup_copy.h""
-6. #include ""backup_mysql.h""
-5. #include ""mysqld.h""
-4. #include ""xb_plugin.h""
-3. #include <sstream>
-2. #include <sql_error.h>
-1. #inclu",Not Useful
/*tool_command*/,"-10. 		|| xtrabackup_databases
-9. 		|| xtrabackup_databases_file
-8. 		|| xtrabackup_tables_exclude
-7. 		|| xtrabackup_databases_exclude
-6. 		);
-5. 	char *buf = NULL;
-4. 	int buf_len = asprintf(&buf,
-3. 		""uuid = %s\n""
-2. 		""name = %s\n""
-1. 		""too",Not Useful
/*server_version*/,"-1. mysql_flavor_t server_flavor = FLAVOR_UNKNOWN;
unsigned long mysql_server_version = 0;

/*server_version*/

111",Not Useful
/*start_time*/,"
time_t history_start_time;



/*start_time*/

1. time_t history_end_time;
2. time_t history_lock_time;
3. MYSQL *mysql_connection;
4. extern my_bool opt_ssl_verify_server_cert, opt_use_ssl;
5. MYSQL *
6. xb_mysql_connect()
7. {
8. 	MYSQL *connection = mysql_init(NULL);
9. 	char mysql_port_str[std::numeric_limits<int>::digits10 + 3];
10. 	sprintf(mysql_port_str, ""%d"", opt_port);",Not Useful
/*end_time*/,"-1. time_t history_start_time;
time_t history_end_time;

/*end_time*/

1. time_t history_lock_time;
2. MYSQL *mysql_connection;
3. extern my_bool opt_ssl_verify_server_cert, opt_use_ssl;
4. MYSQL *
5. xb_mysql_connect()
6. {
7. 	MYSQL *connection = mysql_",Not Useful
/*lock_time*/,"-2. time_t history_start_time;
-1. time_t history_end_time;
time_t history_lock_time;

/*lock_time*/

1. MYSQL *mysql_connection;
2. extern my_bool opt_ssl_verify_server_cert, opt_use_ssl;
3. MYSQL *
4. xb_mysql_connect()
5. {
6. 	MYSQL *connection = mysq",Not Useful
/*binlog_pos*/,"-6. static mysql_mutex_t kill_query_thread_mutex;
-5. static bool kill_query_thread_running, kill_query_thread_stopping;
-4. static mysql_cond_t kill_query_thread_stopped;
-3. static mysql_cond_t kill_query_thread_stop;
-2. bool sql_thread_started = false",Not Useful
/*incremental*/,"-10. @return	true on success. */
-9. bool
-8. detect_mysql_capabilities_for_backup()
-7. {
-6. 	const char *query = ""SELECT 'INNODB_CHANGED_PAGES', COUNT(*) FROM ""
-5. 				""INFORMATION_SCHEMA.PLUGINS ""
-4. 			    ""WHERE PLUGIN_NAME LIKE 'INNODB_CHANGED_PA",Not Useful
/*format*/,"-10. 		""ibbackup_version = %s\n""
-9. 		""server_version = %s\n""
-8. 		""start_time = %s\n""
-7. 		""end_time = %s\n""
-6. 		""lock_time = %d\n""
-5. 		""binlog_pos = %s\n""
-4. 		""innodb_from_lsn = "" LSN_PF ""\n""
-3. 		""innodb_to_lsn = "" LSN_PF ""\n""
-2. 		""partial ",Not Useful
/*compressed*/,"-10. 		""server_version = %s\n""
-9. 		""start_time = %s\n""
-8. 		""end_time = %s\n""
-7. 		""lock_time = %d\n""
-6. 		""binlog_pos = %s\n""
-5. 		""innodb_from_lsn = "" LSN_PF ""\n""
-4. 		""innodb_to_lsn = "" LSN_PF ""\n""
-3. 		""partial = %s\n""
-2. 		""incremental = %s\",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*nothing found*/,"-10. 			goto done;
-9. 		}
-8. 		make_path_n(2, &it->filepath, &it->filepath_len,
-7. 				it->datadir_path, it->dbinfo.name);
-6. 		make_path_n(1, &it->filepath_rel, &it->filepath_rel_len,
-5. 				it->dbinfo.name);
-4. 		it->is_empty_dir = true;
-3. 		dat",Not Useful
/*if it already exists that is fine*/,"-4. 	if (my_mkdir(pathname, Flags, MyFlags) == 0) {
-3. 		free(parent);
-2. 		return(0);
-1. 	}

/*if it already exists that is fine*/

1. 	if (errno == EEXIST) {
2. 		free(parent);
3. 		return(0);
4. 	}
5. 	free(parent);
6. 	return(-1);
7. }",Not Useful
/*unused for now*/,"-10. 		fprintf(f, ""%s\n"", filepath);
-9. 		if (save_to_list) {
-8. 			rsync_list.insert(filepath);
-7. 		}
-6. 	}
-5. 	return(true);
-4. }
-3. bool backup_file_print_buf(const char *filename, const char *buf, int buf_len)
-2. {
-1. 	ds_file_t	*dstfile	= N",Not Useful
/*close*/,"-10. 	return(it);
-9. error:
-8. 	free(it);
-7. 	return(NULL);
-6. }
-5. static
-4. bool
-3. datadir_iter_next_database(datadir_iter_t *it)
-2. {
-1. 	if (it->dbdir != NULL) {
		if (os_file_closedir_failed(it->dbdir)) {

/*close*/

1. 			msg(""Warning: cou",Not Useful
/*ERROR*/,"-10. 	return(NULL);
-9. }
-8. static
-7. bool
-6. datadir_iter_next_database(datadir_iter_t *it)
-5. {
-4. 	if (it->dbdir != NULL) {
-3. 		if (os_file_closedir_failed(it->dbdir)) {
-2. 			msg(""Warning: could not""
-1. 			      "" close database directory %s",Not Useful
/*The main copy loop*/,"-10. 		goto error_close;
-9. 	}
-8. 	strncpy(dst_name, cursor.rel_path, sizeof(dst_name));
-7. 	dstfile = ds_open(datasink, dst_path, &cursor.statinfo);
-6. 	if (dstfile == NULL) {
-5. 		msg(thread_n,""error: ""
-4. 			""cannot open the destination stream fo",Not Useful
/*close*/,"-10. 	return(it);
-9. error:
-8. 	free(it);
-7. 	return(NULL);
-6. }
-5. static
-4. bool
-3. datadir_iter_next_database(datadir_iter_t *it)
-2. {
-1. 	if (it->dbdir != NULL) {
		if (os_file_closedir_failed(it->dbdir)) {

/*close*/

1. 			msg(""Warning: cou",Not Useful
/*ERROR*/,"-10. 	return(NULL);
-9. }
-8. static
-7. bool
-6. datadir_iter_next_database(datadir_iter_t *it)
-5. {
-4. 	if (it->dbdir != NULL) {
-3. 		if (os_file_closedir_failed(it->dbdir)) {
-2. 			msg(""Warning: could not""
-1. 			      "" close database directory %s",Not Useful
"/************************************************************************
Read link from .isl file if any and store it in the global map associated
with given tablespace.*/","-10. 		}
-9. 		my_strerror(errbuf, sizeof(errbuf), my_errno);
-8. 		msg(""Can not move file %s to %s: %s"",
-7. 			src_file_path, dst_file_path_abs,
-6. 			errbuf);
-5. 		return(false);
-4. 	}
-3. 	msg(thread_n,""        ...done"");
-2. 	return(true);
-1. }

",Not Useful
/** Start --backup*/,"-10. 				p += sizeof lsn_prefix - 1;
-9. 				lsn = lsn_t(strtoll(p, NULL, 10));
-8. 			}
-7. 		}
-6. 		mysql_free_result(res);
-5. 	}
-4. 	return lsn;
-3. }
-2. lsn_t server_lsn_after_lock;
-1. extern void backup_wait_for_lsn(lsn_t lsn);

/** Start --back",Not Useful
/*release all locks*/,"-2. void backup_release()
-1. {

/*release all locks*/

1. 	if (!opt_no_lock) {
2. 		unlock_all(mysql_connection);
3. 		history_lock_time = 0;
4. 	} else {
5. 		history_lock_time = time(NULL) - history_lock_time;
6. 	}
7. 	if (opt_lock_ddl_per_table) {
8.",Not Useful
/*Copy buffer pool dump or LRU dump*/,"-2. bool backup_finish()
-1. {

/*Copy buffer pool dump or LRU dump*/

1. 	if (!opt_rsync) {
2. 		if (buffer_pool_filename && file_exists(buffer_pool_filename)) {
3. 			const char *dst_name = get_buffer_pool_filename(NULL);
4. 			copy_file(ds_data, buffer",Not Useful
"/*If we were applying an incremental change set, we need to make
	sure non-InnoDB files and xtrabackup_* metainfo files are copied
	to the full backup directory.*/","-10. 				   ""xtrabackup_slave_info"",
-9. 				   ""xtrabackup_info"",
-8. 				   ""ib_lru_dump"",
-7. 				   NULL};
-6. 	datadir_iter_t *it = NULL;
-5. 	datadir_node_t node;
-4. 	bool ret = true;
-3. 	char path[FN_REFLEN];
-2. 	int i;
-1. 	datadir_node_init(&n",Not Useful
/*copy buffer pool dump*/,"-10. 			}
-9. 			if (!(ret = copy_file(ds_data, node.filepath,
-8. 						node.filepath_rel, 1))) {
-7. 				msg(""Failed to copy file %s"",
-6. 					node.filepath);
-5. 				goto cleanup;
-4. 			}
-3. 		}
-2. 		if (!(ret = backup_files_from_datadir(xtrabackup",Not Useful
/*parse data file path*/,"-5. 	if (my_setwd(xtrabackup_target_dir, MYF(MY_WME)))
-4. 	{
-3. 		msg(""Can't my_setwd %s"", xtrabackup_target_dir);
-2. 		return(false);
-1. 	}

/*parse data file path*/

1. 	if (!innobase_data_file_path) {
2.   		innobase_data_file_path = (char*) ""ibdat",Not Useful
"/*Create temporary checkpoint in $rocksdb_datadir/mariabackup-checkpoint
  directory.
  A (user-level) lock named 'mariabackup_rocksdb_checkpoint' will also be
  acquired be this function.*/","-10. 		exit(EXIT_FAILURE);
-9. 	}
-8. 	mysql_free_result(res);
-7. }
-6. static void rocksdb_unlock_checkpoint()
-5. {
-4. 	xb_mysql_query(mysql_connection, 
-3. 		""SELECT RELEASE_LOCK('mariabackup_rocksdb_checkpoint')"", false, true);
-2. }
-1. /*
  Creat",Not Useful
/*Compression options*/,"-10. } comp_thread_ctxt_t;
-9. typedef struct {
-8. 	comp_thread_ctxt_t	*threads;
-7. 	uint			nthreads;
-6. } ds_compress_ctxt_t;
-5. typedef struct {
-4. 	ds_file_t		*dest_file;
-3. 	ds_compress_ctxt_t	*comp_ctxt;
-2. 	size_t			bytes_processed;
-1. } ds_",Not Useful
/*Create and initialize the worker threads*/,"-10. static comp_thread_ctxt_t *create_worker_threads(uint n);
-9. static void destroy_worker_threads(comp_thread_ctxt_t *threads, uint n);
-8. static void *compress_worker_thread_func(void *arg);
-7. static
-6. ds_ctxt_t *
-5. compress_init(const char *r",Not Useful
/*Write the qpress archive header*/,"-5. 	fn_format(new_name, path, """", "".qp"", MYF(MY_APPEND_EXT));
-4. 	dest_file = ds_open(dest_ctxt, new_name, mystat);
-3. 	if (dest_file == NULL) {
-2. 		return NULL;
-1. 	}

/*Write the qpress archive header*/

1. 	if (ds_write(dest_file, ""qpress10"", 8) ",Not Useful
/*Write the qpress file header*/,"-1. 	fn_format(new_name, path, """", """", MYF(MY_REPLACE_DIR));

/*Write the qpress file header*/

1. 	name_len = strlen(new_name);
2. 	if (ds_write(dest_file, ""F"", 1) ||
3. 	    write_uint32_le(dest_file, (uint)name_len) ||",Not Useful
/*we want to write the terminating \0 as well*/,"-3. 	name_len = strlen(new_name);
-2. 	if (ds_write(dest_file, ""F"", 1) ||
-1. 	    write_uint32_le(dest_file, (uint)name_len) ||

/*we want to write the terminating \0 as well*/

1. 	    ds_write(dest_file, new_name, name_len + 1)) {
2. 		goto err;
3. 	}
",Not Useful
/*Send data to worker threads for compression*/,"-10. 	const char		*ptr;
-9. 	ds_file_t		*dest_file;
-8. 	comp_file = (ds_compress_file_t *) file->ptr;
-7. 	comp_ctxt = comp_file->comp_ctxt;
-6. 	dest_file = comp_file->dest_file;
-5. 	threads = comp_ctxt->threads;
-4. 	nthreads = comp_ctxt->nthreads;
-3",Not Useful
/*Reap and stream the compressed data*/,"-10. 			thd->data_avail = TRUE;
-9. 			pthread_cond_signal(&thd->data_cond);
-8. 			pthread_mutex_unlock(&thd->data_mutex);
-7. 			len -= chunk_len;
-6. 			if (len == 0) {
-5. 				break;
-4. 			}
-3. 			ptr += chunk_len;
-2. 		}
-1. 		max_thread = (i < nt",Not Useful
/*Write the qpress file trailer*/,"-10. }
-9. static
-8. int
-7. compress_close(ds_file_t *file)
-6. {
-5. 	ds_compress_file_t	*comp_file;
-4. 	ds_file_t		*dest_file;
-3. 	int			rc;
-2. 	comp_file = (ds_compress_file_t *) file->ptr;
-1. 	dest_file = comp_file->dest_file;

/*Write the qpres",Not Useful
"/*Supposedly the number of written bytes should be written as a
	""recovery information"" in the file trailer, but in reality qpress
	always writes 8 zeros here. Let's do the same*/","-1. 	ds_write(dest_file, ""ENDSENDS"", 8);

/*Supposedly the number of written bytes should be written as a
	""recovery information"" in the file trailer, but in reality qpress
	always writes 8 zeros here. Let's do the same*/

1. 	write_uint64_le(dest_file, 0",Not Useful
"/*qpress uses 0x00010000 as the initial value, but its own
		Adler-32 implementation treats the value differently:
		  1. higher order bits are the sum of all bytes in the sequence
		  2. lower order bits are the sum of resulting values at every
		     step.
		So it's the other way around as compared to zlib's adler32().
		That's why  0x00000001 is being passed here to be compatible
		with qpress implementation.*/","-10. 	while (1) {
-9. 		thd->data_avail = FALSE;
-8. 		pthread_cond_signal(&thd->data_cond);
-7. 		while (!thd->data_avail && !thd->cancelled) {
-6. 			pthread_cond_wait(&thd->data_cond, &thd->data_mutex);
-5. 		}
-4. 		if (thd->cancelled)
-3. 			break;
-",Not Useful
/*history.c -- standalone history library*/,"
/* history.c -- standalone history library */


/*history.c -- standalone history library*/

1. /* Copyright (C) 1989-2005 Free Software Foundation, Inc.
2.    This file contains the GNU History Library (the Library), a set of
3.    routines for managing the text of previously typed lines.
4.    The Library is free software; you can redistribute it and/or modify
5.    it under the terms of the GNU General Public License as published by
6.    the Free Software Foundation; either version 2, or (at your option)
7.    any later version.
8.    The Library is distributed in the hope that it will be useful, but
9.    WITHOUT ANY WARRANTY; without even the implied warranty of
10.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",Not Useful
"/*The goal is to make the implementation transparent, so that you
   don't have to know what data types are used, just what functions
   you can call.  I think I have done that.*/","-10.    the Free Software Foundation; either version 2, or (at your option)
-9.    any later version.
-8.    The Library is distributed in the hope that it will be useful, but
-7.    WITHOUT ANY WARRANTY; without even the implied warranty of
-6.    MERCHA",Not Useful
/*HAVE_STDLIB_H*/,"-5. #define READLINE_LIBRARY
-4. #if defined (HAVE_CONFIG_H)
-3. #  include ""config_readline.h""
-2. #endif
-1. #include <stdio.h>
#if defined (HAVE_STDLIB_H)

/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/******************************************************************/,"-2. #define DEFAULT_HISTORY_GROW_SIZE 50
-1. static char *hist_inittime PARAMS((void));

/******************************************************************/

111",Not Useful
/*History Functions*/,"-4. #define DEFAULT_HISTORY_GROW_SIZE 50
-3. static char *hist_inittime PARAMS((void));

/*History Functions*/

111",Not Useful
/******************************************************************/,"-2. #define DEFAULT_HISTORY_GROW_SIZE 50
-1. static char *hist_inittime PARAMS((void));

/******************************************************************/

111",Not Useful
/*assume snprintf if vsnprintf exists*/,"-8.   return t;
-7. }
-6. static char *
-5. hist_inittime ()
-4. {
-3.   time_t t;
-2.   char ts[64], *ret;
-1.   t = (time_t) time ((time_t *)0);

/*assume snprintf if vsnprintf exists*/

1.   snprintf (ts, sizeof (ts) - 1, ""X%lu"", (unsigned long) t);
2.",Not Useful
/*Page write filters implementation*/,"-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Not Useful
"/************************************************************************
Write-through page write filter.*/","-6. #include <my_global.h>
-5. #include <my_base.h>
-4. #include ""common.h""
-3. #include ""write_filt.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/************************************************************************
Write-through page writ",Not Useful
"/************************************************************************
Incremental page write filter.*/","-10. Write-through page write filter. */
-9. static my_bool wf_wt_init(xb_write_filt_ctxt_t *ctxt, char *dst_name,
-8. 			  xb_fil_cur_t *cursor, CorruptedPages *corrupted_pages);
-7. static my_bool wf_wt_process(xb_write_filt_ctxt_t *ctxt, ds_file_t *dst",Not Useful
"/************************************************************************
Initialize incremental page write filter.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Not Useful
/*allocate buffer for incremental backup (4096 pages)*/,"-10. Initialize incremental page write filter.
-9. @return TRUE on success, FALSE on error. */
-8. static my_bool
-7. wf_incremental_init(xb_write_filt_ctxt_t *ctxt, char *dst_name,
-6. 		    xb_fil_cur_t *cursor, CorruptedPages *corrupted_pages)
-5. {
-4",Not Useful
/*write delta meta info*/,"-7. 	cp->delta_buf_size = (cursor->page_size / 4) * cursor->page_size;
-6. 	cp->delta_buf = (unsigned char *)my_large_malloc(&cp->delta_buf_size, MYF(0));
-5. 	if (!cp->delta_buf) {
-4. 		msg(cursor->thread_n,""Can't allocate %zu bytes"",
-3. 			(size_t) cp",Not Useful
"/*change the target file name, since we are only going to write
	delta pages*/","-10. 	snprintf(meta_name, sizeof(meta_name), ""%s%s"", dst_name,
-9. 		 XB_DELTA_INFO_SUFFIX);
-8. 	const xb_delta_info_t	info(cursor->page_size, cursor->zip_size,
-7. 				     cursor->space_id);
-6. 	if (!xb_write_delta_metadata(meta_name, &info)) {
-5. 		",Not Useful
"/*""xtra""*/","-1. 	strcat(dst_name, "".delta"");

/*""xtra""*/

1. 	cp->npages = 1;
2. 	cp->corrupted_pages = corrupted_pages;
3. 	return(TRUE);
4. }",Not Useful
/*updated page*/,"-10. 	byte				*page;
-9. 	const ulint			page_size = cursor->page_size;
-8. 	xb_wf_incremental_ctxt_t	*cp = &(ctxt->wf_incremental_ctxt);
-7. 	for (i = 0, page = cursor->buf; i < cursor->buf_npages;
-6. 	     i++, page += page_size) {
-5. 		if ((!cp->corru",Not Useful
/*flush buffer*/,"-1. 		if (cp->npages == page_size / 4) {

/*flush buffer*/

1. 			if (ds_write(dstfile, cp->delta_buf,
2. 				     cp->npages * page_size)) {
3. 				return(FALSE);
4. 			}",Not Useful
/*clear buffer*/,"-4. 			if (ds_write(dstfile, cp->delta_buf,
-3. 				     cp->npages * page_size)) {
-2. 				return(FALSE);
-1. 			}

/*clear buffer*/

1. 			memset(cp->delta_buf, 0, page_size / 4 * page_size);",Not Useful
"/*""xtra""*/","-1. 	strcat(dst_name, "".delta"");

/*""xtra""*/

1. 	cp->npages = 1;
2. 	cp->corrupted_pages = corrupted_pages;
3. 	return(TRUE);
4. }",Not Useful
/*Mark the final block*/,"-10. @return TRUE on success, FALSE on error. */
-9. static my_bool
-8. wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt, ds_file_t *dstfile)
-7. {
-6. 	xb_fil_cur_t			*cursor = ctxt->cursor;
-5. 	const ulint			page_size = cursor->page_size;
-4. 	xb_wf_",Not Useful
"/*""XTRA""*/","-10. static my_bool
-9. wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt, ds_file_t *dstfile)
-8. {
-7. 	xb_fil_cur_t			*cursor = ctxt->cursor;
-6. 	const ulint			page_size = cursor->page_size;
-5. 	xb_wf_incremental_ctxt_t	*cp = &(ctxt->wf_incremental_",Not Useful
/*flush buffer*/,"-1. 		if (cp->npages == page_size / 4) {

/*flush buffer*/

1. 			if (ds_write(dstfile, cp->delta_buf,
2. 				     cp->npages * page_size)) {
3. 				return(FALSE);
4. 			}",Not Useful
"/************************************************************************
Free the incremental page write filter's buffer.*/","-5. 	if (ds_write(dstfile, cp->delta_buf, cp->npages * page_size)) {
-4. 		return(FALSE);
-3. 	}
-2. 	return(TRUE);
-1. }

/************************************************************************
Free the incremental page write filter's buffer.*/

1. sta",Not Useful
"/*readline.c -- a general facility for reading lines of input
   with emacs style editing and completion.*/","
/* readline.c -- a general facility for reading lines of input
   with emacs style editing and completion. */


/*readline.c -- a general facility for reading lines of input
   with emacs style editing and completion.*/

1. /* Copyright (C) 1987-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Not Useful
/*HAVE_SYS_FILE_H*/,"-10.    is generally kept in a file called COPYING or LICENSE.  If you do not
-9.    have a copy of the license, write to the Free Software Foundation,
-8.    51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA. */
-7. #define READLINE_LIBRARY
-6",Not Useful
/*HAVE_UNISTD_H*/,"
#if defined (HAVE_UNISTD_H)



/*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*!errno*/,"-8. #if defined (HAVE_LOCALE_H)
-7. #  include <locale.h>
-6. #endif
-5. #include <stdio.h>
-4. #include ""posixjmp.h""
-3. #include <errno.h>
-2. #if !defined (errno)
-1. extern int errno;

/*!errno*/

111",Not Useful
/*System-specific feature definitions and include files.*/,"-9. #if defined (HAVE_LOCALE_H)
-8. #  include <locale.h>
-7. #endif
-6. #include <stdio.h>
-5. #include ""posixjmp.h""
-4. #include <errno.h>
-3. #if !defined (errno)
-2. extern int errno;

/*System-specific feature definitions and include files.*/

1. #in",Not Useful
/*__EMX__*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""
#if defined (__EMX__)

/*__EMX__*/

1. #  define INCL_DOSPROCESS
2. #  include <os2.h>",Not Useful
/*Some standard library routines.*/,"-6. #include ""rldefs.h""
-5. #include ""rlmbutil.h""
-4. #if defined (__EMX__)
-3. #  define INCL_DOSPROCESS
-2. #  include <os2.h>

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include """,Not Useful
/*Forward declarations used in this file.*/,"-10. #include ""rlprivate.h""
-9. #include ""rlshell.h""
-8. #include ""xmalloc.h""
-7. #ifndef RL_LIBRARY_VERSION
-6. #  define RL_LIBRARY_VERSION ""5.1""
-5. #endif
-4. #ifndef RL_READLINE_VERSION
-3. #  define RL_READLINE_VERSION	0x0501
-2. #endif
-1. extern v",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*True if this is `real' readline as opposed to some stub substitute.*/,"-2. const char *rl_library_version = RL_LIBRARY_VERSION;
-1. int rl_readline_version = RL_READLINE_VERSION;

/*True if this is `real' readline as opposed to some stub substitute.*/

1. int rl_gnu_readline_p = 1;",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*`Forward' declarations*/,"-4. _rl_keyseq_cxt *_rl_kscxt = 0;

/*`Forward' declarations*/

111",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*Top Level Functions*/,"-3. int _rl_bind_stty_chars = 1;

/*Top Level Functions*/

111",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*Non-zero means treat 0200 bit in terminal input as Meta bit.*/,"-6. int _rl_bind_stty_chars = 1;

/*Non-zero means treat 0200 bit in terminal input as Meta bit.*/

111",Not Useful
/*Forward declaration*/,"-10. #include ""rlprivate.h""
-9. #include ""rlshell.h""
-8. #include ""xmalloc.h""
-7. #ifndef RL_LIBRARY_VERSION
-6. #  define RL_LIBRARY_VERSION ""5.1""
-5. #endif
-4. #ifndef RL_READLINE_VERSION
-3. #  define RL_READLINE_VERSION	0x0501
-2. #endif
-1. extern v",Not Useful
/*VI_MODE*/,"-10. 	}
-9.     }
-8.   else
-7.     {
-6.       if (rl_prompt && rl_already_prompted)
-5. 	rl_on_new_line_with_prompt ();
-4.       else
-3. 	rl_on_new_line ();
-2.       (*rl_redisplay_function) ();
-1.     }
#if defined (VI_MODE)

/*VI_MODE*/

1.   if ",Not Useful
/*VI_MODE*/,"-10. 	}
-9.     }
-8.   else
-7.     {
-6.       if (rl_prompt && rl_already_prompted)
-5. 	rl_on_new_line_with_prompt ();
-4.       else
-3. 	rl_on_new_line ();
-2.       (*rl_redisplay_function) ();
-1.     }
#if defined (VI_MODE)

/*VI_MODE*/

1.   if ",Not Useful
/*READLINE_CALLBACKS*/,"-10.   rl_set_signals ();
-9. #endif
-8.   value = readline_internal ();
-7.   if (rl_deprep_term_function)
-6.     (*rl_deprep_term_function) ();
-5. #if defined (HANDLE_SIGNALS)
-4.   rl_clear_signals ();
-3. #endif
-2.   return (value);
-1. }
#if defin",Not Useful
"/*Read a line of input from the global rl_instream, doing output on
   the global rl_outstream.
   If rl_prompt is non-null, then that is our prompt.*/","-10. #if defined (READLINE_CALLBACKS)
-9. static int
-8. readline_internal_charloop ()
-7. {
-6.   int eof = 1;
-5.   while (rl_done == 0)
-4.     eof = readline_internal_char ();
-3.   return (eof);
-2. }

/*Read a line of input from the global rl_instre",Not Useful
/*sentinel value*/,"-10. }
-9. #if defined (READLINE_CALLBACKS)
-8. _rl_keyseq_cxt *
-7. _rl_keyseq_cxt_alloc ()
-6. {
-5.   _rl_keyseq_cxt *cxt;
-4.   cxt = (_rl_keyseq_cxt *)xmalloc (sizeof (_rl_keyseq_cxt));
-3.   cxt->flags = cxt->subseq_arg = cxt->subseq_retval = 0;
-2.",Not Useful
/*For now*/,"-10.   if (key == ESC)
-9.     RL_UNSETSTATE(RL_STATE_METANEXT);
-8.   return k;
-7. }
-6. #if defined (READLINE_CALLBACKS)
-5. int
-4. _rl_dispatch_callback (cxt)
-3.      _rl_keyseq_cxt *cxt;
-2. {
-1.   int nkey, r;

/*For now*/

1. #if 1",Not Useful
"/*The first time this context is used, we want to read input and dispatch
     on it.  When traversing the chain of contexts back `up', we want to use
     the value from the next context down.  We're simulating recursion using
     a chain of contexts.*/","-1. #if 1

/*The first time this context is used, we want to read input and dispatch
     on it.  When traversing the chain of contexts back `up', we want to use
     the value from the next context down.  We're simulating recursion using
     a chain of ",Not Useful
/*For now*/,"-10.   if (key == ESC)
-9.     RL_UNSETSTATE(RL_STATE_METANEXT);
-8.   return k;
-7. }
-6. #if defined (READLINE_CALLBACKS)
-5. int
-4. _rl_dispatch_callback (cxt)
-3.      _rl_keyseq_cxt *cxt;
-2. {
-1.   int nkey, r;

/*For now*/

1. #if 1",Not Useful
/*success!*/,"-1.   r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));

/*success!*/

1.     {
2.       _rl_keyseq_chain_dispose ();
3.       RL_UNSETSTATE (RL_STATE_MULTIKEY);
4.       return r;
5.     }",Not Useful
/*magic value that says we added to the chain*/,"-5.     {
-4.       _rl_keyseq_chain_dispose ();
-3.       RL_UNSETSTATE (RL_STATE_MULTIKEY);
-2.       return r;
-1.     }

/*magic value that says we added to the chain*/

1.     _rl_kscxt = cxt->ocxt;
2.   if (_rl_kscxt)
3.     _rl_kscxt->childval = r;",Not Useful
/*READLINE_CALLBACKS*/,"-10.   rl_set_signals ();
-9. #endif
-8.   value = readline_internal ();
-7.   if (rl_deprep_term_function)
-6.     (*rl_deprep_term_function) ();
-5. #if defined (HANDLE_SIGNALS)
-4.   rl_clear_signals ();
-3. #endif
-2.   return (value);
-1. }
#if defin",Not Useful
/*Special case rl_do_lowercase_version ().*/,"-10.     }
-9.   if (RL_ISSTATE (RL_STATE_MACRODEF))
-8.     _rl_add_macro_char (key);
-7.   r = 0;
-6.   switch (map[key].type)
-5.     {
-4.     case ISFUNC:
-3.       func = map[key].function;
-2.       if (func)
-1. 	{

/*Special case rl_do_lowercase_",Not Useful
"/*If the function that was shadowed was self-insert, we
	     somehow need a keymap with map[key].func == self-insert.
	     Let's use this one.*/","-10.        already taken care of pushing any necessary input back onto
-9.        the input queue with _rl_unget_char. */
-8.     {
-7.       m = _rl_dispatching_keymap;
-6.       type = m[ANYOTHERKEY].type;
-5.       func = m[ANYOTHERKEY].function;
-4. ",Not Useful
"/*OK, back up the chain.*/","-6.       _rl_unget_char (key);
-5.       _rl_dispatching_keymap = map;
-4.       return -2;
-3.     }
-2.   else if (r && got_subseq)
-1.     {

/*OK, back up the chain.*/

1.       _rl_unget_char (key);
2.       _rl_dispatching_keymap = map;
3.       re",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*Initializations*/,"-8.       _rl_unget_char (key);
-7.       _rl_dispatching_keymap = map;
-6.       return -1;
-5.     }
-4.   return r;
-3. }

/*Initializations*/

111",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*__EMX__*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""
#if defined (__EMX__)

/*__EMX__*/

1. #  define INCL_DOSPROCESS
2. #  include <os2.h>",Not Useful
/*XXX*/,"-1.   rl_read_init_file ((char *)NULL);

/*XXX*/

1.   if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
2.     {
3.       _rl_screenwidth--;
4.       _rl_screenchars -= _rl_screenheight;
5.     }",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*Saving and Restoring Readline's state*/,"-10. bind_arrow_keys ()
-9. {
-8.   bind_arrow_keys_internal (emacs_standard_keymap);
-7. #if defined (VI_MODE)
-6.   bind_arrow_keys_internal (vi_movement_keymap);
-5.   bind_arrow_keys_internal (vi_insertion_keymap);
-4. #endif
-3. }

/*Saving and Resto",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*Data file read filter implementation*/,"-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
"/**
Perform read filter context initialization that is common to all read
filters.*/","-10. along with this program; if not, write to the Free Software
-9. Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA
-8. *******************************************************/
-7. /* Data file read filter implementation */",Not Useful
/*!<in/out: read filter context*/,"-4. static
-3. void
-2. common_init(

/*!<in/out: read filter context*/

111",Not Useful
/*!<in: file cursor*/,"-5. static
-4. void
-3. common_init(

/*!<in: file cursor*/

111",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
"/**
Initialize the pass-through read filter.*/","-10. /*========*/
-9. 	xb_read_filt_ctxt_t*	ctxt,	/*!<in/out: read filter context */
-8. 	const xb_fil_cur_t*	cursor)	/*!<in: file cursor */
-7. {
-6. 	ctxt->offset = 0;
-5. 	ctxt->data_file_size = cursor->statinfo.st_size;
-4. 	ctxt->buffer_capacity = cu",Not Useful
/*!<in/out: read filter context*/,"-4. static
-3. void
-2. common_init(

/*!<in/out: read filter context*/

111",Not Useful
/*!<in: file cursor*/,"-5. static
-4. void
-3. common_init(

/*!<in: file cursor*/

111",Not Useful
/*!<in: space id we are reading*/,"-1. 	ulint			space_id __attribute__((unused)))

/*!<in: space id we are reading*/

111",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
"/**
Get the next batch of pages for the pass-through read filter.*/","-10. rf_pass_through_init(
-9. /*=================*/
-8. 	xb_read_filt_ctxt_t*	ctxt,	/*!<in/out: read filter context */
-7. 	const xb_fil_cur_t*	cursor,	/*!<in: file cursor */
-6. 	ulint			space_id __attribute__((unused)))
-5. 					/*!<in: space id we are",Not Useful
"/*!<in/out: read filter
							context*/","-4. static
-3. void
-2. rf_pass_through_get_next_batch(

/*!<in/out: read filter
							context*/

111",Not Useful
"/*!<out: starting read
							offset in bytes for the
							next batch of pages*/","-6. static
-5. void
-4. rf_pass_through_get_next_batch(

/*!<out: starting read
							offset in bytes for the
							next batch of pages*/

111",Not Useful
"/*!<out: length in
							bytes of the next batch
							of pages*/","-10. Get the next batch of pages for the pass-through read filter.  */
-9. static
-8. void
-7. rf_pass_through_get_next_batch(

/*!<out: length in
							bytes of the next batch
							of pages*/

111",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
"/**
Deinitialize the pass-through read filter.*/","-10. 							of pages */
-9. {
-8. 	*read_batch_start = ctxt->offset;
-7. 	*read_batch_len = ctxt->data_file_size - ctxt->offset;
-6. 	if (*read_batch_len > (ib_int64_t)ctxt->buffer_capacity) {
-5. 		*read_batch_len = ctxt->buffer_capacity;
-4. 	}
-3. 	ctx",Not Useful
/*!<in: read filter context*/,"-1. 	xb_read_filt_ctxt_t*	ctxt __attribute__((unused)))

/*!<in: read filter context*/

111",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
"/**
Initialize the changed page bitmap-based read filter.  Assumes that
the bitmap is already set up in changed_page_bitmap.*/","-10. static
-9. void
-8. rf_pass_through_deinit(
-7. /*===================*/
-6. 	xb_read_filt_ctxt_t*	ctxt __attribute__((unused)))
-5. 					/*!<in: read filter context */
-4. {
-3. }
-2. /****************************************************************/",Not Useful
"/*!<in/out: read filter
						context*/","-4. static
-3. void
-2. rf_pass_through_get_next_batch(

/*!<in/out: read filter
						context*/

111",Not Useful
/*!<in: read cursor*/,"-6. static
-5. void
-4. rf_bitmap_init(

/*!<in: read cursor*/

111",Not Useful
/*!<in: space id*/,"-1. 	ulint			space_id __attribute__((unused)))

/*!<in: space id*/

111",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
"/**
Get the next batch of pages for the bitmap read filter.*/","-10. 						context */
-9. 	const xb_fil_cur_t*	cursor,		/*!<in: read cursor */
-8. 	ulint			space_id)	/*!<in: space id  */
-7. {
-6. 	common_init(ctxt, cursor);
-5. 	ctxt->bitmap_range = xb_page_bitmap_range_init(changed_page_bitmap,
-4. 						       spac",Not Useful
"/*!<in/out: read filter
							context*/","-4. static
-3. void
-2. rf_pass_through_get_next_batch(

/*!<in/out: read filter
							context*/

111",Not Useful
"/*!<out: starting read
							offset in bytes for the
							next batch of pages*/","-6. static
-5. void
-4. rf_pass_through_get_next_batch(

/*!<out: starting read
							offset in bytes for the
							next batch of pages*/

111",Not Useful
"/*!<out: length in
							bytes of the next batch
							of pages*/","-10. Get the next batch of pages for the pass-through read filter.  */
-9. static
-8. void
-7. rf_pass_through_get_next_batch(

/*!<out: length in
							bytes of the next batch
							of pages*/

111",Not Useful
"/*Used up all the previous bitmap range, get some more*/","-6. {
-5. 	ulint	start_page_id;
-4. 	const ulint	page_size	= ctxt->page_size;
-3. 	start_page_id = (ulint)(ctxt->offset / page_size);
-2. 	xb_a (ctxt->offset % page_size == 0);
-1. 	if (start_page_id == ctxt->filter_batch_end) {

/*Used up all the previou",Not Useful
/*Find the next changed page using the bitmap*/,"-1. 		ulint next_page_id;

/*Find the next changed page using the bitmap*/

1. 		next_page_id = xb_page_bitmap_range_get_next_bit
2. 			(ctxt->bitmap_range, TRUE);
3. 		if (next_page_id == ULINT_UNDEFINED) {
4. 			*read_batch_len = 0;
5. 			return;
6. 		}",Not Useful
"/*Find the end of the current changed page block by searching
		for the next cleared bitmap bit*/","-7. 		next_page_id = xb_page_bitmap_range_get_next_bit
-6. 			(ctxt->bitmap_range, TRUE);
-5. 		if (next_page_id == ULINT_UNDEFINED) {
-4. 			*read_batch_len = 0;
-3. 			return;
-2. 		}
-1. 		ctxt->offset = next_page_id * page_size;

/*Find the end of the",Not Useful
"/*No more cleared bits in the bitmap, need to copy all the
		remaining pages.*/","-7. 		ctxt->filter_batch_end
-6. 			= xb_page_bitmap_range_get_next_bit(ctxt->bitmap_range,
-5. 							    FALSE);
-4. 		xb_a(next_page_id < ctxt->filter_batch_end);
-3. 	}
-2. 	*read_batch_start = ctxt->offset;
-1. 	if (ctxt->filter_batch_end == ULINT_UN",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
"/**
Deinitialize the changed page bitmap-based read filter.*/","-10. 	is reached, trigerring the next bitmap query.  */
-9. 	if (*read_batch_len > (ib_int64_t)ctxt->buffer_capacity) {
-8. 		*read_batch_len = ctxt->buffer_capacity;
-7. 	}
-6. 	ctxt->offset += *read_batch_len;
-5. 	xb_a (ctxt->offset % page_size == 0);
",Not Useful
/*!<in/out: read filter context*/,"-4. static
-3. void
-2. common_init(

/*!<in/out: read filter context*/

111",Not Useful
/*The pass-through read filter*/,"-3. {
-2. 	xb_page_bitmap_range_deinit(ctxt->bitmap_range);
-1. }

/*The pass-through read filter*/

1. xb_read_filt_t rf_pass_through = {
2. 	&rf_pass_through_init,
3. 	&rf_pass_through_get_next_batch,
4. 	&rf_pass_through_deinit
5. };",Not Useful
/*The changed page bitmap-based read filter*/,"-5. xb_read_filt_t rf_pass_through = {
-4. 	&rf_pass_through_init,
-3. 	&rf_pass_through_get_next_batch,
-2. 	&rf_pass_through_deinit
-1. };

/*The changed page bitmap-based read filter*/

1. xb_read_filt_t rf_bitmap = {
2. 	&rf_bitmap_init,
3. 	&rf_bitma",Not Useful
/*! Name of file where Galera info is stored on recovery*/,"-10.    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA
-9. *******************************************************/
-8. #include <my_global.h>
-7. #include <my_base.h>
-6. #include <handler.h>
-5. #include <trx0rseg.h>
-4. ",Not Useful
"/***********************************************************************
Store Galera checkpoint info in the 'xtrabackup_galera_info' file, if that
information is present in the trx system header. Otherwise, do nothing.*/","-1. #define XB_GALERA_INFO_FILENAME ""xtrabackup_galera_info""

/***********************************************************************
Store Galera checkpoint info in the 'xtrabackup_galera_info' file, if that
information is present in the trx system head",Not Useful
/*Create the directory if needed*/,"-10. 	   MY_STAT *mystat __attribute__((unused)))
-9. {
-8. 	char 		fullpath[FN_REFLEN];
-7. 	char		dirpath[FN_REFLEN];
-6. 	size_t		dirpath_len;
-5. 	size_t		path_len;
-4. 	ds_local_file_t *local_file;
-3. 	ds_file_t	*file;
-2. 	File 		fd;
-1. 	fn_format",Not Useful
/*Calculate size of data without trailing zero bytes.*/,"-10. 	local_file->fd = fd;
-9. 	local_file->init_ibd_done = 0;
-8. 	local_file->is_ibd = (path_len > 5) && !strcmp(fullpath + path_len - 5, "".ibd"");
-7. 	local_file->compressed = 0;
-6. 	local_file->pagesize = 0;
-5. 	file->path = (char *) local_file + si",Not Useful
"/*Write data to the output file, and punch ""holes"" if needed.*/","-6. static size_t trim_binary_zeros(uchar *buf, size_t pagesize)
-5. {
-4. 	size_t i;
-3. 	for (i = pagesize; (i > 0) && (buf[i - 1] == 0); i--) {};
-2. 	return i;
-1. }

/*Write data to the output file, and punch ""holes"" if needed.*/

1. static int write",Not Useful
"/*This punches a ""hole"" in the file.*/","-10. 	{
-9. 		size_t n_bytes =  MY_MIN(pagesize, len - written);
-8. 		size_t datasize= trim_binary_zeros(ptr,n_bytes);
-7. 		if (datasize > 0) {
-6. 			if (!my_write(fd, ptr, datasize, MYF(MY_WME | MY_NABP)))
-5. 				posix_fadvise(fd, 0, 0, POSIX_FADV_DO",Not Useful
"/*Calculate Innodb tablespace specific data, when first page is written.
   We're interested in page compression and page size.*/","-10. 			size_t hole_bytes = n_bytes - datasize;
-9. 			if (my_seek(fd, hole_bytes, MY_SEEK_CUR, MYF(MY_WME | MY_NABP))
-8. 				== MY_FILEPOS_ERROR)
-7. 			 return 1;
-6. 		}
-5. 		written += n_bytes;
-4. 		ptr += n_bytes;
-3. 	}
-2. 	return 0;
-1. }
/* Ca",Not Useful
/*Set EOF at file's current position.*/,"-10. 	}
-9. 	if (local_file->compressed) {
-8. 		return write_compressed(fd, b, len, local_file->pagesize);
-7. 	}
-6. 	if (!my_write(fd, b , len, MYF(MY_WME | MY_NABP))) {
-5. 		posix_fadvise(fd, 0, 0, POSIX_FADV_DONTNEED);
-4. 		return 0;
-3. 	}
-2. 	re",Not Useful
"/*Do all writes to temporary files first, then pipe them to the specified
datasink in a serialized way in deinit().*/","-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Not Useful
"/*Create a temporary file in tmpdir. The file will be automatically
	removed on close. Code copied from mysql_tmpfile().*/","-10. static ds_file_t *
-9. tmpfile_open(ds_ctxt_t *ctxt, const char *path,
-8. 			       MY_STAT *mystat)
-7. {
-6. 	ds_tmpfile_ctxt_t	*tmpfile_ctxt;
-5. 	char			 tmp_path[FN_REFLEN];
-4. 	ds_tmp_file_t		*tmp_file;
-3. 	ds_file_t		*file;
-2. 	size_t			 p",Not Useful
/*terminating '\0'*/,"-6. 	fd = create_temp_file(tmp_path,xtrabackup_tmpdir,
-5. 			      ""xbtemp"", O_BINARY | O_SEQUENTIAL,
-4. 			      MYF(MY_WME | MY_TEMPORARY));
-3. 	if (fd < 0) {
-2. 		return NULL;
-1. 	}

/*terminating '\0'*/

1. 	file = (ds_file_t *) my_malloc(PSI_NOT",Not Useful
/*Size of read buffer in pages (640 pages = 10M for 16K sized pages)*/,"-10. #include <fsp0fsp.h>
-9. #include <srv0start.h>
-8. #include <trx0sys.h>
-7. #include ""fil_cur.h""
-6. #include ""fil0crypt.h""
-5. #include ""fil0pagecompress.h""
-4. #include ""common.h""
-3. #include ""read_filt.h""
-2. #include ""xtrabackup.h""
-1. #include",Not Useful
"/***********************************************************************
Extracts the relative path (""database/table.ibd"") of a tablespace from a
specified possibly absolute path.

For user tablespaces both ""./database/table.ibd"" and
""/remote/dir/database/table.ibd"" result in ""database/table.ibd"".

For system tablepsaces (i.e. When is_system is TRUE) both ""/remote/dir/ibdata1""
and ""./ibdata1"" yield ""ibdata1"" in the output.*/","-1. #define XB_FIL_CUR_PAGES 640

/***********************************************************************
Extracts the relative path (""database/table.ibd"") of a tablespace from a
specified possibly absolute path.

For user tablespaces both ""./database/ta",Not Useful
"/*!< in: tablespace path (either
			  		relative or absolute)*/","-3. const char *
-2. xb_get_relative_path(

/*!< in: tablespace path (either
			  		relative or absolute)*/

111",Not Useful
"/*!< in: TRUE for system tablespaces,
					i.e. when only the filename must be
					returned.*/","-10. specified possibly absolute path.
-9. For user tablespaces both ""./database/table.ibd"" and
-8. ""/remote/dir/database/table.ibd"" result in ""database/table.ibd"".
-7. For system tablepsaces (i.e. When is_system is TRUE) both ""/remote/dir/ibdata1""
-6. an",Not Useful
/**********************************************************************/,"-1. #define XB_FIL_CUR_PAGES 640
/***********************************************************************

/**********************************************************************/

1. Extracts the relative path (""database/table.ibd"") of a tablespace from ",Not Useful
"/************************************************************************
Open a source file cursor and initialize the associated read filter.

@return XB_FIL_CUR_SUCCESS on success, XB_FIL_CUR_SKIP if the source file must
be skipped and XB_FIL_CUR_ERROR on error.*/","-10. 	mysql_mutex_lock(&fil_system.mutex);
-9. 	ut_ad(node);
-8. 	ut_a(!node->being_extended);
-7. 	if (node->is_open()) {
-6. 		ret = os_file_close(node->handle);
-5. 		ut_a(ret);
-4. 		node->handle = OS_FILE_CLOSED;
-3. 	}
-2. 	mysql_mutex_unlock(&fil_s",Not Useful
/*!< out: source file cursor*/,"-3. xb_fil_cur_result_t
-2. xb_fil_cur_open(

/*!< out: source file cursor*/

111",Not Useful
/*!< in: source tablespace node*/,"-5. xb_fil_cur_result_t
-4. xb_fil_cur_open(

/*!< in: source tablespace node*/

111",Not Useful
/*!< thread number for diagnostics*/,"-6. xb_fil_cur_result_t
-5. xb_fil_cur_open(

/*!< thread number for diagnostics*/

1. 	ulonglong max_file_size)
2. {
3. 	bool	success;
4. 	int err;",Not Useful
"/*Initialize these first so xb_fil_cur_close() handles them correctly
	in case of error*/","-4. 	ulonglong max_file_size)
-3. {
-2. 	bool	success;
-1. 	int err;

/*Initialize these first so xb_fil_cur_close() handles them correctly
	in case of error*/

1. 	cursor->buf = NULL;
2. 	cursor->node = NULL;
3. 	cursor->space_id = node->space->id;
4. 	s",Not Useful
"/*Get the relative path for the destination tablespace name, i.e. the
	one that can be appended to the backup root directory. Non-system
	tablespaces may have absolute paths for DATA DIRECTORY.
	We want to make ""local"" copies for the backup.*/","-5. 	cursor->buf = NULL;
-4. 	cursor->node = NULL;
-3. 	cursor->space_id = node->space->id;
-2. 	strncpy(cursor->abs_path, node->name, (sizeof cursor->abs_path) - 1);
-1. 	cursor->abs_path[(sizeof cursor->abs_path) - 1] = '\0';

/*Get the relative path fo",Not Useful
/*The following call prints an error message*/,"-10. 	tablespace. Otherwise we open the file here. */
-9. 	if (!node->is_open()) {
-8. 		ut_ad(cursor->is_system()
-7. 		      || srv_operation == SRV_OPERATION_RESTORE_DELTA
-6. 		      || xb_close_files);
-5. 		node->handle = os_file_create_simple_no_er",Not Useful
/*Allocate read buffer*/,"-10. 		xb_fil_cur_close(cursor);
-9. 		return(XB_FIL_CUR_SKIP);
-8. 	}
-7. 	if (srv_file_flush_method == SRV_O_DIRECT
-6. 	    || srv_file_flush_method == SRV_O_DIRECT_NO_FSYNC) {
-5. 		os_file_set_nocache(cursor->file, node->name, ""OPEN"");
-4. 	}
-3. 	po",Not Useful
/*We ignore the doublewrite buffer pages.*/,"-10. 	return(XB_FIL_CUR_SUCCESS);
-9. }
-8. static bool page_is_corrupted(const byte *page, ulint page_no,
-7. 			      const xb_fil_cur_t *cursor,
-6. 			      const fil_space_t *space)
-5. {
-4. 	byte tmp_frame[UNIV_PAGE_SIZE_MAX];
-3. 	byte tmp_page[UN",Not Useful
/*Validate page number.*/,"-5. 	if (cursor->space_id == TRX_SYS_SPACE
-4. 	    && page_no >= FSP_EXTENT_SIZE
-3. 	    && page_no < FSP_EXTENT_SIZE * 3) {
-2. 		return false;
-1. 	}

/*Validate page number.*/

1. 	if (mach_read_from_4(page + FIL_PAGE_OFFSET) != page_no
2. 	    && cu",Not Useful
"/*On pages that are not all zero, the
		page number must match.

		There may be a mismatch on tablespace ID,
		because files may be renamed during backup.
		We disable the page number check
		on the system tablespace, because it may consist
		of multiple files, and here we count the pages
		from the start of each file.)

		The first 38 and last 8 bytes are never encrypted.*/","-2. 	if (mach_read_from_4(page + FIL_PAGE_OFFSET) != page_no
-1. 	    && cursor->space_id != TRX_SYS_SPACE) {

/*On pages that are not all zero, the
		page number must match.

		There may be a mismatch on tablespace ID,
		because files may be renamed duri",Not Useful
/*Whole zero page is valid.*/,"-10. 		from the start of each file.)
-9. 		The first 38 and last 8 bytes are never encrypted. */
-8. 		const ulint* p = reinterpret_cast<const ulint*>(page);
-7. 		const ulint* const end = reinterpret_cast<const ulint*>(
-6. 			page + page_size);
-5. 		do",Not Useful
"/*Validate encrypted pages. The first page is never encrypted.
	In the system tablespace, the first page would be written with
	FIL_PAGE_FILE_FLUSH_LSN at shutdown, and if the LSN exceeds
	4,294,967,295, the mach_read_from_4() below would wrongly
	interpret the page as encrypted. We prevent that by checking
	page_no first.*/","-5. 		return false;
-4. 	}
-3. 	if (space->full_crc32()) {
-2. 		return buf_page_is_corrupted(true, page, space->flags);
-1. 	}

/*Validate encrypted pages. The first page is never encrypted.
	In the system tablespace, the first page would be written with",Not Useful
"/*Compressed encrypted need to be decrypted
		and decompressed for verification.*/","-10. 	4,294,967,295, the mach_read_from_4() below would wrongly
-9. 	interpret the page as encrypted. We prevent that by checking
-8. 	page_no first. */
-7. 	if (page_no
-6. 	    && mach_read_from_4(page + FIL_PAGE_FILE_FLUSH_LSN_OR_KEY_VERSION)
-5. 	    ",Not Useful
"/*check pages for corruption and re-read if necessary. i.e. in case of
	partially written pages*/","-10. 	cursor->buf_read = 0;
-9. 	cursor->buf_npages = 0;
-8. 	cursor->buf_offset = offset;
-7. 	cursor->buf_page_no = static_cast<unsigned>(offset / page_size);
-6. 	if (os_file_read(IORequestRead, cursor->file, cursor->buf, offset,
-5. 			  (ulint) to_re",Not Useful
"/************************************************************************
Close the source file cursor opened with xb_fil_cur_open() and its
associated read filter.*/","-10. 	mysql_mutex_lock(&fil_system.mutex);
-9. 	ut_ad(node);
-8. 	ut_a(!node->being_extended);
-7. 	if (node->is_open()) {
-6. 		ret = os_file_close(node->handle);
-5. 		ut_a(ret);
-4. 		node->handle = OS_FILE_CLOSED;
-3. 	}
-2. 	mysql_mutex_unlock(&fil_s",Not Useful
/*Path length*/,"-10. 	chunk->type = validate_chunk_type(*ptr);
-9. 	if (chunk->type == XB_CHUNK_TYPE_UNKNOWN &&
-8. 	    !(chunk->flags & XB_STREAM_FLAG_IGNORABLE)) {
-7. 		msg(""xb_stream_read_chunk(): unknown chunk type 0x%lu at ""
-6. 		    ""offset 0x%llx."", (ulong) *pt",Not Useful
/*Path*/,"-10. 	chunk->type = validate_chunk_type(*ptr);
-9. 	if (chunk->type == XB_CHUNK_TYPE_UNKNOWN &&
-8. 	    !(chunk->flags & XB_STREAM_FLAG_IGNORABLE)) {
-7. 		msg(""xb_stream_read_chunk(): unknown chunk type 0x%lu at ""
-6. 		    ""offset 0x%llx."", (ulong) *pt",Not Useful
/*Payload length*/,"-8. 	if (chunk->pathlen > 0) {
-7. 		F_READ((uchar *) chunk->path, pathlen);
-6. 		stream->offset += pathlen;
-5. 	}
-4. 	chunk->path[pathlen] = '\0';
-3. 	if (chunk->type == XB_CHUNK_TYPE_EOF) {
-2. 		return XB_STREAM_READ_CHUNK;
-1. 	}

/*Payload length",Not Useful
/*Payload offset*/,"-10. 	F_READ(tmpbuf, 16);
-9. 	ullval = uint8korr(tmpbuf);
-8. 	if (ullval > (ulonglong) SIZE_T_MAX) {
-7. 		msg(""xb_stream_read_chunk(): chunk length is too large at ""
-6. 		    ""offset 0x%llx: 0x%llx."", (ulonglong) stream->offset,
-5. 		    ullval);
-4.",Not Useful
/*Reallocate the buffer if needed*/,"-9. 	ullval = uint8korr(tmpbuf + 8);
-8. 	if (ullval > (ulonglong) MY_OFF_T_MAX) {
-7. 		msg(""xb_stream_read_chunk(): chunk offset is too large at ""
-6. 		    ""offset 0x%llx: 0x%llx."", (ulonglong) stream->offset,
-5. 		    ullval);
-4. 		goto err;
-3. 	}
",Not Useful
/*Checksum*/,"-10. 	if (chunk->length > chunk->buflen) {
-9. 		chunk->data = my_realloc(PSI_NOT_INSTRUMENTED, chunk->data, chunk->length,
-8. 					 MYF(MY_WME | MY_ALLOW_ZERO_PTR));
-7. 		if (chunk->data == NULL) {
-6. 			msg(""xb_stream_read_chunk(): failed to increase",Not Useful
/*Payload*/,"-8. 	if (chunk->pathlen > 0) {
-7. 		F_READ((uchar *) chunk->path, pathlen);
-6. 		stream->offset += pathlen;
-5. 	}
-4. 	chunk->path[pathlen] = '\0';
-3. 	if (chunk->type == XB_CHUNK_TYPE_EOF) {
-2. 		return XB_STREAM_READ_CHUNK;
-1. 	}

/*Payload*/

1. ",Not Useful
/*!__EMX__*/,"-5.       if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-4. 	{
-3. #if defined (__EMX__)
-2. 	  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
-1. 	  _rl_screenwidth--;

/*!__EMX__*/

1. 	  _rl_get_screen_size (tty, 0);",Not Useful
/*!__EMX__*/,"-5.       if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-4. 	{
-3. #if defined (__EMX__)
-2. 	  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
-1. 	  _rl_screenwidth--;

/*!__EMX__*/

1. 	  _rl_get_screen_size (tty, 0);",Not Useful
/*Defaults.*/,"-1. 	}

/*Defaults.*/

1.       if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
2.         {
3. 	  _rl_screenwidth = 79;
4. 	  _rl_screenheight = 24;
5.         }",Not Useful
/*Everything below here is used by the redisplay code (tputs).*/,"-5.       if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-4.         {
-3. 	  _rl_screenwidth = 79;
-2. 	  _rl_screenheight = 24;
-1.         }

/*Everything below here is used by the redisplay code (tputs).*/

1.       _rl_screenchars = _rl_screenwid",Not Useful
/*VI_MODE*/,"-1.   bind_termcap_arrow_keys (emacs_standard_keymap);
#if defined (VI_MODE)

/*VI_MODE*/

1.   bind_termcap_arrow_keys (vi_movement_keymap);
2.   bind_termcap_arrow_keys (vi_insertion_keymap);",Not Useful
/*Home*/,"-2. static const char *_rl_term_ks;
-1. static const char *_rl_term_ke;

/*Home*/

1. static const char *_rl_term_kh;
2. static const char *_rl_term_kH;",Not Useful
/*End*/,"-2. static const char *_rl_term_ks;
-1. static const char *_rl_term_ke;

/*End*/

1. static const char *_rl_term_kh;
2. static const char *_rl_term_kH;",Not Useful
/*A function for the use of tputs ()*/,"-8. int
-7. rl_reset_terminal (terminal_name)
-6.      const char *terminal_name;
-5. {
-4.   _rl_screenwidth = _rl_screenheight = 0;
-3.   _rl_init_terminal_io (terminal_name);
-2.   return 0;
-1. }

/*A function for the use of tputs ()*/

1. #ifdef _MIN",Not Useful
/*!_MINIX*/,"-7. #ifdef _MINIX
-6. void
-5. _rl_output_character_function (c)
-4.      int c;
-3. {
-2.   putc (c, _rl_out_stream);
-1. }

/*!_MINIX*/

1. int
2. _rl_output_character_function (c)
3.      int c;
4. {
5.   return putc (c, _rl_out_stream);
6. }",Not Useful
/*!_MINIX*/,"-7. #ifdef _MINIX
-6. void
-5. _rl_output_character_function (c)
-4.      int c;
-3. {
-2.   putc (c, _rl_out_stream);
-1. }

/*!_MINIX*/

1. int
2. _rl_output_character_function (c)
3.      int c;
4. {
5.   return putc (c, _rl_out_stream);
6. }",Not Useful
/*Move the cursor back.*/,"-8. void
-7. _rl_output_some_chars (string, count)
-6.      const char *string;
-5.      int count;
-4. {
-3.   if (fwrite (string, 1, count, _rl_out_stream) != (size_t)count)
-2.     fprintf(stderr, ""Write failed\n"");
-1. }

/*Move the cursor back.*/

1.",Not Useful
/*Move to the start of the next line.*/,"-10. {
-9.   register int i;
-8.   if (_rl_term_backspace)
-7.     for (i = 0; i < count; i++)
-6.       tputs (_rl_term_backspace, 1, _rl_output_character_function);
-5.   else
-4.     for (i = 0; i < count; i++)
-3.       putc ('\b', _rl_out_stream);
-2",Not Useful
/*NEW_TTY_DRIVER*/,"-3. int
-2. rl_crlf ()
-1. {
#if defined (NEW_TTY_DRIVER)

/*NEW_TTY_DRIVER*/

1.   if (_rl_term_cr)
2.     tputs (_rl_term_cr, 1, _rl_output_character_function);",Not Useful
/*FALLTHROUGH*/,"-10.         {
-9. 	case NO_BELL:
-8. 	default:
-7. 	  break;
-6. 	case VISIBLE_BELL:
-5. 	  if (_rl_visible_bell)
-4. 	    {
-3. 	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
-2. 	      break;
-1. 	    }

/*FALLTHROUGH*/

1. 	case AU",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/*funmap.c -- attach names to functions.*/,"
/* funmap.c -- attach names to functions. */


/*funmap.c -- attach names to functions.*/

1. /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Not Useful
/*BUFSIZ*/,"-10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-9.    GNU General Public License for more details.
-8.    The GNU General Public License is often shipped with GNU software, and
-7.    is generally kept in a file called COPYING or",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*VI_MODE*/,"-10.   { ""undo"", rl_undo_command },
-9.   { ""universal-argument"", rl_universal_argument },
-8.   { ""unix-filename-rubout"", rl_unix_filename_rubout },
-7.   { ""unix-line-discard"", rl_unix_line_discard },
-6.   { ""unix-word-rubout"", rl_unix_word_rubout },
-",Not Useful
"/*Does buffered output to a destination datasink set with ds_set_pipe().
Writes to the destination datasink are guaranteed to not be smaller than a
specified buffer size (DS_DEFAULT_BUFFER_SIZE by default), with the only
exception for the last write for a file.*/","-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Not Useful
/*Change the default buffer size*/,"-10. static int buffer_close(ds_file_t *file);
-9. static void buffer_deinit(ds_ctxt_t *ctxt);
-8. datasink_t datasink_buffer = {
-7. 	&buffer_init,
-6. 	&buffer_open,
-5. 	&buffer_write,
-4. 	&buffer_close,
-3. 	&dummy_remove,
-2. 	&buffer_deinit
-1. };
",Not Useful
"/*We don't have any buffered bytes, just write
				the entire source buffer*/","-10. 				       bytes);
-9. 				if (ds_write(buffer_file->dst_file,
-8. 					     buffer_file->buf,
-7. 					     buffer_file->size)) {
-6. 					return 1;
-5. 				}
-4. 				buffer_file->pos = 0;
-3. 				buf += bytes;
-2. 				len -= bytes;
-1. 			} else {
",Not Useful
"/************************************************************************
Destroy a datasink handle*/","-5. int
-4. ds_close(ds_file_t *file)
-3. {
-2. 	return file->datasink->close(file);
-1. }

/************************************************************************
Destroy a datasink handle*/

1. void
2. ds_destroy(ds_ctxt_t *ctxt)
3. {
4. 	ctxt->datasi",Not Useful
"/************************************************************************
Set the destination pipe for a datasink (only makes sense for compress and
tmpfile).*/","-5. void
-4. ds_destroy(ds_ctxt_t *ctxt)
-3. {
-2. 	ctxt->datasink->deinit(ctxt);
-1. }

/************************************************************************
Set the destination pipe for a datasink (only makes sense for compress and
tmpfile).*/

1. v",Not Useful
/*list of files to sync for --rsync mode*/,"-10. #include ""xtrabackup.h""
-9. #include ""common.h""
-8. #include ""backup_copy.h""
-7. #include ""backup_debug.h""
-6. #include ""backup_mysql.h""
-5. #include <btr0btr.h>
-4. #ifdef _WIN32
-3. #include <aclapi.h>
-2. #endif
-1. #define ROCKSDB_BACKUP_DIR ""#ro",Not Useful
/*locations of tablespaces read from .isl files*/,"-1. static std::set<std::string> rsync_list;

/*locations of tablespaces read from .isl files*/

1. static std::map<std::string, std::string> tablespace_locations;",Not Useful
/*Whether LOCK BINLOG FOR BACKUP has been issued during backup*/,"-1. static std::map<std::string, std::string> tablespace_locations;

/*Whether LOCK BINLOG FOR BACKUP has been issued during backup*/

1. bool binlog_locked;
2. static void rocksdb_create_checkpoint();
3. static bool has_rocksdb_plugin();
4. static void c",Not Useful
"/************************************************************************
Struct represents file or directory.*/","-10. static void rocksdb_backup_checkpoint();
-9. static void rocksdb_copy_back();
-8. static bool is_abs_path(const char *path)
-7. {
-6. #ifdef _WIN32
-5. 	return path[0] && path[1] == ':' && (path[2] == '/' || path[2] == '\\');
-4. #else
-3. 	return pa",Not Useful
"/************************************************************************
Holds the state needed to enumerate files in MySQL data directory.*/","-10. Struct represents file or directory. */
-9. struct datadir_node_t {
-8. 	ulint		dbpath_len;
-7. 	char		*filepath;
-6. 	ulint		filepath_len;
-5. 	char		*filepath_rel;
-4. 	ulint		filepath_rel_len;
-3. 	bool		is_empty_dir;
-2. 	bool		is_file;
-1. };

/",Not Useful
"/************************************************************************
Represents the context of the thread processing MySQL data directory.*/","-10. 	pthread_mutex_t	mutex;
-9. 	os_file_dir_t	dir;
-8. 	os_file_dir_t	dbdir;
-7. 	os_file_stat_t	dbinfo;
-6. 	os_file_stat_t	fileinfo;
-5. 	dberr_t		err;
-4. 	bool		is_empty_dir;
-3. 	bool		is_file;
-2. 	bool		skip_first_level;
-1. };

/****************",Not Useful
"/************************************************************************
Fill the node struct. Memory for node need to be allocated and freed by
the caller. It is caller responsibility to initialize node with
datadir_node_init and cleanup the memory with datadir_node_free.
Node can not be shared between threads.*/","-5. bool
-4. is_path_separator(char c)
-3. {
-2. 	return(c == FN_LIBCHAR || c == FN_LIBCHAR2);
-1. }

/************************************************************************
Fill the node struct. Memory for node need to be allocated and freed by
the cal",Not Useful
"/************************************************************************
Create the MySQL data directory iterator. Memory needs to be released
with datadir_iter_free. Position should be advanced with
datadir_iter_next_file. Iterator can be shared between multiple
threads. It is guaranteed that each thread receives unique file from
data directory into its local node struct.*/","-10. 	free(node->filepath);
-9. 	free(node->filepath_rel);
-8. 	memset(node, 0, sizeof(datadir_node_t));
-7. }
-6. static
-5. void
-4. datadir_node_init(datadir_node_t *node)
-3. {
-2. 	memset(node, 0, sizeof(datadir_node_t));
-1. }

/********************",Not Useful
"/************************************************************************
Concatenate n parts into single path*/","-8. 		it->dbdir = os_file_opendir(it->dbpath);
-7. 		if (it->dir != IF_WIN(INVALID_HANDLE_VALUE, nullptr)) {
-6. 			it->is_file = false;
-5. 			return(true);
-4. 		}
-3. 	}
-2. 	return(false);
-1. }

/******************************************************",Not Useful
/*We found a symlink or a file*/,"-10. 		return(true);
-9. 	}
-8. 	if (!it->dbpath || !it->dbdir) {
-7. 		return(false);
-6. 	}
-5. 	while (os_file_readdir_next_file(it->dbpath, it->dbdir,
-4. 					  &it->fileinfo) == 0) {
-3. 		if (it->fileinfo.type == OS_FILE_TYPE_DIR) {
-2. 			continue",Not Useful
/*nothing found*/,"-10. 			goto done;
-9. 		}
-8. 		make_path_n(2, &it->filepath, &it->filepath_len,
-7. 				it->datadir_path, it->dbinfo.name);
-6. 		make_path_n(1, &it->filepath_rel, &it->filepath_rel_len,
-5. 				it->dbinfo.name);
-4. 		it->is_empty_dir = true;
-3. 		dat",Not Useful
"/************************************************************************
Interface to read MySQL data file sequentially. One should open file
with datafile_open to get cursor and close the cursor with
datafile_close. Cursor can not be shared between multiple
threads.*/","-5. bool
-4. is_path_separator(char c)
-3. {
-2. 	return(c == FN_LIBCHAR || c == FN_LIBCHAR2);
-1. }

/************************************************************************
Interface to read MySQL data file sequentially. One should open file
with dataf",Not Useful
"/************************************************************************
Holds the state needed to copy single data file.*/","-10. 	}
-9. 	if (it->dir) {
-8. 		os_file_closedir(it->dir);
-7. 	}
-6. 	free(it->dbpath);
-5. 	free(it->filepath);
-4. 	free(it->filepath_rel);
-3. 	free(it->datadir_path);
-2. 	free(it);
-1. }

/**********************************************************",Not Useful
"/*Get the relative path for the destination tablespace name, i.e. the
	one that can be appended to the backup root directory. Non-system
	tablespaces may have absolute paths for remote tablespaces in MySQL
	5.6+. We want to make ""local"" copies for the backup.*/","-10. 		os_file_close(cursor->file);
-9. 	}
-8. 	free(cursor->buf);
-7. }
-6. static
-5. bool
-4. datafile_open(const char *file, datafile_cur_t *cursor, uint thread_n)
-3. {
-2. 	bool		success;
-1. 	new (cursor) datafile_cur_t(file);

/*Get the relative p",Not Useful
/*The following call prints an error message*/,"-10. 	tablespaces may have absolute paths for remote tablespaces in MySQL
-9. 	5.6+. We want to make ""local"" copies for the backup. */
-8. 	strncpy(cursor->rel_path,
-7. 		xb_get_relative_path(cursor->abs_path, FALSE),
-6. 		(sizeof cursor->rel_path) - 1)",Not Useful
"/************************************************************************
Check to see if a file exists.
Takes name of the file to check.
@return true if file exists.*/","-10. 			  cursor->file, cursor->buf, cursor->buf_offset,
-9. 			  to_read) != DB_SUCCESS) {
-8. 		return(XB_FIL_CUR_ERROR);
-7. 	}
-6. 	posix_fadvise(cursor->file, cursor->buf_offset, to_read,
-5. 		      POSIX_FADV_DONTNEED);
-4. 	cursor->buf_read = to_r",Not Useful
"/************************************************************************
Trim leading slashes from absolute path so it becomes relative*/","-10. @return true if file exists. */
-9. bool
-8. file_exists(const char *filename)
-7. {
-6. 	MY_STAT stat_arg;
-5. 	if (!my_stat(filename, &stat_arg, MYF(0))) {
-4. 		return(false);
-3. 	}
-2. 	return(true);
-1. }

/*************************************",Not Useful
/*make a parent directory path*/,"-5. static
-4. int
-3. mkdirp(const char *pathname, int Flags, myf MyFlags)
-2. {
-1. 	char *parent, *p;

/*make a parent directory path*/

1. 	if (!(parent= strdup(pathname)))
2.           return(-1);
3. 	for (p = parent + strlen(parent);
4. 	    !is_pat",Not Useful
/*try to make parent directory*/,"-5. 	if (!(parent= strdup(pathname)))
-4.           return(-1);
-3. 	for (p = parent + strlen(parent);
-2. 	    !is_path_separator(*p) && p != parent; p--) ;
-1. 	*p = 0;

/*try to make parent directory*/

1. 	if (p != parent && mkdirp(parent, Flags, MyFl",Not Useful
/*make this one if parent has been made*/,"-4. 	if (p != parent && mkdirp(parent, Flags, MyFlags) != 0) {
-3. 		free(parent);
-2. 		return(-1);
-1. 	}

/*make this one if parent has been made*/

1. 	if (my_mkdir(pathname, Flags, MyFlags) == 0) {
2. 		free(parent);
3. 		return(0);
4. 	}",Not Useful
/*if it already exists that is fine*/,"-4. 	if (my_mkdir(pathname, Flags, MyFlags) == 0) {
-3. 		free(parent);
-2. 		return(0);
-1. 	}

/*if it already exists that is fine*/

1. 	if (errno == EEXIST) {
2. 		free(parent);
3. 		return(0);
4. 	}
5. 	free(parent);
6. 	return(-1);
7. }",Not Useful
"/************************************************************************
Check if directory exists. Optionally create directory if doesn't
exist.
@return true if directory exists and if it was created successfully.*/","-10. 		return false;
-9. 	}
-8. 	result = strcmp(real_first, real_second);
-7. 	free(real_first);
-6. 	free(real_second);
-5. 	return result == 0;
-4. #else
-3. 	return strcmp(first, second) == 0;
-2. #endif
-1. }

/***************************************",Not Useful
/*could be symlink*/,"-10. 	if (my_stat(dir, &stat_arg, MYF(0)) == NULL) {
-9. 		if (!create) {
-8. 			return(false);
-7. 		}
-6. 		if (mkdirp(dir, 0777, MYF(0)) < 0) {
-5. 			my_strerror(errbuf, sizeof(errbuf), my_errno);
-4. 			msg(""Can not create directory %s: %s"", dir, err",Not Useful
"/************************************************************************
Check that directory exists and it is empty.*/","-10. 	os_dir = os_file_opendir(dir);
-9. 	if (os_dir == IF_WIN(INVALID_HANDLE_VALUE, nullptr)) {
-8. 		my_strerror(errbuf, sizeof(errbuf), my_errno);
-7. 		msg(""Can not open directory %s: %s"", dir,
-6. 			errbuf);
-5. 		return(false);
-4. 	}
-3. 	os_file_",Not Useful
"/************************************************************************
Same as datafile_copy_backup, but put file name into the list for
rsync command.*/","-10. 	of the filters value. */
-9. 	if (check_if_skip_table(filepath)) {
-8. 		msg(thread_n,""Skipping %s."", filepath);
-7. 		return(true);
-6. 	}
-5. 	if (filename_matches(filepath, ext_list)) {
-4. 		return copy_file(ds_data, filepath, filepath, thread_n",Not Useful
"/*Get the name and the path for the tablespace. node->name always
	contains the path (which may be absolute for remote tablespaces in
	5.6+). space->name contains the tablespace name in the form
	""./database/table.ibd"" (in 5.5-) or ""database/table"" (in 5.6+). For a
	multi-node shared tablespace, space->name contains the name of the first
	node, but that's irrelevant, since we only need node_name to match them
	against filters, and the shared tablespace is always copied regardless
	of the filters value.*/","-10. comparing its name to the list of known data file types and checking
-9. if passes the rules for partial backup.
-8. @return true if file backed up or skipped successfully. */
-7. static
-6. bool
-5. datafile_copy_backup(const char *filepath, uint th",Not Useful
/*unused for now*/,"-10. 		fprintf(f, ""%s\n"", filepath);
-9. 		if (save_to_list) {
-8. 			rsync_list.insert(filepath);
-7. 		}
-6. 	}
-5. 	return(true);
-4. }
-3. bool backup_file_print_buf(const char *filename, const char *buf, int buf_len)
-2. {
-1. 	ds_file_t	*dstfile	= N",Not Useful
/*close*/,"-10. 	return(it);
-9. error:
-8. 	free(it);
-7. 	return(NULL);
-6. }
-5. static
-4. bool
-3. datadir_iter_next_database(datadir_iter_t *it)
-2. {
-1. 	if (it->dbdir != NULL) {
		if (os_file_closedir_failed(it->dbdir)) {

/*close*/

1. 			msg(""Warning: cou",Not Useful
/*Wait for threads to exit*/,"-10. 		malloc(sizeof(datadir_thread_ctxt_t) * n);
-9. 	pthread_mutex_init(&count_mutex, NULL);
-8. 	count = n;
-7. 	for (i = 0; i < n; i++) {
-6. 		data_threads[i].it = it;
-5. 		data_threads[i].n_thread = i + 1;
-4. 		data_threads[i].count = &count;
-3. ",Not Useful
/*The main copy loop*/,"-10. 		goto error_close;
-9. 	}
-8. 	strncpy(dst_name, cursor.rel_path, sizeof(dst_name));
-7. 	dstfile = ds_open(datasink, dst_path, &cursor.statinfo);
-6. 	if (dstfile == NULL) {
-5. 		msg(thread_n,""error: ""
-4. 			""cannot open the destination stream fo",Not Useful
/*close*/,"-10. 	return(it);
-9. error:
-8. 	free(it);
-7. 	return(NULL);
-6. }
-5. static
-4. bool
-3. datadir_iter_next_database(datadir_iter_t *it)
-2. {
-1. 	if (it->dbdir != NULL) {
		if (os_file_closedir_failed(it->dbdir)) {

/*close*/

1. 			msg(""Warning: cou",Not Useful
/*ERROR*/,"-10. 	return(NULL);
-9. }
-8. static
-7. bool
-6. datadir_iter_next_database(datadir_iter_t *it)
-5. {
-4. 	if (it->dbdir != NULL) {
-3. 		if (os_file_closedir_failed(it->dbdir)) {
-2. 			msg(""Warning: could not""
-1. 			      "" close database directory %s",Not Useful
/*Trim whitespace from end of filepath*/,"-10. void
-9. read_link_file(const char *ibd_filepath, const char *link_filepath)
-8. {
-7. 	char *filepath= NULL;
-6. 	FILE *file = fopen(link_filepath, ""r+b"");
-5. 	if (file) {
-4. 		filepath = static_cast<char*>(malloc(OS_FILE_MAX_PATH));
-3. 		os_file",Not Useful
/*copy to datadir by default*/,"-10. Copy or move file depending on current mode.
-9. @return true in case of success. */
-8. static
-7. bool
-6. copy_or_move_file(const char *src_file_path,
-5. 		  const char *dst_file_path,
-4. 		  const char *dst_dir,
-3. 		  uint thread_n,
-2. 		 bo",Not Useful
/*read the link from .isl file*/,"-3. 	char filedir[FN_REFLEN];
-2. 	size_t filedir_len;
-1. 	bool ret;

/*read the link from .isl file*/

1. 	if (ends_with(src_file_path, "".isl"")) {
2. 		char *ibd_filepath;
3. 		ibd_filepath = strdup(src_file_path);
4. 		strcpy(ibd_filepath + strlen(ibd_",Not Useful
/*check if there is .isl file*/,"-7. 	if (ends_with(src_file_path, "".isl"")) {
-6. 		char *ibd_filepath;
-5. 		ibd_filepath = strdup(src_file_path);
-4. 		strcpy(ibd_filepath + strlen(ibd_filepath) - 3, ""ibd"");
-3. 		read_link_file(ibd_filepath, src_file_path);
-2. 		free(ibd_filepath);
-",Not Useful
/*backup fake file into empty directory*/,"-10. 				ret = datafile_rsync_backup(node.filepath,
-9. 					!prep_mode, rsync_tmpfile);
-8. 			} else {
-7. 				ret = datafile_copy_backup(node.filepath, 1);
-6. 			}
-5. 			if (!ret) {
-4. 				msg(""Failed to copy file %s"", node.filepath);
-3. 				goto o",Not Useful
"/*Remove files that have been removed between first and
			second passes. Cannot use ""rsync --delete"" because it
			does not work with --files-from.*/","-10. 		if ((err = system(cmd.str().c_str()) && !prep_mode) != 0) {
-9. 			msg(""Error: rsync failed with error code %d"", err);
-8. 			ret = false;
-7. 			goto out;
-6. 		}
-5. 		msg(""rsync finished successfully."");
-4. 		if (!prep_mode && !opt_no_lock) {
-",Not Useful
/** Start --backup*/,"-10. 				p += sizeof lsn_prefix - 1;
-9. 				lsn = lsn_t(strtoll(p, NULL, 10));
-8. 			}
-7. 		}
-6. 		mysql_free_result(res);
-5. 	}
-4. 	return lsn;
-3. }
-2. lsn_t server_lsn_after_lock;
-1. extern void backup_wait_for_lsn(lsn_t lsn);

/** Start --back",Not Useful
"/*There is no need to stop slave thread before coping non-Innodb data when
--no-lock option is used because --no-lock option requires that no DDL or
DML to non-transaction tables can occur.*/","-10. 	}
-9. 	msg(""Waiting for log copy thread to read lsn %llu"", (ulonglong)server_lsn_after_lock);
-8. 	backup_wait_for_lsn(server_lsn_after_lock);
-7. 	DBUG_EXECUTE_FOR_KEY(""sleep_after_waiting_for_lsn"", {},
-6. 		{
-5. 			ulong milliseconds = strtoul(d",Not Useful
"/*The only reason why Galera/binlog info is written before
	wait_for_ibbackup_log_copy_finish() is that after that call the xtrabackup
	binary will start streamig a temporary copy of REDO log to stdout and
	thus, any streaming from innobackupex would interfere. The only way to
	avoid that is to have a single process, i.e. merge innobackupex and
	xtrabackup.*/","-10. 				return(false);
-9. 			}
-8. 		}
-7. 	}
-6. 	if (opt_slave_info) {
-5. 		lock_binlog_maybe(mysql_connection);
-4. 		if (!write_slave_info(mysql_connection)) {
-3. 			return(false);
-2. 		}
-1. 	}

/*The only reason why Galera/binlog info is writte",Not Useful
/** Release resources after backup_start()*/,"-10. 			return(false);
-9. 		}
-8. 	}
-7. 	if (have_flush_engine_logs && !opt_no_lock) {
-6. 		msg(""Executing FLUSH NO_WRITE_TO_BINLOG ENGINE LOGS..."");
-5. 		xb_mysql_query(mysql_connection,
-4. 			""FLUSH NO_WRITE_TO_BINLOG ENGINE LOGS"", false);
-3. 	}
-",Not Useful
/*release all locks*/,"-2. void backup_release()
-1. {

/*release all locks*/

1. 	if (!opt_no_lock) {
2. 		unlock_all(mysql_connection);
3. 		history_lock_time = 0;
4. 	} else {
5. 		history_lock_time = time(NULL) - history_lock_time;
6. 	}
7. 	if (opt_lock_ddl_per_table) {
8.",Not Useful
/** Finish after backup_start() and backup_release()*/,"-10. 	const char *dst_name = default_buffer_pool_file;
-9. 	if (!opt_galera_info) {
-8. 		dir_length = dirname_length(buffer_pool_filename);
-7. 		dst_name = buffer_pool_filename + dir_length;
-6. 	}
-5. 	if (length) {
-4. 		*length=dir_length;
-3. 	}
-2.",Not Useful
/*Copy buffer pool dump or LRU dump*/,"-2. bool backup_finish()
-1. {

/*Copy buffer pool dump or LRU dump*/

1. 	if (!opt_rsync) {
2. 		if (buffer_pool_filename && file_exists(buffer_pool_filename)) {
3. 			const char *dst_name = get_buffer_pool_filename(NULL);
4. 			copy_file(ds_data, buffer",Not Useful
"/*If we were applying an incremental change set, we need to make
	sure non-InnoDB files and xtrabackup_* metainfo files are copied
	to the full backup directory.*/","-10. 				   ""xtrabackup_slave_info"",
-9. 				   ""xtrabackup_info"",
-8. 				   ""ib_lru_dump"",
-7. 				   NULL};
-6. 	datadir_iter_t *it = NULL;
-5. 	datadir_node_t node;
-4. 	bool ret = true;
-3. 	char path[FN_REFLEN];
-2. 	int i;
-1. 	datadir_node_init(&n",Not Useful
/*copy only non-innodb files*/,"-4. 	if (xtrabackup_incremental) {
-3. 		ds_data = ds_create(xtrabackup_target_dir, DS_TYPE_LOCAL);
-2. 		it = datadir_iter_new(xtrabackup_incremental_dir);
-1. 		while (datadir_iter_next(it, &node)) {

/*copy only non-innodb files*/

1. 			if (node.is_em",Not Useful
/*copy buffer pool dump*/,"-10. 			}
-9. 			if (!(ret = copy_file(ds_data, node.filepath,
-8. 						node.filepath_rel, 1))) {
-7. 				msg(""Failed to copy file %s"",
-6. 					node.filepath);
-5. 				goto cleanup;
-4. 			}
-3. 		}
-2. 		if (!(ret = backup_files_from_datadir(xtrabackup",Not Useful
/*copy supplementary files*/,"-9. 		if (innobase_buffer_pool_filename) {
-8. 			const char *src_name = get_buffer_pool_filename(NULL);
-7. 			snprintf(path, sizeof(path), ""%s/%s"",
-6. 				xtrabackup_incremental_dir,
-5. 				src_name);
-4. 			if (file_exists(path)) {
-3. 				copy_file(",Not Useful
"/*If we are applying an incremental change set, we need to make
	sure non-InnoDB files are cleaned up from full backup dir before
	we copy files from incremental dir.*/","-10. 	return(ret);
-9. }
-8. bool
-7. ibx_cleanup_full_backup()
-6. {
-5. 	const char *ext_list[] = {""delta"", ""meta"", ""ibd"", NULL};
-4. 	datadir_iter_t *it = NULL;
-3. 	datadir_node_t node;
-2. 	bool ret = true;
-1. 	datadir_node_init(&node);

/*If we are",Not Useful
/*cd to backup directory*/,"-10. 			return(false);
-9. 	}
-8. 	if (innobase_data_home_dir && *innobase_data_home_dir
-7. 		&& !directory_exists(innobase_data_home_dir, true)) {
-6. 			return(false);
-5. 	}
-4. 	if (srv_log_group_home_dir && *srv_log_group_home_dir
-3. 		&& !director",Not Useful
/*parse data file path*/,"-5. 	if (my_setwd(xtrabackup_target_dir, MYF(MY_WME)))
-4. 	{
-3. 		msg(""Can't my_setwd %s"", xtrabackup_target_dir);
-2. 		return(false);
-1. 	}

/*parse data file path*/

1. 	if (!innobase_data_file_path) {
2.   		innobase_data_file_path = (char*) ""ibdat",Not Useful
/*copy undo tablespaces*/,"-9. 	if (!innobase_data_file_path) {
-8.   		innobase_data_file_path = (char*) ""ibdata1:10M:autoextend"";
-7. 	}
-6. 	srv_sys_space.set_path(""."");
-5. 	if (!srv_sys_space.parse_params(innobase_data_file_path, true)) {
-4. 		msg(""syntax error in innodb_data",Not Useful
/*copy redo logs*/,"-10. 		if (!file_exists(filename)) {
-9. 			break;
-8. 		}
-7. 		if (!(ret = copy_or_move_file(filename, filename,
-6. 					      dst_dir, 1))) {
-5. 			goto cleanup;
-4. 		}
-3. 	}
-2. 	ds_destroy(ds_data);
-1. 	ds_data = NULL;

/*copy redo logs*/

1. 	d",Not Useful
/*copy innodb system tablespace(s)*/,"-6. 	ds_data = ds_create(dst_dir, DS_TYPE_LOCAL);
-5. 	if (!(ret = copy_or_move_file(LOG_FILE_NAME, LOG_FILE_NAME,
-4. 				      dst_dir, 1))) {
-3. 		goto cleanup;
-2. 	}
-1. 	ds_destroy(ds_data);

/*copy innodb system tablespace(s)*/

1. 	dst_dir = (inn",Not Useful
/*copy the rest of tablespaces*/,"-10. 	     end(srv_sys_space.end());
-9. 	     iter != end;
-8. 	     ++iter) {
-7. 		const char *filepath = iter->filepath();
-6. 		if (!(ret = copy_or_move_file(base_name(filepath), filepath,
-5. 					      dst_dir, 1))) {
-4. 			goto cleanup;
-3. 		}
-",Not Useful
/*copied at later step*/,"-10. 			NULL};
-9. 		const char *filename;
-8. 		char c_tmp;
-7. 		int i_tmp;
-6. 		if (strstr(node.filepath,""/"" ROCKSDB_BACKUP_DIR ""/"")
-5. #ifdef _WIN32
-4. 			|| strstr(node.filepath,""\\"" ROCKSDB_BACKUP_DIR ""\\"")
-3. #endif
-2. 		)
-1. 		{

/*copied at",Not Useful
/*create empty directories*/,"-2. 			continue;
-1. 		}

/*create empty directories*/

1. 		if (node.is_empty_dir) {
2. 			char path[FN_REFLEN];
3. 			snprintf(path, sizeof(path), ""%s/%s"",
4. 				mysql_data_home, node.filepath_rel);
5. 			msg(""Creating directory %s"", path);
6. 			if (m",Not Useful
/*skip .qp files*/,"-10. 				my_strerror(errbuf, sizeof(errbuf), my_errno);
-9. 				msg(""Can not create directory %s: %s"",
-8. 					path, errbuf);
-7. 				ret = false;
-6. 				goto cleanup;
-5. 			}
-4. 			msg("" ...done."");
-3. 			continue;
-2. 		}
-1. 		filename = base_name",Not Useful
/*skip undo tablespaces*/,"-3. 		if (filename_matches(filename, ext_list)) {
-2. 			continue;
-1. 		}

/*skip undo tablespaces*/

1. 		if (sscanf(filename, ""undo%d%c"", &i_tmp, &c_tmp) == 1) {
2. 			continue;
3. 		}",Not Useful
/*skip innodb data files*/,"-3. 		if (!strcmp(filename, src_buffer_pool)) {
-2. 			continue;
-1. 		}

/*skip innodb data files*/

1. 		for (Tablespace::const_iterator iter(srv_sys_space.begin()),
2. 		       end(srv_sys_space.end()); iter != end; ++iter) {
3. 			if (!strcmp(base_nam",Not Useful
/*copy buffer pool dump*/,"-10. 			}
-9. 			if (!(ret = copy_file(ds_data, node.filepath,
-8. 						node.filepath_rel, 1))) {
-7. 				msg(""Failed to copy file %s"",
-6. 					node.filepath);
-5. 				goto cleanup;
-4. 			}
-3. 		}
-2. 		if (!(ret = backup_files_from_datadir(xtrabackup",Not Useful
/*skip empty directories in backup*/,"-10. 		}
-9. 	 }
-8.  	return(true);
-7. }
-6. static void decrypt_decompress_thread_func(datadir_thread_ctxt_t *ctxt)
-5. {
-4. 	bool ret = true;
-3. 	datadir_node_t node;
-2. 	datadir_node_init(&node);
-1. 	while (datadir_iter_next(ctxt->it, &node)) {

",Not Useful
/*cd to backup directory*/,"-10. 			return(false);
-9. 	}
-8. 	if (innobase_data_home_dir && *innobase_data_home_dir
-7. 		&& !directory_exists(innobase_data_home_dir, true)) {
-6. 			return(false);
-5. 	}
-4. 	if (srv_log_group_home_dir && *srv_log_group_home_dir
-3. 		&& !director",Not Useful
/*copy the rest of tablespaces*/,"-10. 	     end(srv_sys_space.end());
-9. 	     iter != end;
-8. 	     ++iter) {
-7. 		const char *filepath = iter->filepath();
-6. 		if (!(ret = copy_or_move_file(base_name(filepath), filepath,
-5. 					      dst_dir, 1))) {
-4. 			goto cleanup;
-3. 		}
-",Not Useful
"/*Copy some files from top level datadir.
  Do not copy the Innodb files (ibdata1, redo log files),
  as this is done in a separate step.*/","-10. 	if (it != NULL) {
-9. 		datadir_iter_free(it);
-8. 	}
-7. 	if (ds_data != NULL) {
-6. 		ds_destroy(ds_data);
-5. 	}
-4. 	ds_data = NULL;
-3. 	return(ret);
-2. }
-1. /*
  Copy some files from top level datadir.
  Do not copy the Innodb files (ibdata1",Not Useful
"/*Copies or moves a directory (non-recursively so far).
 Helper function used to backup rocksdb checkpoint, or copy-back the
 rocksdb files.

 Has optimization that allows to use hardlinks when possible
 (source and destination are directories on the same device)*/","-10. 	{
-9. 		strncpy(to_path_full, to_path, sizeof(to_path_full));
-8. 	}
-7. #ifdef _WIN32
-6. 	return  CreateHardLink(to_path_full, from_path, NULL);
-5. #else
-4. 	return !link(from_path, to_path_full);
-3. #endif
-2. }
-1. /*
 Copies or moves a direc",Not Useful
"/*Obtain user level lock , to protect the checkpoint directory of the server
  from being  user/overwritten by different backup processes, if backups are
  running in parallel.
  
  This lock will be acquired before rocksdb checkpoint is created,  held
  while all files from it are being copied to their final backup destination,
  and finally released after the checkpoint is removed.*/","-10. 				move_file(ds_data, from_path, node.filepath_rel,
-9. 					to, 1));
-8. 		}
-7. 		if (!rc)
-6. 			die(""copy or move file failed"");
-5. 	}
-4. 	datadir_iter_free(it);
-3. 	datadir_node_free(&node);
-2. }
-1. /*
  Obtain user level lock , to protect",Not Useful
"/*Create temporary checkpoint in $rocksdb_datadir/mariabackup-checkpoint
  directory.
  A (user-level) lock named 'mariabackup_rocksdb_checkpoint' will also be
  acquired be this function.*/","-10. 		exit(EXIT_FAILURE);
-9. 	}
-8. 	mysql_free_result(res);
-7. }
-6. static void rocksdb_unlock_checkpoint()
-5. {
-4. 	xb_mysql_query(mysql_connection, 
-3. 		""SELECT RELEASE_LOCK('mariabackup_rocksdb_checkpoint')"", false, true);
-2. }
-1. /*
  Creat",Not Useful
"/*Copy files from rocksdb temporary checkpoint to final destination.
  remove temp.checkpoint directory (in server's datadir)
  and release user level lock acquired inside rocksdb_create_checkpoint().*/","-10. 	if (!access(rocksdb_checkpoint_dir, 0))
-9. 	{
-8. 		msg(""Removing rocksdb checkpoint from previous backup attempt."");
-7. 		rocksdb_remove_checkpoint_directory();
-6. 	}
-5. 	char query[FN_REFLEN + 32];
-4. 	snprintf(query, sizeof(query), ""SET GLOB",Not Useful
/*namespace*/,"-10. #include <deal.II/lac/petsc_block_vector.h>
-9. #include <deal.II/lac/petsc_vector.h>
-8. #include <deal.II/lac/trilinos_epetra_vector.h>
-7. #include <deal.II/lac/trilinos_parallel_block_vector.h>
-6. #include <deal.II/lac/trilinos_tpetra_vector.h>
",Not Useful
/*s := d - trace(d) I*/,"-10.           ENDIF
-9.           THETA = (ACOS(XX))/3.D0
-8.           A1 = AM + R*COS(THETA)
-7.           A2 = AM + R*COS(THETA + 2.D0*PI/3.D0)
-6.           A3 = AM + R*COS(THETA + 4.D0*PI/3.D0)
-5.           WRITE(6,*)A1,A2,A3
-4.           STOP
-3.",Not Useful
/*namespace DerivativeApproximation*/,"
namespace DerivativeApproximation



/*namespace DerivativeApproximation*/

1. {
2.   namespace internal
3.   {",Not Useful
/*namespace Assembler*/,"-4. namespace DerivativeApproximation
-3. {
-2.   namespace internal
-1.   {
    namespace Assembler

/*namespace Assembler*/

1.     {
2.       struct Scratch
3.       {
4.         Scratch() = default;
5.       };
6.       struct CopyData
7.       {
8.  ",Not Useful
/*namespace DerivativeApproximation*/,"
namespace DerivativeApproximation



/*namespace DerivativeApproximation*/

1. {
2.   namespace internal
3.   {",Not Useful
/*...and the place where it lives*/,"-5.       const typename DerivativeDescription::ProjectedDerivative
-4.         this_midpoint_value =
-3.           DerivativeDescription::get_projected_derivative(fe_midpoint_value,
-2.                                                           solution,
",Not Useful
/*...and the place where it lives*/,"-5.       const typename DerivativeDescription::ProjectedDerivative
-4.         this_midpoint_value =
-3.           DerivativeDescription::get_projected_derivative(fe_midpoint_value,
-2.                                                           solution,
",Not Useful
/*namespace DerivativeApproximation*/,"
namespace DerivativeApproximation



/*namespace DerivativeApproximation*/

1. {
2.   namespace internal
3.   {",Not Useful
/*namespace DerivativeApproximation*/,"
namespace DerivativeApproximation



/*namespace DerivativeApproximation*/

1. {
2.   namespace internal
3.   {",Not Useful
/*namespace TrilinosWrappers*/,"-10. {
-9.   BlockSparsityPatternBase<DynamicSparsityPattern>::reinit(row_indices.size(),
-8.                                                            col_indices.size());
-7.   for (size_type i = 0; i < row_indices.size(); ++i)
-6.     for (size_type j",Not Useful
/*x_source_fe*/,"-8.         return FiniteElementDomination::no_requirements;
-7.     }
-6.   Assert(false, ExcNotImplemented());
-5.   return FiniteElementDomination::neither_element_dominates;
-4. }
-3. template <>
-2. void
-1. FE_RaviartThomasNodal<1>::get_face_interpo",Not Useful
/*interpolation_matrix*/,"-7.         return FiniteElementDomination::no_requirements;
-6.     }
-5.   Assert(false, ExcNotImplemented());
-4.   return FiniteElementDomination::neither_element_dominates;
-3. }
-2. template <>
-1. void
FE_RaviartThomasNodal<1>::get_face_interpolati",Not Useful
/*x_source_fe*/,"-8.         return FiniteElementDomination::no_requirements;
-7.     }
-6.   Assert(false, ExcNotImplemented());
-5.   return FiniteElementDomination::neither_element_dominates;
-4. }
-3. template <>
-2. void
-1. FE_RaviartThomasNodal<1>::get_face_interpo",Not Useful
/*subface*/,"-6.   const unsigned int) const
-5. {
-4.   Assert(false, ExcImpossibleInDim(1));
-3. }
-2. template <>
-1. void
FE_RaviartThomasNodal<1>::get_subface_interpolation_matrix(

/*subface*/

111",Not Useful
/*interpolation_matrix*/,"-7.         return FiniteElementDomination::no_requirements;
-6.     }
-5.   Assert(false, ExcNotImplemented());
-4.   return FiniteElementDomination::neither_element_dominates;
-3. }
-2. template <>
-1. void
FE_RaviartThomasNodal<1>::get_face_interpolati",Not Useful
/*namespace DoFHandlerImplementation*/,"-6. #include <deal.II/base/exceptions.h>
-5. #include <deal.II/base/memory_consumption.h>
-4. #include <deal.II/dofs/dof_faces.h>
-3. DEAL_II_NAMESPACE_OPEN
-2. namespace internal
-1. {
  namespace DoFHandlerImplementation

/*namespace DoFHandlerImplement",Not Useful
/*other rt_order*/,"-7.                   return (face_index !=
-6.                           GeometryInfo<dim>::opposite_face[shape_index]);
-5.                 }
-4.               default:
-3.                 return true;
-2.             }
-1.         }

/*other rt_order*/",Not Useful
/*TODO: Only one of these two assertions should be relevant*/,"-10.                                GeometryInfo<dim>::vertices_per_cell>
-9. MappingQ1Eulerian<dim, VectorType, spacedim>::get_vertices(
-8.   const typename Triangulation<dim, spacedim>::cell_iterator &cell) const
-7. {
-6.   boost::container::small_vec",Not Useful
/*namespace*/,"-10.   const Quadrature<dim - 1> &quadrature) const
-9. {
-8.   std::unique_ptr<typename Mapping<dim, spacedim>::InternalDataBase> data_ptr =
-7.     std::make_unique<InternalData>(euler_dof_handler->get_fe(), fe_mask);
-6.   auto &                data = ",Not Useful
/*push-forward the j-coordinate*/,"-10.                       fe.system_to_component_index(k).first;
-9.                     if (fe_mask[comp_k])
-8.                       for (unsigned int j = 0; j < dim; ++j)
-7.                         for (unsigned int l = 0; l < dim; ++l)
-6.         ",Not Useful
/*push-forward the l-coordinate*/,"-10.                       for (unsigned int m = 0; m < dim; ++m)
-9.                         for (unsigned int n = 0; n < dim; ++n)
-8.                           {
-7.                             tmp[i][j][l][m][n] = result[i][0][l][m][n] *
-6.          ",Not Useful
/*push-forward the m-coordinate*/,"-10.                               [point][i][j][l][m][n] =
-9.                                 tmp[i][j][0][m][n] *
-8.                                 data.covariant[point][l][0];
-7.                             for (unsigned int lr = 1; lr < dim; ++lr)",Not Useful
/*push-forward the n-coordinate*/,"-10.                                                                      [j][l][0]
-9.                                                                      [n] *
-8.                               data.covariant[point][m][0];
-7.                          ",Not Useful
/*(dim < spacedim)*/,"-10.                           cross_product_2d(data.aux[0][i]);
-9.                         break;
-8.                       case 3:
-7.                         output_data.boundary_forms[i] =
-6.                           cross_product_3d(data.aux[0][i]",Not Useful
/*namespace*/,"-10.   const Quadrature<dim - 1> &quadrature) const
-9. {
-8.   std::unique_ptr<typename Mapping<dim, spacedim>::InternalDataBase> data_ptr =
-7.     std::make_unique<InternalData>(euler_dof_handler->get_fe(), fe_mask);
-6.   auto &                data = ",Not Useful
/*namespace MappingFEFieldImplementation*/,"-10.   std::unique_ptr<typename Mapping<dim, spacedim>::InternalDataBase> data_ptr =
-9.     std::make_unique<InternalData>(euler_dof_handler->get_fe(), fe_mask);
-8.   auto &                data = dynamic_cast<InternalData &>(*data_ptr);
-7.   const Quad",Not Useful
/*dim == 2*/,"-6.                         output_data.boundary_forms[point] =
-5.                           data.contravariant[point].transpose()[0];
-4.                         output_data.boundary_forms[point] /=
-3.                           (face_no == 0 ? -1. : +1",Not Useful
/*calculate hessians of the Jacobians*/,"-8.   internal::MappingFEFieldImplementation::
-7.     maybe_update_jacobian_pushed_forward_grads<dim, spacedim, VectorType>(
-6.       QProjector<dim>::DataSetDescriptor::cell(),
-5.       data,
-4.       euler_dof_handler->get_fe(),
-3.       fe_mask,
-",Not Useful
/*calculate gradients of the hessians of the Jacobians*/,"-10.   internal::MappingFEFieldImplementation::
-9.     maybe_update_jacobian_pushed_forward_2nd_derivatives<dim,
-8.                                                          spacedim,
-7.                                                          VectorTyp",Not Useful
/*namespace*/,"-10.   const Quadrature<dim - 1> &quadrature) const
-9. {
-8.   std::unique_ptr<typename Mapping<dim, spacedim>::InternalDataBase> data_ptr =
-7.     std::make_unique<InternalData>(euler_dof_handler->get_fe(), fe_mask);
-6.   auto &                data = ",Not Useful
/*namespace MappingFEFieldImplementation*/,"-10.   std::unique_ptr<typename Mapping<dim, spacedim>::InternalDataBase> data_ptr =
-9.     std::make_unique<InternalData>(euler_dof_handler->get_fe(), fe_mask);
-8.   auto &                data = dynamic_cast<InternalData &>(*data_ptr);
-7.   const Quad",Not Useful
/*f'(x)*/,"-10.   const Point<spacedim> &                                     p,
-9.   const Point<dim> &                                          initial_p_unit,
-8.   InternalData &                                              mdata) const
-7. {
-6.   const unsign",Not Useful
/*Solve  [f'(x)]d=f(x)*/,"-10.             for (unsigned int j = 0; j < dim; ++j)
-9.               DF[j][fe_to_real[comp_k]] +=
-8.                 mdata.local_dof_values[k] * grad_k[j];
-7.         }
-6.       for (unsigned int j = 0; j < dim; ++j)
-5.         {
-4.           f[",Not Useful
/*f(x)*/,"-10.   const typename Triangulation<dim, spacedim>::cell_iterator &cell,
-9.   const Point<spacedim> &                                     p,
-8.   const Point<dim> &                                          initial_p_unit,
-7.   InternalData &           ",Not Useful
/*1 represented by FE_Q part*/,"-10.     return true;
-9.   else
-8.     return FE_Q_Base<dim, spacedim>::has_support_on_face(shape_index,
-7.                                                          face_index);
-6. }
-5. template <int dim, int spacedim>
-4. std::pair<Table<2, bool>, s",Not Useful
/*1 represented by DG0 part*/,"-2.   for (unsigned int i = 0; i < this->n_dofs_per_cell() - 1; ++i)
-1.     constant_modes(0, i) = true;

/*1 represented by DG0 part*/

1.   constant_modes(1, this->n_dofs_per_cell() - 1) = true;
2.   return std::pair<Table<2, bool>, std::vector<unsigne",Not Useful
/*namespace FESeries*/,"-4. #include <deal.II/base/config.h>
-3. #include <deal.II/fe/fe_series.h>
-2. #include <iostream>
-1. DEAL_II_NAMESPACE_OPEN
namespace FESeries

/*namespace FESeries*/

1. {
2.   std::pair<double, double>
3.   linear_regression(const std::vector<double> ",Not Useful
/*namespace DoFHandlerImplementation*/,"-10.              dynamic_cast<
-9.                const typename dealii::internal::DoFHandlerImplementation::
-8.                  Policy::ParallelShared<dim, spacedim> *>(&policy))
-7.       policy_name = ""Policy::ParallelShared<"";
-6.     else
-5.     ",Not Useful
/*---------------------------------------------------------------------------*/,"-10.     begin_active(level), end_active(level));
-9. }
-8. template <int dim, int spacedim>
-7. IteratorRange<typename DoFHandler<dim, spacedim>::level_cell_iterator>
-6. DoFHandler<dim, spacedim>::mg_cell_iterators_on_level(
-5.   const unsigned int lev",Not Useful
/*namespace PointValueHistoryImplementation*/,"-10. #include <deal.II/lac/trilinos_parallel_block_vector.h>
-9. #include <deal.II/lac/trilinos_vector.h>
-8. #include <deal.II/lac/vector.h>
-7. #include <deal.II/lac/vector_element_access.h>
-6. #include <deal.II/numerics/point_value_history.h>
-5. #inc",Not Useful
/*just one point needed*/,"-8.       const Point<dim> requested_location = point->requested_location;
-7.       const typename DoFHandler<dim>::active_cell_iterator cell =
-6.         GridTools::find_active_cell_around_point(StaticMappingQ1<dim>::mapping,
-5.                       ",Not Useful
/*exact same idea as above*/,"-1.         {

/*exact same idea as above*/

1.           DataPostprocessorInputs::Vector<dim> postprocessor_input;
2.           if (update_flags & update_values)
3.             {
4.               fe_values.get_function_values(solution, vector_solution_va",Not Useful
/*Find field mnemonic*/,"-10.     {
-9.       out << ""No independent values stored\n"";
-8.     }
-7.   if (data_store.begin() != data_store.end())
-6.     {
-5.       out
-4.         << ""Mnemonic: data set size (mask size, n true components) : n data sets\n"";
-3.     }
-2.   for ",Not Useful
/*namespace*/,"-9. #include <deal.II/base/quadrature_lib.h>
-8. #include <deal.II/fe/fe_face.h>
-7. #include <deal.II/fe/fe_nothing.h>
-6. #include <deal.II/fe/fe_poly_face.templates.h>
-5. #include <deal.II/fe/fe_tools.h>
-4. #include <deal.II/lac/householder.h>
-3. #i",Not Useful
/*namespace FE_FaceQImplementation*/,"-10. #include <deal.II/fe/fe_face.h>
-9. #include <deal.II/fe/fe_nothing.h>
-8. #include <deal.II/fe/fe_poly_face.templates.h>
-7. #include <deal.II/fe/fe_tools.h>
-6. #include <deal.II/lac/householder.h>
-5. #include <memory>
-4. #include <sstream>
-3. D",Not Useful
/*fe_other*/,"-10. }
-9. template <int dim, int spacedim>
-8. bool
-7. FE_FaceQ<dim, spacedim>::hp_constraints_are_implemented() const
-6. {
-5.   return true;
-4. }
-3. template <int dim, int spacedim>
-2. std::vector<std::pair<unsigned int, unsigned int>>
-1. FE_Face",Not Useful
"/*----------------------------- FE_FaceQ<1,spacedim> ------------------------*/","-10.   AssertDimension(support_point_values.size(),
-9.                   this->get_unit_support_points().size());
-8.   AssertDimension(support_point_values.size(), nodal_values.size());
-7.   AssertDimension(this->n_dofs_per_cell(), nodal_values.size())",Not Useful
/*subface*/,"-10.           << this->degree << "")"";
-9.   return namebuf.str();
-8. }
-7. template <int dim, int spacedim>
-6. void
-5. FE_FaceQ<dim, spacedim>::get_face_interpolation_matrix(
-4.   const FiniteElement<dim, spacedim> &source_fe,
-3.   FullMatrix<double",Not Useful
/*fe_other*/,"-10. }
-9. template <int dim, int spacedim>
-8. bool
-7. FE_FaceQ<dim, spacedim>::hp_constraints_are_implemented() const
-6. {
-5.   return true;
-4. }
-3. template <int dim, int spacedim>
-2. std::vector<std::pair<unsigned int, unsigned int>>
-1. FE_Face",Not Useful
/*--------------------------------------- FE_FaceP --------------------------*/,"-10.   const dealii::internal::FEValuesImplementation::MappingRelatedData<1,
-9.                                                                      spacedim>
-8.     &,
-7.   const typename FiniteElement<1, spacedim>::InternalDataBase &,
-6.   dealii::i",Not Useful
/*Constructor:*/,"-10. // it, and/or modify it under the terms of the GNU Lesser General
-9. // Public License as published by the Free Software Foundation; either
-8. // version 2.1 of the License, or (at your option) any later version.
-7. // The full text of the license",Not Useful
/*Shape functions:*/,"-2.   create_polynomials(order);
-1. }

/*Shape functions:*/

1. template <int dim, int spacedim>
2. double",Not Useful
/*i*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*i*/

111",Not Useful
/*p*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*p*/

111",Not Useful
/*i*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*i*/

111",Not Useful
/*p*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*p*/

111",Not Useful
/*component*/,"-10.       FiniteElementData<dim>(get_dpo_vector(order),
-9.                              dim,
-8.                              order + 1,
-7.                              FiniteElementData<dim>::Hcurl),
-6.       std::vector<bool>(compute_num_dofs(order)",Not Useful
/*Not implemented yet:*/,"-1. {

/*Not implemented yet:*/

1.   Assert(false, ExcNotImplemented());
2.   return 0.;
3. }
4. template <int dim, int spacedim>
5. Tensor<1, dim>",Not Useful
/*i*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*i*/

111",Not Useful
/*p*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*p*/

111",Not Useful
/*i*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*i*/

111",Not Useful
/*p*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*p*/

111",Not Useful
/*component*/,"-10.       FiniteElementData<dim>(get_dpo_vector(order),
-9.                              dim,
-8.                              order + 1,
-7.                              FiniteElementData<dim>::Hcurl),
-6.       std::vector<bool>(compute_num_dofs(order)",Not Useful
/*i*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*i*/

111",Not Useful
/*p*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*p*/

111",Not Useful
/*i*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*i*/

111",Not Useful
/*p*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2015 - 2021 by the deal.II authors

/*p*/

111",Not Useful
/*component*/,"-10.       FiniteElementData<dim>(get_dpo_vector(order),
-9.                              dim,
-8.                              order + 1,
-7.                              FiniteElementData<dim>::Hcurl),
-6.       std::vector<bool>(compute_num_dofs(order)",Not Useful
/*output_data*/,"-3.   const Quadrature<dim> &quadrature,
-2.   dealii::internal::FEValuesImplementation::FiniteElementRelatedData<dim,
-1.                                                                      spacedim>

/*output_data*/

1. {
2.   std::unique_ptr<
3.     t",Not Useful
/*Type 1:*/,"-10.           // HOWEVER, we have different types of DoFs on a line/face/cell.
-9.           // On a line we have two types, lowest order and higher order
-8.           // gradients.
-7.           //    - The numbering is such the lowest order is first, ",Not Useful
/*Type 2:*/,"-10.           //    - The numbering is such the lowest order is first, then higher
-9.           //    order.
-8.           //      This is simple enough as there is only 1 lowest order and
-7.           //      degree higher orders DoFs per line.
-6.   ",Not Useful
/*Type 3:*/,"-10.           //      degree higher orders DoFs per line.
-9.           //
-8.           // On a 2D cell, we have 3 types: Type 1/2/3:
-7.           //    - The ordering done by type:
-6.           //      - Type 1: 0 <= i1,j1 < degree. degree^2 in total",Not Useful
/*Type 1:*/,"-10.           // HOWEVER, we have different types of DoFs on a line/face/cell.
-9.           // On a line we have two types, lowest order and higher order
-8.           // gradients.
-7.           //    - The numbering is such the lowest order is first, ",Not Useful
/*Type 2:*/,"-10.           //    - The numbering is such the lowest order is first, then higher
-9.           //    order.
-8.           //      This is simple enough as there is only 1 lowest order and
-7.           //      degree higher orders DoFs per line.
-6.   ",Not Useful
/*Type 3:*/,"-10.           //      degree higher orders DoFs per line.
-9.           //
-8.           // On a 2D cell, we have 3 types: Type 1/2/3:
-7.           //    - The ordering done by type:
-6.           //      - Type 1: 0 <= i1,j1 < degree. degree^2 in total",Not Useful
/*edge_lambda_grads*/,"-7.           const unsigned int
-6.             edge_sigma_direction[GeometryInfo<2>::lines_per_cell] = {1,
-5.                                                                      1,
-4.                                                                   ",Not Useful
/*edge_lambda gradgrads:*/,"-10.               data.edge_lambda_grads_3d[3][q]  = {0.0, 1.0 - z, -y};
-9.               data.edge_lambda_grads_3d[4][q]  = {-z, 0.0, 1.0 - x};
-8.               data.edge_lambda_grads_3d[5][q]  = {z, 0.0, x};
-7.               data.edge_lambda_grads_3",Not Useful
/*Type 1:*/,"-10.           // HOWEVER, we have different types of DoFs on a line/face/cell.
-9.           // On a line we have two types, lowest order and higher order
-8.           // gradients.
-7.           //    - The numbering is such the lowest order is first, ",Not Useful
/*Type 2:*/,"-10.           //    - The numbering is such the lowest order is first, then higher
-9.           //    order.
-8.           //      This is simple enough as there is only 1 lowest order and
-7.           //      degree higher orders DoFs per line.
-6.   ",Not Useful
/*Type 1:*/,"-10.           // HOWEVER, we have different types of DoFs on a line/face/cell.
-9.           // On a line we have two types, lowest order and higher order
-8.           // gradients.
-7.           //    - The numbering is such the lowest order is first, ",Not Useful
/*Type 2:*/,"-10.           //    - The numbering is such the lowest order is first, then higher
-9.           //    order.
-8.           //      This is simple enough as there is only 1 lowest order and
-7.           //      degree higher orders DoFs per line.
-6.   ",Not Useful
/*DoF info:*/,"-3.           const unsigned int vertices_per_face(
-2.             GeometryInfo<dim>::vertices_per_face);
-1.           const unsigned int faces_per_cell(GeometryInfo<dim>::faces_per_cell);

/*DoF info:*/

1.           const unsigned int n_line_dofs =
2.",Not Useful
/*Type 1:*/,"-10.           // HOWEVER, we have different types of DoFs on a line/face/cell.
-9.           // On a line we have two types, lowest order and higher order
-8.           // gradients.
-7.           //    - The numbering is such the lowest order is first, ",Not Useful
/*Type 2:*/,"-10.           //    - The numbering is such the lowest order is first, then higher
-9.           //    order.
-8.           //      This is simple enough as there is only 1 lowest order and
-7.           //      degree higher orders DoFs per line.
-6.   ",Not Useful
/*Type 3:*/,"-10.           //      degree higher orders DoFs per line.
-9.           //
-8.           // On a 2D cell, we have 3 types: Type 1/2/3:
-7.           //    - The ordering done by type:
-6.           //      - Type 1: 0 <= i1,j1 < degree. degree^2 in total",Not Useful
/*Type 1:*/,"-10.           // HOWEVER, we have different types of DoFs on a line/face/cell.
-9.           // On a line we have two types, lowest order and higher order
-8.           // gradients.
-7.           //    - The numbering is such the lowest order is first, ",Not Useful
/*Type 2:*/,"-10.           //    - The numbering is such the lowest order is first, then higher
-9.           //    order.
-8.           //      This is simple enough as there is only 1 lowest order and
-7.           //      degree higher orders DoFs per line.
-6.   ",Not Useful
/*Type 3:*/,"-10.           //      degree higher orders DoFs per line.
-9.           //
-8.           // On a 2D cell, we have 3 types: Type 1/2/3:
-7.           //    - The ordering done by type:
-6.           //      - Type 1: 0 <= i1,j1 < degree. degree^2 in total",Not Useful
/*cell_similarity*/,"-10.                     }
-9.                 }
-8.             }
-7.         }
-6.     }
-5. }
-4. template <int dim, int spacedim>
-3. void
-2. FE_NedelecSZ<dim, spacedim>::fill_fe_values(
-1.   const typename Triangulation<dim, dim>::cell_iterator &ce",Not Useful
/*cell*/,"
  const unsigned int vertices_per_cell = GeometryInfo<dim>::vertices_per_cell;



/*cell*/

1.   const unsigned int lines_per_cell    = GeometryInfo<dim>::lines_per_cell;
2.   const unsigned int faces_per_cell    = GeometryInfo<dim>::faces_per_cell;
3.   const unsigned int n_line_dofs = this->n_dofs_per_line() * lines_per_cell;",Not Useful
/*face_no*/,"-10.                     transformed_shape_hessians[q][d];
-9.                 }
-8.             }
-7.         }
-6.     }
-5. }
-4. template <int dim, int spacedim>
-3. void
-2. FE_NedelecSZ<dim, spacedim>::fill_fe_face_values(
-1.   const typename Trian",Not Useful
/*sub_no*/,"-10.                 }
-9.             }
-8.         }
-7.     }
-6. }
-5. template <int dim, int spacedim>
-4. void
-3. FE_NedelecSZ<dim, spacedim>::fill_fe_subface_values(

/*sub_no*/

111",Not Useful
/*quadrature*/,"
  const Quadrature<dim> &quadrature,



/*quadrature*/

1.   dealii::internal::FEValuesImplementation::FiniteElementRelatedData<dim,
2.                                                                      spacedim>",Not Useful
/*mapping_internal*/,"-2.   const Quadrature<dim> &                             quadrature,
-1.   const Mapping<dim, dim> &                           mapping,
  const typename Mapping<dim, dim>::InternalDataBase &mapping_internal,

/*mapping_internal*/

1.   const dealii::inte",Not Useful
/*mapping_data*/,"-4.   const Quadrature<dim> &                             quadrature,
-3.   const Mapping<dim, dim> &                           mapping,
-2.   const typename Mapping<dim, dim>::InternalDataBase &mapping_internal,
-1.   const dealii::internal::FEValuesImpl",Not Useful
/*fe_internal*/,"-5.   const Quadrature<dim> &                             quadrature,
-4.   const Mapping<dim, dim> &                           mapping,
-3.   const typename Mapping<dim, dim>::InternalDataBase &mapping_internal,
-2.   const dealii::internal::FEValuesImpl",Not Useful
/*namespace*/,"-5. #include <deal.II/base/thread_management.h>
-4. #include <deal.II/fe/mapping_q1.h>
-3. #include <deal.II/hp/fe_values.h>
-2. #include <memory>
-1. DEAL_II_NAMESPACE_OPEN
namespace hp

/*namespace*/

1. {
2.   namespace
3.   {",Not Useful
/*namespace*/,"-5. #include <deal.II/base/thread_management.h>
-4. #include <deal.II/fe/mapping_q1.h>
-3. #include <deal.II/hp/fe_values.h>
-2. #include <memory>
-1. DEAL_II_NAMESPACE_OPEN
namespace hp

/*namespace*/

1. {
2.   namespace
3.   {",Not Useful
/*namespace*/,"-6. #  include <kinsol/kinsol_direct.h>
-5. #  include <sunlinsol/sunlinsol_dense.h>
-4. #  include <sunmatrix/sunmatrix_dense.h>
-3. #  include <iomanip>
-2. #  include <iostream>
-1. DEAL_II_NAMESPACE_OPEN
namespace SUNDIALS

/*namespace*/

1. {
2.   te",Not Useful
/*call to KINSol*/,"-8.         if (!setup_jacobian)
-7.           setup_jacobian = [](const VectorType &, const VectorType &) {
-6.             return 0;
-5.           };
-4.         status = KINSetJacFn(kinsol_mem, &setup_jacobian_callback<VectorType>);
-3.         AssertK",Not Useful
/*namespace SUNDIALS*/,"-6. #  include <kinsol/kinsol_direct.h>
-5. #  include <sunlinsol/sunlinsol_dense.h>
-4. #  include <sunmatrix/sunmatrix_dense.h>
-3. #  include <iomanip>
-2. #  include <iostream>
-1. DEAL_II_NAMESPACE_OPEN
namespace SUNDIALS

/*namespace SUNDIALS*/

1. ",Not Useful
/*clean up*/,"-3.         std::vector<types::global_dof_index> constrained_rows;
-2.         matrix.clear_rows(constrained_rows, 1.);
-1.       }

/*clean up*/

1.     solution.compress(VectorOperation::insert);
2.     right_hand_side.compress(VectorOperation::insert);",Not Useful
/*clean up*/,"-3.         std::vector<types::global_dof_index> constrained_rows;
-2.         matrix.clear_rows(constrained_rows, 1.);
-1.       }

/*clean up*/

1.     solution.compress(VectorOperation::insert);
2.     right_hand_side.compress(VectorOperation::insert);",Not Useful
/*namespace TrilinosWrappers*/,"-10.             constrained_rows.push_back(dof->first);
-9.         for (unsigned int block_n = 0; block_n < n_blocks; ++block_n)
-8.           if (block_m != block_n)
-7.             matrix.block(block_m, block_n).clear_rows(constrained_rows);
-6.      ",Not Useful
/*namespace MatrixTools*/,"-10. #endif
-9. #ifdef DEAL_II_WITH_TRILINOS
-8. #  include <deal.II/lac/trilinos_block_sparse_matrix.h>
-7. #  include <deal.II/lac/trilinos_parallel_block_vector.h>
-6. #  include <deal.II/lac/trilinos_sparse_matrix.h>
-5. #  include <deal.II/lac/trilin",Not Useful
/*this is the code from FE_FaceQ*/,"-10.                                    face_no);
-9. }
-8. template <int dim, int spacedim>
-7. void
-6. FE_TraceQ<dim, spacedim>::get_subface_interpolation_matrix(
-5.   const FiniteElement<dim, spacedim> &x_source_fe,
-4.   const unsigned int          ",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*---------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*---------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*---------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*---------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/** \brief Copy constructor.*/,"-10. 		, m_iPos(iPos)
-9. 		, m_iErrc(ecGENERIC)
-8. 		, m_ErrMsg(ParserErrorMsg::Instance())
-7. 	{
-6. 		stringstream_type stream;
-5. 		stream << (int)m_iPos;
-4. 		ReplaceSubString(m_strMsg, _T(""$POS$""), stream.str());
-3. 		ReplaceSubString(m_strMsg,",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-3. #endif
-2. namespace mu
-1. {

/*------------------------------------------------------------------------------*/

1. 	const ParserErrorMsg& ParserErrorMsg::Instance()
2. 	{
3. 		static const ParserErrorMsg instance;
4. 		return instance;
5. 	}",Not Useful
/*namespace mu*/,"-1. #endif
namespace mu

/*namespace mu*/

1. {",Not Useful
/*other rt_order*/,"-7.                   return (face_index !=
-6.                           GeometryInfo<dim>::opposite_face[shape_index]);
-5.                 }
-4.               default:
-3.                 return true;
-2.             }
-1.         }

/*other rt_order*/",Not Useful
/*------------------------------- FiniteElement ----------------------*/,"-10. #include <deal.II/fe/fe.h>
-9. #include <deal.II/fe/fe_values.h>
-8. #include <deal.II/fe/mapping.h>
-7. #include <deal.II/grid/tria.h>
-6. #include <deal.II/grid/tria_iterator.h>
-5. #include <algorithm>
-4. #include <functional>
-3. #include <numer",Not Useful
/*DoF is on a face*/,"-9.       return (this->reference_cell().face_to_cell_vertices(
-8.                 face,
-7.                 face_vertex,
-6.                 (face_orientation ? 1 : 0) + (face_rotation ? 2 : 0) +
-5.                   (face_flip ? 4 : 0)) *
-4.         ",Not Useful
/*DoF is on a quad*/,"-10.         this->get_first_line_index() +
-9.         this->reference_cell().face_to_cell_lines(face,
-8.                                                   face_line,
-7.                                                   (face_orientation ? 1 : 0) +
-6.",Not Useful
/*------------------------------- FiniteElement ----------------------*/,"-10. #include <deal.II/fe/fe.h>
-9. #include <deal.II/fe/fe_values.h>
-8. #include <deal.II/fe/mapping.h>
-7. #include <deal.II/grid/tria.h>
-6. #include <deal.II/grid/tria_iterator.h>
-5. #include <algorithm>
-4. #include <functional>
-3. #include <numer",Not Useful
/*namespace*/,"-5. #include <deal.II/base/std_cxx17/cmath.h>
-4. #include <deal.II/base/thread_management.h>
-3. #include <deal.II/fe/fe_series.h>
-2. #include <iostream>
-1. DEAL_II_NAMESPACE_OPEN
namespace

/*namespace*/

1. {
2.   DeclException2(ExcLegendre,
3.      ",Not Useful
/*namespace FESeries*/,"
namespace FESeries



/*namespace FESeries*/

1. {
2.   template <int dim, int spacedim>
3.   Legendre<dim, spacedim>::Legendre(
4.     const std::vector<unsigned int> &      n_coefficients_per_direction,
5.     const hp::FECollection<dim, spacedim> &fe_collection,
6.     const hp::QCollection<dim> &           q_collection,
7.     const unsigned int                     component_)
8.     : n_coefficients_per_direction(n_coefficients_per_direction)
9.     , fe_collection(&fe_collection)
10.     , q_collection(q_collection)",Not Useful
/*namespace*/,"-10. #include <deal.II/fe/fe_q_iso_q1.h>
-9. #include <deal.II/fe/fe_simplex_p.h>
-8. #include <deal.II/fe/fe_simplex_p_bubbles.h>
-7. #include <deal.II/fe/fe_tools.h>
-6. #include <deal.II/fe/fe_wedge_p.h>
-5. #include <deal.II/lac/vector.h>
-4. #include",Not Useful
/*namespace FE_DGQ*/,"-10. #include <deal.II/fe/fe_simplex_p_bubbles.h>
-9. #include <deal.II/fe/fe_tools.h>
-8. #include <deal.II/fe/fe_wedge_p.h>
-7. #include <deal.II/lac/vector.h>
-6. #include <iostream>
-5. #include <memory>
-4. #include <sstream>
-3. DEAL_II_NAMESPACE_OP",Not Useful
/*fe_other*/,"-10. }
-9. template <int dim, int spacedim>
-8. bool
-7. FE_DGQ<dim, spacedim>::hp_constraints_are_implemented() const
-6. {
-5.   return true;
-4. }
-3. template <int dim, int spacedim>
-2. std::vector<std::pair<unsigned int, unsigned int>>
-1. FE_DGQ<di",Not Useful
/*fe_other*/,"-10. }
-9. template <int dim, int spacedim>
-8. bool
-7. FE_DGQ<dim, spacedim>::hp_constraints_are_implemented() const
-6. {
-5.   return true;
-4. }
-3. template <int dim, int spacedim>
-2. std::vector<std::pair<unsigned int, unsigned int>>
-1. FE_DGQ<di",Not Useful
/*fe_other*/,"-10. }
-9. template <int dim, int spacedim>
-8. bool
-7. FE_DGQ<dim, spacedim>::hp_constraints_are_implemented() const
-6. {
-5.   return true;
-4. }
-3. template <int dim, int spacedim>
-2. std::vector<std::pair<unsigned int, unsigned int>>
-1. FE_DGQ<di",Not Useful
/*x=0*/,"-10.             return true;
-9.           if (face_index == 2 && shape_index < n)
-8.             return true;
-7.           if (face_index == 3 && shape_index >= this->n_dofs_per_cell() - n)
-6.             return true;
-5.           return false;
-4. ",Not Useful
/*x=1*/,"-2.           if (face_index == 0 && (shape_index % n) == 0)
-1.             return true;

/*x=1*/

1.           if (face_index == 1 && (shape_index % n) == n - 1)
2.             return true;",Not Useful
/*y=0*/,"-2.           if (face_index == 1 && (shape_index % n) == n - 1)
-1.             return true;

/*y=0*/

1.           if (face_index == 2 && in2 < n)
2.             return true;",Not Useful
/*y=1*/,"-2.           if (face_index == 2 && in2 < n)
-1.             return true;

/*y=1*/

1.           if (face_index == 3 && in2 >= n2 - n)
2.             return true;",Not Useful
/*z=0*/,"-2.           if (face_index == 3 && in2 >= n2 - n)
-1.             return true;

/*z=0*/

1.           if (face_index == 4 && shape_index < n2)
2.             return true;",Not Useful
/*z=1*/,"-2.           if (face_index == 4 && shape_index < n2)
-1.             return true;

/*z=1*/

1.           if (face_index == 5 && shape_index >= this->n_dofs_per_cell() - n2)
2.             return true;
3.           return false;
4.         }
5.       def",Not Useful
/*------------------------------ FE_DGQArbitraryNodes -----------------------*/,"-10. }
-9. template <int dim, int spacedim>
-8. std::pair<Table<2, bool>, std::vector<unsigned int>>
-7. FE_DGQ<dim, spacedim>::get_constant_modes() const
-6. {
-5.   Table<2, bool> constant_modes(1, this->n_dofs_per_cell());
-4.   constant_modes.fill(tru",Not Useful
/*All guesses exhausted*/,"-10.       {
-9.         gauss_log = false;
-8.         break;
-7.       }
-6.   if (gauss_log == true)
-5.     {
-4.       namebuf << ""FE_DGQArbitraryNodes<"" << Utilities::dim_string(dim, spacedim)
-3.               << "">(QGaussLog("" << this->degree + 1 ",Not Useful
/*---------------------------------- FE_DGQLegendre -------------------------*/,"-10.   auto *const           polynomial_space =
-9.     dynamic_cast<TensorProductPolynomials<dim> *>(this->poly_space.get());
-8.   Assert(polynomial_space != nullptr, ExcInternalError());
-7.   std::vector<unsigned int> lexicographic =
-6.     polynomia",Not Useful
/*---------------------------------- FE_DGQHermite --------------------------*/,"-10. {
-9.   return ""FE_DGQLegendre<"" + Utilities::dim_string(dim, spacedim) + "">("" +
-8.          Utilities::int_to_string(this->degree) + "")"";
-7. }
-6. template <int dim, int spacedim>
-5. std::unique_ptr<FiniteElement<dim, spacedim>>
-4. FE_DGQLegendr",Not Useful
/*---------------------- Functions: DoFInvalidAccessor --------------------*/,"-6. template <int structdim, int dim, int spacedim, bool level_dof_access>
-5. const unsigned int
-4.   DoFAccessor<structdim, dim, spacedim, level_dof_access>::dimension;
-3. template <int structdim, int dim, int spacedim, bool level_dof_access>
-2. cons",Not Useful
/*------------------------- Functions: DoFCellAccessor -----------------------*/,"-10. }
-9. template <int structdim, int dim, int spacedim>
-8. void
-7. DoFInvalidAccessor<structdim, dim, spacedim>::set_dof_index(
-6.   const unsigned int,
-5.   const types::global_dof_index,
-4.   const unsigned int) const
-3. {
-2.   Assert(false, E",Not Useful
/*namespace boosttypes*/,"-10. #include <algorithm>
-9. #include <cmath>
-8. #include <functional>
-7. #include <map>
-6. #include <vector>
-5. DEAL_II_NAMESPACE_OPEN
-4. namespace DoFRenumbering
-3. {
-2.   namespace boost
-1.   {
    namespace boosttypes

/*namespace boosttypes*",Not Useful
/*namespace boost*/,"-10. #undef BOOST_BIND_GLOBAL_PLACEHOLDERS
-9. DEAL_II_ENABLE_EXTRA_DIAGNOSTICS
-8. #include <algorithm>
-7. #include <cmath>
-6. #include <functional>
-5. #include <map>
-4. #include <vector>
-3. DEAL_II_NAMESPACE_OPEN
-2. namespace DoFRenumbering
-1. {
",Not Useful
/*calculate shifts*/,"-10.                                     prefix_dof_count.data(),
-9.                                     n_buckets,
-8.                                     DEAL_II_DOF_INDEX_MPI_TYPE,
-7.                                     MPI_SUM,
-6.                  ",Not Useful
/*calculate shifts*/,"-10.                                     prefix_dof_count.data(),
-9.                                     n_buckets,
-8.                                     DEAL_II_DOF_INDEX_MPI_TYPE,
-7.                                     MPI_SUM,
-6.                  ",Not Useful
/*namespace*/,"-10. #include <boost/random.hpp>
-9. #include <boost/random/uniform_int_distribution.hpp>
-8. #undef BOOST_BIND_GLOBAL_PLACEHOLDERS
-7. DEAL_II_ENABLE_EXTRA_DIAGNOSTICS
-6. #include <algorithm>
-5. #include <cmath>
-4. #include <functional>
-3. #include <",Not Useful
"/*re-sort the dofs according to
their selection state*/","-10.   template <int dim, int spacedim>
-9.   void
-8.   compute_sort_selected_dofs_back(
-7.     std::vector<types::global_dof_index> &new_indices,
-6.     const DoFHandler<dim, spacedim> &     dof_handler,
-5.     const std::vector<bool> &             s",Not Useful
"/*re-sort the dofs according to
their selection state*/","-10.   template <int dim, int spacedim>
-9.   void
-8.   compute_sort_selected_dofs_back(
-7.     std::vector<types::global_dof_index> &new_indices,
-6.     const DoFHandler<dim, spacedim> &     dof_handler,
-5.     const std::vector<bool> &             s",Not Useful
"/**
       * Constructor.*/","-2.       bool counter;
-1.       /**
       * Constructor.

/**
       * Constructor.*/

1.        */
2.       ClockCells(const Point<dim> &center, bool counter)
3.         : center(center)
4.         , counter(counter)
5.       {}",Not Useful
/*namespace DoFRenumbering*/,"-10. #include <boost/random.hpp>
-9. #include <boost/random/uniform_int_distribution.hpp>
-8. #undef BOOST_BIND_GLOBAL_PLACEHOLDERS
-7. DEAL_II_ENABLE_EXTRA_DIAGNOSTICS
-6. #include <algorithm>
-5. #include <cmath>
-4. #include <functional>
-3. #include <",Not Useful
/*namespace*/,"-10. {
-9.   std::unique_ptr<typename Mapping<dim, spacedim>::InternalDataBase> data_ptr =
-8.     std::make_unique<InternalData>();
-7.   auto &data = dynamic_cast<InternalData &>(*data_ptr);
-6.   data.initialize_face(this->requires_update_flags(update_",Not Useful
/*namespace MappingManifoldImplementation*/,"-10.     std::make_unique<InternalData>();
-9.   auto &data = dynamic_cast<InternalData &>(*data_ptr);
-8.   data.initialize_face(this->requires_update_flags(update_flags),
-7.                        QProjector<dim>::project_to_all_subfaces(
-6.          ",Not Useful
/*dim == 2*/,"-10.                            ""There is no (unique) cell normal for "" +
-9.                            Utilities::int_to_string(dim) +
-8.                            ""-dimensional cells in "" +
-7.                            Utilities::int_to_string(spac",Not Useful
/*(dim < spacedim)*/,"-10.                           cross_product_2d(data.aux[0][i]);
-9.                         break;
-8.                       case 3:
-7.                         output_data.boundary_forms[i] =
-6.                           cross_product_3d(data.aux[0][i]",Not Useful
/*namespace*/,"-10. {
-9.   std::unique_ptr<typename Mapping<dim, spacedim>::InternalDataBase> data_ptr =
-8.     std::make_unique<InternalData>();
-7.   auto &data = dynamic_cast<InternalData &>(*data_ptr);
-6.   data.initialize_face(this->requires_update_flags(update_",Not Useful
/*namespace MappingManifoldImplementation*/,"-10.     std::make_unique<InternalData>();
-9.   auto &data = dynamic_cast<InternalData &>(*data_ptr);
-8.   data.initialize_face(this->requires_update_flags(update_flags),
-7.                        QProjector<dim>::project_to_all_subfaces(
-6.          ",Not Useful
/*namespace*/,"-10. #include <deal.II/fe/fe_q_bubbles.h>
-9. #include <deal.II/fe/fe_tools.h>
-8. #include <deal.II/fe/fe_values.h>
-7. #include <deal.II/fe/mapping_q1.h>
-6. #include <deal.II/grid/grid_generator.h>
-5. #include <deal.II/grid/tria.h>
-4. #include <memor",Not Useful
/*namespace FE_Q_Bubbles*/,"-10. #include <deal.II/fe/fe_values.h>
-9. #include <deal.II/fe/mapping_q1.h>
-8. #include <deal.II/grid/grid_generator.h>
-7. #include <deal.II/grid/tria.h>
-6. #include <memory>
-5. #include <sstream>
-4. #include <vector>
-3. DEAL_II_NAMESPACE_OPEN
-2.",Not Useful
/*dof_handler*/,"-6. #include <deal.II/base/geometry_info.h>
-5. #include <deal.II/base/quadrature.h>
-4. #include <deal.II/base/quadrature_lib.h>
-3. #include <deal.II/base/work_stream.h>
-2. #include <deal.II/distributed/tria_base.h>
-1. #include <deal.II/dofs/dof_acces",Not Useful
/*neumann_bc*/,"-10. DEAL_II_NAMESPACE_OPEN
-9. template <int spacedim>
-8. template <typename InputVector>
-7. void
-6. KellyErrorEstimator<1, spacedim>::estimate(
-5.   const Mapping<1, spacedim> &   mapping,
-4.   const DoFHandler<1, spacedim> &dof_handler,
-3.   cons",Not Useful
/*solutions*/,"const std::vector<const InputVector *> solutions(1, &solution);

/*solutions*/

1.   std::vector<Vector<float> *>           errors(1, &error);
2.   estimate(mapping,
3.            dof_handler,
4.            quadrature,
5.            neumann_bc,
6.            solutions,
7.            errors,
8.            component_mask,
9.            coefficients,
10.            n_threads,",Not Useful
/*coefficient*/,"-10. KellyErrorEstimator<1, spacedim>::estimate(
-9.   const Mapping<1, spacedim> &   mapping,
-8.   const DoFHandler<1, spacedim> &dof_handler,
-7.   const Quadrature<0> &          quadrature,
-6.   const std::map<types::boundary_id,
-5.                 ",Not Useful
/*subdomain_id*/,"-10.   const DoFHandler<1, spacedim> &dof_handler,
-9.   const Quadrature<0> &          quadrature,
-8.   const std::map<types::boundary_id,
-7.                  const Function<spacedim, typename InputVector::value_type> *>
-6.     &                      ",Not Useful
/*material_id*/,"-10.   const Quadrature<0> &          quadrature,
-9.   const std::map<types::boundary_id,
-8.                  const Function<spacedim, typename InputVector::value_type> *>
-7.     &                       neumann_bc,
-6.   const InputVector &       solut",Not Useful
/*strategy*/,"-10.   const std::map<types::boundary_id,
-9.                  const Function<spacedim, typename InputVector::value_type> *>
-8.     &                       neumann_bc,
-7.   const InputVector &       solution,
-6.   Vector<float> &           error,
-5.  ",Not Useful
"/*mapping_collection,*/","-10.   if (coefficient == nullptr)
-9.     for (unsigned int c = 0; c < n_components; ++c)
-8.       coefficient_values(c) = 1;
-7.   const QTrapezoid<1>      quadrature;
-6.   const hp::QCollection<1> q_collection(quadrature);
-5.   const QGauss<0>      ",Not Useful
/*fill with zeroes.*/,"-10.                 else
-9.                   {
-8.                     Vector<typename InputVector::value_type> v(n_components);
-7.                     neumann_bc.find(n)->second->vector_value(cell->vertex(n),
-6.                                      ",Not Useful
/*namespace mu*/,"
namespace mu



/*namespace mu*/

1. {
2. 	value_type ParserInt::Abs(value_type v) { return (value_type)Round(fabs((double)v)); }
3. 	value_type ParserInt::Sign(value_type v) { return (Round(v) < 0) ? -1 : (Round(v) > 0) ? 1 : 0; }
4. 	value_type ParserInt::Ite(value_type v1, value_type v2,	value_type v3) { return (Round(v1) == 1) ? Round(v2) : Round(v3); }
5. 	value_type ParserInt::Add(value_type v1, value_type v2) { return Round(v1) + Round(v2); }
6. 	value_type ParserInt::Sub(value_type v1, value_type v2) { return Round(v1) - Round(v2); }
7. 	value_type ParserInt::Mul(value_type v1, value_type v2) { return Round(v1) * Round(v2); }
8. 	value_type ParserInt::Div(value_type v1, value_type v2) { return Round(v1) / Round(v2); }
9. 	value_type ParserInt::Mod(value_type v1, value_type v2) { return Round(v1) % Round(v2); }
10. 	value_type ParserInt::Shr(value_type v1, value_type v2) { return Round(v1) >> Round(v2); }",Not Useful
/*namespace*/,"-1. DEAL_II_NAMESPACE_OPEN
namespace internal

/*namespace*/

1. {
2.   namespace FE_Q_Hierarchical
3.   {
4.     namespace
5.     {",Not Useful
/*namespace FE_Q_Hierarchical*/,"-3. DEAL_II_NAMESPACE_OPEN
-2. namespace internal
-1. {
  namespace FE_Q_Hierarchical

/*namespace FE_Q_Hierarchical*/

1.   {
2.     namespace
3.     {",Not Useful
"/*dofs_cells[0](j,k):
0  1 |  2  3  4.
0  1  0 |         .
1  0  0 |         .
-------------------
2          \      .
3            \  2^k * k! / (k-j)!j!
4               \ .*/","-10.     2 * this->n_dofs_per_vertex() + this->n_dofs_per_line();

/*dofs_cells[0](j,k):
0  1 |  2  3  4.
0  1  0 |         .
1  0  0 |         .
-------------------
2          \      .
3            \  2^k * k! / (k-j)!j!
4               \ .*/

111",Not Useful
"/*dofs_subcells[0](j,k):
0    1   |  2  3   4  5  6 .
0  1    0   |                 .
1  1/2  1/2 | -1  0  -1  0  -1.
-------------------------------
2              \              .
3                 \     (-1)^(k+j)/ 2^k * k!/(k-j)!j!
4                     \       .*/","-10.   // the case. Perhaps this factor is added later on in auxiliary functions
-9.   // which use these matrices.
-8.   // dofs_cells[0](j,k):
-7.   //    0  1 |  2  3  4.
-6.   // 0  1  0 |         .
-5.   // 1  0  0 |         .
-4.   // --------------",Not Useful
"/*dofs_cells[1](j,k):
0  1 |  2  3  4.
0  0  0 |         .
1  0  1 |         .
-------------------
2          \      .
3             \   (-1)^(k+j) * 2^k * k!/(k-j)!j!
4                \.*/","-10.   // 3            \  2^k * k! / (k-j)!j!
-9.   // 4               \ .
-8.   // dofs_subcells[0](j,k):
-7.   //    0    1   |  2  3   4  5  6 .
-6.   // 0  1    0   |                 .
-5.   // 1  1/2  1/2 | -1  0  -1  0  -1.
-4.   // ----------------",Not Useful
"/*dofs_subcells[1](j,k):
0    1   |  2  3   4  5  6 .
0  1/2  1/2 | -1  0  -1  0  -1.
1  0    1   |                 .
-------------------------------
2              \              .
3                 \      1/ 2^k * k!/(k-j)!j!
4                             .*/","-10.   // 3                 \     (-1)^(k+j)/ 2^k * k!/(k-j)!j!
-9.   // 4                     \       .
-8.   // dofs_cells[1](j,k):
-7.   //    0  1 |  2  3  4.
-6.   // 0  0  0 |         .
-5.   // 1  0  1 |         .
-4.   // -------------------
-3.  ",Not Useful
/*subcell 0*/,"-3.               for (unsigned int j = 0; j < (this->degree - 1); ++j)
-2.                 for (unsigned int k = 0; k < (this->degree - 1); ++k)
-1.                   {

/*subcell 0*/

1.                     this->interface_constraints(5 + 12 * (this->de",Not Useful
/*subcell 1*/,"-5.                     this->interface_constraints(5 + 12 * (this->degree - 1) +
-4.                                                   j + k * (this->degree - 1),
-3.                                                 face_renumber[i]) =
-2.                ",Not Useful
/*subcell 2*/,"-7.                     this->interface_constraints(5 + 12 * (this->degree - 1) +
-6.                                                   j + k * (this->degree - 1) +
-5.                                                   (this->degree - 1) *
-4.            ",Not Useful
/*subcell 3*/,"-7.                     this->interface_constraints(5 + 12 * (this->degree - 1) +
-6.                                                   j + k * (this->degree - 1) +
-5.                                                   2 * (this->degree - 1) *
-4.        ",Not Useful
/*left/right line: 0/1*/,"-10.   for (unsigned int j = 0; j < this->n_dofs_per_cell(); ++j)
-9.     for (unsigned int i = 0; i < this->n_dofs_per_cell(); ++i)
-8.       switch (dim)
-7.         {
-6.           case 2:
-5.             {
-4.               for (unsigned int c = 0;
-3",Not Useful
/*bottom/top line: 0/1*/,"-1.                   const unsigned int c0 = c % 2;

/*bottom/top line: 0/1*/

1.                   const unsigned int c1 = c / 2;
2.                   this->prolongation[iso][c](j, i) =
3.                     dofs_subcell[c0](renumber[j] % dofs_1d,
4.  ",Not Useful
/*left/right face: 0/1*/,"-10.                                     dofs_1d);
-9.                 }
-8.               break;
-7.             }
-6.           case 3:
-5.             {
-4.               for (unsigned int c = 0;
-3.                    c < GeometryInfo<3>::max_children",Not Useful
/*front/back face: 0/1*/,"-1.                   const unsigned int c0 = c % 2;

/*front/back face: 0/1*/

1.                   const unsigned int c1 = (c % 4) / 2;",Not Useful
/*bottom/top face: 0/1*/,"-1.                   const unsigned int c1 = (c % 4) / 2;

/*bottom/top face: 0/1*/

1.                   const unsigned int c2 = c / 4;
2.                   this->prolongation[iso][c](j, i) =
3.                     dofs_subcell[c0](renumber[j] % dofs_1d",Not Useful
/*x_source_fe*/,"-4. }
-3. template <>
-2. void
-1. FE_Q_Hierarchical<1>::get_face_interpolation_matrix(

/*x_source_fe*/

111",Not Useful
/*interpolation_matrix*/,"-10.   return namebuf.str();
-9. }
-8. template <int dim>
-7. std::unique_ptr<FiniteElement<dim, dim>>
-6. FE_Q_Hierarchical<dim>::clone() const
-5. {
-4.   return std::make_unique<FE_Q_Hierarchical<dim>>(*this);
-3. }
-2. template <int dim>
-1. void
FE_Q",Not Useful
/*x_source_fe*/,"-4. }
-3. template <>
-2. void
-1. FE_Q_Hierarchical<1>::get_face_interpolation_matrix(

/*x_source_fe*/

111",Not Useful
/*subface*/,"-6.   const unsigned int) const
-5. {
-4.   Assert(false, ExcImpossibleInDim(1));
-3. }
-2. template <>
-1. void
FE_Q_Hierarchical<1>::get_subface_interpolation_matrix(

/*subface*/

111",Not Useful
/*interpolation_matrix*/,"-10.   return namebuf.str();
-9. }
-8. template <int dim>
-7. std::unique_ptr<FiniteElement<dim, dim>>
-6. FE_Q_Hierarchical<dim>::clone() const
-5. {
-4.   return std::make_unique<FE_Q_Hierarchical<dim>>(*this);
-3. }
-2. template <int dim>
-1. void
FE_Q",Not Useful
/*we use same dpo_vector as FE_Q*/,"-10.                 p(2) = 0.;
-9.               else if (iz == 1)
-8.                 p(2) = 1.;
-7.               else
-6.                 p(2) = .5;
-5.             }
-4.           this->generalized_face_support_points[face_no][face_renumber[k++]] =
-",Not Useful
/*bottom line*/,"-2.           for (unsigned int i = 0; i < fe.n_dofs_per_line(); ++i)
-1.             h2l[next_index++] = (2 + i) * n + 1;

/*bottom line*/

1.           for (unsigned int i = 0; i < fe.n_dofs_per_line(); ++i)
2.             h2l[next_index++] = 2 + i;",Not Useful
"/*now the lines
bottom face*/","for (unsigned int i = 0; i < fe.n_dofs_per_line(); ++i)
            h2l[next_index++] = (2 + i) * n2;
          for (unsigned int i = 0; i < fe.n_dofs_per_line(); ++i)
            h2l[next_index++] = (2 + i) * n2 + 1;
          for (unsigned int i = 0; i < fe.n_dofs_per_line(); ++i)
            h2l[next_index++] = (2 + i) * n2 + n;
          for (unsigned int i = 0; i < fe.n_dofs_per_line(); ++i)
            h2l[next_index++] = (2 + i) * n2 + n + 1;

/*now the lines
bottom face*/

1.           for (unsigned int i = 0; i < fe.n_dofs_per_line(); ++i)
2.             for (unsigned int j = 0; j < fe.n_dofs_per_line(); ++j)
3.               h2l[next_index++] = (2 + i) * n + 2 + j;",Not Useful
/*bottom face*/,"-10.             for (unsigned int j = 0; j < fe.n_dofs_per_line(); ++j)
-9.               h2l[next_index++] = (2 + i) * n + 2 + j;
-8.           Assert(next_index == fe.n_dofs_per_cell(), ExcInternalError());
-7.           break;
-6.         }
-5.       ",Not Useful
/*dof is on a quad*/,"-10.       const unsigned int line_index =
-9.         (shape_index - this->get_first_line_index()) / this->n_dofs_per_line();
-8.       Assert(line_index < GeometryInfo<dim>::lines_per_cell,
-7.              ExcInternalError());
-6.       for (unsigned i",Not Useful
"/*in 3d,
quad_index=face_index*/","-1.       Assert(dim != 2, ExcInternalError());

/*in 3d,
quad_index=face_index*/

1.       if (dim == 3)
2.         return (quad_index == face_index);
3.       else
4.         Assert(false, ExcNotImplemented());
5.     }
6.   else",Not Useful
/*dof on hex*/,"-6.       if (dim == 3)
-5.         return (quad_index == face_index);
-4.       else
-3.         Assert(false, ExcNotImplemented());
-2.     }
-1.   else

/*dof on hex*/

1.     {",Not Useful
/*we should not have gotten here*/,"-3.       Assert(false, ExcNotImplemented());
-2.       return false;
-1.     }

/*we should not have gotten here*/

1.   Assert(false, ExcInternalError());
2.   return false;
3. }
4. template <int dim>
5. std::vector<unsigned int>
6. FE_Q_Hierarchical<di",Not Useful
/*line*/,"-7. #include <deal.II/fe/fe_dgq.h>
-6. #include <deal.II/fe/fe_nothing.h>
-5. #include <deal.II/fe/fe_q_hierarchical.h>
-4. #include <cmath>
-3. #include <memory>
-2. #include <sstream>

/*line*/

111",Not Useful
/*quad*/,"-6. #include <deal.II/fe/fe_dgq.h>
-5. #include <deal.II/fe/fe_nothing.h>
-4. #include <deal.II/fe/fe_q_hierarchical.h>
-3. #include <cmath>
-2. #include <memory>
-1. #include <sstream>

/*quad*/

111",Not Useful
/*hex*/,"-5.       Assert(matrix.m() == this->n_dofs_per_cell(),
-4.              ExcDimensionMismatch(matrix.m(), this->n_dofs_per_cell()));
-3.       Assert(matrix.n() == source.n_dofs_per_cell(),
-2.              ExcDimensionMismatch(matrix.m(), source_fe->n_do",Not Useful
/*avoid reinterpret_cast*/,"-10.                             booleantype *jcurPtr,
-9.                             N_Vector,
-8.                             N_Vector,
-7.                             N_Vector)
-6.     {
-5.       Assert(arkode_mem->ark_user_data != nullptr, ExcIntern",Not Useful
/*namespace*/,"-3. const auto &SundialsARKode = ARKode;
-2. #  endif
-1. DEAL_II_NAMESPACE_OPEN
namespace SUNDIALS

/*namespace*/

1. {
2.   namespace
3.   {
4.     template <typename VectorType>
5.     int
6.     explicit_function_callback(realtype tt,
7.              ",Not Useful
/*DEAL_II_WITH_TRILINOS*/,"-8. #include <deal.II/base/config.h>
-7. #include <deal.II/sundials/arkode.h>
-6. #ifdef DEAL_II_WITH_SUNDIALS
-5. #  include <deal.II/base/discrete_time.h>
-4. #  include <deal.II/base/utilities.h>
-3. #  include <deal.II/lac/block_vector.h>
-2. #  inclu",Not Useful
/*PETSC_USE_COMPLEX*/,"-1. #    ifdef DEAL_II_WITH_PETSC
#      ifndef PETSC_USE_COMPLEX

/*PETSC_USE_COMPLEX*/

1.   template class ARKode<PETScWrappers::MPI::Vector>;
2.   template class ARKode<PETScWrappers::MPI::BlockVector>;",Not Useful
/*DEAL_II_WITH_PETSC*/,"-10. #ifdef DEAL_II_WITH_SUNDIALS
-9. #  include <deal.II/base/discrete_time.h>
-8. #  include <deal.II/base/utilities.h>
-7. #  include <deal.II/lac/block_vector.h>
-6. #  include <deal.II/lac/la_parallel_block_vector.h>
-5. #  include <deal.II/lac/la_pa",Not Useful
/*DEAL_II_WITH_MPI*/,"-10.         ARKodeFree(&arkode_mem);
-9. #  else
-8.         ARKStepFree(&arkode_mem);
-7. #  endif
-6. #  if !DEAL_II_SUNDIALS_VERSION_LT(6, 0, 0)
-5.         const int status = SUNContext_Free(&arkode_ctx);
-4.         (void)status;
-3.         AssertA",Not Useful
/*namespace SUNDIALS*/,"-3. const auto &SundialsARKode = ARKode;
-2. #  endif
-1. DEAL_II_NAMESPACE_OPEN
namespace SUNDIALS

/*namespace SUNDIALS*/

1. {
2.   namespace
3.   {
4.     template <typename VectorType>
5.     int
6.     explicit_function_callback(realtype tt,
7.     ",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*pExpr*/,"-10. 		\throw nothrow
-9. 	*/
-8. 	void ParserBase::ReInit() const
-7. 	{
-6. 		m_pParseFormula = &ParserBase::ParseString;
-5. 		m_vStringBuf.clear();
-4. 		m_vRPN.clear();
-3. 		m_pTokenReader->ReInit();
-2. 	}

/*pExpr*/

1. 	{}",Not Useful
/*nEnd*/,"-10. 		\throw nothrow
-9. 	*/
-8. 	void ParserBase::ReInit() const
-7. 	{
-6. 		m_pParseFormula = &ParserBase::ParseString;
-5. 		m_vStringBuf.clear();
-4. 		m_vRPN.clear();
-3. 		m_pTokenReader->ReInit();
-2. 	}

/*nEnd*/

1. 	{}",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*built in operators*/,"
	/** \brief Get the default symbols used for the built in operators.



/*built in operators*/

1. 		\sa c_DefaultOprt
2. 	*/
3. 	const char_type** ParserBase::GetOprtDef() const
4. 	{
5. 		return (const char_type**)(&c_DefaultOprt[0]);
6. 	}",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*e*/,"-3.    |  Y Y  \  |  /  |_> > __ \|  | \/\___ \\  ___/|  | \/
-2.    |__|_|  /____/|   __(____  /__|  /____  >\___  >__|
-1. 		 \/      |__|       \/           \/     \/
   Copyright (C) 2022 Ingo Berg

/*e*/

1. 	Redistribution and use in source and bina",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*switch according to argument count*/,"-3. 			case  cmFUNC:
-2. 			{
-1. 				int iArgCount = pTok->u.Fun.argc;

/*switch according to argument count*/

1. 				switch (iArgCount)
2. 				{
3. 				case 0: sidx += 1; stack[sidx] = pTok->u.Fun.cb.call_fun<0 >(); continue;
4. 				case 1:            ",Not Useful
/*function with variable arguments store the number as a negative value*/,"-10. 				case 2: sidx -= 1; stack[sidx] = pTok->u.Fun.cb.call_fun<2 >(stack[sidx], stack[sidx + 1]); continue;
-9. 				case 3: sidx -= 2; stack[sidx] = pTok->u.Fun.cb.call_fun<3 >(stack[sidx], stack[sidx + 1], stack[sidx + 2]); continue;
-8. 				case 4: s",Not Useful
/*switch according to argument count*/,"-3. 			case  cmFUNC:
-2. 			{
-1. 				int iArgCount = pTok->u.Fun.argc;

/*switch according to argument count*/

1. 				switch (iArgCount)
2. 				{
3. 				case 0: sidx += 1; stack[sidx] = pTok->u.Fun.cb.call_fun<0 >(); continue;
4. 				case 1:            ",Not Useful
/*switch according to argument count*/,"-3. 			case  cmFUNC:
-2. 			{
-1. 				int iArgCount = pTok->u.Fun.argc;

/*switch according to argument count*/

1. 				switch (iArgCount)
2. 				{
3. 				case 0: sidx += 1; stack[sidx] = pTok->u.Fun.cb.call_fun<0 >(); continue;
4. 				case 1:            ",Not Useful
/*switch CmdCode*/,"-10. 				case 7: sidx -= 6; stack[sidx] = pTok->u.Fun.cb.call_bulkfun<7 >(nOffset, nThreadID, stack[sidx], stack[sidx + 1], stack[sidx + 2], stack[sidx + 3], stack[sidx + 4], stack[sidx + 5], stack[sidx + 6]); continue;
-9. 				case 8: sidx -= 7; stack[si",Not Useful
/*for all bytecode tokens*/,"-10. 				case 8: sidx -= 7; stack[sidx] = pTok->u.Fun.cb.call_bulkfun<8 >(nOffset, nThreadID, stack[sidx], stack[sidx + 1], stack[sidx + 2], stack[sidx + 3], stack[sidx + 4], stack[sidx + 5], stack[sidx + 6], stack[sidx + 7]); continue;
-9. 				case 9: si",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*for storing operators*/,"-6. 	void ParserBase::CreateRPN() const
-5. 	{
-4. 		if (!m_pTokenReader->GetExpr().length())
-3. 			Error(ecUNEXPECTED_EOF, 0);
-2. 		std::stack<token_type> stOpt, stVal;
-1. 		std::stack<int> stArgCount;

/*for storing operators*/

111",Not Useful
/*for storing value*/,"-7. 	void ParserBase::CreateRPN() const
-6. 	{
-5. 		if (!m_pTokenReader->GetExpr().length())
-4. 			Error(ecUNEXPECTED_EOF, 0);
-3. 		std::stack<token_type> stOpt, stVal;
-2. 		std::stack<int> stArgCount;

/*for storing value*/

1. 		int ifElseCounter = ",Not Useful
"/*
Next three are different kind of value entries
*/","
/*



/*
Next three are different kind of value entries
*/

1. 	 _____  __ _____________ _______  ______ ___________",Not Useful
/*Assign buffer index to token*/,"-3. 			case cmSTRING:
-2. 				if (stOpt.empty())
-1. 					Error(ecSTR_RESULT, m_pTokenReader->GetPos(), opt.GetAsString());

/*Assign buffer index to token*/

1. 				stVal.push(opt);",Not Useful
/*Store string in internal buffer*/,"-1. 				stVal.push(opt);

/*Store string in internal buffer*/

1. 				break;
2. 			case cmVAR:
3. 				stVal.push(opt);
4. 				m_vRPN.AddVar(static_cast<value_type*>(opt.GetVar()));
5. 				break;
6. 			case cmVAL:
7. 				stVal.push(opt);
8. 				m_vRPN.AddV",Not Useful
"/*The argument count for parameterless functions is zero
by default an opening bracket sets parameter count to 1
in preparation of arguments to come. If the last token
was an opening bracket we know better...*/","-5. 			case cmEND:
-4. 				ApplyRemainingOprt(stOpt, stVal);
-3. 				break;
-2. 			case cmBC:
-1. 			{

/*The argument count for parameterless functions is zero
by default an opening bracket sets parameter count to 1
in preparation of arguments to come. I",Not Useful
"/*if opt is "")"" and opta is ""("" the bracket has been evaluated, now its time to check
if there is either a function or a sign pending
neither the opening nor the closing bracket will be pushed back to
the operator stack
Check if a function is standing in front of the opening bracket,
if yes evaluate it afterwards check for infix operators*/","-2. 				if (stOpt.size() && stOpt.top().GetCode() == cmBO)
-1. 				{

/*if opt is "")"" and opta is ""("" the bracket has been evaluated, now its time to check
if there is either a function or a sign pending
neither the opening nor the closing bracket will be",Not Useful
/*Take opening bracket from stack*/,"-3. 					MUP_ASSERT(stArgCount.size());
-2. 					int iArgCount = stArgCount.top();
-1. 					stArgCount.pop();

/*Take opening bracket from stack*/

1. 					if (iArgCount > 1 && (stOpt.size() == 0 ||
2. 						(stOpt.top().GetCode() != cmFUNC &&
3. 							s",Not Useful
"/*The opening bracket was popped from the stack now check if there
was a function before this bracket*/","-5. 					if (iArgCount > 1 && (stOpt.size() == 0 ||
-4. 						(stOpt.top().GetCode() != cmFUNC &&
-3. 							stOpt.top().GetCode() != cmFUNC_BULK &&
-2. 							stOpt.top().GetCode() != cmFUNC_STR)))
-1. 						Error(ecUNEXPECTED_ARG, m_pTokenReader->GetPos",Not Useful
/*if bracket content is evaluated*/,"-8. 					if (stOpt.size() &&
-7. 						stOpt.top().GetCode() != cmOPRT_INFIX &&
-6. 						stOpt.top().GetCode() != cmOPRT_BIN &&
-5. 						stOpt.top().GetFuncAddr() != 0)
-4. 					{
-3. 						ApplyFunc(stOpt, stVal, iArgCount);
-2. 					}
-1. 				}

/*if ",Not Useful
/*A binary operator (user defined or built in) has been found.*/,"-10. 			case cmGE:
-9. 			case cmNEQ:
-8. 			case cmEQ:
-7. 			case cmADD:
-6. 			case cmSUB:
-5. 			case cmMUL:
-4. 			case cmDIV:
-3. 			case cmPOW:
-2. 			case cmASSIGN:
-1. 			case cmOPRT_BIN:

/*A binary operator (user defined or built in) has been f",Not Useful
/*Deal with operator associativity*/,"-10. 				while (
-9. 					stOpt.size() &&
-8. 					stOpt.top().GetCode() != cmBO &&
-7. 					stOpt.top().GetCode() != cmELSE &&
-6. 					stOpt.top().GetCode() != cmIF)
-5. 				{
-4. 					int nPrec1 = GetOprtPrecedence(stOpt.top()),
-3. 						nPrec2 = GetO",Not Useful
/*while ( ... )*/,"-6. 						break;
-5. 					}
-4. 					if (stOpt.top().GetCode() == cmOPRT_INFIX)
-3. 						ApplyFunc(stOpt, stVal, 1);
-2. 					else
-1. 						ApplyBinOprt(stOpt, stVal);

/*while ( ... )*/

1. 				if (opt.GetCode() == cmIF)
2. 					m_vRPN.AddIfElse(opt.Ge",Not Useful
"/*The operator can't be evaluated right now, push back to the operator stack*/","-2. 				if (opt.GetCode() == cmIF)
-1. 					m_vRPN.AddIfElse(opt.GetCode());

/*The operator can't be evaluated right now, push back to the operator stack*/

1. 				stOpt.push(opt);
2. 				break;",Not Useful
"/*
Last section contains functions and operators implicitely mapped to functions
*/","
/*



/*
Last section contains functions and operators implicitely mapped to functions
*/

1. 	 _____  __ _____________ _______  ______ ___________",Not Useful
/*this is the postfix operator*/,"-10. 				stOpt.push(opt);
-9. 				break;
-8. 			case cmOPRT_INFIX:
-7. 			case cmFUNC:
-6. 			case cmFUNC_BULK:
-5. 			case cmFUNC_STR:
-4. 				stOpt.push(opt);
-3. 				break;
-2. 			case cmOPRT_POSTFIX:
-1. 				stOpt.push(opt);

/*this is the postfix ope",Not Useful
/*end of switch operator-token*/,"-2. 				break;
-1. 			default:  Error(ecINTERNAL_ERROR, 3);

/*end of switch operator-token*/

1. 			opta = opt;
2. 			if (opt.GetCode() == cmEND)
3. 			{
4. 				m_vRPN.Finalize();
5. 				break;
6. 			}
7. 			if (ParserBase::g_DbgDumpStack)
8. 			{
9. 			",Not Useful
/*while (true)*/,"-10. 				m_vRPN.Finalize();
-9. 				break;
-8. 			}
-7. 			if (ParserBase::g_DbgDumpStack)
-6. 			{
-5. 				StackDump(stVal, stOpt);
-4. 				m_vRPN.AsciiDump();
-3. 			}

/*while (true)*/

1. 		if (ParserBase::g_DbgDumpCmdCode)
2. 			m_vRPN.AsciiDump();
3",Not Useful
/*get the last value (= final result) from the stack*/,"-4. 		if (ParserBase::g_DbgDumpCmdCode)
-3. 			m_vRPN.AsciiDump();
-2. 		if (ifElseCounter > 0)
-1. 			Error(ecMISSING_ELSE_CLAUSE);

/*get the last value (= final result) from the stack*/

1. 		MUP_ASSERT(stArgCount.size() == 1);
2. 		m_nFinalResultIdx =",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/** \brief Get the argument separator character.*/,"
	/** \brief Get the argument separator character.



/** \brief Get the argument separator character.*/

1. 	*/
2. 	char_type ParserBase::GetArgSep() const
3. 	{
4. 		return m_pTokenReader->GetArgSep();
5. 	}",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*------------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*(for historic reasons the stack starts at position 1)*/,"-10. 	{
-9. 		if (m_vRPN.GetSize() > 0)
-8. 		{
-7. 			ParseCmdCode();
-6. 		}
-5. 		else
-4. 		{
-3. 			ParseString();
-2. 		}
-1. 		nStackSize = m_nFinalResultIdx;

/*(for historic reasons the stack starts at position 1)*/

1. 		return &m_vStackBuffer[1",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*---------------------------------------------------------------------------*/,"-5. namespace mu
-4. {
-3. 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
-2. 	bool ParserBase::g_DbgDumpCmdCode = false;
-1. 	bool ParserBase::g_DbgDumpStack = false;

/*----------------------",Not Useful
/*#define DEBUG_OMP_STUFF*/,"-5. 	void ParserBase::Eval(value_type* results, int nBulkSize)
-4. 	{
-3. 		CreateRPN();
-2. 		int i = 0;
-1. #ifdef MUP_USE_OPENMP

/*#define DEBUG_OMP_STUFF*/

1. #ifdef DEBUG_OMP_STUFF
2. 		int* pThread = new int[nBulkSize];
3. 		int* pIdx = new int[nB",Not Useful
/*this is not FE_Nothing => there will be enrichment*/,"-2.         for (unsigned int fe = 1; fe < fes.size(); ++fe)
-1.           if (dynamic_cast<const FE_Nothing<dim> *>(fes[fe]) == nullptr)

/*this is not FE_Nothing => there will be enrichment*/

1.             return true;
2.         return false;
3.     ",Not Useful
/*namespace*/,"-5. #include <deal.II/fe/fe_enriched.h>
-4. #include <deal.II/fe/fe_tools.h>
-3. #include <deal.II/lac/sparsity_tools.h>
-2. #include <memory>
-1. DEAL_II_NAMESPACE_OPEN
namespace internal

/*namespace*/

1. {
2.   namespace FE_Enriched
3.   {
4.     name",Not Useful
/*namespace FE_Enriched*/,"-7. #include <deal.II/fe/fe_enriched.h>
-6. #include <deal.II/fe/fe_tools.h>
-5. #include <deal.II/lac/sparsity_tools.h>
-4. #include <memory>
-3. DEAL_II_NAMESPACE_OPEN
-2. namespace internal
-1. {
  namespace FE_Enriched

/*namespace FE_Enriched*/

1.  ",Not Useful
/*0th is always non-enriched FE*/,"-10.       {
-9.         AssertThrow(fes.size() > 0, ExcMessage(""FEs size should be >=1""));
-8.         AssertThrow(fes.size() == multiplicities.size(),
-7.                     ExcMessage(
-6.                       ""FEs and multiplicities should have the ",Not Useful
/*take adjust_quad_dof_index_for_face_orientation_table from FESystem:*/,"-4.   {
-3.     this->unit_support_points      = fe_system->unit_support_points;
-2.     this->unit_face_support_points = fe_system->unit_face_support_points;
-1.   }

/*take adjust_quad_dof_index_for_face_orientation_table from FESystem:*/

1.   {
2.    ",Not Useful
/*----------------------- FESystem::InternalData -------------------*/,"-10.   return fe_system->get_prolongation_matrix(child, refinement_case);
-9. }
-8. template <int dim, int spacedim>
-7. const FullMatrix<double> &
-6. FE_Enriched<dim, spacedim>::get_restriction_matrix(
-5.   const unsigned int         child,
-4.   const",Not Useful
/*True ==> part of subdomain 1*/,"-1.       for (const auto &cell : dof_handler.active_cell_iterators())

/*True ==> part of subdomain 1*/

1.           for (const unsigned int v : GeometryInfo<dim>::vertex_indices())
2.             vertices_subdomain_1[cell->vertex_index(v)] = true;",Not Useful
/*True ==> part of subdomain 2*/,"-1.       for (const auto &cell : dof_handler.active_cell_iterators())

/*True ==> part of subdomain 2*/

1.           for (const unsigned int v : GeometryInfo<dim>::vertex_indices())
2.             if (vertices_subdomain_1[cell->vertex_index(v)] == true)",Not Useful
/*when entry is not found*/,"-10.            *
-9.            * Eg: if cell has color list {1,2} associated and
-8.            * fe_sets = { {}, {1}, {2} } for now, we need to add a new set {1,2}
-7.            * to fe_sets and a new active FE index 3 because 0 to 2 FE indices
-6.   ",Not Useful
/*when entry is found*/,"-5.               if (it == fe_sets.end())
-4.                 {
-3.                   fe_sets.push_back(color_list);
-2.                   cell->set_active_fe_index(fe_sets.size() - 1);
-1.                 }

/*when entry is found*/

1.               els",Not Useful
/*loop through faces*/,"-10.        * entry as zero since the 3rd enrichment function is not relevant for
-9.        * the cell. If the interface has enriched FE [1 0 1] and [0 1 1]
-8.        * on adjacent cells, an enriched FE [0 0 1] should exist and is
-7.        * found as ",Not Useful
/*namespace ColorEnriched*/,"-10. {
-9.   return fesystem_data->get_fe_data(base_no);
-8. }
-7. template <int dim, int spacedim>
-6. internal::FEValuesImplementation::FiniteElementRelatedData<dim, spacedim> &
-5. FE_Enriched<dim, spacedim>::InternalData::get_fe_output_object(
-4.   c",Not Useful
/*---------------------------- InternalDataBase ---------------------------*/,"-10.   const Quadrature<dim - 1> &quadrature) const
-9. {
-8.   Assert(false,
-7.          ExcMessage(""Use of a deprecated interface, please implement ""
-6.                     ""fill_fe_face_values taking a hp::QCollection argument""));
-5.   (void)update_",Not Useful
/*namespace*/,"-10. #include <deal.II/fe/fe_pyramid_p.h>
-9. #include <deal.II/fe/fe_q.h>
-8. #include <deal.II/fe/fe_simplex_p.h>
-7. #include <deal.II/fe/fe_simplex_p_bubbles.h>
-6. #include <deal.II/fe/fe_wedge_p.h>
-5. #include <deal.II/lac/vector.h>
-4. #include <m",Not Useful
/*namespace FE_Q*/,"-10. #include <deal.II/fe/fe_simplex_p.h>
-9. #include <deal.II/fe/fe_simplex_p_bubbles.h>
-8. #include <deal.II/fe/fe_wedge_p.h>
-7. #include <deal.II/lac/vector.h>
-6. #include <memory>
-5. #include <sstream>
-4. #include <vector>
-3. DEAL_II_NAMESPACE_",Not Useful
/*namespace*/,"-10. #    else
-9. #      include <ida/ida_impl.h>
-8. #    endif
-7. #  endif
-6. #  if DEAL_II_SUNDIALS_VERSION_LT(5, 0, 0)
-5. #    include <deal.II/sundials/sunlinsol_newempty.h>
-4. #  endif
-3. #  include <iomanip>
-2. #  include <iostream>
-1. DEAL",Not Useful
/*DEAL_II_WITH_TRILINOS*/,"-8. #include <deal.II/base/config.h>
-7. #include <deal.II/lac/vector_operation.h>
-6. #include <deal.II/sundials/ida.h>
-5. #ifdef DEAL_II_WITH_SUNDIALS
-4. #  include <deal.II/base/utilities.h>
-3. #  include <deal.II/lac/block_vector.h>
-2. #  include ",Not Useful
/*PETSC_USE_COMPLEX*/,"-1. #    ifdef DEAL_II_WITH_PETSC
#      ifndef PETSC_USE_COMPLEX

/*PETSC_USE_COMPLEX*/

1.   template class IDA<PETScWrappers::MPI::Vector>;
2.   template class IDA<PETScWrappers::MPI::BlockVector>;",Not Useful
/*DEAL_II_WITH_PETSC*/,"-10. #include <deal.II/sundials/ida.h>
-9. #ifdef DEAL_II_WITH_SUNDIALS
-8. #  include <deal.II/base/utilities.h>
-7. #  include <deal.II/lac/block_vector.h>
-6. #  include <deal.II/sundials/n_vector.h>
-5. #  include <deal.II/sundials/sunlinsol_wrapper.h",Not Useful
/*DEAL_II_WITH_MPI*/,"-10.   {
-9.     if (ida_mem)
-8.       {
-7.         IDAFree(&ida_mem);
-6. #  if !DEAL_II_SUNDIALS_VERSION_LT(6, 0, 0)
-5.         const int status = SUNContext_Free(&ida_ctx);
-4.         (void)status;
-3.         AssertIDA(status);
-2. #  endif
-1.   ",Not Useful
/*namespace SUNDIALS*/,"-10. #    else
-9. #      include <ida/ida_impl.h>
-8. #    endif
-7. #  endif
-6. #  if DEAL_II_SUNDIALS_VERSION_LT(5, 0, 0)
-5. #    include <deal.II/sundials/sunlinsol_newempty.h>
-4. #  endif
-3. #  include <iomanip>
-2. #  include <iostream>
-1. DEAL",Not Useful
/*DEAL_II_WITH_SUNDIALS*/,"-10. //    it, and/or modify it under the terms of the GNU Lesser General
-9. //    Public License as published by the Free Software Foundation; either
-8. //    version 2.1 of the License, or (at your option) any later version.
-7. //    The full text of",Not Useful
/*i*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2009 - 2021 by the deal.II authors

/*i*/

111",Not Useful
/*p*/,"-2. // ---------------------------------------------------------------------
-1. //
// Copyright (C) 2009 - 2021 by the deal.II authors

/*p*/

111",Not Useful
/*update_flags*/,"-10.     {
-9.       namebuf << comp;
-8.       if (comp != name_components.back())
-7.         namebuf << "", "";
-6.     }
-5.   namebuf << "")"";
-4.   return namebuf.str();
-3. }
-2. template <int dim, int spacedim>
-1. UpdateFlags
FE_Nothing<dim, spacedi",Not Useful
/*quadrature*/,"-9. {
-8.   Assert(false, ExcMessage(""This element has no shape functions.""));
-7.   return 0;
-6. }
-5. template <int dim, int spacedim>
-4. std::unique_ptr<typename FiniteElement<dim, spacedim>::InternalDataBase>
-3. FE_Nothing<dim, spacedim>::get_data(",Not Useful
/*output_data*/,"-2.   dealii::internal::FEValuesImplementation::FiniteElementRelatedData<dim,
-1.                                                                      spacedim>

/*output_data*/

1. {",Not Useful
/*fe_other*/,"-5.     return FiniteElementDomination::this_element_dominates;
-4. }
-3. template <int dim, int spacedim>
-2. std::vector<std::pair<unsigned int, unsigned int>>
-1. FE_Nothing<dim, spacedim>::hp_vertex_dof_identities(

/*fe_other*/

1. {",Not Useful
/*fe_other*/,"-5.     return FiniteElementDomination::this_element_dominates;
-4. }
-3. template <int dim, int spacedim>
-2. std::vector<std::pair<unsigned int, unsigned int>>
-1. FE_Nothing<dim, spacedim>::hp_vertex_dof_identities(

/*fe_other*/

1. {",Not Useful
/*fe_other*/,"-5.     return FiniteElementDomination::this_element_dominates;
-4. }
-3. template <int dim, int spacedim>
-2. std::vector<std::pair<unsigned int, unsigned int>>
-1. FE_Nothing<dim, spacedim>::hp_vertex_dof_identities(

/*fe_other*/

1. {",Not Useful
/*source_fe*/,"-10. }
-9. template <int dim, int spacedim>
-8. bool
-7. FE_Nothing<dim, spacedim>::hp_constraints_are_implemented() const
-6. {
-5.   return true;
-4. }
-3. template <int dim, int spacedim>
-2. void
-1. FE_Nothing<dim, spacedim>::get_interpolation_matrix",Not Useful
/*source_fe*/,"-10. }
-9. template <int dim, int spacedim>
-8. bool
-7. FE_Nothing<dim, spacedim>::hp_constraints_are_implemented() const
-6. {
-5.   return true;
-4. }
-3. template <int dim, int spacedim>
-2. void
-1. FE_Nothing<dim, spacedim>::get_interpolation_matrix",Not Useful
/*source_fe*/,"-10. }
-9. template <int dim, int spacedim>
-8. bool
-7. FE_Nothing<dim, spacedim>::hp_constraints_are_implemented() const
-6. {
-5.   return true;
-4. }
-3. template <int dim, int spacedim>
-2. void
-1. FE_Nothing<dim, spacedim>::get_interpolation_matrix",Not Useful
/*namespace*/,"-10. #include <deal.II/fe/fe_pyramid_p.h>
-9. #include <deal.II/fe/fe_q_base.h>
-8. #include <deal.II/fe/fe_simplex_p.h>
-7. #include <deal.II/fe/fe_simplex_p_bubbles.h>
-6. #include <deal.II/fe/fe_tools.h>
-5. #include <deal.II/fe/fe_wedge_p.h>
-4. #incl",Not Useful
/*namespace FE_Q_Base*/,"-10. #include <deal.II/fe/fe_simplex_p.h>
-9. #include <deal.II/fe/fe_simplex_p_bubbles.h>
-8. #include <deal.II/fe/fe_tools.h>
-7. #include <deal.II/fe/fe_wedge_p.h>
-6. #include <memory>
-5. #include <sstream>
-4. #include <vector>
-3. DEAL_II_NAMESPACE",Not Useful
/*subface 0*/,"-5.     constraint_points.emplace_back(0.5);
-4.     if (q_deg > 1)
-3.       {
-2.         const unsigned int n    = q_deg - 1;
-1.         const double       step = 1. / q_deg;

/*subface 0*/

1.         for (unsigned int i = 1; i <= n; ++i)
2.         ",Not Useful
/*subface 1*/,"-10.     //
-9.     // Note, that we build up these matrices for all subfaces at once, rather
-8.     // than considering them separately. the reason is that we finally will
-7.     // want to have them in this order anyway, as this is the format we need
",Not Useful
/*line 6: use line 10*/,"-4.         QProjector<dim - 1>::project_to_subface(
-3.           ReferenceCells::get_hypercube<dim - 1>(), qline, 0, 0, p_line);
-2.         for (unsigned int i = 0; i < n; ++i)
-1.           constraint_points.push_back(p_line[i] + Point<dim - 1>(0.5, 0",Not Useful
/*line 7: use line 13*/,"-4.         QProjector<dim - 1>::project_to_subface(
-3.           ReferenceCells::get_hypercube<dim - 1>(), qline, 0, 1, p_line);
-2.         for (unsigned int i = 0; i < n; ++i)
-1.           constraint_points.push_back(p_line[i] + Point<dim - 1>(0.5, 0",Not Useful
/*line 8: use line 14*/,"-4.         QProjector<dim - 1>::project_to_subface(
-3.           ReferenceCells::get_hypercube<dim - 1>(), qline, 2, 0, p_line);
-2.         for (unsigned int i = 0; i < n; ++i)
-1.           constraint_points.push_back(p_line[i] + Point<dim - 1>(0, 0.5",Not Useful
/*DoFs on bordering lines lines 9-16*/,"-4.         QProjector<dim - 1>::project_to_subface(
-3.           ReferenceCells::get_hypercube<dim - 1>(), qline, 2, 1, p_line);
-2.         for (unsigned int i = 0; i < n; ++i)
-1.           constraint_points.push_back(p_line[i] + Point<dim - 1>(0, 0.5",Not Useful
/*NOLINT*/,"-1.   const Quadrature<1>   support_1d(points);

/*NOLINT*/

111",Not Useful
/*NOLINT*/,"-1.   const Quadrature<1>   support_1d(points);

/*NOLINT*/

111",Not Useful
"/*face_orientation=false, face_flip=false, face_rotation=false*/","-5.   for (unsigned int local = 0; local < this->n_dofs_per_quad(face_no); ++local)

/*face_orientation=false, face_flip=false, face_rotation=false*/

1.       this->adjust_quad_dof_index_for_face_orientation_table[face_no](local,
2.                      ",Not Useful
"/*face_orientation=false, face_flip=false, face_rotation=true*/","-3.       this->adjust_quad_dof_index_for_face_orientation_table[face_no](local,
-2.                                                                       0) =
-1.         j + i * n - local;

/*face_orientation=false, face_flip=false, face_rotation=true*/",Not Useful
"/*face_orientation=false, face_flip=true,  face_rotation=false*/","-3.       this->adjust_quad_dof_index_for_face_orientation_table[face_no](local,
-2.                                                                       1) =
-1.         i + (n - 1 - j) * n - local;

/*face_orientation=false, face_flip=true,  face_rotat",Not Useful
"/*face_orientation=false, face_flip=true,  face_rotation=true*/","-3.       this->adjust_quad_dof_index_for_face_orientation_table[face_no](local,
-2.                                                                       2) =
-1.         (n - 1 - j) + (n - 1 - i) * n - local;

/*face_orientation=false, face_flip=true,  ",Not Useful
"/*face_orientation=true,  face_flip=false, face_rotation=false*/","-3.       this->adjust_quad_dof_index_for_face_orientation_table[face_no](local,
-2.                                                                       3) =
-1.         (n - 1 - i) + j * n - local;

/*face_orientation=true,  face_flip=false, face_rotat",Not Useful
"/*face_orientation=true,  face_flip=false, face_rotation=true*/","-2.       this->adjust_quad_dof_index_for_face_orientation_table[face_no](local,
-1.                                                                       4) = 0;

/*face_orientation=true,  face_flip=false, face_rotation=true*/

1.       this->adjust_quad",Not Useful
"/*face_orientation=true,  face_flip=true,  face_rotation=false*/","-3.       this->adjust_quad_dof_index_for_face_orientation_table[face_no](local,
-2.                                                                       5) =
-1.         j + (n - 1 - i) * n - local;

/*face_orientation=true,  face_flip=true,  face_rotat",Not Useful
"/*face_orientation=true,  face_flip=true,  face_rotation=true*/","-3.       this->adjust_quad_dof_index_for_face_orientation_table[face_no](local,
-2.                                                                       6) =
-1.         (n - 1 - i) + (n - 1 - j) * n - local;

/*face_orientation=true,  face_flip=true,  ",Not Useful
/*DoF is on a face*/,"-6.       return (GeometryInfo<dim>::face_to_cell_vertices(
-5.                 face, face_vertex, face_orientation, face_flip, face_rotation) *
-4.                 this->n_dofs_per_vertex() +
-3.               dof_index_on_vertex);
-2.     }
-1.   else i",Not Useful
/*DoF is on a quad*/,"-10.           default:
-9.             Assert(false, ExcInternalError());
-8.         }
-7.       return (this->get_first_line_index() +
-6.               GeometryInfo<dim>::face_to_cell_lines(
-5.                 face, face_line, face_orientation, face_",Not Useful
/*see whether the given line is on the given face.*/,"-2.           const unsigned int lines_per_face =
-1.             dim == 3 ? GeometryInfo<dim>::lines_per_face : 1;

/*see whether the given line is on the given face.*/

1.           for (unsigned int l = 0; l < lines_per_face; ++l)
2.             if (Ge",Not Useful
/*dof is on a quad*/,"-10.           for (unsigned int l = 0; l < lines_per_face; ++l)
-9.             if (GeometryInfo<3>::face_to_cell_lines(face_index, l) ==
-8.                 line_index)
-7.               return true;
-6.           return false;
-5.         }
-4.       e",Not Useful
"/*in 3d, quad_index=face_index*/","-1.       Assert(dim != 2, ExcInternalError());

/*in 3d, quad_index=face_index*/

1.       if (dim == 3)
2.         return (quad_index == face_index);
3.       else
4.         Assert(false, ExcNotImplemented());
5.     }
6.   else",Not Useful
/*dof on hex*/,"-6.       if (dim == 3)
-5.         return (quad_index == face_index);
-4.       else
-3.         Assert(false, ExcNotImplemented());
-2.     }
-1.   else

/*dof on hex*/

1.     {",Not Useful
/*we should not have gotten here*/,"-3.       Assert(false, ExcNotImplemented());
-2.       return false;
-1.     }

/*we should not have gotten here*/

1.   Assert(false, ExcInternalError());
2.   return false;
3. }
4. template <int dim, int spacedim>
5. std::pair<Table<2, bool>, std::vect",Not Useful
/*namespace DataOutRotationImplementation*/,"-2. namespace internal
-1. {
  namespace DataOutRotationImplementation

/*namespace DataOutRotationImplementation*/

1.   {
2.     template <int dim, int spacedim>
3.     ParallelData<dim, spacedim>::ParallelData(
4.       const unsigned int              ",Not Useful
/*system of components*/,"-10.                                                      x * n_points * n_points +
-9.                                                        y + z * n_points) =
-8.                                 data.patch_values_scalar
-7.                            ",Not Useful
/*namespace*/,"-7.   std::vector<bool> ret_val(dofs_per_cell, false);
-6.   for (unsigned int i = GeometryInfo<dim>::faces_per_cell * dofs_per_face;
-5.        i < dofs_per_cell;
-4.        ++i)
-3.     ret_val[i] = true;
-2.   return ret_val;
-1. }
namespace internal

",Not Useful
/*namespace FE_BDM*/,"-9.   std::vector<bool> ret_val(dofs_per_cell, false);
-8.   for (unsigned int i = GeometryInfo<dim>::faces_per_cell * dofs_per_face;
-7.        i < dofs_per_cell;
-6.        ++i)
-5.     ret_val[i] = true;
-4.   return ret_val;
-3. }
-2. namespace intern",Not Useful
/*We have (deg+1)^(dim-1) DoFs per face...*/,"-10.         }
-9.       for (unsigned int k = 0; k < quadrature->size(); ++k)
-8.         this->generalized_support_points[current++] = quadrature->point(k);
-7.     }
-6.   Assert(current == this->n_dofs_per_cell(), ExcInternalError());
-5. }
-4. templa",Not Useful
/*same algorithm as above*/,"-8.                 ++i;
-7.               }
-6.             index += fe1.n_dofs_per_vertex();
-5.           }
-4.         for (int l = 0;
-3.              l < static_cast<signed int>(GeometryInfo<dim>::lines_per_face);
-2.              ++l)
-1.          ",Not Useful
/*same algorithm as above*/,"-8.                 ++i;
-7.               }
-6.             index += fe1.n_dofs_per_vertex();
-5.           }
-4.         for (int l = 0;
-3.              l < static_cast<signed int>(GeometryInfo<dim>::lines_per_face);
-2.              ++l)
-1.          ",Not Useful
/*namespace*/,"-10. #include <deal.II/lac/affine_constraints.h>
-9. #include <deal.II/lac/vector.h>
-8. #ifdef DEAL_II_WITH_MPI
-7. #  include <deal.II/lac/la_parallel_vector.h>
-6. #endif
-5. #include <algorithm>
-4. #include <array>
-3. #include <memory>
-2. #include ",Not Useful
/*dof_handler*/,"-5. #include <deal.II/base/table.h>
-4. #include <deal.II/base/template_constraints.h>
-3. #include <deal.II/base/utilities.h>
-2. #include <deal.II/base/work_stream.h>
-1. #include <deal.II/dofs/dof_accessor.h>
#include <deal.II/dofs/dof_handler.h>

/*do",Not Useful
/*dof_handler*/,"-5. #include <deal.II/base/table.h>
-4. #include <deal.II/base/template_constraints.h>
-3. #include <deal.II/base/utilities.h>
-2. #include <deal.II/base/work_stream.h>
-1. #include <deal.II/dofs/dof_accessor.h>
#include <deal.II/dofs/dof_handler.h>

/*do",Not Useful
/*skip artificial cells*/,"-10.                       this_face->vertex_dof_index(vertex, dof, fe_index);
-9.                 for (unsigned int dof = 0; dof != fe.n_dofs_per_line(); ++dof)
-8.                   dofs_on_mother[next_index++] =
-7.                     this_face->dof_i",Not Useful
/*dofs on the bordering lines*/,"-10.                     this_face->child(0)->line(1)->dof_index(dof, fe_index));
-9.                 for (unsigned int dof = 0; dof < fe.n_dofs_per_line(); ++dof)
-8.                   dofs_on_children.push_back(
-7.                     this_face->child(",Not Useful
/*skip artificial cells*/,"-10.                       this_face->vertex_dof_index(vertex, dof, fe_index);
-9.                 for (unsigned int dof = 0; dof != fe.n_dofs_per_line(); ++dof)
-8.                   dofs_on_mother[next_index++] =
-7.                     this_face->dof_i",Not Useful
/*codim=*/,"-10.                        c < cell->face(face)->n_active_descendants();
-9.                        ++c)
-8.                     {
-7.                       const auto subcell =
-6.                         cell->neighbor_child_on_subface(face, c);
-5.   ",Not Useful
/*codim=*/,"-10.                        c < cell->face(face)->n_active_descendants();
-9.                        ++c)
-8.                     {
-7.                       const auto subcell =
-6.                         cell->neighbor_child_on_subface(face, c);
-5.   ",Not Useful
/*codim=*/,"-10.                        c < cell->face(face)->n_active_descendants();
-9.                        ++c)
-8.                     {
-7.                       const auto subcell =
-6.                         cell->neighbor_child_on_subface(face, c);
-5.   ",Not Useful
/*codim=*/,"-10.                        c < cell->face(face)->n_active_descendants();
-9.                        ++c)
-8.                     {
-7.                       const auto subcell =
-6.                         cell->neighbor_child_on_subface(face, c);
-5.   ",Not Useful
/*codim=*/,"-10.                        c < cell->face(face)->n_active_descendants();
-9.                        ++c)
-8.                     {
-7.                       const auto subcell =
-6.                         cell->neighbor_child_on_subface(face, c);
-5.   ",Not Useful
/*Obey the component mask*/,"-2.       for (unsigned int i = 0; i < dofs_per_face; ++i)
-1.         {

/*Obey the component mask*/

1.           if ((component_mask.n_selected_components(fe.n_components()) !=
2.                fe.n_components()) &&
3.               !component_mask[fe",Not Useful
/*namespace*/,"-10. #include <deal.II/lac/affine_constraints.h>
-9. #include <deal.II/lac/vector.h>
-8. #ifdef DEAL_II_WITH_MPI
-7. #  include <deal.II/lac/la_parallel_vector.h>
-6. #endif
-5. #include <algorithm>
-4. #include <array>
-3. #include <memory>
-2. #include ",Not Useful
/*flip:*/,"-1.     static const int lookup_table_2d[2][2] = {

/*flip:*/

111",Not Useful
/*false       false false*/,"-2.       {
-1.         {

/*false       false false*/

111",Not Useful
/*false       false true*/,"-3.       {
-2.         {

/*false       false true*/

1.         },
2.         {",Not Useful
/*false       true  false*/,"-2.         },
-1.         {

/*false       true  false*/

111",Not Useful
/*false       true  true*/,"-3.         },
-2.         {

/*false       true  true*/

1.         },
2.       },
3.       {
4.         {",Not Useful
/*true        false false*/,"-4.         },
-3.       },
-2.       {
-1.         {

/*true        false false*/

111",Not Useful
/*true        false true*/,"-5.         },
-4.       },
-3.       {
-2.         {

/*true        false true*/

1.         },
2.         {",Not Useful
/*true        true  false*/,"-2.         },
-1.         {

/*true        true  false*/

111",Not Useful
/*true        true  true*/,"-3.         },
-2.         {

/*true        true  true*/

1.         },
2.       },
3.     };
4.     if (face_1->has_children() && face_2->has_children())
5.       {",Not Useful
/*namespace Assembler*/,"-10.                                       direction,
-9.                                       matched_faces);
-8.     make_periodicity_constraints<dim, spacedim>(matched_faces,
-7.                                                 constraints,
-6.        ",Not Useful
/*namespace*/,"-10. #include <deal.II/lac/affine_constraints.h>
-9. #include <deal.II/lac/vector.h>
-8. #ifdef DEAL_II_WITH_MPI
-7. #  include <deal.II/lac/la_parallel_vector.h>
-6. #endif
-5. #include <algorithm>
-4. #include <array>
-3. #include <memory>
-2. #include ",Not Useful
/*find the column where the representant is mentioned*/,"-1.           Assert(weights[parameter_dof].size() > 0, ExcInternalError());

/*find the column where the representant is mentioned*/

1.           std::map<types::global_dof_index, float>::const_iterator i =
2.             weights[parameter_dof].begin();",Not Useful
/*output_data*/,"-8. template <int dim, int spacedim>
-7. std::unique_ptr<typename FiniteElement<dim, spacedim>::InternalDataBase>
-6. FE_DGPNonparametric<dim, spacedim>::get_data(
-5.   const UpdateFlags update_flags,
-4.   const Mapping<dim, spacedim> &,
-3.   const Qua",Not Useful
/*---------------------------------------------------------------------------*/,"-10. template <int dim, int spacedim>
-9. MappingQ1<dim, spacedim>::MappingQ1()
-8.   : MappingQ<dim, spacedim>(1)
-7. {}
-6. template <int dim, int spacedim>
-5. std::unique_ptr<Mapping<dim, spacedim>>
-4. MappingQ1<dim, spacedim>::clone() const
-3. {
-2",Not Useful
"/*---------------------------------------------------------------------------
misc*/","
	void Parser::InitFun()
	{
		if (mu::TypeInfo<mu::value_type>::IsInteger())
		{


/*---------------------------------------------------------------------------
misc*/

1. 			DefineFun(_T(""exp""), MathImpl<value_type>::Exp);
2. 			DefineFun(_T(""sqrt""), MathImpl<value_type>::Sqrt);
3. 			DefineFun(_T(""sign""), MathImpl<value_type>::Sign);
4. 			DefineFun(_T(""rint""), MathImpl<value_type>::Rint);
5. 			DefineFun(_T(""abs""), MathImpl<value_type>::Abs);",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*misc*/,"-4. 			DefineFun(_T(""log2""), MathImpl<value_type>::Log2);
-3. 			DefineFun(_T(""log10""), MathImpl<value_type>::Log10);
-2. 			DefineFun(_T(""log""), MathImpl<value_type>::Log);
-1. 			DefineFun(_T(""ln""), MathImpl<value_type>::Log);

/*misc*/

1. 			DefineFun",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*pExpr*/,"-6. 	void Parser::InitOprt()
-5. 	{
-4. 		DefineInfixOprt(_T(""-""), MathImpl<value_type>::UnaryMinus);
-3. 		DefineInfixOprt(_T(""+""), MathImpl<value_type>::UnaryPlus);
-2. 	}

/*pExpr*/

1. 	{",Not Useful
/*nEnd*/,"-6. 	void Parser::InitOprt()
-5. 	{
-4. 		DefineInfixOprt(_T(""-""), MathImpl<value_type>::UnaryMinus);
-3. 		DefineInfixOprt(_T(""+""), MathImpl<value_type>::UnaryPlus);
-2. 	}

/*nEnd*/

1. 	{",Not Useful
/*---------------------------------------------------------------------------*/,"-2. namespace mu
-1. {

/*---------------------------------------------------------------------------*/

111",Not Useful
/*namespace mu*/,"
namespace mu



/*namespace mu*/

1. {",Not Useful
/*namespace DoFHandlerImplementation*/,"-8. #include <deal.II/base/exceptions.h>
-7. #include <deal.II/base/memory_consumption.h>
-6. #include <deal.II/dofs/dof_handler.h>
-5. #include <deal.II/dofs/dof_objects.h>
-4. #include <deal.II/fe/fe.h>
-3. DEAL_II_NAMESPACE_OPEN
-2. namespace internal
",Not Useful
/*namespace DoFHandlerImplementation*/,"-7. #include <deal.II/base/memory_consumption.h>
-6. #include <deal.II/base/mpi.h>
-5. #include <deal.II/dofs/number_cache.h>
-4. #include <numeric>
-3. DEAL_II_NAMESPACE_OPEN
-2. namespace internal
-1. {
  namespace DoFHandlerImplementation

/*namespace ",Not Useful
/*namespace*/,"-10. #ifdef DEAL_II_WITH_TRILINOS
-9. #  include <deal.II/lac/trilinos_block_sparse_matrix.h>
-8. #  include <deal.II/lac/trilinos_parallel_block_vector.h>
-7. #  include <deal.II/lac/trilinos_sparse_matrix.h>
-6. #  include <deal.II/lac/trilinos_vector.h",Not Useful
/*namespace MatrixTools*/,"-10. #ifdef DEAL_II_WITH_TRILINOS
-9. #  include <deal.II/lac/trilinos_block_sparse_matrix.h>
-8. #  include <deal.II/lac/trilinos_parallel_block_vector.h>
-7. #  include <deal.II/lac/trilinos_sparse_matrix.h>
-6. #  include <deal.II/lac/trilinos_vector.h",Not Useful
/*namespace*/,"-5. #include <deal.II/base/numbers.h>
-4. #include <deal.II/base/thread_management.h>
-3. #include <deal.II/fe/fe_series.h>
-2. #include <iostream>
-1. DEAL_II_NAMESPACE_OPEN
namespace

/*namespace*/

1. {
2.   void
3.   set_k_vectors(Table<1, Tensor<1, 1",Not Useful
/*namespace FESeries*/,"
namespace FESeries



/*namespace FESeries*/

1. {
2.   template <int dim, int spacedim>
3.   Fourier<dim, spacedim>::Fourier(
4.     const std::vector<unsigned int> &      n_coefficients_per_direction,
5.     const hp::FECollection<dim, spacedim> &fe_collection,
6.     const hp::QCollection<dim> &           q_collection,
7.     const unsigned int                     component_)
8.     : n_coefficients_per_direction(n_coefficients_per_direction)
9.     , fe_collection(&fe_collection)
10.     , q_collection(q_collection)",Not Useful
/** \brief Clone this instance and return a pointer to the new instance.*/,"-10. 			m_pFun = new CbWithUserData(*reinterpret_cast<CbWithUserData*>(ref.m_pFun));
-9. 		else
-8. 			m_pFun = ref.m_pFun;
-7. 		m_iArgc = ref.m_iArgc;
-6. 		m_bAllowOpti = ref.m_bAllowOpti;
-5. 		m_iCode = ref.m_iCode;
-4. 		m_iType = ref.m_iType;
-3. 	",Not Useful
/** \brief Return the callback code.*/,"-10. 		\throw nothrow
-9. 		Check that the function pointer is not null,
-8. 		and if there are user data that they are not null.
-7. 	*/
-6. 	bool ParserCallback::IsValid() const
-5. 	{
-4. 		return GetAddr() != nullptr
-3. 			&& !((m_iArgc & CALLBACK_IN",Not Useful
/*namespace mu*/,"
namespace mu



/*namespace mu*/

1. {
2. 	static constexpr int CALLBACK_INTERNAL_VAR_ARGS         = 1 << 14;
3. 	static constexpr int CALLBACK_INTERNAL_FIXED_ARGS_MASK  = 0xf;
4. 	static constexpr int CALLBACK_INTERNAL_WITH_USER_DATA	= 1 << 13;
5. 	struct CbWithUserData
6. 	{
7. 		void*	pFun;
8. 		void* 	pUserData;
9. 	};
10. 	ParserCallback::ParserCallback(fun_type0 a_pFun, bool a_bAllowOpti)",Not Useful
"/*,35*/","-10.         {2. / 3., 0}, {0, 1. / 3.}, {0, 2. / 3.}, {0.5, 1},     {1, 0.5},
-9.         {0, 0},       {1, 0},       {0, 1},       {1, 1},       {0.25, 0},
-8.         {0.5, 0},     {0.75, 0},    {0, 0.25},    {0, 0.5},     {0, 0.75},
-7.         {1. / ",Not Useful
/*namespace*/,"-6. #include <deal.II/fe/fe_dgp_monomial.h>
-5. #include <deal.II/fe/fe_nothing.h>
-4. #include <deal.II/fe/fe_tools.h>
-3. #include <memory>
-2. #include <sstream>
-1. DEAL_II_NAMESPACE_OPEN
namespace internal

/*namespace*/

1. {
2.   namespace FE_DGPMo",Not Useful
/*namespace FE_DGPMonomial*/,"-8. #include <deal.II/fe/fe_dgp_monomial.h>
-7. #include <deal.II/fe/fe_nothing.h>
-6. #include <deal.II/fe/fe_tools.h>
-5. #include <memory>
-4. #include <sstream>
-3. DEAL_II_NAMESPACE_OPEN
-2. namespace internal
-1. {
  namespace FE_DGPMonomial

/*name",Not Useful
/*namespace*/,"
namespace internal



/*namespace*/

1. {
2.   namespace FE_Nedelec
3.   {
4.     namespace
5.     {
6.       double
7.       get_embedding_computation_tolerance(const unsigned int p)
8.       {",Not Useful
/*namespace FE_Nedelec*/,"-2. namespace internal
-1. {
  namespace FE_Nedelec

/*namespace FE_Nedelec*/

1.   {
2.     namespace
3.     {
4.       double
5.       get_embedding_computation_tolerance(const unsigned int p)
6.       {",Not Useful
/*----------------------------------------------------------------------//*/,"-10.   return std::pair<Table<2, bool>, std::vector<unsigned int>>(constant_modes,
-9.                                                               components);
-8. }
-7. template <int dim>
-6. std::size_t
-5. FE_Nedelec<dim>::memory_consumption() const
",Not Useful
/*namespace DataOutFacesImplementation*/,"-10. #include <deal.II/fe/mapping_q1.h>
-9. #include <deal.II/grid/tria.h>
-8. #include <deal.II/grid/tria_iterator.h>
-7. #include <deal.II/hp/fe_values.h>
-6. #include <deal.II/lac/block_vector.h>
-5. #include <deal.II/lac/vector.h>
-4. #include <deal.I",Not Useful
/*.... SUPPORT QUADRATURE CONSTRUCTOR*/,"-10.               support_quadrature,
-9.               update_values | update_quadrature_points)
-8. {}
-7. template <int dim, class VectorType, int spacedim>
-6. std::unique_ptr<Mapping<dim, spacedim>>
-5. MappingQEulerian<dim, VectorType, spacedim>::c",Not Useful
/** \brief Bytecode default constructor.*/,"-10. #include ""muParserDef.h""
-9. #include ""muParserError.h""
-8. #include ""muParserToken.h""
-7. #include ""muParserTemplateMagic.h""
-6. #if defined(_MSC_VER)
-5. 	#pragma warning(push)
-4. 	#pragma warning(disable : 26812) 
-3. #endif
-2. namespace mu
-1. ",Not Useful
/*optimization does not apply*/,"-4. 	void ParserByteCode::AddVar(value_type* a_pVar)
-3. 	{
-2. 		++m_iStackPos;
-1. 		m_iMaxStackSize = std::max(m_iMaxStackSize, (size_t)m_iStackPos);

/*optimization does not apply*/

1. 		SToken tok;
2. 		tok.Cmd = cmVAR;
3. 		tok.u.Val.ptr = a_pVar;
",Not Useful
/*If optimization does not apply*/,"-10. 		  <li>the operator code according to ParserToken::cmVAL</li>
-9. 		  <li>the value stored in #mc_iSizeVal number of bytecode entries.</li>
-8. 		</ul>
-7. 		\param a_pVal Value to be added.
-6. 		\throw nothrow
-5. 	*/
-4. 	void ParserByteCode::Add",Not Useful
/*switch opcode*/,"-10. 		case cmMUL:  x = x * y;  m_vRPN.pop_back();  break;
-9. 		case cmDIV:
-8. 			x = x / y;
-7. 			m_vRPN.pop_back();
-6. 			break;
-5. 		case cmPOW: x = MathImpl<value_type>::Pow(x, y);
-4. 			m_vRPN.pop_back();
-3. 			break;
-2. 		default:
-1. 			bre",Not Useful
"/*Check for foldable constants like:
cmVAL cmVAL cmADD
where cmADD can stand fopr any binary operator applied to
two constant values.*/","-10. 		  <li>the operator code according to ParserToken::ECmdCode</li>
-9. 		</ul>
-8. 		\sa  ParserToken::ECmdCode
-7. 	*/
-6. 	void ParserByteCode::AddOp(ECmdCode a_Oprt)
-5. 	{
-4. 		bool bOptimized = false;
-3. 		if (m_bEnableOptimizer)
-2. 		{
-1. 		",Not Useful
"/*Simple optimization based on pattern recognition for a shitload of different
bytecode combinations of addition/subtraction*/","-10. 						else if (m_vRPN[sz - 1].u.Val.data2 == 4)
-9. 							m_vRPN[sz - 2].Cmd = cmVARPOW4;
-8. 						else
-7. 							break;
-6. 						m_vRPN.pop_back();
-5. 						bOptimized = true;
-4. 					}
-3. 					break;
-2. 				case  cmSUB:
-1. 				case  cmADD:",Not Useful
/*Optimization: 2*(3*b+1) or (3*b+1)*2 -> 6*b+2*/,"-10. 						m_vRPN[sz - 2].u.Val.ptr = (value_type*)((long long)(m_vRPN[sz - 2].u.Val.ptr) | (long long)(m_vRPN[sz - 1].u.Val.ptr));
-9. 						m_vRPN[sz - 2].u.Val.data = m_vRPN[sz - 2].u.Val.data2 + m_vRPN[sz - 1].u.Val.data2;
-8. 						m_vRPN[sz - 2].u.V",Not Useful
/*Optimization: a*a -> a^2*/,"-10. 							m_vRPN[sz - 2].u.Val.data = m_vRPN[sz - 1].u.Val.data * m_vRPN[sz - 2].u.Val.data2;
-9. 							m_vRPN[sz - 2].u.Val.data2 = m_vRPN[sz - 1].u.Val.data2 * m_vRPN[sz - 2].u.Val.data2;
-8. 						}
-7. 						m_vRPN.pop_back();
-6. 						bOptimized ",Not Useful
/*Optimization: 4*a/2 -> 2*a*/,"-8. 						m_vRPN[sz - 2].Cmd = cmVARPOW2;
-7. 						m_vRPN.pop_back();
-6. 						bOptimized = true;
-5. 					}
-4. 					break;
-3. 				case cmDIV:
-2. 					if (m_vRPN[sz - 1].Cmd == cmVAL && m_vRPN[sz - 2].Cmd == cmVARMUL && m_vRPN[sz - 1].u.Val.data2 != ",Not Useful
/*switch a_Oprt*/,"-2. 				default:
-1. 					break;

/*switch a_Oprt*/

1. 			}
2. 		}",Not Useful
/*If optimization can't be applied just write the value*/,"-2. 			}
-1. 		}

/*If optimization can't be applied just write the value*/

1. 		if (!bOptimized)
2. 		{
3. 			--m_iStackPos;
4. 			SToken tok;
5. 			tok.Cmd = a_Oprt;
6. 			m_vRPN.push_back(tok);
7. 		}
8. 	}
9. 	void ParserByteCode::AddIfElse(ECmdCode ",Not Useful
/*shrink bytecode vector to fit*/,"-5. 	void ParserByteCode::Finalize()
-4. 	{
-3. 		SToken tok;
-2. 		tok.Cmd = cmEND;
-1. 		m_vRPN.push_back(tok);

/*shrink bytecode vector to fit*/

111",Not Useful
/*Determine the if-then-else jump offsets*/,"-6. 	void ParserByteCode::Finalize()
-5. 	{
-4. 		SToken tok;
-3. 		tok.Cmd = cmEND;
-2. 		m_vRPN.push_back(tok);

/*Determine the if-then-else jump offsets*/

1. 		std::stack<int> stIf, stElse;
2. 		int idx;
3. 		for (int i = 0; i < (int)m_vRPN.size(); +",Not Useful
/*switch cmdCode*/,"-10. 			case cmELSE:  mu::console() << _T(""ELSE\t"");
-9. 				mu::console() << _T(""[OFFSET:"") << std::dec << m_vRPN[i].u.Oprt.offset << _T(""]\n"");
-8. 				break;
-7. 			case cmENDIF: mu::console() << _T(""ENDIF\n""); break;
-6. 			case cmASSIGN:
-5. 				mu::",Not Useful
/*while bytecode*/,"-10. 				mu::console() << _T(""[OFFSET:"") << std::dec << m_vRPN[i].u.Oprt.offset << _T(""]\n"");
-9. 				break;
-8. 			case cmENDIF: mu::console() << _T(""ENDIF\n""); break;
-7. 			case cmASSIGN:
-6. 				mu::console() << _T(""ASSIGN\t"");
-5. 				mu::console() <",Not Useful
/*namespace DataOutImplementation*/,"-10. #include <deal.II/fe/mapping_q1.h>
-9. #include <deal.II/grid/tria.h>
-8. #include <deal.II/grid/tria_iterator.h>
-7. #include <deal.II/hp/dof_handler.h>
-6. #include <deal.II/hp/fe_values.h>
-5. #include <deal.II/numerics/data_out.h>
-4. #include <s",Not Useful
/*did we mess up the indices?*/,"-7.       patch.neighbors[f] =
-6.         (*scratch_data
-5.             .cell_to_patch_index_map)[neighbor->level()][neighbor->index()];
-4.     }
-3.   const unsigned int patch_idx =
-2.     (*scratch_data.cell_to_patch_index_map)[cell_and_index->first",Not Useful
/*(fe_collection.size())*/,"-10.       {
-9.         Assert((subdomain_id == numbers::invalid_subdomain_id) ||
-8.                  (subdomain_id == triangulation->locally_owned_subdomain()),
-7.                ExcMessage(
-6.                  ""For distributed Triangulation objects ",Not Useful
/*namespace*/,"-10. #include <deal.II/hp/q_collection.h>
-9. #include <deal.II/lac/affine_constraints.h>
-8. #include <deal.II/lac/block_sparsity_pattern.h>
-7. #include <deal.II/lac/dynamic_sparsity_pattern.h>
-6. #include <deal.II/lac/sparsity_pattern.h>
-5. #include ",Not Useful
"/*"");
  if (slash_star_comment_begin != std::string::npos)
    {
      const std::string::size_type slash_star_comment_end = line.find(""*/","-5.   if (double_slash_comment != std::string::npos)
-4.     line.erase(double_slash_comment, std::string::npos);

/*"");
  if (slash_star_comment_begin != std::string::npos)
    {
      const std::string::size_type slash_star_comment_end = line.find(""*/

",Not Useful
/*block*/,"-2.       if (slash_star_comment_end == std::string::npos)
-1.         {

/*block*/

1.                     << ""comments that start and end within the same line.""
2.                     << std::endl;
3.           std::exit(1);
4.         }
5.       line.e",Not Useful
"/*split a given string assumed to consist of a list of substrings
delimited by a particular character into its components*/","-5.   std::size_t position = 0;
-4.   while ((position = whole_file.find(""  "", position)) != std::string::npos)
-3.     whole_file.replace(position, 2, 1, ' ');
-2.   return whole_file;
-1. }

/*split a given string assumed to consist of a list of substri",Not Useful
/*split the input list*/,"-5. std::list<std::string>
-4. split_string_list(const std::string &s, const char delimiter)
-3. {
-2.   std::string            tmp = s;
-1.   std::list<std::string> split_list;

/*split the input list*/

1.   while (tmp.length() != 0)
2.     {
3.       s",Not Useful
"/*determine whether a given substring at position #pos and length #length
in the string #text is a real token, i.e. not just part of another word*/","-9. std::list<std::string>
-8. delete_empty_entries(const std::list<std::string> &list)
-7. {
-6.   std::list<std::string> return_list;
-5.   for (const auto &entry : list)
-4.     if (!entry.empty())
-3.       return_list.push_back(entry);
-2.   return r",Not Useful
"/*substitute all occurrences of #token in #text by #substitute. because a
replacement token could be a templated class like std::complex<double>
and because the token to the substituted may be a template argument
itself, we surround the substitution by a space which shouldn't matter
in C++*/","-10.                                        ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
-9.                                        ""0123456789""
-8.                                        ""_"");
-7.   if ((pos != 0) && (token_chars.find(text[pos - 1]) != std::string::npos",Not Useful
"/*produce all combinations of substitutions of the tokens given in the
#substitutions list in #text and output it to std::cout*/","-4.       get_expansion_lists()[name] =
-3.         delete_empty_entries(split_string_list(expansion, ';'));
-2.     }
-1. }

/*produce all combinations of substitutions of the tokens given in the
#substitutions list in #text and output it to std::cout*/
",Not Useful
"/*do things recursively: if the list of substitutions has a single
entry, then process all of them. otherwise, process the first in the
list and call the function recursively with the rest of the
substitutions*/","if (substitutions.size() > 1)
    {

/*do things recursively: if the list of substitutions has a single
entry, then process all of them. otherwise, process the first in the
list and call the function recursively with the rest of the
substitutions*/

1.     }
2. }
3. int
4. main(int argc, char **argv)
5. {
6.   if (argc < 2)
7.     {
8.       std::cerr
9.         << ""Usage: "" << std::endl
10.         << ""  expand_instantiations class_list_files < in_file > out_file""",Not Useful
"/*do the first substitution, then call function recursively*/","-2.   if (substitutions.size() > 1)
-1.     {

/*do the first substitution, then call function recursively*/

1.       const std::string name    = substitutions.front().first,
2.                         pattern = substitutions.front().second;
3.       if ",Not Useful
/*do the substitutions*/,"-10.              get_expansion_lists()[pattern].begin();
-9.            expansion != get_expansion_lists()[pattern].end();
-8.            ++expansion)
-7.         {
-6.           std::string new_text = substitute_tokens(text, name, *expansion);
-5.      ",Not Useful
"/*process the list of instantiations given in the form
for (u,v:VECTORS; z:SCALARS) { f(u, z, const v &); }*/","-10.                     << std::endl;
-9.           std::cout << substitute_tokens(text, name, *expansion) << std::endl;
-8.           std::cout << ""#endif"" << std::endl;
-7.         }
-6.     }
-5.   else
-4.     {
-3.       std::cout << text << std::en",Not Useful
"/*process entries of the form
for (X:Y; A:B) { INST }*/","-4. void
-3. process_instantiations()
-2. {
-1.   std::string whole_file = read_whole_file(std::cin);

/*process entries of the form
for (X:Y; A:B) { INST }*/

1.   while (whole_file.size() != 0)
2.     {",Not Useful
/*process the header*/,"-10.       skip_space(whole_file);
-9.       const std::list<std::string> substitutions_list =
-8.         split_string_list(get_substring_with_delim(whole_file, "")""), ';');
-7.       if (whole_file[0] != ')')
-6.         {
-5.           std::cerr << ""Inv",Not Useful
/*now read the part in {...}*/,"-10.             {
-9.               std::cerr << ""Invalid instantiation header: '"" << substitution
-8.                         << ""'"" << std::endl;
-7.               std::exit(1);
-6.             }
-5.           const std::list<std::string> names =
-4.  ",Not Useful
"/*now produce the substitutions. first replace all occurrences of
""\{"" by ""{""*/","-10.         {
-9.           std::cerr << ""Invalid substitution text"" << std::endl;
-8.           std::exit(1);
-7.         }
-6.       whole_file.erase(0, 1);
-5.       skip_space(whole_file);
-4.       const std::string text_to_substitute =
-3.         ",Not Useful
/*write header:*/,"-10.   if (argc < 2)
-9.     {
-8.       std::cerr
-7.         << ""Usage: "" << std::endl
-6.         << ""  expand_instantiations class_list_files < in_file > out_file""
-5.         << std::endl;
-4.       std::exit(1);
-3.     }
-2.   for (int i = 1; i < a",Not Useful
/*namespace VectorTools*/,"-10. // The deal.II library is free software; you can use it, redistribute
-9. // it, and/or modify it under the terms of the GNU Lesser General
-8. // Public License as published by the Free Software Foundation; either
-7. // version 2.1 of the License, ",Not Useful
/*copier*/,"-3.           WorkStream::run(dof_handler.begin_active(),
-2.                           dof_handler.end(),
-1.                           worker,

/*copier*/

111",Not Useful
/*scratch_data*/,"-4.           WorkStream::run(dof_handler.begin_active(),
-3.                           dof_handler.end(),
-2.                           worker,

/*scratch_data*/

111",Not Useful
/*copy_data*/,"-5.           WorkStream::run(dof_handler.begin_active(),
-4.                           dof_handler.end(),
-3.                           worker,

/*copy_data*/

1.                           2 * MultithreadInfo::n_threads(),",Not Useful
/*chunk_size =*/,"-1.                           2 * MultithreadInfo::n_threads(),

/*chunk_size =*/

1.         }",Not Useful
/*copier*/,"-3.           WorkStream::run(dof_handler.begin_active(),
-2.                           dof_handler.end(),
-1.                           worker,

/*copier*/

111",Not Useful
/*scratch_data*/,"-4.           WorkStream::run(dof_handler.begin_active(),
-3.                           dof_handler.end(),
-2.                           worker,

/*scratch_data*/

111",Not Useful
/*copy_data*/,"-5.           WorkStream::run(dof_handler.begin_active(),
-4.                           dof_handler.end(),
-3.                           worker,

/*copy_data*/

1.                           2 * MultithreadInfo::n_threads(),",Not Useful
/*chunk_size =*/,"-1.                           2 * MultithreadInfo::n_threads(),

/*chunk_size =*/

1.         }",Not Useful
/*namespace*/,"-10. #include <deal.II/fe/fe.h>
-9. #include <deal.II/grid/grid_tools.h>
-8. #include <deal.II/grid/tria.h>
-7. #include <deal.II/grid/tria_iterator.h>
-6. #include <algorithm>
-5. #include <limits>
-4. #include <memory>
-3. #include <numeric>
-2. #includ",Not Useful
/*-------------- distribute_dofs functionality -------------*/,"-2.       struct Implementation
-1.       {

/*-------------- distribute_dofs functionality -------------*/

111",Not Useful
/*codim=*/,"-5.                                     const std::set<unsigned int> fe_indices{
-4.                                       fe_index_1, fe_index_2};
-3.                                     unsigned int dominating_fe_index =
-2.                             ",Not Useful
/*codim=*/,"-5.                                     const std::set<unsigned int> fe_indices{
-4.                                       fe_index_1, fe_index_2};
-3.                                     unsigned int dominating_fe_index =
-2.                             ",Not Useful
/*codim=*/,"-5.                                     const std::set<unsigned int> fe_indices{
-4.                                       fe_index_1, fe_index_2};
-3.                                     unsigned int dominating_fe_index =
-2.                             ",Not Useful
/*codim=*/,"-5.                                     const std::set<unsigned int> fe_indices{
-4.                                       fe_index_1, fe_index_2};
-3.                                     unsigned int dominating_fe_index =
-2.                             ",Not Useful
/*mark all vertices on ghost cells*/,"-3.           dealii::Table<2, std::unique_ptr<DoFIdentities>>
-2.             vertex_dof_identities(dof_handler.get_fe_collection().size(),
-1.                                   dof_handler.get_fe_collection().size());

/*mark all vertices on ghost cells",Not Useful
/*codim=*/,"-5.                                     const std::set<unsigned int> fe_indices{
-4.                                       fe_index_1, fe_index_2};
-3.                                     unsigned int dominating_fe_index =
-2.                             ",Not Useful
/*mark all lines on ghost cells*/,"-5.           std::vector<bool> user_flags;
-4.           dof_handler.get_triangulation().save_user_flags_line(user_flags);
-3.           const_cast<dealii::Triangulation<dim, spacedim> &>(
-2.             dof_handler.get_triangulation())
-1.             ",Not Useful
/*codim*/,"-3.                     unsigned int most_dominating_fe_index =
-2.                       dof_handler.get_fe_collection().find_dominating_fe(
-1.                         fe_indices,

/*codim*/

111",Not Useful
/*codim=*/,"-5.                                     const std::set<unsigned int> fe_indices{
-4.                                       fe_index_1, fe_index_2};
-3.                                     unsigned int dominating_fe_index =
-2.                             ",Not Useful
/*mark all quads on ghost cells*/,"-5.           std::vector<bool> user_flags;
-4.           dof_handler.get_triangulation().save_user_flags_quad(user_flags);
-3.           const_cast<dealii::Triangulation<dim, spacedim> &>(
-2.             dof_handler.get_triangulation())
-1.             ",Not Useful
/*codim=*/,"-5.                                     const std::set<unsigned int> fe_indices{
-4.                                       fe_index_1, fe_index_2};
-3.                                     unsigned int dominating_fe_index =
-2.                             ",Not Useful
"/*we found a neighboring ghost cell whose subdomain
is ""stronger"" than our own subdomain*/","-10.         static void
-9.         invalidate_dof_indices_on_weaker_ghost_cells_for_renumbering(
-8.           std::vector<types::global_dof_index> &renumbering,
-7.           const types::subdomain_id             subdomain_id,
-6.           const DoFHa",Not Useful
/*-------------- distribute_mg_dofs functionality -------------*/,"-10.                 local_dof_indices.resize(cell->get_fe().n_dofs_per_cell());
-9.                 internal::DoFAccessorImplementation::Implementation::
-8.                   get_dof_indices(*cell,
-7.                                   local_dof_indices",Not Useful
/*--------------------- renumber_dofs functionality ----------------*/,"-10.                           ""In practice, this can only happen if you are using ""
-9.                           ""32-bit data types. You will have to re-compile ""
-8.                           ""deal.II with the `DEAL_II_WITH_64BIT_INDICES' ""
-7.        ",Not Useful
/*new_numbers*/,"-3.         template <int dim, int spacedim>
-2.         static void
-1.         renumber_face_dofs(
          const std::vector<types::global_dof_index> &new_numbers,

/*new_numbers*/

1.           const IndexSet &                            indices_we_c",Not Useful
/*indices_we_care_about*/,#NAME?,Not Useful
/*dof_handler*/,"-10. #include <deal.II/base/geometry_info.h>
-9. #include <deal.II/base/memory_consumption.h>
-8. #include <deal.II/base/partitioner.h>
-7. #include <deal.II/base/thread_management.h>
-6. #include <deal.II/base/types.h>
-5. #include <deal.II/base/utilitie",Not Useful
/*new_numbers*/,"-3.         template <int dim, int spacedim>
-2.         static void
-1.         renumber_face_dofs(
          const std::vector<types::global_dof_index> &new_numbers,

/*new_numbers*/

1.           const IndexSet &                            indices_we_c",Not Useful
/*indices_we_care_about*/,#NAME?,Not Useful
/*dof_handler*/,"-10. #include <deal.II/base/geometry_info.h>
-9. #include <deal.II/base/memory_consumption.h>
-8. #include <deal.II/base/partitioner.h>
-7. #include <deal.II/base/thread_management.h>
-6. #include <deal.II/base/types.h>
-5. #include <deal.II/base/utilitie",Not Useful
/*deal with DoFs on lines*/,"-10.             {
-9.               for (unsigned int d = 1; d < dim; ++d)
-8.                 for (auto &i : dof_handler.object_dof_indices[0][d])
-7.                   if (i != numbers::invalid_dof_index)
-6.                     i = ((indices_we_care_a",Not Useful
/*deal with DoFs on lines*/,"-10.             {
-9.               for (unsigned int d = 1; d < dim; ++d)
-8.                 for (auto &i : dof_handler.object_dof_indices[0][d])
-7.                   if (i != numbers::invalid_dof_index)
-6.                     i = ((indices_we_care_a",Not Useful
/*--------------------- renumber_mg_dofs functionality ----------------*/,"-10.           tasks += Threads::new_task([&]() {
-9.             renumber_cell_dofs(new_numbers,
-8.                                indices_we_care_about,
-7.                                const_cast<DoFHandler<dim, space_dim> &>(
-6.                   ",Not Useful
/*new_numbers*/,"-3.         template <int dim, int spacedim>
-2.         static void
-1.         renumber_face_dofs(
          const std::vector<types::global_dof_index> &new_numbers,

/*new_numbers*/

1.           const IndexSet &                            indices_we_c",Not Useful
/*indices_we_care_about*/,#NAME?,Not Useful
/*dof_handler*/,"-10. #include <deal.II/base/geometry_info.h>
-9. #include <deal.II/base/memory_consumption.h>
-8. #include <deal.II/base/partitioner.h>
-7. #include <deal.II/base/thread_management.h>
-6. #include <deal.II/base/types.h>
-5. #include <deal.II/base/utilitie",Not Useful
/*check_validity*/,#NAME?,Not Useful
/*new_numbers*/,"-3.         template <int dim, int spacedim>
-2.         static void
-1.         renumber_face_dofs(
          const std::vector<types::global_dof_index> &new_numbers,

/*new_numbers*/

1.           const IndexSet &                            indices_we_c",Not Useful
/*indices_we_care_about*/,#NAME?,Not Useful
/*dof_handler*/,"-10. #include <deal.II/base/geometry_info.h>
-9. #include <deal.II/base/memory_consumption.h>
-8. #include <deal.II/base/partitioner.h>
-7. #include <deal.II/base/thread_management.h>
-6. #include <deal.II/base/types.h>
-5. #include <deal.II/base/utilitie",Not Useful
/*check_validity*/,#NAME?,Not Useful
/*check_validity=*/,"-10.       template <int dim, int spacedim>
-9.       NumberCache
-8.       Sequential<dim, spacedim>::distribute_dofs() const
-7.       {
-6.         const types::global_dof_index n_initial_dofs =
-5.           Implementation::distribute_dofs(numbers::in",Not Useful
/*check_validity=*/,"-10.       template <int dim, int spacedim>
-9.       NumberCache
-8.       Sequential<dim, spacedim>::distribute_dofs() const
-7.       {
-6.         const types::global_dof_index n_initial_dofs =
-5.           Implementation::distribute_dofs(numbers::in",Not Useful
/*namespace*/,"-10. #include <deal.II/fe/fe.h>
-9. #include <deal.II/grid/grid_tools.h>
-8. #include <deal.II/grid/tria.h>
-7. #include <deal.II/grid/tria_iterator.h>
-6. #include <algorithm>
-5. #include <limits>
-4. #include <memory>
-3. #include <numeric>
-2. #includ",Not Useful
/*check_validity=*/,"-10.       template <int dim, int spacedim>
-9.       NumberCache
-8.       Sequential<dim, spacedim>::distribute_dofs() const
-7.       {
-6.         const types::global_dof_index n_initial_dofs =
-5.           Implementation::distribute_dofs(numbers::in",Not Useful
/*check_validity=*/,"-10.       template <int dim, int spacedim>
-9.       NumberCache
-8.       Sequential<dim, spacedim>::distribute_dofs() const
-7.       {
-6.         const types::global_dof_index n_initial_dofs =
-5.           Implementation::distribute_dofs(numbers::in",Not Useful
/*check_validity=*/,"-10.       template <int dim, int spacedim>
-9.       NumberCache
-8.       Sequential<dim, spacedim>::distribute_dofs() const
-7.       {
-6.         const types::global_dof_index n_initial_dofs =
-5.           Implementation::distribute_dofs(numbers::in",Not Useful
/*new_numbers*/,"-3.         template <int dim, int spacedim>
-2.         static void
-1.         renumber_face_dofs(
          const std::vector<types::global_dof_index> &new_numbers,

/*new_numbers*/

1.           const IndexSet &                            indices_we_c",Not Useful
/*why would somebody request a cell that is not ours?*/,"-10.       {
-9.         template <int dim, int spacedim>
-8.         void
-7.         communicate_mg_ghost_cells(
-6.           const typename dealii::parallel::
-5.             DistributedTriangulationBase<dim, spacedim> &tria,
-4.           DoFHandler<",Not Useful
/*namespace*/,"-10. #include <deal.II/fe/fe.h>
-9. #include <deal.II/grid/grid_tools.h>
-8. #include <deal.II/grid/tria.h>
-7. #include <deal.II/grid/tria_iterator.h>
-6. #include <algorithm>
-5. #include <limits>
-4. #include <memory>
-3. #include <numeric>
-2. #includ",Not Useful
/*check_validity=*/,"-10.       template <int dim, int spacedim>
-9.       NumberCache
-8.       Sequential<dim, spacedim>::distribute_dofs() const
-7.       {
-6.         const types::global_dof_index n_initial_dofs =
-5.           Implementation::distribute_dofs(numbers::in",Not Useful
"/*we found a neighboring ghost cell whose
subdomain is ""stronger"" than our own
subdomain*/","local_dof_indices.resize(
                        cell->get_fe().n_dofs_per_cell());
                      cell->get_mg_dof_indices(local_dof_indices);
                      for (unsigned int i = 0;
                           i < cell->get_fe().n_dofs_per_cell();
                           ++i)
                        if (local_dof_indices[i] != numbers::invalid_dof_index)
                          renumbering[local_dof_indices[i]] =
                            numbers::invalid_dof_index;
                    }
              }

            level_number_cache.n_locally_owned_dofs = 0;
            for (types::global_dof_index &index : renumbering)
              if (index != numbers::invalid_dof_index)
                index = level_number_cache.n_locally_owned_dofs++;

/*we found a neighboring ghost cell whose
subdomain is ""stronger"" than our own
subdomain*/

111",Not Useful
/*check_validity=*/,"-10.       template <int dim, int spacedim>
-9.       NumberCache
-8.       Sequential<dim, spacedim>::distribute_dofs() const
-7.       {
-6.         const types::global_dof_index n_initial_dofs =
-5.           Implementation::distribute_dofs(numbers::in",Not Useful
/*namespace Policy*/,"-10. #include <algorithm>
-9. #include <limits>
-8. #include <memory>
-7. #include <numeric>
-6. #include <set>
-5. DEAL_II_NAMESPACE_OPEN
-4. namespace internal
-3. {
-2.   namespace DoFHandlerImplementation
-1.   {
    namespace Policy

/*namespace Poli",Not Useful
/*namespace DoFHandlerImplementation*/,"-10. #include <deal.II/grid/tria.h>
-9. #include <deal.II/grid/tria_iterator.h>
-8. #include <algorithm>
-7. #include <limits>
-6. #include <memory>
-5. #include <numeric>
-4. #include <set>
-3. DEAL_II_NAMESPACE_OPEN
-2. namespace internal
-1. {
  namesp",Not Useful
/*-------------------------- DataPostprocessor ---------------------------*/,"-10.   {
-9.     Assert(
-8.       face_number != numbers::invalid_unsigned_int,
-7.       ExcMessage(
-6.         ""This function can only be called if set_cell_and_face() has ""
-5.         ""previously been called. Typically, this would be by using DataOu",Not Useful
/*namespace FEValuesExtractors*/,"-10. // it, and/or modify it under the terms of the GNU Lesser General
-9. // Public License as published by the Free Software Foundation; either
-8. // version 2.1 of the License, or (at your option) any later version.
-7. // The full text of the license",Not Useful
/*line*/,"-10. std::unique_ptr<FiniteElement<2, 2>>
-9. FE_P1NC::clone() const
-8. {
-7.   return std::make_unique<FE_P1NC>(*this);
-6. }
-5. std::vector<unsigned int>
-4. FE_P1NC::get_dpo_vector()
-3. {
-2.   std::vector<unsigned int> dpo(3);

/*line*/

111",Not Useful
/*quad*/,"-10. std::string
-9. FE_P1NC::get_name() const
-8. {
-7.   return ""FE_P1NC"";
-6. }
-5. UpdateFlags
-4. FE_P1NC::requires_update_flags(const UpdateFlags flags) const
-3. {
-2.   UpdateFlags out = update_default;
-1.   if (flags & update_values)
    out |= ",Not Useful
/*system of components*/,"-10.               if (n_components == 1)
-9.                 {
-8.                   fe_patch_values.get_function_values(dof_data[dataset].data,
-7.                                                       patch_values);
-6.                   for (unsigned ",Not Useful
/*namespace*/,"-10. #include <deal.II/dofs/dof_accessor.h>
-9. #include <deal.II/fe/fe_system.h>
-8. #include <deal.II/fe/fe_tools.h>
-7. #include <deal.II/fe/fe_values.h>
-6. #include <deal.II/fe/mapping.h>
-5. #include <deal.II/grid/tria.h>
-4. #include <deal.II/grid/",Not Useful
/*----------------------- FESystem::InternalData -------------------*/,"-10. namespace
-9. {
-8.   unsigned int
-7.   count_nonzeros(const std::vector<unsigned int> &vec)
-6.   {
-5.     return std::count_if(vec.begin(), vec.end(), [](const unsigned int i) {
-4.       return i > 0;
-3.     });
-2.   }

/*---------------------",Not Useful
/*---------------------------------- FESystem -------------------*/,"-10.   base_fe_datas[base_no] = std::move(ptr);
-9. }
-8. template <int dim, int spacedim>
-7. internal::FEValuesImplementation::FiniteElementRelatedData<dim, spacedim> &
-6. FESystem<dim, spacedim>::InternalData::get_fe_output_object(
-5.   const unsigne",Not Useful
/*output_data*/,"-10.   return out;
-9. }
-8. template <int dim, int spacedim>
-7. std::unique_ptr<typename FiniteElement<dim, spacedim>::InternalDataBase>
-6. FESystem<dim, spacedim>::get_data(
-5.   const UpdateFlags             flags,
-4.   const Mapping<dim, spacedim>",Not Useful
/*output_data*/,"-10.   return out;
-9. }
-8. template <int dim, int spacedim>
-7. std::unique_ptr<typename FiniteElement<dim, spacedim>::InternalDataBase>
-6. FESystem<dim, spacedim>::get_data(
-5.   const UpdateFlags             flags,
-4.   const Mapping<dim, spacedim>",Not Useful
/*output_data*/,"-10.   return out;
-9. }
-8. template <int dim, int spacedim>
-7. std::unique_ptr<typename FiniteElement<dim, spacedim>::InternalDataBase>
-6. FESystem<dim, spacedim>::get_data(
-5.   const UpdateFlags             flags,
-4.   const Mapping<dim, spacedim>",Not Useful
/*on one of the four sub-quads*/,"-10.                                     .n_dofs_per_line(),
-9.                            ExcInternalError());
-8.                     m_index.second =
-7.                       5 *
-6.                         base_element(m_index.first.first).n_dofs_pe",Not Useful
/*let's see whether we have the information pre-computed*/,"-10.                                  face_index));
-9. }
-8. template <int dim, int spacedim>
-7. Point<dim>
-6. FESystem<dim, spacedim>::unit_support_point(const unsigned int index) const
-5. {
-4.   AssertIndexRange(index, this->n_dofs_per_cell());
-3.",Not Useful
/*let's see whether we have the information pre-computed*/,"-10.                                  face_index));
-9. }
-8. template <int dim, int spacedim>
-7. Point<dim>
-6. FESystem<dim, spacedim>::unit_support_point(const unsigned int index) const
-5. {
-4.   AssertIndexRange(index, this->n_dofs_per_cell());
-3.",Not Useful
/*cell stayed as it was or was refined*/,"-10.   for (const auto &cell : dof_handler->cell_iterators())
-9.     {
-8.       pointerstruct =
-7.         cell_map.find(std::make_pair(cell->level(), cell->index()));
-6.       if (pointerstruct != cell_map_end)
-5.         {
-4.           const std::",Not Useful
/*----------------------------   fe_tools.cc     ---------------------------*/,"-4. #include <deal.II/fe/fe_tools_extrapolate.templates.h>
-3. DEAL_II_NAMESPACE_OPEN

/*----------------------------   fe_tools.cc     ---------------------------*/

1. DEAL_II_NAMESPACE_CLOSE",Not Useful
/*not primitive*/,"-5.       for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)
-4.         if (fe.is_primitive(i))
-3.           local_component_association[i] =
-2.             fe.system_to_component_index(i).first;
-1.         else

/*not primitive*/

111",Not Useful
/*not primitive*/,"-5.       for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)
-4.         if (fe.is_primitive(i))
-3.           local_component_association[i] =
-2.             fe.system_to_component_index(i).first;
-1.         else

/*not primitive*/

111",Not Useful
/*namespace*/,"-10. #include <deal.II/hp/q_collection.h>
-9. #include <deal.II/lac/affine_constraints.h>
-8. #include <deal.II/lac/block_sparsity_pattern.h>
-7. #include <deal.II/lac/dynamic_sparsity_pattern.h>
-6. #include <deal.II/lac/sparsity_pattern.h>
-5. #include ",Not Useful
/*skip artificial and own cells (only look at ghost cells)*/,"-5.     std::vector<types::global_dof_index> dof_indices;
-4.     std::vector<types::global_dof_index> dofs_on_ghosts;
-3.     for (const auto &cell : dof_handler.cell_iterators_on_level(level))
-2.       {
-1.         const types::subdomain_id id = cell-",Not Useful
/*namespace*/,"-10. #include <deal.II/hp/q_collection.h>
-9. #include <deal.II/lac/affine_constraints.h>
-8. #include <deal.II/lac/block_sparsity_pattern.h>
-7. #include <deal.II/lac/dynamic_sparsity_pattern.h>
-6. #include <deal.II/lac/sparsity_pattern.h>
-5. #include ",Not Useful
/*only work on locally relevant cells*/,"-6.         hp::FEValues<dim, spacedim> hp_fe_values(mapping,
-5.                                                  fe_collection,
-4.                                                  q_coll_dummy,
-3.                                                  updat",Not Useful
/*namespace*/,"-10. #include <deal.II/hp/q_collection.h>
-9. #include <deal.II/lac/affine_constraints.h>
-8. #include <deal.II/lac/block_sparsity_pattern.h>
-7. #include <deal.II/lac/dynamic_sparsity_pattern.h>
-6. #include <deal.II/lac/sparsity_pattern.h>
-5. #include ",Not Useful
/*options*/,"-10. #include <set>
-9. #include ""common.h""
-8. #include ""innobackupex.h""
-7. #include ""xtrabackup.h""
-6. #include ""xbstream.h""
-5. #include ""fil_cur.h""
-4. #include ""write_filt.h""
-3. #include ""backup_copy.h""
-2. using std::min;
-1. using std::max;

/*op",Not Useful
/*********************************************************************/,"-4. 	--(*argv);
-3. 	++(*argc);
-2. 	return(true);
-1. }

/*********************************************************************/

1. Parse command-line options, connect to MySQL server,
2. detect server capabilities, etc.
3. @return	true on success. */
4",Not Useful
/*setup xtrabackup options*/,"-10. 	opt_socket = opt_ibx_socket;
-9. 	opt_port = opt_ibx_port;
-8. 	opt_lock_wait_query_type = opt_ibx_lock_wait_query_type;
-7. 	opt_kill_long_query_type = opt_ibx_kill_long_query_type;
-6. 	opt_kill_long_queries_timeout = opt_ibx_kill_long_queries_tim",Not Useful
/*--tables and --tables-file options are xtrabackup only*/,"-10. 			""--incremental option.\n"");
-9. 		return(false);
-8. 	}
-7. 	if (opt_ibx_databases != NULL) {
-6. 		if (is_path_separator(*opt_ibx_databases)) {
-5. 			xtrabackup_databases_file = opt_ibx_databases;
-4. 		} else {
-3. 			xtrabackup_databases = opt",Not Useful
"/*--binlog-info is xtrabackup only, so force
	--binlog-info=ON. i.e. behavior before the feature had been
	implemented*/","-6. 	ibx_partial_backup = (opt_ibx_include || opt_ibx_databases);
-5. 	if (ibx_mode == IBX_MODE_BACKUP) {
-4. 		if (!make_backup_dir()) {
-3. 			return(false);
-2. 		}
-1. 	}

/*--binlog-info is xtrabackup only, so force
	--binlog-info=ON. i.e. behavior b",Not Useful
/*Compression options*/,"-10. } comp_thread_ctxt_t;
-9. typedef struct {
-8. 	comp_thread_ctxt_t	*threads;
-7. 	uint			nthreads;
-6. } ds_compress_ctxt_t;
-5. typedef struct {
-4. 	ds_file_t		*dest_file;
-3. 	ds_compress_ctxt_t	*comp_ctxt;
-2. 	size_t			bytes_processed;
-1. } ds_",Not Useful
/*history.c -- standalone history library*/,"
/* history.c -- standalone history library */


/*history.c -- standalone history library*/

1. /* Copyright (C) 1989-2005 Free Software Foundation, Inc.
2.    This file contains the GNU History Library (the Library), a set of
3.    routines for managing the text of previously typed lines.
4.    The Library is free software; you can redistribute it and/or modify
5.    it under the terms of the GNU General Public License as published by
6.    the Free Software Foundation; either version 2, or (at your option)
7.    any later version.
8.    The Library is distributed in the hope that it will be useful, but
9.    WITHOUT ANY WARRANTY; without even the implied warranty of
10.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",Not Useful
/*HAVE_STDLIB_H*/,"-5. #define READLINE_LIBRARY
-4. #if defined (HAVE_CONFIG_H)
-3. #  include ""config_readline.h""
-2. #endif
-1. #include <stdio.h>
#if defined (HAVE_STDLIB_H)

/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/******************************************************************/,"-2. #define DEFAULT_HISTORY_GROW_SIZE 50
-1. static char *hist_inittime PARAMS((void));

/******************************************************************/

111",Not Useful
/******************************************************************/,"-2. #define DEFAULT_HISTORY_GROW_SIZE 50
-1. static char *hist_inittime PARAMS((void));

/******************************************************************/

111",Not Useful
/*backwards compatibility*/,"-1. int history_max_entries;

/*backwards compatibility*/

111",Not Useful
/*XXX - should use strtol() here*/,"-10. history_get_time (hist)
-9.      HIST_ENTRY *hist;
-8. {
-7.   char *ts;
-6.   time_t t;
-5.   if (hist == 0 || hist->timestamp == 0)
-4.     return 0;
-3.   ts = hist->timestamp;
-2.   if (ts[0] != history_comment_char)
-1.     return 0;

/*XXX - sh",Not Useful
/*savestring.c*/,"
/* savestring.c  */


/*savestring.c*/

1. /* Copyright (C) 1998,2003 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Not Useful
/*HAVE_STDLIB_H*/,"-10.    General Public License for more details.
-9.    The GNU General Public License is often shipped with GNU software, and
-8.    is generally kept in a file called COPYING or LICENSE.  If you do not
-7.    have a copy of the license, write to the Fre",Not Useful
/*local*/,"-10.    returned. */
-9. static int
-8. history_search_internal (string, direction, anchored)
-7.      const char *string;
-6.      int direction, anchored;
-5. {
-4.   register int i, reverse;
-3.   register char *line;
-2.   register int line_index;
-1.",Not Useful
/*!HAVE_STRING_H*/,"-10. #  include ""config_readline.h""
-9. #endif
-8. #if defined (HAVE_UNISTD_H)
-7. #  ifdef _MINIX
-6. #    include <sys/types.h>
-5. #  endif
-4. #  include <unistd.h>
-3. #endif
-2. #if defined (HAVE_STRING_H)
-1. #  include <string.h>

/*!HAVE_STRING_H",Not Useful
/*!HAVE_STRING_H*/,"-10. #  include ""config_readline.h""
-9. #endif
-8. #if defined (HAVE_UNISTD_H)
-7. #  ifdef _MINIX
-6. #    include <sys/types.h>
-5. #  endif
-4. #  include <unistd.h>
-3. #endif
-2. #if defined (HAVE_STRING_H)
-1. #  include <string.h>

/*!HAVE_STRING_H",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*!HAVE_GETPW_DECLS*/,"-7. #if !defined (HAVE_GETPW_DECLS)
-6. #  if defined (HAVE_GETPWUID)
-5. extern struct passwd *getpwuid PARAMS((uid_t));
-4. #  endif
-3. #  if defined (HAVE_GETPWNAM)
-2. extern struct passwd *getpwnam PARAMS((const char *));
-1. #  endif

/*!HAVE_GETPW",Not Useful
/*!savestring*/,"-2. #if !defined (savestring)
-1. #define savestring(x) strcpy ((char *)xmalloc (1 + strlen (x)), (x))

/*!savestring*/

1. #if !defined (NULL)
2. #  if defined (__STDC__)
3. #    define NULL ((void *) 0)
4. #  else
5. #    define NULL 0x0",Not Useful
/*!__STDC__*/,"-5. #if !defined (NULL)
-4. #  if defined (__STDC__)
-3. #    define NULL ((void *) 0)
-2. #  else
-1. #    define NULL 0x0

/*!__STDC__*/

111",Not Useful
/*|| !string[i]*/,"-10. tilde_find_suffix (string)
-9.      const char *string;
-8. {
-7.   register int i, j, string_len;
-6.   register char **suffixes;
-5.   suffixes = tilde_additional_suffixes;
-4.   string_len = strlen (string);
-3.   for (i = 0; i < string_len; i++)
",Not Useful
/*|| !string[i]*/,"-10. tilde_find_suffix (string)
-9.      const char *string;
-8. {
-7.   register int i, j, string_len;
-6.   register char **suffixes;
-5.   suffixes = tilde_additional_suffixes;
-4.   string_len = strlen (string);
-3.   for (i = 0; i < string_len; i++)
",Not Useful
/*TEST*/,"-5. #include <sys/types.h>
-4. #if defined (HAVE_PWD_H)
-3. #include <pwd.h>
-2. #endif
-1. #include ""tilde.h""
#if defined (TEST) || defined (STATIC_MALLOC)

/*TEST*/

1. static void *xmalloc (), *xrealloc ();
2. #else
3. #  include ""xmalloc.h""",Not Useful
"/*""xtra""*/","-1. 	strcat(dst_name, "".delta"");

/*""xtra""*/

1. 	cp->npages = 1;
2. 	cp->corrupted_pages = corrupted_pages;
3. 	return(TRUE);
4. }",Not Useful
"/*""xtra""*/","-1. 	strcat(dst_name, "".delta"");

/*""xtra""*/

1. 	cp->npages = 1;
2. 	cp->corrupted_pages = corrupted_pages;
3. 	return(TRUE);
4. }",Not Useful
"/*""XTRA""*/","-10. static my_bool
-9. wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt, ds_file_t *dstfile)
-8. {
-7. 	xb_fil_cur_t			*cursor = ctxt->cursor;
-6. 	const ulint			page_size = cursor->page_size;
-5. 	xb_wf_incremental_ctxt_t	*cp = &(ctxt->wf_incremental_",Not Useful
/*HAVE_SYS_FILE_H*/,"-10.    is generally kept in a file called COPYING or LICENSE.  If you do not
-9.    have a copy of the license, write to the Free Software Foundation,
-8.    51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA. */
-7. #define READLINE_LIBRARY
-6",Not Useful
/*HAVE_UNISTD_H*/,"
#if defined (HAVE_UNISTD_H)



/*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*!errno*/,"-8. #if defined (HAVE_LOCALE_H)
-7. #  include <locale.h>
-6. #endif
-5. #include <stdio.h>
-4. #include ""posixjmp.h""
-3. #include <errno.h>
-2. #if !defined (errno)
-1. extern int errno;

/*!errno*/

111",Not Useful
/*__EMX__*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""
#if defined (__EMX__)

/*__EMX__*/

1. #  define INCL_DOSPROCESS
2. #  include <os2.h>",Not Useful
/*Some standard library routines.*/,"-6. #include ""rldefs.h""
-5. #include ""rlmbutil.h""
-4. #if defined (__EMX__)
-3. #  define INCL_DOSPROCESS
-2. #  include <os2.h>

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include """,Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*VI_MODE*/,"-10. 	}
-9.     }
-8.   else
-7.     {
-6.       if (rl_prompt && rl_already_prompted)
-5. 	rl_on_new_line_with_prompt ();
-4.       else
-3. 	rl_on_new_line ();
-2.       (*rl_redisplay_function) ();
-1.     }
#if defined (VI_MODE)

/*VI_MODE*/

1.   if ",Not Useful
/*VI_MODE*/,"-10. 	}
-9.     }
-8.   else
-7.     {
-6.       if (rl_prompt && rl_already_prompted)
-5. 	rl_on_new_line_with_prompt ();
-4.       else
-3. 	rl_on_new_line ();
-2.       (*rl_redisplay_function) ();
-1.     }
#if defined (VI_MODE)

/*VI_MODE*/

1.   if ",Not Useful
/*EOF typed to a non-blank line is a <NL>.*/,"-10.       if (c == READERR)
-9. 	{
-8. #if defined (READLINE_CALLBACKS)
-7. 	  RL_SETSTATE(RL_STATE_DONE);
-6. 	  return (rl_done = 1);
-5. #else
-4. 	  eof_found = 1;
-3. 	  break;
-2. #endif
-1. 	}

/*EOF typed to a non-blank line is a <NL>.*/

1.     ",Not Useful
/*READLINE_CALLBACKS*/,"-10.   rl_set_signals ();
-9. #endif
-8.   value = readline_internal ();
-7.   if (rl_deprep_term_function)
-6.     (*rl_deprep_term_function) ();
-5. #if defined (HANDLE_SIGNALS)
-4.   rl_clear_signals ();
-3. #endif
-2.   return (value);
-1. }
#if defin",Not Useful
/*READLINE_CALLBACKS*/,"-10.   rl_set_signals ();
-9. #endif
-8.   value = readline_internal ();
-7.   if (rl_deprep_term_function)
-6.     (*rl_deprep_term_function) ();
-5. #if defined (HANDLE_SIGNALS)
-4.   rl_clear_signals ();
-3. #endif
-2.   return (value);
-1. }
#if defin",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*Tell the history routines what is going on.*/,"-2.   rl_done = 0;
-1.   RL_UNSETSTATE(RL_STATE_DONE);

/*Tell the history routines what is going on.*/

1.   _rl_start_using_history ();",Not Useful
/*__EMX__*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""
#if defined (__EMX__)

/*__EMX__*/

1. #  define INCL_DOSPROCESS
2. #  include <os2.h>",Not Useful
/*XXX*/,"-1.   rl_read_init_file ((char *)NULL);

/*XXX*/

1.   if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
2.     {
3.       _rl_screenwidth--;
4.       _rl_screenchars -= _rl_screenheight;
5.     }",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/******************************************************************/,"-7. static char *readline_internal PARAMS((void));
-6. static void readline_initialize_everything PARAMS((void));
-5. static void bind_arrow_keys_internal PARAMS((Keymap));
-4. static void bind_arrow_keys PARAMS((void));
-3. static void readline_default_b",Not Useful
/*HAVE_UNISTD_H*/,"-10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-9.    GNU General Public License for more details.
-8.    The GNU General Public License is often shipped with GNU software, and
-7.    is generally kept in a file called COPYING or",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*__EMX__*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""
#if defined (__EMX__)

/*__EMX__*/

1. #  define INCL_DOSPROCESS
2. #  include <os2.h>",Not Useful
/*Some standard library routines.*/,"-6. #include ""rldefs.h""
-5. #include ""rlmbutil.h""
-4. #if defined (__EMX__)
-3. #  define INCL_DOSPROCESS
-2. #  include <os2.h>

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include """,Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*fix boundaries*/,"-2.   if (from > to)
-1.     SWAP (from, to);

/*fix boundaries*/

1.   if (to > rl_end)
2.     {
3.       to = rl_end;
4.       if (from > to)
5. 	from = to;
6.     }
7.   if (from < 0)
8.     from = 0;
9.   text = rl_copy_text (from, to);",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*Movement Commands*/,"-10.    rl_end is the place in the string that we would place '\0';
-9.    i.e., it is always safe to place '\0' there.
-8.    rl_point is the place in the string where the cursor is.  Sometimes
-7.    this is the same as rl_end.
-6.    Any command that i",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

/*!HANDLE_MU",Not Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

/*!HANDLE_MU",Not Useful
/*Backwards compatibility.*/,"-7. int
-6. rl_forward_char (count, key)
-5.      int count, key;
-4. {
-3.   return (rl_forward_byte (count, key));
-2. }

/*Backwards compatibility.*/

1. int
2. rl_forward (count, key)
3.      int count, key;
4. {
5.   return (rl_forward_char (count, k",Not Useful
/*Backwards compatibility.*/,"-7. int
-6. rl_forward_char (count, key)
-5.      int count, key;
-4. {
-3.   return (rl_forward_byte (count, key));
-2. }

/*Backwards compatibility.*/

1. int
2. rl_forward (count, key)
3.      int count, key;
4. {
5.   return (rl_forward_char (count, k",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*Text commands*/,"-10.       else
-9. 	rl_backward_byte (count, ch);
-8.       break;
-7.     default:
-6.       rl_ding ();
-5.     }
-4.   return 0;
-3. }

/*Text commands*/

111",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*HANDLE_MULTIBYTE*/,"-10. 	  rl_point = lend;
-9. 	  rl_ding ();
-8. 	}
-7.       else
-6. 	rl_point = end;
-5.     }
-4.   if (rl_end < 0)
-3.     rl_end = 0;
-2.   return 0;
-1. }
#if defined (HANDLE_MULTIBYTE)

/*HANDLE_MULTIBYTE*/

111",Not Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

/*!HANDLE_MU",Not Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

/*!HANDLE_MU",Not Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

/*!HANDLE_MU",Not Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

/*!HANDLE_MU",Not Useful
/*XXX*/,"-7. int
-6. rl_refresh_line (ignore1, ignore2)
-5.      int ignore1 __attribute__((unused)), ignore2 __attribute__((unused));
-4. {
-3.   int curr_line;
-2.   curr_line = _rl_current_display_line ();
-1.   _rl_move_vert (curr_line);

/*XXX*/

111",Not Useful
/*VI_MODE*/,"-9. int
-8. rl_forward_byte (count, key)
-7.      int count, key;
-6. {
-5.   if (count < 0)
-4.     return (rl_backward_byte (-count, key));
-3.   if (count > 0)
-2.     {
-1.       int end = rl_point + count;
#if defined (VI_MODE)

/*VI_MODE*/

1.      ",Not Useful
/*The erase-at-end-of-line hack is of questionable merit now.*/,"-10.   orig_point = rl_point;
-9.   if (count > 1 || rl_explicit_arg)
-8.     {
-7.       rl_backward_char (count, key);
-6.       rl_kill_text (orig_point, rl_point);
-5.     }
-4.   else if (MB_CUR_MAX == 1 || rl_byte_oriented)
-3.     {
-2.       c = r",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*Assume the same width*/,"-4. 	    {
-3. 	      mlen = wcrtomb (mb, nwc, &mps);
-2. 	      if (mlen > 0)
-1. 		mb[mlen] = '\0';

/*Assume the same width*/

1. 	      strncpy (rl_line_buffer + start, mb, mlen);
2. 	    }
3. 	}
4. #endif
5.       start = next;
6.     }
7.   rl_point",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*Transposition*/,"-10. 	    }
-9. 	}
-8. #endif
-7.       start = next;
-6.     }
-5.   rl_point = end;
-4.   return 0;
-3. }

/*Transposition*/

111",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*I think that does it.*/,"-1.   rl_point = w2_end;

/*I think that does it.*/

1.   rl_end_undo_group ();
2.   free (word1);
3.   free (word2);
4.   return 0;
5. }",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

/*!HANDLE_MU",Not Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

/*!HANDLE_MU",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*The Mark and the Region.*/,"-10.       _rl_callback_data->i1 = BFIND;
-9.       _rl_callback_data->i2 = FFIND;
-8.       _rl_callback_func = _rl_char_search_callback;
-7.       return (0);
-6.     }
-5. #endif
-4.   return (_rl_char_search (count, BFIND, FFIND));
-3. }

/*The Mark a",Not Useful
/******************************************************************/,"-6. static int rl_change_case PARAMS((int, int));
-5. static int _rl_char_search PARAMS((int, int, int));
-4. #if defined (READLINE_CALLBACKS)
-3. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-2. static int _rl_char_search_cal",Not Useful
/*HAVE_UNISTD_H*/,"-10.    GNU General Public License for more details.
-9.    The GNU General Public License is often shipped with GNU software, and
-8.    is generally kept in a file called COPYING or LICENSE.  If you do not
-7.    have a copy of the license, write to the",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*!HAVE_STRING_H*/,"-4. #if defined (HAVE_STRING_H)
-3. #  include <string.h>
-2. #else
-1. #  include <strings.h>

/*!HAVE_STRING_H*/

1. #if defined (HAVE_LIMITS_H)
2. #  include <limits.h>
3. #endif
4. #if defined (HAVE_FCNTL_H)
5. #include <fcntl.h>
6. #endif
7. #if defi",Not Useful
/*HAVE_GETPWUID && !HAVE_GETPW_DECLS*/,"-10. #endif
-9. #if defined (HAVE_PWD_H)
-8. #include <pwd.h>
-7. #endif
-6. #include <stdio.h>
-5. #include ""rlstdc.h""
-4. #include ""rlshell.h""
-3. #include ""xmalloc.h""
-2. #if defined (HAVE_GETPWUID) && !defined (HAVE_GETPW_DECLS)
-1. extern struct pass",Not Useful
/*!HAVE_SETENV*/,"-10.   char *b;
-9. #if defined (HAVE_SETENV)
-8.   b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);
-7.   sprintf (b, ""%d"", lines);
-6.   setenv (""LINES"", b, 1);
-5.   free (b);
-4.   b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);
-3.   sprintf (b, """,Not Useful
/*HAVE_PUTENV*/,"
#  if defined (HAVE_PUTENV)



/*HAVE_PUTENV*/

1.   b = (char *)xmalloc (INT_STRLEN_BOUND (int) + sizeof (""LINES="") + 1);
2.   sprintf (b, ""LINES=%d"", lines);
3.   putenv (b);
4.   b = (char *)xmalloc (INT_STRLEN_BOUND (int) + sizeof (""COLUMNS="") + 1);
5.   sprintf (b, ""COLUMNS=%d"", cols);
6.   putenv (b);",Not Useful
/*!HAVE_SETENV*/,"-10.   char *b;
-9. #if defined (HAVE_SETENV)
-8.   b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);
-7.   sprintf (b, ""%d"", lines);
-6.   setenv (""LINES"", b, 1);
-5.   free (b);
-4.   b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);
-3.   sprintf (b, """,Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
/*!<in: file cursor*/,"-5. static
-4. void
-3. common_init(

/*!<in: file cursor*/

111",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
/*!<in: file cursor*/,"-5. static
-4. void
-3. common_init(

/*!<in: file cursor*/

111",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
/****************************************************************/,"-4. #include ""read_filt.h""
-3. #include ""common.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

/****************************************************************/

1. Perform read filter context initialization that is common to all read
2. filter",Not Useful
/******************************************************************/,"-2. _rl_callback_func_t *_rl_callback_func = 0;
-1. _rl_callback_generic_arg *_rl_callback_data = 0;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-2. _rl_callback_func_t *_rl_callback_func = 0;
-1. _rl_callback_generic_arg *_rl_callback_data = 0;

/******************************************************************/

111",Not Useful
/**********************************************************************/,"-1. #define XB_FIL_CUR_PAGES 640
/***********************************************************************

/**********************************************************************/

1. Extracts the relative path (""database/table.ibd"") of a tablespace from ",Not Useful
/*!< in/out: source file cursor*/,"-3. void
-2. xb_fil_cur_close(

/*!< in/out: source file cursor*/

1. {
2. 	if (cursor->read_filter) {
3. 		cursor->read_filter->deinit(&cursor->read_filter_ctxt);
4. 	}
5. 	aligned_free(cursor->buf);
6. 	cursor->buf = NULL;
7. 	if (cursor->node != NULL) ",Not Useful
/*!< in/out: source file cursor*/,"-3. void
-2. xb_fil_cur_close(

/*!< in/out: source file cursor*/

1. {
2. 	if (cursor->read_filter) {
3. 		cursor->read_filter->deinit(&cursor->read_filter_ctxt);
4. 	}
5. 	aligned_free(cursor->buf);
6. 	cursor->buf = NULL;
7. 	if (cursor->node != NULL) ",Not Useful
/******************************************************************/,"
/* **************************************************************** */


/******************************************************************/

111",Not Useful
/******************************************************************/,"
/* **************************************************************** */


/******************************************************************/

111",Not Useful
/*Variables exported to other files in the readline library.*/,"-10. #  include <stdlib.h>
-9. #else
-8. #  include ""ansi_stdlib.h""
-7. #endif
-6. #include ""rldefs.h""
-5. #include ""rlmbutil.h""
-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

/*Variables exported t",Not Useful
/*Variables imported from other files in the readline library.*/,"-2. char *_rl_isearch_terminators = (char *)NULL;
-1. _rl_search_cxt *_rl_iscxt = 0;

/*Variables imported from other files in the readline library.*/

1. extern HIST_ENTRY *_rl_saved_line_for_history;
2. static int rl_search_history PARAMS((int, int));
3",Not Useful
/*XXX*/,"-10.     {
-9.       f = _rl_keymap[c].function;
-8.       if (f == rl_reverse_search_history)
-7. 	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -1 : -2;
-6.       else if (f == rl_forward_search_history)
-5. 	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -2 : -",Not Useful
/*XXX*/,"-10.     {
-9.       f = _rl_keymap[c].function;
-8.       if (f == rl_reverse_search_history)
-7. 	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -1 : -2;
-6.       else if (f == rl_forward_search_history)
-5. 	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -2 : -",Not Useful
"/*C-H, DEL*/","-8.     case -2:
-7.       cxt->direction = -cxt->direction;
-6.       if (cxt->direction < 0)
-5. 	cxt->sflags |= SF_REVERSE;
-4.       else
-3. 	cxt->sflags &= ~SF_REVERSE;
-2.       break;

/*C-H, DEL*/

111",Not Useful
/*C-W*/,"-6.       rl_replace_line (cxt->lines[cxt->save_line], 0);
-5.       rl_point = cxt->save_point;
-4.       rl_mark = cxt->save_mark;
-3.       rl_restore_prompt();
-2.       rl_clear_message ();
-1.       return -1;

/*C-W*/

111",Not Useful
/*C-Y*/,"-10.       wlen = n - wstart + 1;
-9.       if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)
-8. 	{
-7. 	  cxt->search_string_size += wlen + 1;
-6. 	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
",Not Useful
/*skip over portion of line we already matched and yank rest*/,"-10.       if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)
-9. 	{
-8. 	  cxt->search_string_size += wlen + 1;
-7. 	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
-6. 	}
-5.       for (; wstart < ",Not Useful
/*We will need these later.*/,"-5. 	  if ((cxt->sflags & SF_REVERSE) ? (cxt->history_pos < 0) : (cxt->history_pos == cxt->hlen))
-4. 	    {
-3. 	      cxt->sflags |= SF_FAILED;
-2. 	      break;
-1. 	    }

/*We will need these later.*/

1. 	  cxt->sline = cxt->lines[cxt->history_pos];",Not Useful
/*HAVE_UNISTD_H*/,"-3. #if defined (HAVE_SYS_FILE_H) && !defined(__FreeBSD__)
-2. #  include <sys/file.h>
-1. #endif
#if defined (HAVE_UNISTD_H)

/*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*!errno*/,"-4. #include <stdio.h>
-3. #include <errno.h>
-2. #if !defined (errno)
-1. extern int errno;

/*!errno*/

1. #if defined (HAVE_PWD_H)
2. #include <pwd.h>
3. #endif
4. #include ""posixdir.h""
5. #include ""posixstat.h""",Not Useful
/*Some standard library routines.*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""xmalloc.h""
3. #include ""rlprivate.h""
4. #ifdef __STDC__
5. typedef int QSFUNC (const void *, const void *);
6. #else
7. typedef i",Not Useful
/*HAVE_GETPWENT && (!HAVE_GETPW_DECLS || _POSIX_SOURCE)*/,"-2. #if defined (HAVE_GETPWENT) && (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))
-1. extern struct passwd *getpwent PARAMS((void));

/*HAVE_GETPWENT && (!HAVE_GETPW_DECLS || _POSIX_SOURCE)*/

111",Not Useful
/******************************************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
/******************************************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
/*Variables known only to the readline library.*/,"-10. static void insert_all_matches PARAMS((char **, int, char *));
-9. static void display_matches PARAMS((char **));
-8. static int compute_lcd_of_matches PARAMS((char **, int, const char *));
-7. static int postprocess_matches PARAMS((char ***, int));
",Not Useful
/*VISIBLE_STATS*/,"-1. rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
#if defined (VISIBLE_STATS)

/*VISIBLE_STATS*/

1. #  if !defined (X_OK)
2. #    define X_OK 1
3. #  endif
4. static int stat_char PARAMS((char *));
5. #endif
6. stat",Not Useful
/*})*/,"-5. int rl_completion_query_items = 100;
-4. int _rl_page_completions = 1;

/*})*/

111",Not Useful
/*Variables local to this file.*/,"-1. int rl_inhibit_completion;

/*Variables local to this file.*/

111",Not Useful
/*************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
/*************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
/************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
/************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
/*S_ISCHR*/,"-10. #if defined (HAVE_LSTAT) && defined (S_ISLNK)
-9.   r = lstat (filename, &finfo);
-8. #else
-7.   r = stat (filename, &finfo);
-6. #endif
-5.   if (r == -1)
-4.     return (0);
-3.   character = 0;
-2.   if (S_ISDIR (finfo.st_mode))
-1.     character",Not Useful
/*S_ISBLK*/,"
#if defined (S_ISBLK)



/*S_ISBLK*/

1.   else if (S_ISBLK (finfo.st_mode))
2.     character = '#';",Not Useful
/*S_ISLNK*/,"-10.      `=' for sockets
-9.      `|' for FIFOs
-8.      `%' for character special devices
-7.      `#' for block special devices */
-6. static int
-5. stat_char (filename)
-4.      char *filename;
-3. {
-2.   struct stat finfo;
-1.   int character, r;
#",Not Useful
/*S_ISSOCK*/,"
#if defined (S_ISSOCK)



/*S_ISSOCK*/

1.   else if (S_ISSOCK (finfo.st_mode))
2.     character = '=';",Not Useful
/*VISIBLE_STATS*/,"-1. rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
#if defined (VISIBLE_STATS)

/*VISIBLE_STATS*/

1. #  if !defined (X_OK)
2. #    define X_OK 1
3. #  endif
4. static int stat_char PARAMS((char *));
5. #endif
6. stat",Not Useful
/*don't turn /// into //*/,"-1. 	  else if (full_pathname[1] == '/' && full_pathname[2] == 0)

/*don't turn /// into //*/

1. 	  else
2. 	    dn = full_pathname;
3. 	  s = tilde_expand (dn);
4. 	  if (rl_directory_completion_hook)
5. 	    (*rl_directory_completion_hook) (&s);
6. 	  ",Not Useful
/*Shell-like quoting conventions.*/,"-2. 	      quote_char = rl_line_buffer[scan];
-1. 	      rl_point = scan + 1;

/*Shell-like quoting conventions.*/

1. 	      if (quote_char == '\'')
2. 		found_quote |= RL_QF_SINGLE_QUOTE;
3. 	      else if (quote_char == '""')
4. 		found_quote |= RL_QF_D",Not Useful
/*&& rl_completion_suppress_append == 0*/,"-10.     temp_string[temp_string_index++] = rl_completion_append_character;
-9.   temp_string[temp_string_index++] = '\0';
-8.   if (rl_filename_completion_desired)
-7.     {
-6.       filename = tilde_expand (text);
-5.       s = (nontrivial_match && rl_",Not Useful
/*There are other matches remaining.*/,"-10. 	      display_matches (matches);
-9. 	      break;
-8. 	    }
-7. 	  else if (what_to_do == '@')
-6. 	    {
-5. 	      if (nontrivial_lcd == 0)
-4. 		display_matches (matches);
-3. 	      break;
-2. 	    }
-1. 	  else if (rl_editing_mode != vi_mode)",Not Useful
/***************************************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
/***************************************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Not Useful
/*There were no matches.*/,"-2.   if (matches)
-1.     compute_lcd_of_matches (match_list, matches, text);

/*There were no matches.*/

1.     {
2.       free (match_list);
3.       match_list = (char **)NULL;
4.     }
5.   return (match_list);
6. }",Not Useful
/*!__WIN32__ && !__OPENNT)*/,"-7. char *
-6. rl_username_completion_function (text, state)
-5.      const char *text;
-4.      int state;
-3. {
-2. #if defined (__WIN32__) || defined (__OPENNT)
-1.   return (char *)NULL;

/*!__WIN32__ && !__OPENNT)*/

1.   static char *username = (cha",Not Useful
/*!__WIN32__ && !__OPENNT*/,"-7. char *
-6. rl_username_completion_function (text, state)
-5.      const char *text;
-4.      int state;
-3. {
-2. #if defined (__WIN32__) || defined (__OPENNT)
-1.   return (char *)NULL;

/*!__WIN32__ && !__OPENNT*/

1.   static char *username = (char",Not Useful
/**** UNIMPLEMENTED ****/,"-10. 	  free (filename);
-9. 	  filename = temp;
-8. 	}
-7.       filename_len = strlen (filename);
-6.       rl_filename_completion_desired = 1;
-5.     }

/**** UNIMPLEMENTED ****/

111",Not Useful
"/*dirname && (strcmp (dirname, ""."") != 0)*/","-10. 	}
-9.       if (users_dirname)
-8. 	{
-7. 	  free (users_dirname);
-6. 	  users_dirname = (char *)NULL;
-5. 	}
-4.       return (char *)NULL;
-3.     }
-2.   else
-1.     {

/*dirname && (strcmp (dirname, ""."") != 0)*/

1.       if (dirname && (dirna",Not Useful
/*HAVE_UNISTD_H*/,"-10.    GNU General Public License for more details.
-9.    The GNU General Public License is often shipped with GNU software, and
-8.    is generally kept in a file called COPYING or LICENSE.  If you do not
-7.    have a copy of the license, write to the",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*Some standard library routines.*/,"-1. #include ""rldefs.h""

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include ""xmalloc.h""",Not Useful
/******************************************************************/,"-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/******************************************************************/,"-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/*Chunk flags*/,"-7. 	if (memcmp(tmpbuf, XB_STREAM_CHUNK_MAGIC, 8)) {
-6. 		msg(""xb_stream_read_chunk(): wrong chunk magic at offset ""
-5. 		    ""0x%llx."", (ulonglong) stream->offset);
-4. 		goto err;
-3. 	}
-2. 	ptr += 8;
-1. 	stream->offset += 8;

/*Chunk flags*/

1. 	c",Not Useful
/*kill.c -- kill ring management.*/,"
/* kill.c -- kill ring management. */


/*kill.c -- kill ring management.*/

1. /* Copyright (C) 1994 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Not Useful
/*HAVE_UNISTD_H*/,"-10.    GNU General Public License for more details.
-9.    The GNU General Public License is often shipped with GNU software, and
-8.    is generally kept in a file called COPYING or LICENSE.  If you do not
-7.    have a copy of the license, write to the",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*Some standard library routines.*/,"-1. #include ""rldefs.h""

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include ""xmalloc.h""",Not Useful
/******************************************************************/,"-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/*Killing Mechanism*/,"-6. #include ""readline.h""
-5. #include ""history.h""
-4. #include ""rlprivate.h""
-3. #include ""xmalloc.h""

/*Killing Mechanism*/

111",Not Useful
/******************************************************************/,"-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/*Where we are in the kill ring.*/,"-3. static int rl_max_kills =  DEFAULT_MAX_KILLS;

/*Where we are in the kill ring.*/

1. static int rl_kill_index;",Not Useful
/*How many slots we have in the kill ring.*/,"-1. static int rl_kill_index;

/*How many slots we have in the kill ring.*/

1. static int rl_kill_ring_length;
2. static int _rl_copy_to_kill_ring PARAMS((char *, int));
3. static int region_kill_internal PARAMS((int));
4. static int _rl_copy_word_as_kil",Not Useful
/*Is there anything to kill?*/,"-5. int
-4. rl_kill_text (from, to)
-3.      int from, to;
-2. {
-1.   char *text;

/*Is there anything to kill?*/

1.   if (from == to)
2.     {
3.       _rl_last_command_was_kill++;
4.       return 0;
5.     }
6.   text = rl_copy_text (from, to);",Not Useful
/******************************************************************/,"-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/*Killing Commands*/,"-10.   rl_delete_text (from, to);
-9.   _rl_copy_to_kill_ring (text, from < to);
-8.   _rl_last_command_was_kill++;
-7.   return 0;
-6. }

/*Killing Commands*/

111",Not Useful
/******************************************************************/,"-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
"/*Kill the whole line, no matter where point is.*/","-10. 	  orig_point = rl_point;
-9. 	  rl_beg_of_line (1, ignore);
-8. 	  if (rl_point != orig_point)
-7. 	    rl_kill_text (orig_point, rl_point);
-6. 	  if (rl_editing_mode == emacs_mode)
-5. 	    rl_mark = rl_point;
-4. 	}
-3.     }
-2.   return 0;
-1. ",Not Useful
"/*This does what C-w does in Unix.  We can't prevent people from
   using behaviour that they expect.*/","-10.   rl_begin_undo_group ();
-9.   rl_point = 0;
-8.   rl_kill_text (rl_point, rl_end);
-7.   rl_mark = 0;
-6.   rl_end_undo_group ();
-5.   return 0;
-4. }

/*This does what C-w does in Unix.  We can't prevent people from
   using behaviour that they e",Not Useful
/*Kill the text between the point and mark.*/,"-6. int
-5. rl_copy_region_to_kill (count, ignore)
-4.      int count __attribute__((unused)), ignore __attribute__((unused));
-3. {
-2.   return (region_kill_internal (0));
-1. }

/*Kill the text between the point and mark.*/

1. int
2. rl_kill_region (c",Not Useful
/*VI_MODE*/,"-10.     }
-9.   arg = history_arg_extract (count, count, entry->line);
-8.   if (!arg || !*arg)
-7.     {
-6.       rl_ding ();
-5.       FREE (arg);
-4.       return -1;
-3.     }
-2.   rl_begin_undo_group ();
-1.   _rl_set_mark_at_pos (rl_point);
#if d",Not Useful
/*__CYGWIN__*/,"
#if defined (__CYGWIN__)



/*__CYGWIN__*/

1. #include <windows.h>
2. int
3. rl_paste_from_clipboard (count, key)
4.      int count, key;
5. {
6.   char *data, *ptr;
7.   int len;
8.   if (OpenClipboard (NULL) == 0)
9.     return (0);
10.   data = (char *)GetClipboardData (CF_TEXT);",Not Useful
/*HAVE_SYS_FILE_H*/,"-10.    is generally kept in a file called COPYING or LICENSE.  If you do not
-9.    have a copy of the license, write to the Free Software Foundation,
-8.    51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA. */
-7. #define READLINE_LIBRARY
-6",Not Useful
/*HAVE_UNISTD_H*/,"
#if defined (HAVE_UNISTD_H)



/*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ*/,"-3. #include ""rldefs.h""
-2. #if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)
-1. #  include <sys/ioctl.h>

/*GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ*/

1. #include ""rltty.h""
2. #include ""tcap.h""",Not Useful
/*Some standard library routines.*/,"-2. #include ""rltty.h""
-1. #include ""tcap.h""

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include ""rlshell.h""
5. #include ""xmalloc.h""
6. #if defined (__MINGW32__)
7. #  include <windo",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/*__EMX__ || NEED_EXTERN_PC*/,"-6. static char *term_buffer = (char *)NULL;
-5. static char *term_string_buffer = (char *)NULL;
-4. static int tcap_initialized;
-3. #if !defined (__linux__)
-2. #  if defined (__EMX__) || defined (NEED_EXTERN_PC)
-1. extern

/*__EMX__ || NEED_EXTERN_PC*",Not Useful
/*__linux__*/,"-3. static char *term_buffer = (char *)NULL;
-2. static char *term_string_buffer = (char *)NULL;
-1. static int tcap_initialized;
#if !defined (__linux__)

/*__linux__*/

1. #  if defined (__EMX__) || defined (NEED_EXTERN_PC)
2. extern",Not Useful
/*How to go up a line.*/,"-3. const char *_rl_term_dc;
-2. const char *_rl_term_DC;
-1. const char *_rl_term_forward_char;

/*How to go up a line.*/

1. const char *_rl_term_up;
2. char _rl_term_up_default[2] = { 0, 0 };",Not Useful
/*@7*/,"-2. static const char *_rl_term_kh;
-1. static const char *_rl_term_kH;

/*@7*/

111",Not Useful
/*Cursor control*/,"-1. static const char *_rl_term_kI;

/*Cursor control*/

111",Not Useful
/*TIOCGWINSZ*/,"-1. #include ""rldefs.h""
#if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)

/*TIOCGWINSZ*/

1. #  include <sys/ioctl.h>",Not Useful
/*TIOCGWINSZ*/,"-1. #include ""rldefs.h""
#if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)

/*TIOCGWINSZ*/

1. #  include <sys/ioctl.h>",Not Useful
/*home down ??*/,"-10.   { ""DC"", &_rl_term_DC },
-9.   { ""IC"", &_rl_term_IC },
-8.   { ""ce"", &_rl_term_clreol },
-7.   { ""cl"", &_rl_term_clrpag },
-6.   { ""cr"", &_rl_term_cr },
-5.   { ""dc"", &_rl_term_dc },
-4.   { ""ei"", &_rl_term_ei },
-3.   { ""ic"", &_rl_term_ic },
-2.   ",Not Useful
/*home*/,"-10.   { ""DC"", &_rl_term_DC },
-9.   { ""IC"", &_rl_term_IC },
-8.   { ""ce"", &_rl_term_clreol },
-7.   { ""cl"", &_rl_term_clrpag },
-6.   { ""cr"", &_rl_term_cr },
-5.   { ""dc"", &_rl_term_dc },
-4.   { ""ei"", &_rl_term_ei },
-3.   { ""ic"", &_rl_term_ic },
-2.   ",Not Useful
/*XXX - doesn't DJGPP have a termcap library?*/,"-4. static void
-3. get_term_capabilities (bp)
-2.      char **bp;
-1. {

/*XXX - doesn't DJGPP have a termcap library?*/

1.   register unsigned int i;
2.   for (i = 0; i < NUM_TC_STRINGS; i++)
3.     *(tc_strings[i].tc_value) = tgetstr ((char *)tc_strin",Not Useful
/*used by _rl_get_screen_size*/,"-10.       if (term_buffer == 0)
-9. 	term_buffer = (char *)xmalloc(4080);
-8.       buffer = term_string_buffer;
-7.       tgetent_ret = tgetent (term_buffer, term);
-6.     }
-5.   if (tgetent_ret <= 0)
-4.     {
-3.       FREE (term_string_buffer);
-2.",Not Useful
/*!__EMX__*/,"-5.       if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-4. 	{
-3. #if defined (__EMX__)
-2. 	  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
-1. 	  _rl_screenwidth--;

/*!__EMX__*/

1. 	  _rl_get_screen_size (tty, 0);",Not Useful
/*!__EMX__*/,"-5.       if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-4. 	{
-3. #if defined (__EMX__)
-2. 	  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
-1. 	  _rl_screenwidth--;

/*!__EMX__*/

1. 	  _rl_get_screen_size (tty, 0);",Not Useful
/*VI_MODE*/,"-1.   bind_termcap_arrow_keys (emacs_standard_keymap);
#if defined (VI_MODE)

/*VI_MODE*/

1.   bind_termcap_arrow_keys (vi_movement_keymap);
2.   bind_termcap_arrow_keys (vi_insertion_keymap);",Not Useful
/*Home*/,"-2. static const char *_rl_term_ks;
-1. static const char *_rl_term_ke;

/*Home*/

1. static const char *_rl_term_kh;
2. static const char *_rl_term_kH;",Not Useful
/*!_MINIX*/,"-7. #ifdef _MINIX
-6. void
-5. _rl_output_character_function (c)
-4.      int c;
-3. {
-2.   putc (c, _rl_out_stream);
-1. }

/*!_MINIX*/

1. int
2. _rl_output_character_function (c)
3.      int c;
4. {
5.   return putc (c, _rl_out_stream);
6. }",Not Useful
/*!_MINIX*/,"-7. #ifdef _MINIX
-6. void
-5. _rl_output_character_function (c)
-4.      int c;
-3. {
-2.   putc (c, _rl_out_stream);
-1. }

/*!_MINIX*/

1. int
2. _rl_output_character_function (c)
3.      int c;
4. {
5.   return putc (c, _rl_out_stream);
6. }",Not Useful
/*NEW_TTY_DRIVER*/,"-3. int
-2. rl_crlf ()
-1. {
#if defined (NEW_TTY_DRIVER)

/*NEW_TTY_DRIVER*/

1.   if (_rl_term_cr)
2.     tputs (_rl_term_cr, 1, _rl_output_character_function);",Not Useful
/*FALLTHROUGH*/,"-10.         {
-9. 	case NO_BELL:
-8. 	default:
-7. 	  break;
-6. 	case VISIBLE_BELL:
-5. 	  if (_rl_visible_bell)
-4. 	    {
-3. 	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
-2. 	      break;
-1. 	    }

/*FALLTHROUGH*/

1. 	case AU",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/*Controlling the Meta Key and Keypad*/,"-10. 	  fprintf (stderr, ""\007"");
-9. 	  fflush (stderr);
-8. 	  break;
-7.         }
-6.       return (0);
-5.     }
-4.   return (-1);
-3. }

/*Controlling the Meta Key and Keypad*/

111",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/*Controlling the Cursor*/,"-10. {
-9. #if !defined (__DJGPP__)
-8.   if (on && _rl_term_ks)
-7.     tputs (_rl_term_ks, 1, _rl_output_character_function);
-6.   else if (!on && _rl_term_ke)
-5.     tputs (_rl_term_ke, 1, _rl_output_character_function);
-4. #endif
-3. }

/*Controlli",Not Useful
/******************************************************************/,"-1. int rl_prefer_env_winsize = 0;

/******************************************************************/

111",Not Useful
/*funmap.c -- attach names to functions.*/,"
/* funmap.c -- attach names to functions. */


/*funmap.c -- attach names to functions.*/

1. /* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Not Useful
/*BUFSIZ*/,"-10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-9.    GNU General Public License for more details.
-8.    The GNU General Public License is often shipped with GNU software, and
-7.    is generally kept in a file called COPYING or",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*VI_MODE*/,"-10.   { ""undo"", rl_undo_command },
-9.   { ""universal-argument"", rl_universal_argument },
-8.   { ""unix-filename-rubout"", rl_unix_filename_rubout },
-7.   { ""unix-line-discard"", rl_unix_line_discard },
-6.   { ""unix-word-rubout"", rl_unix_word_rubout },
-",Not Useful
/*log0online.h*/,"-6. #include ""changed_page_bitmap.h""
-5. #include ""common.h""
-4. #include ""xtrabackup.h""
-3. #include ""srv0srv.h""

/*log0online.h*/

111",Not Useful
/*!< Name of a file*/,"-1. 	struct files_t {

/*!< Name of a file*/

111",Not Useful
/*log0online.c*/,"-2. 	}	*files;
-1. };

/*log0online.c*/

111",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
"/*!<in/out: bitmap
							file*/","-4. static
-3. ibool
-2. log_online_read_bitmap_page(

/*!<in/out: bitmap
							file*/

111",Not Useful
/*********************************************************************/,"-10. 		    ""file \'%s\'"", bitmap_file->name);
-9. 		return FALSE;
-8. 	}
-7. 	bitmap_file->offset += MODIFIED_PAGE_BLOCK_SIZE;
-6. 	ut_ad(bitmap_file->offset <= bitmap_file->size);
-5. 	checksum = mach_read_from_4(page + MODIFIED_PAGE_BLOCK_CHECKSUM);
-4.",Not Useful
/*********************************************************************/,"-10. 		    ""file \'%s\'"", bitmap_file->name);
-9. 		return FALSE;
-8. 	}
-7. 	bitmap_file->offset += MODIFIED_PAGE_BLOCK_SIZE;
-6. 	ut_ad(bitmap_file->offset <= bitmap_file->size);
-5. 	checksum = mach_read_from_4(page + MODIFIED_PAGE_BLOCK_CHECKSUM);
-4.",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
"/*!<in: bitmap file
							name without directory,
							which is assumed to be
							srv_data_home*/","-4. static
-3. bool
-2. log_online_open_bitmap_file_read_only(

/*!<in: bitmap file
							name without directory,
							which is assumed to be
							srv_data_home*/

111",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/*!< in: bitmap file*/,"-10. Diagnose one or both of the following situations if we read close to
-9. the end of bitmap file:
-8. 1) Warn if the remainder of the file is less than one page.
-7. 2) Error if we cannot read any more full pages but the last read page
-6. did not hav",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
"/*!<in/out: bitmap
							file*/","-4. static
-3. ibool
-2. log_online_read_bitmap_page(

/*!<in/out: bitmap
							file*/

111",Not Useful
/*!<in: LSN to find*/,"-10. static
-9. ibool
-8. xb_find_lsn_in_bitmap_file(

/*!<in: LSN to find*/

1. {
2. 	ibool		last_page_ok		= TRUE;
3. 	ibool		next_to_last_page_ok	= TRUE;
4. 	xb_ad (bitmap_file->size >= MODIFIED_PAGE_BLOCK_SIZE);
5. 	*page_end_lsn = 0;
6. 	while ((*page",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/****************************************************************/,"-2. enum { MODIFIED_PAGE_BLOCK_ID_COUNT = MODIFIED_PAGE_BLOCK_BITMAP_LEN * 8 };
-1. typedef ib_uint64_t	bitmap_word_t;

/****************************************************************/

1. Calculate a bitmap block checksum.  Algorithm borrowed from
2. l",Not Useful
/*HAVE_SYS_FILE_H*/,"-10. #define READLINE_LIBRARY
-9. #if defined (__TANDEM)
-8. #  include <floss.h>
-7. #endif
-6. #if defined (HAVE_CONFIG_H)
-5. #  include ""config_readline.h""
-4. #endif
-3. #include <stdio.h>
-2. #include <sys/types.h>
-1. #include <fcntl.h>
#if defined",Not Useful
/*HAVE_UNISTD_H*/,"
#if defined (HAVE_UNISTD_H)



/*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*!errno*/,"-3. #include <errno.h>
-2. #if !defined (errno)
-1. extern int errno;

/*!errno*/

1. #include ""posixstat.h""",Not Useful
/*Some standard library routines.*/,"-1. #include ""rldefs.h""

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include ""rlshell.h""
5. #include ""xmalloc.h""
6. #if !defined (strchr) && !defined (__STDC__)
7. extern char *strchr",Not Useful
/*!strchr && !__STDC__*/,"-7. #include ""readline.h""
-6. #include ""history.h""
-5. #include ""rlprivate.h""
-4. #include ""rlshell.h""
-3. #include ""xmalloc.h""
-2. #if !defined (strchr) && !defined (__STDC__)
-1. extern char *strchr (), *strrchr ();

/*!strchr && !__STDC__*/

111",Not Useful
/*Variables exported by this file.*/,"-8. #include ""readline.h""
-7. #include ""history.h""
-6. #include ""rlprivate.h""
-5. #include ""rlshell.h""
-4. #include ""xmalloc.h""
-3. #if !defined (strchr) && !defined (__STDC__)
-2. extern char *strchr (), *strrchr ();

/*Variables exported by this file.*/",Not Useful
/*used only in this file*/,"-9. Keymap rl_binding_keymap;
-8. static char *_rl_read_file PARAMS((char *, size_t *));
-7. static void _rl_init_file_error PARAMS((const char *));
-6. static int _rl_read_init_file PARAMS((const char *, int));
-5. static int glean_key_from_name PARAMS((",Not Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

/******************************************************************/

111",Not Useful
/*ESC is meta-prefix*/,"-2. 	      if (strncmp (&seq[i], ""C-\\M-"", 5) == 0)
-1. 		{

/*ESC is meta-prefix*/

1. 		  i += 5;
2. 		  array[l++] = CTRL (_rl_to_upper (seq[i]));
3. 		  if (seq[i] == '\0')
4. 		    i--;
5. 		}
6. 	      else if (c == 'M')
7. 		{",Not Useful
/*seq[i] == '-'*/,"-7. 		  i += 5;
-6. 		  array[l++] = CTRL (_rl_to_upper (seq[i]));
-5. 		  if (seq[i] == '\0')
-4. 		    i--;
-3. 		}
-2. 	      else if (c == 'M')
-1. 		{

/*seq[i] == '-'*/

111",Not Useful
/*ESC is meta-prefix*/,"-2. 	      if (strncmp (&seq[i], ""C-\\M-"", 5) == 0)
-1. 		{

/*ESC is meta-prefix*/

1. 		  i += 5;
2. 		  array[l++] = CTRL (_rl_to_upper (seq[i]));
3. 		  if (seq[i] == '\0')
4. 		    i--;
5. 		}
6. 	      else if (c == 'M')
7. 		{",Not Useful
/*readline-specific*/,"-10. 	     preceding a character that is not special is stripped. */
-9. 	  switch (c)
-8. 	    {
-7. 	    case 'a':
-6. 	      array[l++] = '\007';
-5. 	      break;
-4. 	    case 'b':
-3. 	      array[l++] = '\b';
-2. 	      break;
-1. 	    case 'd':

/",Not Useful
/*map[ic].type != ISKMAP && keyseq[i+1] == 0*/,"-2.       else if (map[ic].type != ISKMAP && keyseq[i+1])
-1. 	return ((rl_command_func_t *)NULL);

/*map[ic].type != ISKMAP && keyseq[i+1] == 0*/

1. 	{
2. 	  if (type)
3. 	    *type = map[ic].type;
4. 	  return (map[ic].function);
5. 	}
6.     }
7.   re",Not Useful
/*``Be liberal in what you accept.''*/,"-2.       for (i = 0; line + i != end && line[i] != '\n'; i++);
-1. #if defined (__CYGWIN__)

/*``Be liberal in what you accept.''*/

1.       if (line[i] == '\n' && line[i-1] == '\r')
2. 	line[i - 1] = '\0';
3. #endif",Not Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

/******************************************************************/

111",Not Useful
/*Conditionals.*/,"-6. const char *_rl_possible_control_prefixes[] = {
-5.   ""Control-"", ""C-"", ""CTRL-"", (const char *)NULL
-4. };
-3. const char *_rl_possible_meta_prefixes[] = {
-2.   ""Meta"", ""M-"", (const char *)NULL
-1. };

/*Conditionals.*/

111",Not Useful
/*VI_MODE*/,"-10. int
-9. rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
-8.      const char *keyseq;
-7.      rl_command_func_t *default_func;
-6.      Keymap kmap;
-5. {
-4.   rl_command_func_t *func;
-3.   if (keyseq)
-2.     {
-1.       func = rl_fu",Not Useful
/*Skip whitespace.*/,"-7. static int
-6. handle_parser_directive (statement)
-5.      char *statement;
-4. {
-3.   register int i;
-2.   char *directive, *args;

/*Skip whitespace.*/

1.   for (i = 0; whitespace (statement[i]); i++);
2.   directive = &statement[i];
3.   for (;",Not Useful
"/*Lookup the command, and act on it.*/","-7.   for (i = 0; whitespace (statement[i]); i++);
-6.   directive = &statement[i];
-5.   for (; statement[i] && !whitespace (statement[i]); i++);
-4.   if (statement[i])
-3.     statement[i++] = '\0';
-2.   for (; statement[i] && whitespace (statement[i]",Not Useful
/*Skip any whitespace between keyname and funname.*/,"-6. 	  if (*e && e >= value)
-5. 	    *e = '\0';
-4. 	}
-3.       rl_variable_bind (var, value);
-2.       return 0;
-1.     }

/*Skip any whitespace between keyname and funname.*/

1.   for (; string[i] && whitespace (string[i]); i++);
2.   funname = &st",Not Useful
/*PREFIX_META_HACK*/,"-9.   if (*funname == '\'' || *funname == '""')
-8.     {
-7.       char useq[2];
-6.       int fl = strlen (funname);
-5.       useq[0] = key; useq[1] = '\0';
-4.       if (fl && funname[fl - 1] == *funname)
-3. 	funname[fl - 1] = '\0';
-2.       rl_macro",Not Useful
/*VISIBLE_STATS*/,"-10.   { ""mark-modified-lines"",	&_rl_mark_modified_lines,	0 },
-9.   { ""mark-symlinked-directories"", &_rl_complete_mark_symlink_dirs, 0 },
-8.   { ""match-hidden-files"",	&_rl_match_hidden_files,	0 },
-7.   { ""meta-flag"",		&_rl_meta_flag,			0 },
-6.   { ""ou",Not Useful
/*VI_MODE*/,"-10. int
-9. rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
-8.      const char *keyseq;
-7.      rl_command_func_t *default_func;
-6.      Keymap kmap;
-5. {
-4.   rl_command_func_t *func;
-3.   if (keyseq)
-2.     {
-1.       func = rl_fu",Not Useful
/*VI_MODE*/,"-10. int
-9. rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
-8.      const char *keyseq;
-7.      rl_command_func_t *default_func;
-6.      Keymap kmap;
-5. {
-4.   rl_command_func_t *func;
-3.   if (keyseq)
-2.     {
-1.       func = rl_fu",Not Useful
/*VI_MODE*/,"-10. int
-9. rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
-8.      const char *keyseq;
-7.      rl_command_func_t *default_func;
-6.      Keymap kmap;
-5. {
-4.   rl_command_func_t *func;
-3.   if (keyseq)
-2.     {
-1.       func = rl_fu",Not Useful
/*VI_MODE*/,"-10. int
-9. rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
-8.      const char *keyseq;
-7.      rl_command_func_t *default_func;
-6.      Keymap kmap;
-5. {
-4.   rl_command_func_t *func;
-3.   if (keyseq)
-2.     {
-1.       func = rl_fu",Not Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

/******************************************************************/

111",Not Useful
/*XXX - Experimental*/,"-1. #if 1

/*XXX - Experimental*/

111",Not Useful
/*compat.c -- backwards compatibility functions.*/,"
/* compat.c -- backwards compatibility functions. */


/*compat.c -- backwards compatibility functions.*/

1. /* Copyright (C) 2000 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Not Useful
/*HAVE_UNISTD_H*/,"-10.    is generally kept in a file called COPYING or LICENSE.  If you do not
-9.    have a copy of the license, write to the Free Software Foundation,
-8.    51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA. */
-7. #define READLINE_LIBRARY
-6",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*TIOCSTAT_IN_SYS_IOCTL*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""
#if defined (TIOCSTAT_IN_SYS_IOCTL)

/*TIOCSTAT_IN_SYS_IOCTL*/

1. #  include <sys/ioctl.h>",Not Useful
/*Some standard library routines.*/,"-5. #include ""rldefs.h""
-4. #include ""rlmbutil.h""
-3. #if defined (TIOCSTAT_IN_SYS_IOCTL)
-2. #  include <sys/ioctl.h>

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""rlprivate.h""
3. #include ""xmalloc.h""",Not Useful
/******************************************************************/,"-5. #if defined (HANDLE_MULTIBYTE)
-4. int rl_byte_oriented = 0;
-3. #else
-2. int rl_byte_oriented = 1;
-1. #endif

/******************************************************************/

111",Not Useful
/******************************************************************/,"-5. #if defined (HANDLE_MULTIBYTE)
-4. int rl_byte_oriented = 0;
-3. #else
-2. int rl_byte_oriented = 1;
-1. #endif

/******************************************************************/

111",Not Useful
/*found wide '\0'*/,"-3. 	  memset(&ps, 0, sizeof(mbstate_t));
-2. 	}
-1.       else if (MB_NULLWCH (tmp))

/*found wide '\0'*/

1.       else
2. 	{",Not Useful
/*HANDLE_MULTIBYTE*/,"
#if defined (HANDLE_MULTIBYTE)



/*HANDLE_MULTIBYTE*/

1. int rl_byte_oriented = 0;
2. #else
3. int rl_byte_oriented = 1;
4. #endif",Not Useful
/*Chunk magic*/,"-10. 		return 1;
-9. 	}
-8. 	file->chunk_ptr = file->chunk;
-7. 	file->chunk_free = XB_STREAM_MIN_CHUNK_SIZE;
-6. 	return 0;
-5. }
-4. static
-3. int
-2. xb_stream_write_chunk(xb_wstream_file_t *file, const void *buf, size_t len)
-1. {
	/* Chunk magic + f",Not Useful
/*Chunk flags*/,"-2. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-1. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

/*Chunk flags*/

111",Not Useful
/*Chunk type*/,"-3. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-2. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

/*Chunk type*/

111",Not Useful
/*Chunk magic*/,"-10. 		return 1;
-9. 	}
-8. 	file->chunk_ptr = file->chunk;
-7. 	file->chunk_free = XB_STREAM_MIN_CHUNK_SIZE;
-6. 	return 0;
-5. }
-4. static
-3. int
-2. xb_stream_write_chunk(xb_wstream_file_t *file, const void *buf, size_t len)
-1. {
	/* Chunk magic + f",Not Useful
/*Chunk flags*/,"-2. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-1. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

/*Chunk flags*/

111",Not Useful
/*Chunk type*/,"-3. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-2. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

/*Chunk type*/

111",Not Useful
/*HAVE_STDLIB_H*/,"-10.    WITHOUT ANY WARRANTY; without even the implied warranty of
-9.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-8.    General Public License for more details.
-7.    You should have received a copy of the GNU General Public Li",Not Useful
/******************************************************************/,"-7. #include ""readline.h""
-6. #include ""rlconf.h""
-5. #include ""emacs_keymap.c""
-4. #if defined (VI_MODE)
-3. #include ""vi_keymap.c""
-2. #endif
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/******************************************************************/,"-7. #include ""readline.h""
-6. #include ""rlconf.h""
-5. #include ""emacs_keymap.c""
-4. #if defined (VI_MODE)
-3. #include ""vi_keymap.c""
-2. #endif
-1. #include ""xmalloc.h""

/******************************************************************/

111",Not Useful
/*RUBOUT == 127*/,"-3.   for (i = ' '; i < 127; i++)
-2.     newmap[i].function = rl_insert;
-1.   newmap[TAB].function = rl_insert;

/*RUBOUT == 127*/

1.   newmap[CTRL('H')].function = rl_rubout;
2. #if KEYMAP_SIZE > 128",Not Useful
/*KEYMAP_SIZE > 128*/,"-1.   newmap[CTRL('H')].function = rl_rubout;
#if KEYMAP_SIZE > 128

/*KEYMAP_SIZE > 128*/

111",Not Useful
/*HAVE_UNISTD_H*/,"-10.    GNU General Public License for more details.
-9.    The GNU General Public License is often shipped with GNU software, and
-8.    is generally kept in a file called COPYING or LICENSE.  If you do not
-7.    have a copy of the license, write to the",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*Some standard library routines.*/,"-1. #include ""rldefs.h""

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include ""xmalloc.h""
5. extern void replace_history_data PARAMS((int, histdata_t *, histdata_t *));",Not Useful
/******************************************************************/,"-1. UNDO_LIST *rl_undo_list = (UNDO_LIST *)NULL;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. UNDO_LIST *rl_undo_list = (UNDO_LIST *)NULL;

/******************************************************************/

111",Not Useful
"/************************************************************************
Open a datasink file*/","-10. 		return NULL;
-9. 	}
-8. 	ctxt = ds->init(root);
-7. 	if (ctxt != NULL) {
-6. 		ctxt->datasink = ds;
-5. 	} else {
-4. 		die(""failed to initialize datasink."");
-3. 	}
-2. 	return ctxt;
-1. }

/********************************************************",Not Useful
/*HAVE_UNISTD_H*/,"-2. #include <sys/types.h>
-1. #include <signal.h>
#if defined (HAVE_UNISTD_H)

/*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Not Useful
/*GWINSZ_IN_SYS_IOCTL*/,"-1. #include ""rldefs.h""
#if defined (GWINSZ_IN_SYS_IOCTL)

/*GWINSZ_IN_SYS_IOCTL*/

1. #  include <sys/ioctl.h>",Not Useful
/*Some standard library routines.*/,"-1. #if defined (HANDLE_SIGNALS)

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #if !defined (RETSIGTYPE)
5. #  if defined (VOID_SIGHANDLER)
6. #    define RETSIGTYPE void
7. #  else
8. ",Not Useful
/*!VOID_SIGHANDLER*/,"-8. #include ""readline.h""
-7. #include ""history.h""
-6. #include ""rlprivate.h""
-5. #if !defined (RETSIGTYPE)
-4. #  if defined (VOID_SIGHANDLER)
-3. #    define RETSIGTYPE void
-2. #  else
-1. #    define RETSIGTYPE int

/*!VOID_SIGHANDLER*/

111",Not Useful
/*!RETSIGTYPE*/,"-9. #include ""readline.h""
-8. #include ""history.h""
-7. #include ""rlprivate.h""
-6. #if !defined (RETSIGTYPE)
-5. #  if defined (VOID_SIGHANDLER)
-4. #    define RETSIGTYPE void
-3. #  else
-2. #    define RETSIGTYPE int

/*!RETSIGTYPE*/

1. #if defined (VO",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/******************************************************************/,"-3. #endif
-2. static int signals_set_flag;
-1. static int sigwinch_set_flag;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-3. #endif
-2. static int signals_set_flag;
-1. static int sigwinch_set_flag;

/******************************************************************/

111",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*!HAVE_BSD_SIGNALS*/,"-2. #  if defined (HAVE_BSD_SIGNALS)
-1.   long omask;

/*!HAVE_BSD_SIGNALS*/

111",Not Useful
/*!HAVE_BSD_SIGNALS*/,"-2. #  if defined (HAVE_BSD_SIGNALS)
-1.   long omask;

/*!HAVE_BSD_SIGNALS*/

111",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*!HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS*/,"-6. #  if defined (SIGALRM)
-5.   if (sig == SIGINT || sig == SIGALRM)
-4. #  else
-3.   if (sig == SIGINT)
-2. #  endif
-1.     rl_set_sighandler (sig, SIG_IGN, &dummy_cxt);

/*!HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS*/

1.   switch (sig)
2.     {
3.    ",Not Useful
/*FALLTHROUGH*/,"-4.   switch (sig)
-3.     {
-2.     case SIGINT:
-1.       rl_free_line_state ();

/*FALLTHROUGH*/

1.     case SIGTERM:
2. #if defined (SIGTSTP)
3.     case SIGTSTP:
4.     case SIGTTOU:
5.     case SIGTTIN:",Not Useful
/*SIGTSTP*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTSTP*/

1. in",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*HAVE_BSD_SIGNALS*/,"
#  if defined (HAVE_BSD_SIGNALS)



/*HAVE_BSD_SIGNALS*/

1.   long omask;",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*assume we have raise*/,"-6. #if defined (__EMX__)
-5.       signal (sig, SIG_ACK);
-4. #endif
-3. #if defined (HAVE_KILL)
-2.       kill (getpid (), sig);
-1. #else

/*assume we have raise*/

1. #endif",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*HAVE_BSD_SIGNALS*/,"
#  if defined (HAVE_BSD_SIGNALS)



/*HAVE_BSD_SIGNALS*/

1.   long omask;",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*SIGWINCH*/,"-1. int rl_catch_signals = 1;

/*SIGWINCH*/

1. #ifdef SIGWINCH
2. int rl_catch_sigwinch = 1;
3. #else",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*!HAVE_POSIX_SIGNALS*/,"-7. typedef RETSIGTYPE SigHandler ();
-6. #if defined (HAVE_POSIX_SIGNALS)
-5. typedef struct sigaction sighandler_cxt;
-4. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-3. #else
-2. typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags",Not Useful
/*HAVE_POSIX_SIGNALS*/,"-1. typedef RETSIGTYPE SigHandler ();
#if defined (HAVE_POSIX_SIGNALS)

/*HAVE_POSIX_SIGNALS*/

1. typedef struct sigaction sighandler_cxt;
2. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
3. #else
4. typedef struct { SigHandler *sa_handler; int ",Not Useful
/*HAVE_POSIX_SIGNALS*/,"-1. typedef RETSIGTYPE SigHandler ();
#if defined (HAVE_POSIX_SIGNALS)

/*HAVE_POSIX_SIGNALS*/

1. typedef struct sigaction sighandler_cxt;
2. #  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
3. #else
4. typedef struct { SigHandler *sa_handler; int ",Not Useful
/*SIGALRM*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGALRM*/

1. in",Not Useful
/*SIGTSTP*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTSTP*/

1. in",Not Useful
/*SIGTTOU*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTTOU*/

1. in",Not Useful
/*SIGTTIN*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTTIN*/

1. in",Not Useful
/*SIGWINCH*/,"-1. int rl_catch_signals = 1;

/*SIGWINCH*/

1. #ifdef SIGWINCH
2. int rl_catch_sigwinch = 1;
3. #else",Not Useful
/*SIGTSTP*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTSTP*/

1. in",Not Useful
/*SIGTTOU*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTTOU*/

1. in",Not Useful
/*SIGTTIN*/,"-7. #ifndef SA_RESTART
-6. #  define SA_RESTART 0
-5. #endif
-4. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-3. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

/*SIGTTIN*/

1. in",Not Useful
/*HANDLE_SIGNALS*/,"
#if defined (HANDLE_SIGNALS)



/*HANDLE_SIGNALS*/

111",Not Useful
/*HAVE_STDLIB_H*/,"-10. #if defined (HAVE_CONFIG_H)
-9. #  include ""config_readline.h""
-8. #endif
-7. #include <stdio.h>
-6. #include <sys/types.h>
-5. #if ! defined (_MINIX) && defined (HAVE_SYS_FILE_H)
-4. #  include <sys/file.h>
-3. #endif
-2. #include ""posixstat.h""
-1. ",Not Useful
/*HISTORY_USE_MMAP*/,"-6. #if defined (HAVE_UNISTD_H)
-5. #  include <unistd.h>
-4. #endif
-3. #if defined (__EMX__) || defined (__CYGWIN__)
-2. #  undef HAVE_MMAP
-1. #endif
#ifdef HISTORY_USE_MMAP

/*HISTORY_USE_MMAP*/

1. #  include <sys/mman.h>
2. #  ifdef MAP_FILE
3. #   ",Not Useful
/*!__EMX__ && !__CYGWIN__*/,"-4. #if defined (__EMX__) || defined (__CYGWIN__)
-3. #  ifndef O_BINARY
-2. #    define O_BINARY 0
-1. #  endif

/*!__EMX__ && !__CYGWIN__*/

1. #  undef O_BINARY
2. #  define O_BINARY 0",Not Useful
/*!__EMX__ && !__CYGWIN__*/,"-4. #if defined (__EMX__) || defined (__CYGWIN__)
-3. #  ifndef O_BINARY
-2. #    define O_BINARY 0
-1. #  endif

/*!__EMX__ && !__CYGWIN__*/

1. #  undef O_BINARY
2. #  define O_BINARY 0",Not Useful
/*!errno*/,"-3. #include <errno.h>
-2. #if !defined (errno)
-1. extern int errno;

/*!errno*/

1. #include ""history.h""
2. #include ""histlib.h""
3. #include ""rlshell.h""
4. #include ""xmalloc.h""",Not Useful
"/*strlen("".history"") == 8*/","-10.   if (return_val)
-9.     return (return_val);
-8.   home = sh_get_env_value (""HOME"");
-7.   if (home == 0)
-6.     {
-5.       home = ""."";
-4.       home_len = 1;
-3.     }
-2.   else
-1.     home_len = strlen (home);

/*strlen("".history"") == 8*/

1",Not Useful
/*bp1 == bp+1*/,"-5. int
-4. history_truncate_file (fname, lines)
-3.      const char *fname;
-2.      int lines;
-1. {

/*bp1 == bp+1*/

1.   int file, chars_read, rv;
2.   struct stat finfo;
3.   size_t file_size;
4.   size_t bytes_written;
5.   buffer = (char *)NULL;
6",Not Useful
/*BeOS ignores O_TRUNC.*/,"-5.   if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
-4.     {
-3.       bytes_written= write (file, bp, chars_read - (bp - buffer));
-2.       (void) bytes_written;
-1. #if defined (__BEOS__)

/*BeOS ignores O_TRUNC",Not Useful
/*local*/,"-1.   {

/*local*/

1.     register int j;
2.     int buffer_size;
3.     char *buffer;
4.     the_history = history_list ();",Not Useful
/*HAVE_STDLIB_H*/,"-10.    General Public License for more details.
-9.    The GNU General Public License is often shipped with GNU software, and
-8.    is generally kept in a file called COPYING or LICENSE.  If you do not
-7.    have a copy of the license, write to the Fre",Not Useful
/*Variables exported by this file.*/,"-10. static char error_pointer;
-9. static char *subst_lhs;
-8. static char *subst_rhs;
-7. static int subst_lhs_len;
-6. static int subst_rhs_len;
-5. static char *get_history_word_specifier PARAMS((char *, char *, int *));
-4. static char *history_find_",Not Useful
/******************************************************************/,"-1. rl_linebuf_func_t *history_inhibit_expansion_function;

/******************************************************************/

111",Not Useful
/******************************************************************/,"-1. rl_linebuf_func_t *history_inhibit_expansion_function;

/******************************************************************/

111",Not Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

/*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Not Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

/*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Not Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

/*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Not Useful
/*:r discards the suffix.*/,"-5. 	case 'h':
-4. 	  tstr = strrchr (temp, '/');
-3. 	  if (tstr)
-2. 	    *tstr = '\0';
-1. 	  break;

/*:r discards the suffix.*/

1. 	case 'r':
2. 	  tstr = strrchr (temp, '.');
3. 	  if (tstr)
4. 	    *tstr = '\0';
5. 	  break;",Not Useful
/*:e discards everything but the suffix.*/,"-5. 	case 'r':
-4. 	  tstr = strrchr (temp, '.');
-3. 	  if (tstr)
-2. 	    *tstr = '\0';
-1. 	  break;

/*:e discards everything but the suffix.*/

1. 	case 'e':
2. 	  tstr = strrchr (temp, '.');
3. 	  if (tstr)
4. 	    {
5. 	      t = savestring (tstr);",Not Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

/*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Not Useful
/*Done with modfiers.*/,"-8. 	    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
-7. 	    free (result);
-6. 	    free (temp);
-5. 	    return (-1);
-4. 	  }
-3. 	}
-2.       i += 2;
-1.     }

/*Done with modfiers.*/

111",Not Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

/*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Not Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

/*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Not Useful
/*history_comment_char*/,"char history_comment_char = '\0';

/*history_comment_char*/

111",Not Useful
/*history_expansion_char*/,"
char history_expansion_char = '!';



/*history_expansion_char*/

111",Not Useful
/*)*/,"/* Copyright (C) 1989-2004 Free Software Foundation, Inc.

/*)*/

1.    This file contains the GNU History Library (the Library), a set of
2.    routines for managing the text of previously typed lines.
3.    The Library is free software; you can redistribute it and/or modify
4.    it under the terms of the GNU General Public License as published by
5.    the Free Software Foundation; either version 2, or (at your option)
6.    any later version.
7.    The Library is distributed in the hope that it will be useful, but
8.    WITHOUT ANY WARRANTY; without even the implied warranty of
9.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
10.    General Public License for more details.",Not Useful
/*)*/,"/* Copyright (C) 1989-2004 Free Software Foundation, Inc.

/*)*/

1.    This file contains the GNU History Library (the Library), a set of
2.    routines for managing the text of previously typed lines.
3.    The Library is free software; you can redistribute it and/or modify
4.    it under the terms of the GNU General Public License as published by
5.    the Free Software Foundation; either version 2, or (at your option)
6.    any later version.
7.    The Library is distributed in the hope that it will be useful, but
8.    WITHOUT ANY WARRANTY; without even the implied warranty of
9.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
10.    General Public License for more details.",Not Useful
/*HAVE_SYS_FILE_H*/,"-10.    51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA. */
-9. #define READLINE_LIBRARY
-8. #if defined (__TANDEM)
-7. #  include <floss.h>
-6. #endif
-5. #if defined (HAVE_CONFIG_H)
-4. #  include ""config_readline.h""
-3. #endif
-2. #include",Not Useful
/*HAVE_UNISTD_H*/,"
#if defined (HAVE_UNISTD_H)



/*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Not Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



/*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Not Useful
/*HAVE_SELECT*/,"
#if defined (HAVE_SELECT)



/*HAVE_SELECT*/

1. #  if !defined (HAVE_SYS_SELECT_H) || !defined (M_UNIX)
2. #    include <sys/time.h>
3. #  endif",Not Useful
/*!errno*/,"-10. #if defined (HAVE_SYS_SELECT_H)
-9. #  include <sys/select.h>
-8. #endif
-7. #if defined (FIONREAD_IN_SYS_IOCTL)
-6. #  include <sys/ioctl.h>
-5. #endif
-4. #include <stdio.h>
-3. #include <errno.h>
-2. #if !defined (errno)
-1. extern int errno;

/*!",Not Useful
/*Some standard library routines.*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""

/*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""rlprivate.h""
3. #include ""rlshell.h""
4. #include ""xmalloc.h""",Not Useful
/*Posix style*/,"-1. #if !defined (O_NDELAY) && defined (O_NONBLOCK)

/*Posix style*/

1. #endif",Not Useful
/******************************************************************/,"-3. static int ibuffer_space PARAMS((void));
-2. static int rl_get_char PARAMS((int *));
-1. static int rl_gather_tyi PARAMS((void));

/******************************************************************/

111",Not Useful
/******************************************************************/,"-3. static int ibuffer_space PARAMS((void));
-2. static int rl_get_char PARAMS((int *));
-1. static int rl_gather_tyi PARAMS((void));

/******************************************************************/

111",Not Useful
/*EOF*/,"-10. #endif
-9. #if defined (O_NDELAY)
-8.   if (result == -1)
-7.     {
-6.       tem = fcntl (tty, F_GETFL, 0);
-5.       fcntl (tty, F_SETFL, (tem | O_NDELAY));
-4.       chars_avail = read (tty, &input, 1);
-3.       fcntl (tty, F_SETFL, tem);
-2.    ",Not Useful
/*O_NDELAY*/,"
#if !defined (O_NDELAY) && defined (O_NONBLOCK)



/*O_NDELAY*/

111",Not Useful
/******************************************************************/,"-3. static int ibuffer_space PARAMS((void));
-2. static int rl_get_char PARAMS((int *));
-1. static int rl_gather_tyi PARAMS((void));

/******************************************************************/

111",Not Useful
/******************************************************************/,"-3. static int ibuffer_space PARAMS((void));
-2. static int rl_get_char PARAMS((int *));
-1. static int rl_gather_tyi PARAMS((void));

/******************************************************************/

111",Not Useful
/*XXX - experimental*/,"-5.       if (rl_event_hook)
-4. 	{
-3. 	  while (rl_event_hook && rl_get_char (&c) == 0)
-2. 	    {
-1. 	      (*rl_event_hook) ();

/*XXX - experimental*/

1. 		return ('\n');",Not Useful
/*XXX - EIO*/,"-1. 		return ('\n');

/*XXX - EIO*/

1. 		{
2. 		  rl_done = 1;
3. 		  return ('\n');
4. 		}
5. 	    }
6. 	}
7.       else
8. 	{
9. 	  if (rl_get_char (&c) == 0)
10. 	    c = (*rl_getc_function) (rl_instream);",Not Useful
/*HANDLE_MULTIBYTE*/,"-4.       if (errno != EINTR)
-3. 	return (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF);
-2.     }
-1. }
#if defined (HANDLE_MULTIBYTE)

/*HANDLE_MULTIBYTE*/

111",Not Useful
/*mysql flavor and version*/,"-10. #include ""mysql_version.h""
-9. #include ""backup_copy.h""
-8. #include ""backup_mysql.h""
-7. #include ""mysqld.h""
-6. #include ""xb_plugin.h""
-5. #include <sstream>
-4. #include <sql_error.h>
-3. #include ""page0zip.h""
-2. char *tool_name;
-1. char tool_ar",Not Useful
/*server capabilities*/,"-2. mysql_flavor_t server_flavor = FLAVOR_UNKNOWN;
-1. unsigned long mysql_server_version = 0;

/*server capabilities*/

1. bool have_changed_page_bitmaps = false;
2. bool have_backup_locks = false;
3. bool have_lock_wait_timeout = false;
4. bool have_gal",Not Useful
/*History on server*/,"-7. static mysql_mutex_t kill_query_thread_mutex;
-6. static bool kill_query_thread_running, kill_query_thread_stopping;
-5. static mysql_cond_t kill_query_thread_stopped;
-4. static mysql_cond_t kill_query_thread_stop;
-3. bool sql_thread_started = false",Not Useful
/*database*/,"-10. 		mysql_options(connection, MYSQL_OPT_SSL_CRLPATH,
-9. 			      opt_ssl_crlpath);
-8. 	}
-7. 	mysql_options(connection,MYSQL_OPT_SSL_VERIFY_SERVER_CERT,
-6. 		      (char*)&opt_ssl_verify_server_cert);
-5. #endif
-4. 	if (!mysql_real_connect(connecti",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
"/**
Execute mysql query.*/","-10. 				opt_socket, 0)) {
-9. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-8. 		mysql_close(connection);
-7. 		return(NULL);
-6. 	}
-5. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
",Not Useful
"/*bugs.launchpad.net/percona-xtrabackup"",*/","-10. 		|| ((version_number > 100000)
-9. 		    && server_flavor == FLAVOR_MARIADB);
-8. 	if (mysql51 && innodb_version == NULL) {
-7. 		msg(""Error: Built-in InnoDB in MySQL 5.1 is not ""
-6. 		    ""supported in this release. You can either use ""
-5. 		    ",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*MySQL >= 5.6 with GTID enabled*/,"-1. 	if (gtid_executed != NULL && *gtid_executed) {

/*MySQL >= 5.6 with GTID enabled*/

1. 		for (ptr = strchr(gtid_executed, '\n');
2. 		     ptr;
3. 		     ptr = strchr(ptr, '\n')) {
4. 			*ptr = ' ';
5. 		}
6. 		result = backup_file_printf(XTRABACKUP_",Not Useful
/*MariaDB >= 10.0 with GTID enabled*/,"-10. 		}
-9. 		result = backup_file_printf(XTRABACKUP_SLAVE_INFO,
-8. 			""SET GLOBAL gtid_purged='%s';\n""
-7. 			""CHANGE MASTER TO MASTER_AUTO_POSITION=1\n"",
-6. 			gtid_executed);
-5. 		ut_a(asprintf(&mysql_slave_position,
-4. 			""master host '%s', purge",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*uuid*/,"-10. 				opt_incremental_history_name,
-9. 				(unsigned long)strlen(opt_incremental_history_name));
-8. 		snprintf(query, sizeof(query),
-7. 			""SELECT innodb_to_lsn ""
-6. 			""FROM PERCONA_SCHEMA.xtrabackup_history ""
-5. 			""WHERE name = '%s' ""
-4. 			""A",Not Useful
/*name*/,"-10. #include ""xtrabackup.h""
-9. #include ""srv0srv.h""
-8. #include ""mysql_version.h""
-7. #include ""backup_copy.h""
-6. #include ""backup_mysql.h""
-5. #include ""mysqld.h""
-4. #include ""xb_plugin.h""
-3. #include <sstream>
-2. #include <sql_error.h>
-1. #inclu",Not Useful
/*tool_name*/,"-10. #include ""xtrabackup.h""
-9. #include ""srv0srv.h""
-8. #include ""mysql_version.h""
-7. #include ""backup_copy.h""
-6. #include ""backup_mysql.h""
-5. #include ""mysqld.h""
-4. #include ""xb_plugin.h""
-3. #include <sstream>
-2. #include <sql_error.h>
-1. #inclu",Not Useful
/*tool_command*/,"-10. 		|| xtrabackup_databases
-9. 		|| xtrabackup_databases_file
-8. 		|| xtrabackup_tables_exclude
-7. 		|| xtrabackup_databases_exclude
-6. 		);
-5. 	char *buf = NULL;
-4. 	int buf_len = asprintf(&buf,
-3. 		""uuid = %s\n""
-2. 		""name = %s\n""
-1. 		""too",Not Useful
/*tool_version*/,"-10. 		|| xtrabackup_databases_file
-9. 		|| xtrabackup_tables_exclude
-8. 		|| xtrabackup_databases_exclude
-7. 		);
-6. 	char *buf = NULL;
-5. 	int buf_len = asprintf(&buf,
-4. 		""uuid = %s\n""
-3. 		""name = %s\n""
-2. 		""tool_name = %s\n""
-1. 		""tool_com",Not Useful
/*ibbackup_version*/,"-10. 		|| xtrabackup_tables_exclude
-9. 		|| xtrabackup_databases_exclude
-8. 		);
-7. 	char *buf = NULL;
-6. 	int buf_len = asprintf(&buf,
-5. 		""uuid = %s\n""
-4. 		""name = %s\n""
-3. 		""tool_name = %s\n""
-2. 		""tool_command = %s\n""
-1. 		""tool_version = ",Not Useful
/*server_version*/,"-1. mysql_flavor_t server_flavor = FLAVOR_UNKNOWN;
unsigned long mysql_server_version = 0;

/*server_version*/

111",Not Useful
/*start_time*/,"
time_t history_start_time;



/*start_time*/

1. time_t history_end_time;
2. time_t history_lock_time;
3. MYSQL *mysql_connection;
4. extern my_bool opt_ssl_verify_server_cert, opt_use_ssl;
5. MYSQL *
6. xb_mysql_connect()
7. {
8. 	MYSQL *connection = mysql_init(NULL);
9. 	char mysql_port_str[std::numeric_limits<int>::digits10 + 3];
10. 	sprintf(mysql_port_str, ""%d"", opt_port);",Not Useful
/*end_time*/,"-1. time_t history_start_time;
time_t history_end_time;

/*end_time*/

1. time_t history_lock_time;
2. MYSQL *mysql_connection;
3. extern my_bool opt_ssl_verify_server_cert, opt_use_ssl;
4. MYSQL *
5. xb_mysql_connect()
6. {
7. 	MYSQL *connection = mysql_",Not Useful
/*lock_time*/,"-2. time_t history_start_time;
-1. time_t history_end_time;
time_t history_lock_time;

/*lock_time*/

1. MYSQL *mysql_connection;
2. extern my_bool opt_ssl_verify_server_cert, opt_use_ssl;
3. MYSQL *
4. xb_mysql_connect()
5. {
6. 	MYSQL *connection = mysq",Not Useful
/*binlog_pos*/,"-6. static mysql_mutex_t kill_query_thread_mutex;
-5. static bool kill_query_thread_running, kill_query_thread_stopping;
-4. static mysql_cond_t kill_query_thread_stopped;
-3. static mysql_cond_t kill_query_thread_stop;
-2. bool sql_thread_started = false",Not Useful
/*innodb_from_lsn*/,"-10. 		""name = %s\n""
-9. 		""tool_name = %s\n""
-8. 		""tool_command = %s\n""
-7. 		""tool_version = %s\n""
-6. 		""ibbackup_version = %s\n""
-5. 		""server_version = %s\n""
-4. 		""start_time = %s\n""
-3. 		""end_time = %s\n""
-2. 		""lock_time = %d\n""
-1. 		""binlog_po",Not Useful
/*innodb_to_lsn*/,"-10. select_incremental_lsn_from_history(lsn_t *incremental_lsn)
-9. {
-8. 	MYSQL_RES *mysql_result;
-7. 	char query[1000];
-6. 	char buf[100];
-5. 	if (opt_incremental_history_name) {
-4. 		mysql_real_escape_string(mysql_connection, buf,
-3. 				opt_incr",Not Useful
/*format*/,"-10. 		""ibbackup_version = %s\n""
-9. 		""server_version = %s\n""
-8. 		""start_time = %s\n""
-7. 		""end_time = %s\n""
-6. 		""lock_time = %d\n""
-5. 		""binlog_pos = %s\n""
-4. 		""innodb_from_lsn = "" LSN_PF ""\n""
-3. 		""innodb_to_lsn = "" LSN_PF ""\n""
-2. 		""partial ",Not Useful
/*compressed*/,"-10. 		""server_version = %s\n""
-9. 		""start_time = %s\n""
-8. 		""end_time = %s\n""
-7. 		""lock_time = %d\n""
-6. 		""binlog_pos = %s\n""
-5. 		""innodb_from_lsn = "" LSN_PF ""\n""
-4. 		""innodb_to_lsn = "" LSN_PF ""\n""
-3. 		""partial = %s\n""
-2. 		""incremental = %s\",Not Useful
/*capture tool name tool args*/,"-10. 		}
-9. 		left-= snprintf(buf + len - left, left,
-8. 				""%s%c"", arg, argc > 1 ? ' ' : 0);
-7. 		++argv; --argc;
-6. 	}
-5. 	return buf;
-4. }
-3. void
-2. capture_tool_command(int argc, char **argv)
-1. {

/*capture tool name tool args*/

1. 	tool_",Not Useful
/*********************************************************************/,"-9. 				opt_socket, 0)) {
-8. 		msg(""Failed to connect to MariaDB server: %s."", mysql_error(connection));
-7. 		mysql_close(connection);
-6. 		return(NULL);
-5. 	}
-4. 	xb_mysql_query(connection, ""SET SESSION wait_timeout=2147483, max_statement_time=0"",
-",Not Useful
/*We found a symlink or a file*/,"-10. 		return(true);
-9. 	}
-8. 	if (!it->dbpath || !it->dbdir) {
-7. 		return(false);
-6. 	}
-5. 	while (os_file_readdir_next_file(it->dbpath, it->dbdir,
-4. 					  &it->fileinfo) == 0) {
-3. 		if (it->fileinfo.type == OS_FILE_TYPE_DIR) {
-2. 			continue",Not Useful
/*nothing found*/,"-10. 			goto done;
-9. 		}
-8. 		make_path_n(2, &it->filepath, &it->filepath_len,
-7. 				it->datadir_path, it->dbinfo.name);
-6. 		make_path_n(1, &it->filepath_rel, &it->filepath_rel_len,
-5. 				it->dbinfo.name);
-4. 		it->is_empty_dir = true;
-3. 		dat",Not Useful
/*could be symlink*/,"-10. 	if (my_stat(dir, &stat_arg, MYF(0)) == NULL) {
-9. 		if (!create) {
-8. 			return(false);
-7. 		}
-6. 		if (mkdirp(dir, 0777, MYF(0)) < 0) {
-5. 			my_strerror(errbuf, sizeof(errbuf), my_errno);
-4. 			msg(""Can not create directory %s: %s"", dir, err",Not Useful
/*close*/,"-10. 	return(it);
-9. error:
-8. 	free(it);
-7. 	return(NULL);
-6. }
-5. static
-4. bool
-3. datadir_iter_next_database(datadir_iter_t *it)
-2. {
-1. 	if (it->dbdir != NULL) {
		if (os_file_closedir_failed(it->dbdir)) {

/*close*/

1. 			msg(""Warning: cou",Not Useful
/*The main copy loop*/,"-10. 		goto error_close;
-9. 	}
-8. 	strncpy(dst_name, cursor.rel_path, sizeof(dst_name));
-7. 	dstfile = ds_open(datasink, dst_path, &cursor.statinfo);
-6. 	if (dstfile == NULL) {
-5. 		msg(thread_n,""error: ""
-4. 			""cannot open the destination stream fo",Not Useful
/*close*/,"-10. 	return(it);
-9. error:
-8. 	free(it);
-7. 	return(NULL);
-6. }
-5. static
-4. bool
-3. datadir_iter_next_database(datadir_iter_t *it)
-2. {
-1. 	if (it->dbdir != NULL) {
		if (os_file_closedir_failed(it->dbdir)) {

/*close*/

1. 			msg(""Warning: cou",Not Useful
/** Finish after backup_start() and backup_release()*/,"-10. 	const char *dst_name = default_buffer_pool_file;
-9. 	if (!opt_galera_info) {
-8. 		dir_length = dirname_length(buffer_pool_filename);
-7. 		dst_name = buffer_pool_filename + dir_length;
-6. 	}
-5. 	if (length) {
-4. 		*length=dir_length;
-3. 	}
-2.",Not Useful
/*copy only non-innodb files*/,"-4. 	if (xtrabackup_incremental) {
-3. 		ds_data = ds_create(xtrabackup_target_dir, DS_TYPE_LOCAL);
-2. 		it = datadir_iter_new(xtrabackup_incremental_dir);
-1. 		while (datadir_iter_next(it, &node)) {

/*copy only non-innodb files*/

1. 			if (node.is_em",Not Useful
/*copy supplementary files*/,"-9. 		if (innobase_buffer_pool_filename) {
-8. 			const char *src_name = get_buffer_pool_filename(NULL);
-7. 			snprintf(path, sizeof(path), ""%s/%s"",
-6. 				xtrabackup_incremental_dir,
-5. 				src_name);
-4. 			if (file_exists(path)) {
-3. 				copy_file(",Not Useful
/*copy undo tablespaces*/,"-9. 	if (!innobase_data_file_path) {
-8.   		innobase_data_file_path = (char*) ""ibdata1:10M:autoextend"";
-7. 	}
-6. 	srv_sys_space.set_path(""."");
-5. 	if (!srv_sys_space.parse_params(innobase_data_file_path, true)) {
-4. 		msg(""syntax error in innodb_data",Not Useful
/*copy innodb system tablespace(s)*/,"-6. 	ds_data = ds_create(dst_dir, DS_TYPE_LOCAL);
-5. 	if (!(ret = copy_or_move_file(LOG_FILE_NAME, LOG_FILE_NAME,
-4. 				      dst_dir, 1))) {
-3. 		goto cleanup;
-2. 	}
-1. 	ds_destroy(ds_data);

/*copy innodb system tablespace(s)*/

1. 	dst_dir = (inn",Not Useful
/*copy the rest of tablespaces*/,"-10. 	     end(srv_sys_space.end());
-9. 	     iter != end;
-8. 	     ++iter) {
-7. 		const char *filepath = iter->filepath();
-6. 		if (!(ret = copy_or_move_file(base_name(filepath), filepath,
-5. 					      dst_dir, 1))) {
-4. 			goto cleanup;
-3. 		}
-",Not Useful
/*skip .qp files*/,"-10. 				my_strerror(errbuf, sizeof(errbuf), my_errno);
-9. 				msg(""Can not create directory %s: %s"",
-8. 					path, errbuf);
-7. 				ret = false;
-6. 				goto cleanup;
-5. 			}
-4. 			msg("" ...done."");
-3. 			continue;
-2. 		}
-1. 		filename = base_name",Not Useful
/*skip undo tablespaces*/,"-3. 		if (filename_matches(filename, ext_list)) {
-2. 			continue;
-1. 		}

/*skip undo tablespaces*/

1. 		if (sscanf(filename, ""undo%d%c"", &i_tmp, &c_tmp) == 1) {
2. 			continue;
3. 		}",Not Useful
/*copy the rest of tablespaces*/,"-10. 	     end(srv_sys_space.end());
-9. 	     iter != end;
-8. 	     ++iter) {
-7. 		const char *filepath = iter->filepath();
-6. 		if (!(ret = copy_or_move_file(base_name(filepath), filepath,
-5. 					      dst_dir, 1))) {
-4. 			goto cleanup;
-3. 		}
-",Not Useful
/*cexcept interface*/,"-10. #include ""png.h""
-9. #include ""pngfile.h""
-8. #include ""cexcept.h""
-7. define_exception_type(const char *);
-6. extern struct exception_context the_exception_context[1];
-5. struct exception_context the_exception_context[1];
-4. png_const_charp msg;
",Not Useful
/*and we're done*/,"-1.         png_read_end(png_ptr, NULL);

/*and we're done*/

1.         free (ppbRowPointers);
2.         ppbRowPointers = NULL;",Not Useful
"/*yepp, done*/","-2.         free (ppbRowPointers);
-1.         ppbRowPointers = NULL;

/*yepp, done*/

1.     }
2.     Catch (msg)
3.     {
4.         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
5.         *ppbImageData = pbImageData = NULL;
6.         if(ppbRowP",Not Useful
/*and we're done*/,"-1.         png_read_end(png_ptr, NULL);

/*and we're done*/

1.         free (ppbRowPointers);
2.         ppbRowPointers = NULL;",Not Useful
"/*yepp, done*/","-2.         free (ppbRowPointers);
-1.         ppbRowPointers = NULL;

/*yepp, done*/

1.     }
2.     Catch (msg)
3.     {
4.         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
5.         *ppbImageData = pbImageData = NULL;
6.         if(ppbRowP",Not Useful
/*SIMPLIFIED_WRITE_STDIO*/,"-10.  * Last changed in libpng 1.6.32 [August 24, 2017]
-9.  * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
-8.  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
-7.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Grou",Not Useful
/*safe-to-copy overrides everything*/,#NAME?,Not Useful
/*WRITE_UNKNOWN_CHUNKS*/,"-1. #ifdef PNG_WRITE_SUPPORTED
#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED

/*WRITE_UNKNOWN_CHUNKS*/

111",Not Useful
/*sCAL*/,"-10.    if ((info_ptr->valid & PNG_INFO_oFFs) != 0)
-9.       png_write_oFFs(png_ptr, info_ptr->x_offset, info_ptr->y_offset,
-8.           info_ptr->offset_unit_type);
-7. #endif
-6. #ifdef PNG_WRITE_pCAL_SUPPORTED
-5.    if ((info_ptr->valid & PNG_INFO_",Not Useful
/*pHYs*/,"
#ifdef PNG_WRITE_pHYs_SUPPORTED



/*pHYs*/

1.    if ((info_ptr->valid & PNG_INFO_pHYs) != 0)
2.       png_write_pHYs(png_ptr, info_ptr->x_pixels_per_unit,
3.           info_ptr->y_pixels_per_unit, info_ptr->phys_unit_type);",Not Useful
/*tIME*/,"
#ifdef PNG_WRITE_tIME_SUPPORTED



/*tIME*/

1.    if ((info_ptr->valid & PNG_INFO_tIME) != 0)
2.    {
3.       png_write_tIME(png_ptr, &(info_ptr->mod_time));
4.       png_ptr->mode |= PNG_WROTE_tIME;
5.    }",Not Useful
/*sPLT*/,"-10. #endif
-9. #ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
-8.          write_unknown_chunks(png_ptr, info_ptr, PNG_HAVE_IHDR);
-7. #endif
-6.       png_ptr->mode |= PNG_WROTE_INFO_BEFORE_PLTE;
-5.    }
-4. }
-3. void PNGAPI
-2. png_write_info(png_structrp",Not Useful
/*An internationalized chunk?*/,"-4.    for (i = 0; i < info_ptr->num_text; i++)
-3.    {
-2.       png_debug2(2, ""Writing header text chunk %d, type %d"", i,
-1.           info_ptr->text[i].compression);

/*An internationalized chunk?*/

1.       if (info_ptr->text[i].compression > 0)
2.",Not Useful
/*tEXt*/,"-7.          info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
-6. #else
-5.          png_warning(png_ptr, ""Unable to write compressed text"");
-4. #endif
-3.       }
-2.       else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE",Not Useful
/*An internationalized chunk?*/,"-4.    for (i = 0; i < info_ptr->num_text; i++)
-3.    {
-2.       png_debug2(2, ""Writing header text chunk %d, type %d"", i,
-1.           info_ptr->text[i].compression);

/*An internationalized chunk?*/

1.       if (info_ptr->text[i].compression > 0)
2.",Not Useful
/*pass variables*/,"-4. void PNGAPI
-3. png_write_image(png_structrp png_ptr, png_bytepp image)
-2. {

/*pass variables*/

111",Not Useful
/*Loop through passes*/,"-4.    num_pass = png_set_interlace_handling(png_ptr);
-3. #else
-2.    num_pass = 1;
-1. #endif

/*Loop through passes*/

1.    for (pass = 0; pass < num_pass; pass++)
2.    {",Not Useful
/*WRITE_16BIT*/,"-10.          else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-9.             bytes_per_pixel = 4;
-8.          else
-7.             return;
-6.          for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
-5.          {
-4.       ",Not Useful
/*MNG_FEATURES*/,"-1.       png_write_sig(png_ptr);
#ifdef PNG_MNG_FEATURES_SUPPORTED

/*MNG_FEATURES*/

1.       if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) != 0 && \
2.           png_ptr->mng_features_permitted != 0)
3.       {
4.          png_warning(png_ptr,
5.       ",Not Useful
"/*At this point the row_info pixel depth must match the 'transformed' depth,
    * which is also the output depth.*/","-3.    if (png_ptr->transformations != 0)
-2.       png_do_write_transformations(png_ptr, &row_info);
-1. #endif
   /* At this point the row_info pixel depth must match the 'transformed' depth,
    * which is also the output depth.

/*At this point the ro",Not Useful
/*WRITE_FLUSH*/,"-5.    png_write_IEND(png_ptr);
-4.    /* This flush, added in libpng-1.0.8, removed from libpng-1.0.9beta03,
-3.     * and restored again in libpng-1.2.30, may cause some applications that
-2.     * do not set png_ptr->output_flush_fn to crash.  If your ",Not Useful
/*WRITE_FILTER*/,"-3.    png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list);
-2.    png_free(png_ptr, png_ptr->row_buf);
-1.    png_ptr->row_buf = NULL;
#ifdef PNG_WRITE_FILTER_SUPPORTED

/*WRITE_FILTER*/

1.    png_free(png_ptr, png_ptr->prev_row);
2.    png_free(png_p",Not Useful
/*FALLTHROUGH*/,"-10. #endif
-9.    if (method == PNG_FILTER_TYPE_BASE)
-8.    {
-7.       switch (filters & (PNG_ALL_FILTERS | 0x07))
-6.       {
-5. #ifdef PNG_WRITE_FILTER_SUPPORTED
-4.          case 5:
-3.          case 6:
-2.          case 7: png_app_error(png_ptr, """,Not Useful
/*WRITE_FILTER*/,"-3.    png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list);
-2.    png_free(png_ptr, png_ptr->row_buf);
-1.    png_ptr->row_buf = NULL;
#ifdef PNG_WRITE_FILTER_SUPPORTED

/*WRITE_FILTER*/

1.    png_free(png_ptr, png_ptr->prev_row);
2.    png_free(png_p",Not Useful
/*DEPRECATED*/,"-10.                png_ptr->tst_row = png_voidcast(png_bytep,
-9.                    png_malloc(png_ptr, buf_size));
-8.          }
-7.       }
-6.       png_ptr->do_filter = (png_byte)filters;
-5. #endif
-4.    }
-3.    else
-2.       png_error(png_ptr,",Not Useful
/*FLOATING_POINT*/,"
#ifdef PNG_FLOATING_POINT_SUPPORTED



/*FLOATING_POINT*/

1. void PNGAPI
2. png_set_filter_heuristics(png_structrp png_ptr, int heuristic_method,
3.     int num_weights, png_const_doublep filter_weights,
4.     png_const_doublep filter_costs)
5. {
6.    PNG_UNUSED(png_ptr)
7.    PNG_UNUSED(heuristic_method)
8.    PNG_UNUSED(num_weights)
9.    PNG_UNUSED(filter_weights)
10.    PNG_UNUSED(filter_costs)",Not Useful
/*FIXED_POINT*/,"
#ifdef PNG_FIXED_POINT_SUPPORTED



/*FIXED_POINT*/

1. void PNGAPI
2. png_set_filter_heuristics_fixed(png_structrp png_ptr, int heuristic_method,
3.     int num_weights, png_const_fixed_point_p filter_weights,
4.     png_const_fixed_point_p filter_costs)
5. {
6.    PNG_UNUSED(png_ptr)
7.    PNG_UNUSED(heuristic_method)
8.    PNG_UNUSED(num_weights)
9.    PNG_UNUSED(filter_weights)
10.    PNG_UNUSED(filter_costs)",Not Useful
/*WRITE_WEIGHTED_FILTER*/,"-10.                png_ptr->tst_row = png_voidcast(png_bytep,
-9.                    png_malloc(png_ptr, buf_size));
-8.          }
-7.       }
-6.       png_ptr->do_filter = (png_byte)filters;
-5. #endif
-4.    }
-3.    else
-2.       png_error(png_ptr,",Not Useful
/*The flag setting here prevents the libpng dynamic selection of strategy.*/,"-10.    if (png_ptr == NULL)
-9.       return;
-8.    png_ptr->zlib_mem_level = mem_level;
-7. }
-6. void PNGAPI
-5. png_set_compression_strategy(png_structrp png_ptr, int strategy)
-4. {
-3.    png_debug(1, ""in png_set_compression_strategy"");
-2.    if (",Not Useful
/*Arguments to png_image_write_main:*/,"-6.          png_destroy_info_struct(png_ptr, &info_ptr);
-5.       }
-4.       png_destroy_write_struct(&png_ptr, NULL);
-3.    }
-2.    return png_image_error(image, ""png_image_write_: out of memory"");
-1. }

/*Arguments to png_image_write_main:*/

1. t",Not Useful
/*Arguments:*/,"-2. typedef struct
-1. {

/*Arguments:*/

1.    png_imagep      image;
2.    png_const_voidp buffer;
3.    png_int_32      row_stride;
4.    png_const_voidp colormap;
5.    int             convert_to_8bit;",Not Useful
/*Local variables:*/,"-5.    png_imagep      image;
-4.    png_const_voidp buffer;
-3.    png_int_32      row_stride;
-2.    png_const_voidp colormap;
-1.    int             convert_to_8bit;

/*Local variables:*/

1.    png_const_voidp first_row;
2.    ptrdiff_t       row_byte",Not Useful
/*Use row_end in place of a loop counter:*/,"-5.          ++output_row;
-4.       }
-3.       else
-2. #   endif
-1.       aindex = (int)channels;

/*Use row_end in place of a loop counter:*/

1.       row_end = output_row + image->width * (channels+1);
2.       for (; y > 0; --y)
3.       {
4.     ",Not Useful
/*while out_ptr < row_end*/,"-2.             ++in_ptr;
-1.             ++out_ptr;

/*while out_ptr < row_end*/

1.          png_write_row(png_ptr, png_voidcast(png_const_bytep,
2.              display->local_row));
3.          input_row += (png_uint_16)display->row_bytes/(sizeof (png",Not Useful
/*no alpha*/,"-4.       if ((format & PNG_FORMAT_FLAG_LINEAR) != 0)
-3.       {
-2.          png_const_uint_16p entry = png_voidcast(png_const_uint_16p, cmap);
-1.          entry += (unsigned int)i * channels;

/*no alpha*/

1.          {",Not Useful
/*RGB*/,"-10.        */
-9. #ifdef PNG_GAMMA_SUPPORTED
-8. #  ifdef PNG_WRITE_gAMA_SUPPORTED
-7.       if ((info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) == 0 &&
-6.           (info_ptr->colorspace.flags & PNG_COLORSPACE_FROM_gAMA) != 0 &&
-5.           (in",Not Useful
/*Gray*/,"-8.             {
-7.                palette[i].blue = (png_byte)PNG_sRGB_FROM_LINEAR(255 *
-6.                    entry[(2 ^ bgr)]);
-5.                palette[i].green = (png_byte)PNG_sRGB_FROM_LINEAR(255 *
-4.                    entry[1]);
-3.         ",Not Useful
/*alpha*/,"-10.    png_write_info_before_PLTE(png_ptr, info_ptr);
-9.    if ((info_ptr->valid & PNG_INFO_PLTE) != 0)
-8.       png_write_PLTE(png_ptr, info_ptr->palette,
-7.           (png_uint_32)info_ptr->num_palette);
-6.    else if (info_ptr->color_type == PNG_C",Not Useful
/*RGB*/,"-10.        */
-9. #ifdef PNG_GAMMA_SUPPORTED
-8. #  ifdef PNG_WRITE_gAMA_SUPPORTED
-7.       if ((info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) == 0 &&
-6.           (info_ptr->colorspace.flags & PNG_COLORSPACE_FROM_gAMA) != 0 &&
-5.           (in",Not Useful
/*gray*/,"-8.             {
-7.                palette[i].blue = png_unpremultiply(entry[afirst + (2 ^ bgr)],
-6.                    alpha, reciprocal);
-5.                palette[i].green = png_unpremultiply(entry[afirst + 1], alpha,
-4.                    recipro",Not Useful
/*FALLTHROUGH*/,"-10. #endif
-9.    if (method == PNG_FILTER_TYPE_BASE)
-8.    {
-7.       switch (filters & (PNG_ALL_FILTERS | 0x07))
-6.       {
-5. #ifdef PNG_WRITE_FILTER_SUPPORTED
-4.          case 5:
-3.          case 6:
-2.          case 7: png_app_error(png_ptr, """,Not Useful
/*FALLTHROUGH*/,"-10. #endif
-9.    if (method == PNG_FILTER_TYPE_BASE)
-8.    {
-7.       switch (filters & (PNG_ALL_FILTERS | 0x07))
-6.       {
-5. #ifdef PNG_WRITE_FILTER_SUPPORTED
-4.          case 5:
-3.          case 6:
-2.          case 7: png_app_error(png_ptr, """,Not Useful
/*The following four ints are actually booleans*/,"-10. }
-9. static int
-8. png_image_write_main(png_voidp argument)
-7. {
-6.    png_image_write_control *display = png_voidcast(png_image_write_control*,
-5.        argument);
-4.    png_imagep image = display->image;
-3.    png_structrp png_ptr = image->",Not Useful
/*SAFE*/,"-4.       {
-3.          png_uint_32 check;
-2.          const png_uint_32 png_row_stride = image->width * channels;
-1.          if (display->row_stride == 0)

/*SAFE*/

1.          if (display->row_stride < 0)
2.             check = (png_uint_32)(-displ",Not Useful
/*white*/,"-4.       png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_LINEAR);
-3.       if ((image->flags & PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB) == 0)
-2.          png_set_cHRM_fixed(png_ptr, info_ptr,

/*white*/

111",Not Useful
/*red*/,"-10.    int i;
-9. #endif
-8.    png_debug(1, ""in png_write_info"");
-7.    if (png_ptr == NULL || info_ptr == NULL)
-6.       return;
-5.    png_write_info_before_PLTE(png_ptr, info_ptr);
-4.    if ((info_ptr->valid & PNG_INFO_PLTE) != 0)
-3.       png_wr",Not Useful
/*green*/,"-3.             {
-2.                palette[i].blue = (png_byte)PNG_sRGB_FROM_LINEAR(255 *
-1.                    entry[(2 ^ bgr)]);
               palette[i].green = (png_byte)PNG_sRGB_FROM_LINEAR(255 *

/*green*/

1.                    entry[1]);
2.   ",Not Useful
/*blue*/,"-10.          else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-9.             bytes_per_pixel = 8;
-8.          else
-7.             return;
-6.          for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
-5.          {
-4.       ",Not Useful
/*const*/,"-1. static void
write_unknown_chunks(png_structrp png_ptr, png_const_inforp info_ptr,

/*const*/

1.     unsigned int where)
2. {
3.    if (info_ptr->unknown_chunks_num != 0)
4.    {
5.       png_const_unknown_chunkp up;
6.       png_debug(5, ""writing ext",Not Useful
/*backdoor: png_get_io_ptr(png_ptr)*/,"-3.     png_size_t size)
-2. {
-1.    png_image_write_control *display = png_voidcast(png_image_write_control*,

/*backdoor: png_get_io_ptr(png_ptr)*/

1.    const png_alloc_size_t ob = display->output_bytes;",Not Useful
/*io_ptr*/,"-3.     png_size_t size)
-2. {
-1.    png_image_write_control *display = png_voidcast(png_image_write_control*,

/*io_ptr*/

1.    const png_alloc_size_t ob = display->output_bytes;",Not Useful
/*from fflush/fclose*/,"-10.    if (image != NULL && image->version == PNG_IMAGE_VERSION)
-9.    {
-8.       if (file_name != NULL && buffer != NULL)
-7.       {
-6.          FILE *fp = fopen(file_name, ""wb"");
-5.          if (fp != NULL)
-4.          {
-3.             if (png_i",Not Useful
/*Make sure the file is flushed correctly.*/,"-10.    {
-9.       if (file_name != NULL && buffer != NULL)
-8.       {
-7.          FILE *fp = fopen(file_name, ""wb"");
-6.          if (fp != NULL)
-5.          {
-4.             if (png_image_write_to_stdio(image, fp, convert_to_8bit, buffer,
-3.      ",Not Useful
/*Clean up: just the opened file.*/,"-4.                return png_image_error(image, strerror(error));
-3.             }
-2.             else
-1.             {

/*Clean up: just the opened file.*/

1.                (void)fclose(fp);
2.                (void)remove(file_name);
3.            ",Not Useful
/*SIMPLIFIED_WRITE_STDIO*/,"-10.  * Last changed in libpng 1.6.32 [August 24, 2017]
-9.  * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
-8.  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
-7.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Grou",Not Useful
/*SIMPLIFIED_WRITE*/,"-10.  * Last changed in libpng 1.6.32 [August 24, 2017]
-9.  * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
-8.  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
-7.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Grou",Not Useful
/*need getche()*/,"-2. #  ifdef __EMX__
-1. #    ifndef getch

/*need getche()*/

1. #    endif",Not Useful
/*!__EMX__*/,"-1. #    endif

/*!__EMX__*/

1. #    ifdef __GO32__
2. #      include <pc.h>",Not Useful
/*GRR:  need getche()*/,"-2. #    ifdef __GO32__
-1. #      include <pc.h>

/*GRR:  need getche()*/

1. #    else",Not Useful
/*?__EMX__*/,"-1. #    endif

/*?__EMX__*/

1. #  define FGETS(buf,len,stream)  dos_kbd_gets(buf,len)
2. #else",Not Useful
/*local prototypes*/,"-7. #  define FGETS fgets
-6. #endif

/*local prototypes*/

1. static int  wpng_isvalid_latin1(uch *p, int len);
2. static void wpng_cleanup(void);
3. #ifdef DOS_OS2_W32
4.    static char *dos_kbd_gets(char *buf, int len);
5. #endif",Not Useful
"/*or we could just use keybd, since no overlap*/","-6. int main(int argc, char **argv)
-5. {
-4. #ifndef DOS_OS2_W32
-3.     FILE *keybd;
-2. #endif
-1. #ifdef sgi

/*or we could just use keybd, since no overlap*/

1.     char tmpline[80];
2. #endif
3.     char *inname = NULL, outname[256];
4.     char *p",Not Useful
/*just the lookup table*/,"-10.     char tmpline[80];
-9. #endif
-8.     char *inname = NULL, outname[256];
-7.     char *p, pnmchar, pnmline[256];
-6.     char *bgstr, *textbuf = NULL;
-5.     ulg rowbytes;
-4.     int rc, len = 0;
-3.     int error = 0;
-2.     int text = FALSE;
",Not Useful
/*just the monitor*/,"-10. #endif
-9.     char *inname = NULL, outname[256];
-8.     char *p, pnmchar, pnmline[256];
-7.     char *bgstr, *textbuf = NULL;
-6.     ulg rowbytes;
-5.     int rc, len = 0;
-4.     int error = 0;
-3.     int text = FALSE;
-2.     int maxval;

/*jus",Not Useful
/*assume no LUT:  most PCs*/,"-1. #else

/*assume no LUT:  most PCs*/

1. #endif",Not Useful
/*shouldn't be any more args after filename*/,"-10.                     sscanf(bgstr+1, ""%2x%2x%2x"", &r, &g, &b);
-9.                     wpng_info.bg_red   = (uch)r;
-8.                     wpng_info.bg_green = (uch)g;
-7.                     wpng_info.bg_blue  = (uch)b;
-6.                     wpng_",Not Useful
/*not expecting any other options*/,"-2.                     ++error;
-1.             } else

/*not expecting any other options*/

1.         }
2.     }",Not Useful
/*<==> maxval 255*/,"-9.             } while (pnmline[0] == '#');
-8.             sscanf(pnmline, ""%d"", &maxval);
-7.             if (wpng_info.width <= 0L || wpng_info.height <= 0L ||
-6.                 maxval != 255)
-5.             {
-4.                 fprintf(stderr, PR",Not Useful
"/*OK, we're done (successfully):  clean up all resources and quit*/","-10.             wpng_cleanup();
-9.             exit(2);
-8.         }
-7.         if (writepng_encode_finish(&wpng_info) != 0) {
-6.             fprintf(stderr, PROGNAME "":  error on final libpng call\n"");
-5.             writepng_cleanup(&wpng_info);
-",Not Useful
/*Enter key does *not* cause a newline*/,"-1.         buf[count] = '\n';

/*Enter key does *not* cause a newline*/

1.     fflush(stderr);
2.     return buf;
3. }",Not Useful
/*DOS_OS2_W32*/,"---*/
-4. #define PROGNAME  ""wpng""
-3. #define VERSION   ""2.00 of 2 June 2007""
-2. #define APPNAME   ""Simple PGM/PPM/PAM to PNG Converter""
-1. #if defined(__MSDOS__) || defined(__OS2__)
#  define DOS_OS2_W32

/*DOS_OS2_W32*/

1. #elif defined(WIN32) || de",Not Useful
"/*READ_PNG and WRITE_PNG were not defined, so:*/","-6. #ifdef PNG_FREESTANDING_TESTS
-5. #  include <png.h>
-4. #else
-3. #  include ""../../png.h""
-2. #endif
-1. #if PNG_LIBPNG_VER < 10700

/*READ_PNG and WRITE_PNG were not defined, so:*/

1. #  ifdef PNG_INFO_IMAGE_SUPPORTED
2. #     ifdef PNG_SEQUENTIAL",Not Useful
/*SEQUENTIAL_READ*/,"-1. #  ifdef PNG_INFO_IMAGE_SUPPORTED
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED

/*SEQUENTIAL_READ*/

1. #        define PNG_READ_PNG_SUPPORTED",Not Useful
/*pre 1.7.0*/,"-4. #     ifdef PNG_WRITE_SUPPORTED
-3. #        define PNG_WRITE_PNG_SUPPORTED

/*pre 1.7.0*/

1. #if (defined(PNG_READ_PNG_SUPPORTED)) && (defined(PNG_WRITE_PNG_SUPPORTED))
2. #include <stdarg.h>
3. #include <stdlib.h>
4. #include <string.h>
5. #include",Not Useful
/*__cplusplus*/,"-1. #endif
#ifdef __cplusplus

/*__cplusplus*/

1. #  define voidcast(type, value) static_cast<type>(value)
2. #else
3. #  define voidcast(type, value) (value)",Not Useful
/*Prevent inclusion of the spurious code:*/,"-1. #  ifndef CLOCK_PROCESS_CPUTIME_ID

/*Prevent inclusion of the spurious code:*/

1. #     undef PNG_PNGCP_TIMING_SUPPORTED
2. #  endif",Not Useful
/*PNGCP_TIMING*/,"
#ifdef PNG_PNGCP_TIMING_SUPPORTED



/*PNGCP_TIMING*/

1.    /* WARNING:
2.     *
3.     * This test is here to allow POSIX.1b extensions to be used if enabled in
4.     * the compile; specifically the code requires_POSIX_C_SOURCE support of
5.     * 199309L or later to enable clock_gettime use.
6.     *
7.     * IF this causes problems THEN compile with a strict ANSI C compiler and let
8.     * this code turn on the POSIX features that it minimally requires.
9.     *
10.     * IF this does not work there is probably a bug in your ANSI C compiler or",Not Useful
/*such as out-of-memory in a callback*/,"-6.    LIBPNG_WARNING,
-5.    APP_WARNING,

/*such as out-of-memory in a callback*/

111",Not Useful
/*such as file-not-found*/,"-8.    LIBPNG_WARNING,
-7.    APP_WARNING,

/*such as file-not-found*/

1.    INTERNAL_ERROR
2. } error_level;",Not Useful
/*CHECK_FOR_INVALID_INDEX*/,"-9.    INTERNAL_ERROR
-8. } error_level;

/*CHECK_FOR_INVALID_INDEX*/

111",Not Useful
/*SW_COMPRESS_png_level*/,"-2. }  value_list;
-1. static const value_list
#ifdef PNG_SW_COMPRESS_png_level

/*SW_COMPRESS_png_level*/

1. vl_compression[] =
2. {",Not Useful
/*from zlib*/,"-7.    { ""filtered"", Z_FILTERED },
-6.    { ""default"", Z_DEFAULT_STRATEGY },
-5.    { all, 0 }
-4. },
-3. #ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
-2. vl_windowBits_text[] =
-1. {

/*from zlib*/

1.    { ""minimum"", 8 },",Not Useful
/*from zlib*/,"-7.    { ""filtered"", Z_FILTERED },
-6.    { ""default"", Z_DEFAULT_STRATEGY },
-5.    { all, 0 }
-4. },
-3. #ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
-2. vl_windowBits_text[] =
-1. {

/*from zlib*/

1.    { ""minimum"", 8 },",Not Useful
/*this is -1*/,"-2. vl_level[] =
-1. {

/*this is -1*/

1.    { ""none"", Z_NO_COMPRESSION },
2.    { ""speed"", Z_BEST_SPEED },
3.    { ""best"", Z_BEST_COMPRESSION },
4.    { ""0"", Z_NO_COMPRESSION },",Not Useful
/*zlib*/,"-9. #if (defined(PNG_READ_PNG_SUPPORTED)) && (defined(PNG_WRITE_PNG_SUPPORTED))
-8. #include <stdarg.h>
-7. #include <stdlib.h>
-6. #include <string.h>
-5. #include <errno.h>
-4. #include <limits.h>
-3. #include <assert.h>
-2. #include <unistd.h>
-1. #inc",Not Useful
/*WRITE_FILTER*/,"
#ifdef PNG_WRITE_FILTER_SUPPORTED



/*WRITE_FILTER*/

1. vl_filter[] =
2. {
3.    { all,      PNG_ALL_FILTERS   },
4.    { ""off"",    PNG_NO_FILTERS    },
5.    { ""none"",   PNG_FILTER_NONE   },
6.    { ""sub"",    PNG_FILTER_SUB    },
7.    { ""up"",     PNG_FILTER_UP     },
8.    { ""avg"",    PNG_FILTER_AVG    },
9.    { ""paeth"",  PNG_FILTER_PAETH  }
10. },",Not Useful
/*PNGCP_TIMING*/,"
#ifdef PNG_PNGCP_TIMING_SUPPORTED



/*PNGCP_TIMING*/

1.    /* WARNING:
2.     *
3.     * This test is here to allow POSIX.1b extensions to be used if enabled in
4.     * the compile; specifically the code requires_POSIX_C_SOURCE support of
5.     * 199309L or later to enable clock_gettime use.
6.     *
7.     * IF this causes problems THEN compile with a strict ANSI C compiler and let
8.     * this code turn on the POSIX features that it minimally requires.
9.     *
10.     * IF this does not work there is probably a bug in your ANSI C compiler or",Not Useful
/*Pre 1.7 API:*/,"-6. {
-5.    { ""default"", 0x7FFFFFFF },
-4.    { ""minimal"", 1 },
-3.    RANGE(1, 0x7FFFFFFF)
-2. },
-1. #ifndef PNG_SW_IDAT_size

/*Pre 1.7 API:*/

1. #  define png_set_IDAT_size(p,v) png_set_compression_buffer_size(p, v)",Not Useful
/*IGNORE_INDEX*/,"-10.    INTERNAL_ERROR
-9. } error_level;

/*IGNORE_INDEX*/

1. #  ifdef PNG_GET_PALETTE_MAX_SUPPORTED",Not Useful
/*FIX_INDEX*/,"-10. #define LEVEL_MASK      0xf   /* where the level is in 'options' */
-9. #define STRICT          0x010 /* Fail on warnings as well as errors */
-8. #define LOG             0x020 /* Log pass/fail to stdout */
-7. #define CONTINUE        0x040 /* Contin",Not Useful
/*SW_COMPRESS_png_level*/,"-2. }  value_list;
-1. static const value_list
#ifdef PNG_SW_COMPRESS_png_level

/*SW_COMPRESS_png_level*/

1. vl_compression[] =
2. {",Not Useful
/*sic*/,"-3.    VLC(strategy)
-2.    VLO(""windowBits"", windowBits_IDAT, 1)
-1. #  ifdef PNG_SW_COMPRESS_windowBits

/*sic*/

1. #  endif
2.    VLO(""text-windowBits"", windowBits_text, 0)
3.    VLC(level)
4.    VLC(memLevel)
5.    VLO(""IDAT-size"", IDAT_size, 0)
6.  ",Not Useful
/*WRITE_FILTER*/,"
#ifdef PNG_WRITE_FILTER_SUPPORTED



/*WRITE_FILTER*/

1. vl_filter[] =
2. {
3.    { all,      PNG_ALL_FILTERS   },
4.    { ""off"",    PNG_NO_FILTERS    },
5.    { ""none"",   PNG_FILTER_NONE   },
6.    { ""sub"",    PNG_FILTER_SUB    },
7.    { ""up"",     PNG_FILTER_UP     },
8.    { ""avg"",    PNG_FILTER_AVG    },
9.    { ""paeth"",  PNG_FILTER_PAETH  }
10. },",Not Useful
/*PNGCP_TIMING*/,"
#ifdef PNG_PNGCP_TIMING_SUPPORTED



/*PNGCP_TIMING*/

1.    /* WARNING:
2.     *
3.     * This test is here to allow POSIX.1b extensions to be used if enabled in
4.     * the compile; specifically the code requires_POSIX_C_SOURCE support of
5.     * 199309L or later to enable clock_gettime use.
6.     *
7.     * IF this causes problems THEN compile with a strict ANSI C compiler and let
8.     * this code turn on the POSIX features that it minimally requires.
9.     *
10.     * IF this does not work there is probably a bug in your ANSI C compiler or",Not Useful
/*!__cplusplus*/,"-5. #  undef VLL
-4. #  undef VL
-3. };
-2. #ifdef __cplusplus
-1.    static const size_t option_count((sizeof options)/(sizeof options[0]));

/*!__cplusplus*/

1. #  define option_count ((sizeof options)/(sizeof options[0]))",Not Useful
/*!__cplusplus*/,"-5. #  undef VLL
-4. #  undef VL
-3. };
-2. #ifdef __cplusplus
-1.    static const size_t option_count((sizeof options)/(sizeof options[0]));

/*!__cplusplus*/

1. #  define option_count ((sizeof options)/(sizeof options[0]))",Not Useful
/*pre 1.7*/,"-4. #     ifdef PNG_WRITE_SUPPORTED
-3. #        define PNG_WRITE_PNG_SUPPORTED

/*pre 1.7*/

1. #if (defined(PNG_READ_PNG_SUPPORTED)) && (defined(PNG_WRITE_PNG_SUPPORTED))
2. #include <stdarg.h>
3. #include <stdlib.h>
4. #include <string.h>
5. #include <",Not Useful
/*PNGCP_TIMING*/,"
#ifdef PNG_PNGCP_TIMING_SUPPORTED



/*PNGCP_TIMING*/

1.    /* WARNING:
2.     *
3.     * This test is here to allow POSIX.1b extensions to be used if enabled in
4.     * the compile; specifically the code requires_POSIX_C_SOURCE support of
5.     * 199309L or later to enable clock_gettime use.
6.     *
7.     * IF this causes problems THEN compile with a strict ANSI C compiler and let
8.     * this code turn on the POSIX features that it minimally requires.
9.     *
10.     * IF this does not work there is probably a bug in your ANSI C compiler or",Not Useful
/*See display_log below*/,"-9.    png_alloc_size_t size;
-8.    png_uint_32      w;
-7.    png_uint_32      h;
-6.    int              bpp;
-5.    png_byte         ct;

/*See display_log below*/

111",Not Useful
/*highest active entry+1 found so far*/,"-10.    png_uint_32      options;             /* See display_log below */
-9.    png_byte         entry[option_count]; /* The selected entry+1 of an option
-8.                                           * that appears on the command line, or
-7.           ",Not Useful
/*best options*/,"-10.       png_alloc_size_t lo_size;
-9.       png_alloc_size_t hi_size;

/*best options*/

111",Not Useful
"/*this is an OPTIND, so -1 won't match anything*/","-4.    dp->fp = NULL;
-3.    dp->read_pp = NULL;
-2.    dp->ip = NULL;
-1.    dp->write_pp = NULL;

/*this is an OPTIND, so -1 won't match anything*/

1. #  if PNG_LIBPNG_VER < 10700 && defined PNG_TEXT_SUPPORTED
2.       dp->text_ptr = NULL;
3.       dp-",Not Useful
/*pre 1.7*/,"-4. #     ifdef PNG_WRITE_SUPPORTED
-3. #        define PNG_WRITE_PNG_SUPPORTED

/*pre 1.7*/

1. #if (defined(PNG_READ_PNG_SUPPORTED)) && (defined(PNG_WRITE_PNG_SUPPORTED))
2. #include <stdarg.h>
3. #include <stdlib.h>
4. #include <string.h>
5. #include <",Not Useful
/*pre 1.7*/,"-4. #     ifdef PNG_WRITE_SUPPORTED
-3. #        define PNG_WRITE_PNG_SUPPORTED

/*pre 1.7*/

1. #if (defined(PNG_READ_PNG_SUPPORTED)) && (defined(PNG_WRITE_PNG_SUPPORTED))
2. #include <stdarg.h>
3. #include <stdlib.h>
4. #include <string.h>
5. #include <",Not Useful
/*prevents a crash*/,"-5. {
-4.    struct display *dp = (struct display*)png_get_error_ptr(pp);
-3.    if (dp == NULL)
-2.    {
-1.       fprintf(stderr, ""pngcp: internal error (no display)\n"");

/*prevents a crash*/

1.    }
2.    return dp;
3. }",Not Useful
/*pre 1.7*/,"-4. #     ifdef PNG_WRITE_SUPPORTED
-3. #        define PNG_WRITE_PNG_SUPPORTED

/*pre 1.7*/

1. #if (defined(PNG_READ_PNG_SUPPORTED)) && (defined(PNG_WRITE_PNG_SUPPORTED))
2. #include <stdarg.h>
3. #include <stdlib.h>
4. #include <string.h>
5. #include <",Not Useful
/*SAFE*/,"-1.    display_log(dp, dp->errset ? INTERNAL_ERROR : USER_ERROR,

/*SAFE*/

111",Not Useful
/*SAFE*/,"-1.    display_log(dp, dp->errset ? INTERNAL_ERROR : USER_ERROR,

/*SAFE*/

111",Not Useful
/*missing range_hi*/,"-5. }
-4. static int
-3. opt_list_end(struct display *dp, png_byte opt, png_byte entry)
-2. {
-1.    if (options[opt].values[entry].name == range_lo)

/*missing range_hi*/

111",Not Useful
/*likewise*/,"-6. }
-5. static int
-4. opt_list_end(struct display *dp, png_byte opt, png_byte entry)
-3. {
-2.    if (options[opt].values[entry].name == range_lo)

/*likewise*/

111",Not Useful
/*missing 'all'*/,"-1.    else

/*missing 'all'*/

111",Not Useful
/*only 2 entries*/,"-2.             dp->stack[sp].lo_size = best_size;
-1.             assert(hi > val);

/*only 2 entries*/

1.                dp->stack[sp].end = 1;
2.             val = hi;
3.          }
4.          else if (val == hi)
5.          {
6.             dp->stac",Not Useful
/*only three entries to test*/,"-7.                dp->stack[sp].end = 1;
-6.             val = hi;
-5.          }
-4.          else if (val == hi)
-3.          {
-2.             dp->stack[sp].hi_size = best_size;

/*only three entries to test*/

1.                dp->stack[sp].end = 1;",Not Useful
/*down from hi*/,"-10.                   }
-9.                }
-8.                /* If both those tests failed 'best_size' is either greater than
-7.                 * or less than both lo_size and hi_size.  There is a peak or dip
-6.                 * in the curve of si",Not Useful
/*up from low*/,"-5.                {
-4.                   dp->stack[sp].hi = val;
-3.                   dp->stack[sp].hi_size = best_size;
-2.                   val = --hi;
-1.                }

/*up from low*/

1.                {
2.                   dp->stack[sp].lo ",Not Useful
/*still active after all these tests*/,"-1.       dp->stack[sp].end = 1;

/*still active after all these tests*/

1.       dp->nsp = dp->tsp;
2. }
3. static int
4. compare_option(const struct display *dp, unsigned int sp)
5. {
6.    int opt = dp->stack[sp].opt;",Not Useful
/*advanced*/,"-2.    unsigned int     tsp;               /* nsp from the last run; this is the
-1.                                         * index+1 of the highest active entry on
                                        * this run; this entry will be advanced.

/*advan",Not Useful
/*all*/,"-3. #ifdef PNG_PNGCP_TIMING_SUPPORTED
-2.    /* WARNING:
-1.     *
    * This test is here to allow POSIX.1b extensions to be used if enabled in

/*all*/

1.     * the compile; specifically the code requires_POSIX_C_SOURCE support of
2.     * 199309L or l",Not Useful
/*range_lo*/,"
static const char range_lo[] = ""low"";



/*range_lo*/

1. static const char range_hi[] = ""high"";
2. static const char all[] = ""all"";
3. #define RANGE(lo,hi) { range_lo, lo }, { range_hi, hi }
4. typedef struct value_list
5. {",Not Useful
/*SAFE*/,"-1.    display_log(dp, dp->errset ? INTERNAL_ERROR : USER_ERROR,

/*SAFE*/

111",Not Useful
/*SAFE*/,"-1.    display_log(dp, dp->errset ? INTERNAL_ERROR : USER_ERROR,

/*SAFE*/

111",Not Useful
/*--no-*/,"-6. /* OPTIONS:
-5.  *
-4.  * The command handles options of the forms:
-3.  *
-2.  *    --option
-1.  *       Turn an option on (Option)
 *    --no-option

/*--no-*/

1.  *       Turn an option off (Option)
2.  *    --option=value
3.  *       Set an opti",Not Useful
/*--*/,"-2. /* Result masks apply to the result bits in the 'results' field below; these
-1.  * bits are simple 1U<<error_level.  A pass requires either nothing worse than
 * warnings (--relaxes) or nothing worse than information (--strict)

/*--*/

1.  */
2. #de",Not Useful
/*SAFE*/,"-1.    display_log(dp, dp->errset ? INTERNAL_ERROR : USER_ERROR,

/*SAFE*/

111",Not Useful
"/*skip the ','*/","-8.                while (list[++iv] != 0 && list[iv] != ',') {}
-7.                v = find_val(dp, j, list, iv);
-6.                if (negate)
-5.                   val &= ~v;
-4.                else
-3.                   val |= v;
-2.                l",Not Useful
/*i.e. off*/,"-4.    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, timer))
-3.    {
-2.       display_log(dp, APP_ERROR,
-1.             ""CLOCK_PROCESS_CPUTIME_ID: %s: timing disabled\n"", strerror(errno));

/*i.e. off*/

1.    }
2. }
3. static void
4. start_timer(struct ",Not Useful
/*!PNGCP_TIMING*/,"-10.          dp->read_time_total = tmp;
-9.       else
-8.          dp->write_time_total = tmp;
-7.    }
-6. }
-5. static void
-4. print_time(const char *what, struct timespec t)
-3. {
-2.    printf(""%s %.2lu.%.9ld"", what, (unsigned long)t.tv_sec, t.tv_n",Not Useful
/*!PNGCP_TIMING*/,"-10.          dp->read_time_total = tmp;
-9.       else
-8.          dp->write_time_total = tmp;
-7.    }
-6. }
-5. static void
-4. print_time(const char *what, struct timespec t)
-3. {
-2.    printf(""%s %.2lu.%.9ld"", what, (unsigned long)t.tv_sec, t.tv_n",Not Useful
/*stdout*/,"-4.    INTERNAL_ERROR
-3. } error_level;

/*stdout*/

111",Not Useful
"/*file (exists, can be written)*/","-3.          if (access(pathname, W_OK) != 0)
-2.             display_log(dp, USER_ERROR, ""%s: cannot be written (%s)"", pathname,
-1.                   strerror(errno));

/*file (exists, can be written)*/

1.       }",Not Useful
/*safety*/,"-10.       if (feof(dp->fp))
-9.          display_log(dp, LIBPNG_ERROR, ""PNG file truncated"");
-8.       else
-7.          display_log(dp, LIBPNG_ERROR, ""PNG file read failed (%s)"",
-6.                strerror(errno));
-5.    }
-4. }
-3. static void
-2. r",Not Useful
/*allowed*/,"-8.          {
-7.             memcpy(dp->namebuf+dsize, infile, isize+1);
-6.             if (isdir(dp, dp->namebuf))
-5.                display_log(dp, USER_ERROR, ""%s: output file is a directory"",
-4.                      dp->namebuf);
-3.          }
-",Not Useful
/*BENIGN_ERRORS*/,"-5.    display_start_read(dp, filename);
-4.    dp->read_pp = png_create_read_struct(PNG_LIBPNG_VER_STRING, dp,
-3.       display_error, display_warning);
-2.    if (dp->read_pp == NULL)
-1.       display_log(dp, LIBPNG_ERROR, ""failed to create read struc",Not Useful
"/*on, no warning*/","-2. #  ifdef FIX_INDEX
-1.       if ((dp->options & FIX_INDEX) != 0)

/*on, no warning*/

1. #     ifdef IGNORE_INDEX
2.          else",Not Useful
/*IGNORE_INDEX*/,"-10.    INTERNAL_ERROR
-9. } error_level;

/*IGNORE_INDEX*/

1. #  ifdef PNG_GET_PALETTE_MAX_SUPPORTED",Not Useful
/*FIX_INDEX*/,"-10. #define LEVEL_MASK      0xf   /* where the level is in 'options' */
-9. #define STRICT          0x010 /* Fail on warnings as well as errors */
-8. #define LOG             0x020 /* Log pass/fail to stdout */
-7. #define CONTINUE        0x040 /* Contin",Not Useful
/*DANGEROUS*/,"-1. #  ifdef IGNORE_INDEX

/*DANGEROUS*/

111",Not Useful
/*IGNORE_INDEX*/,"-10.    INTERNAL_ERROR
-9. } error_level;

/*IGNORE_INDEX*/

1. #  ifdef PNG_GET_PALETTE_MAX_SUPPORTED",Not Useful
/*HANDLE_AS_UNKNOWN*/,"-1.    png_set_read_fn(dp->read_pp, dp, read_function);
#  ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED

/*HANDLE_AS_UNKNOWN*/

111",Not Useful
/*SET_USER_LIMITS*/,"
#  ifdef PNG_SET_USER_LIMITS_SUPPORTED



/*SET_USER_LIMITS*/

111",Not Useful
/*transforms*/,"-10.  * Last changed in libpng 1.6.24 [August 4, 2016]
-9.  *
-8.  * This code is released under the libpng license.
-7.  * For conditions of distribution and use, see the disclaimer
-6.  * and license in png.h
-5.  *
-4.  * This is an example of copying ",Not Useful
/*FIX_INDEX*/,"-10. #define LEVEL_MASK      0xf   /* where the level is in 'options' */
-9. #define STRICT          0x010 /* Fail on warnings as well as errors */
-8. #define LOG             0x020 /* Log pass/fail to stdout */
-7. #define CONTINUE        0x040 /* Contin",Not Useful
/*1.7.0+*/,"-10. }
-9. static void
-8. set_compression(struct display *dp)
-7. {
-6.    int val;
-5. #  define SET(name, func) if (getallopts(dp, #name, &val))\
-4.       png_set_compression_ ## func(dp->write_pp, val);
-3.    SET_COMPRESSION
-2. #  undef SET
-1. }

",Not Useful
/*safety*/,"-10.       if (feof(dp->fp))
-9.          display_log(dp, LIBPNG_ERROR, ""PNG file truncated"");
-8.       else
-7.          display_log(dp, LIBPNG_ERROR, ""PNG file read failed (%s)"",
-6.                strerror(errno));
-5.    }
-4. }
-3. static void
-2. r",Not Useful
/*allowed*/,"-8.          {
-7.             memcpy(dp->namebuf+dsize, infile, isize+1);
-6.             if (isdir(dp, dp->namebuf))
-5.                display_log(dp, USER_ERROR, ""%s: output file is a directory"",
-4.                      dp->namebuf);
-3.          }
-",Not Useful
/*BENIGN_ERRORS*/,"-5.    display_start_read(dp, filename);
-4.    dp->read_pp = png_create_read_struct(PNG_LIBPNG_VER_STRING, dp,
-3.       display_error, display_warning);
-2.    if (dp->read_pp == NULL)
-1.       display_log(dp, LIBPNG_ERROR, ""failed to create read struc",Not Useful
/*flush*/,"-8.    display_start_write(dp, destname);
-7.    dp->write_pp = png_create_write_struct(PNG_LIBPNG_VER_STRING, dp,
-6.       display_error, display_warning);
-5.    if (dp->write_pp == NULL)
-4.       display_log(dp, LIBPNG_ERROR, ""failed to create write ",Not Useful
/*DANGEROUS*/,"-1. #  ifdef IGNORE_INDEX

/*DANGEROUS*/

111",Not Useful
/*IGNORE_INDEX*/,"-10.    INTERNAL_ERROR
-9. } error_level;

/*IGNORE_INDEX*/

1. #  ifdef PNG_GET_PALETTE_MAX_SUPPORTED",Not Useful
/*HANDLE_AS_UNKNOWN*/,"-1.    png_set_read_fn(dp->read_pp, dp, read_function);
#  ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED

/*HANDLE_AS_UNKNOWN*/

111",Not Useful
/*png_level support*/,"-7.          if (getallopts(dp, ""compression"", &val))
-6.             png_set_compression(dp->write_pp, val);
-5.          if (getallopts(dp, ""ICC-profile-compression"", &val))
-4.             png_set_ICC_profile_compression(dp->write_pp, val);
-3.        ",Not Useful
/*WRITE_FILTER*/,"
#ifdef PNG_WRITE_FILTER_SUPPORTED



/*WRITE_FILTER*/

1. vl_filter[] =
2. {
3.    { all,      PNG_ALL_FILTERS   },
4.    { ""off"",    PNG_NO_FILTERS    },
5.    { ""none"",   PNG_FILTER_NONE   },
6.    { ""sub"",    PNG_FILTER_SUB    },
7.    { ""up"",     PNG_FILTER_UP     },
8.    { ""avg"",    PNG_FILTER_AVG    },
9.    { ""paeth"",  PNG_FILTER_PAETH  }
10. },",Not Useful
/*transforms*/,"-10.  * Last changed in libpng 1.6.24 [August 4, 2016]
-9.  *
-8.  * This code is released under the libpng license.
-7.  * For conditions of distribution and use, see the disclaimer
-6.  * and license in png.h
-5.  *
-4.  * This is an example of copying ",Not Useful
/*worse*/,"-7. #  ifdef PNG_GET_PALETTE_MAX_SUPPORTED

/*worse*/

1.  * warnings (--relaxes) or nothing worse than information (--strict)
2.  */
3. #define RESULT_STRICT(r)   (((r) & ~((1U<<WARNINGS)-1)) == 0)
4. #define RESULT_RELAXED(r)  (((r) & ~((1U<<ERRORS)-1))",Not Useful
/*better*/,"-4.    if (wb == 8)
-3.       dp->min_windowBits = OPTIND(dp, windowBits);
-2. }
-1. static int
better_options(const struct display *dp)

/*better*/

1. {
2.    /* Are these options better than the best found so far?  Normally the
3.     * options are tes",Not Useful
/*But 'destname' may be a directory.*/,"-4.    if (filename != NULL && access(filename, R_OK) != 0)
-3.       display_log(dp, USER_ERROR, ""%s: invalid file name (%s)"",
-2.             filename, strerror(errno));
-1.    read_png(dp, filename);

/*But 'destname' may be a directory.*/

1.    dp->o",Not Useful
/*SAFE*/,"-1.    display_log(dp, dp->errset ? INTERNAL_ERROR : USER_ERROR,

/*SAFE*/

111",Not Useful
/*safety*/,"-10.       if (feof(dp->fp))
-9.          display_log(dp, LIBPNG_ERROR, ""PNG file truncated"");
-8.       else
-7.          display_log(dp, LIBPNG_ERROR, ""PNG file read failed (%s)"",
-6.                strerror(errno));
-5.    }
-4. }
-3. static void
-2. r",Not Useful
/*stdout*/,"-4.    INTERNAL_ERROR
-3. } error_level;

/*stdout*/

111",Not Useful
/*Loop to find the best option.*/,"-4.          tmpname = tmpbuf;
-3.       }
-2.       else

/*Loop to find the best option.*/

1.       do
2.       {
3.          write_png(dp, tmpname);",Not Useful
/*shouldn't longjmp on warnings*/,"-10.    if (ret == 0)
-9.    {
-8.       dp->errset = 1;
-7.       cp_one_file(dp, file, dest);
-6.       dp->errset = 0;
-5.       return 0;
-4.    }
-3.    else
-2.    {
-1.       dp->errset = 0;

/*shouldn't longjmp on warnings*/

1.          display_l",Not Useful
/*PNGCP_TIMING*/,"
#ifdef PNG_PNGCP_TIMING_SUPPORTED



/*PNGCP_TIMING*/

1.    /* WARNING:
2.     *
3.     * This test is here to allow POSIX.1b extensions to be used if enabled in
4.     * the compile; specifically the code requires_POSIX_C_SOURCE support of
5.     * 199309L or later to enable clock_gettime use.
6.     *
7.     * IF this causes problems THEN compile with a strict ANSI C compiler and let
8.     * this code turn on the POSIX features that it minimally requires.
9.     *
10.     * IF this does not work there is probably a bug in your ANSI C compiler or",Not Useful
/*PNGCP_TIMING*/,"
#ifdef PNG_PNGCP_TIMING_SUPPORTED



/*PNGCP_TIMING*/

1.    /* WARNING:
2.     *
3.     * This test is here to allow POSIX.1b extensions to be used if enabled in
4.     * the compile; specifically the code requires_POSIX_C_SOURCE support of
5.     * 199309L or later to enable clock_gettime use.
6.     *
7.     * IF this causes problems THEN compile with a strict ANSI C compiler and let
8.     * this code turn on the POSIX features that it minimally requires.
9.     *
10.     * IF this does not work there is probably a bug in your ANSI C compiler or",Not Useful
/*!READ_PNG || !WRITE_PNG*/,"-3.       return errors != 0;
-2.    }
-1. }

/*!READ_PNG || !WRITE_PNG*/

1. int
2. main(void)
3. {
4.    fprintf(stderr, ""pngcp: no support for png_read/write_image\n"");
5.    return 77;
6. }",Not Useful
/*!READ_PNG || !WRITE_PNG*/,"-3.       return errors != 0;
-2.    }
-1. }

/*!READ_PNG || !WRITE_PNG*/

1. int
2. main(void)
3. {
4.    fprintf(stderr, ""pngcp: no support for png_read/write_image\n"");
5.    return 77;
6. }",Not Useful
/*__cplusplus*/,"-5. #ifdef PNG_FREESTANDING_TESTS
-4. #  include <cexcept.h>
-3. #else
-2. #  include ""../visupng/cexcept.h""
-1. #endif
#ifdef __cplusplus

/*__cplusplus*/

1. #  define this not_the_cpp_this
2. #  define new not_the_cpp_new
3. #  define voidcast(type, va",Not Useful
/*!GNUC broken versions*/,"-3. #ifdef __GNUC__
-2.    const void * volatile make_volatile_for_gnu;
-1. #  define gnu_volatile(x) make_volatile_for_gnu = &x;

/*!GNUC broken versions*/

1. #  define gnu_volatile(x)",Not Useful
/*!GNUC broken versions*/,"-3. #ifdef __GNUC__
-2.    const void * volatile make_volatile_for_gnu;
-1. #  define gnu_volatile(x) make_volatile_for_gnu = &x;

/*!GNUC broken versions*/

1. #  define gnu_volatile(x)",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*0 .. max-1*/,"-5. #if defined PNG_READ_TRANSFORMS_SUPPORTED ||\
-4.     defined PNG_WRITE_FILTER_SUPPORTED
-3. static unsigned int
-2. random_mod(unsigned int max)
-1. {

/*0 .. max-1*/

1. }",Not Useful
/*READ_TRANSFORMS || WRITE_FILTER*/,"-1. }

/*READ_TRANSFORMS || WRITE_FILTER*/

1. #if (defined PNG_READ_RGB_TO_GRAY_SUPPORTED) ||\
2.     (defined PNG_READ_FILLER_SUPPORTED)
3. static int
4. random_choice(void)
5. {
6.    return random_byte() & 1;
7. }",Not Useful
/*PNG_READ_TRANSFORMS_SUPPORTED*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, ",Not Useful
/*Sub-byte*/,"-2.    toIndex *= pixelSize;
-1.    fromIndex *= pixelSize;

/*Sub-byte*/

1.    {",Not Useful
"/*Ok, any differences?*/","-10.  * given buffers.
-9.  */
-8. static int
-7. pixel_cmp(png_const_bytep pa, png_const_bytep pb, png_uint_32 bit_width)
-6. {
-5. #if PNG_LIBPNG_VER < 10506
-4.    if (memcmp(pa, pb, bit_width>>3) == 0)
-3.    {
-2.       png_uint_32 p;
-1.       if ((",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*arbitrary*/,"-10.       while (pa[where] == pb[where]) ++where;
-9.       return 1+where;
-8.    }
-7. }

/*arbitrary*/

1. typedef struct png_store_buffer
2. {",Not Useful
/*as many as you like...*/,"-8. {
-7.    png_byte red;
-6.    png_byte green;
-5.    png_byte blue;
-4.    png_byte alpha;
-3. } store_palette_entry, store_palette[256];
-2. typedef struct png_store_file
-1. {

/*as many as you like...*/

1.    char                    name[FILE_NAME",Not Useful
/*Overall statistics (retained across successive runs).*/,"-10. typedef struct store_pool
-9. {

/*Overall statistics (retained across successive runs).*/

1.    png_alloc_size_t     max_max;
2.    png_alloc_size_t     max_limit;
3.    png_alloc_size_t     max_total;
4. } store_pool;
5. typedef struct png_store
6",Not Useful
/*Name of test*/,"-1.    }                  options[16];

/*Name of test*/

1.    char               error[256];",Not Useful
/*Share fields*/,"-1.    char               error[256];

/*Share fields*/

111",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*0..32*/,"-7.    unsigned int b = 0;
-6.    if (num & 0xffff0000U)  b += 16U, num >>= 16;
-5.    if (num & 0xff00U)      b += 8U, num >>= 8;
-4.    if (num & 0xf0U)        b += 4U, num >>= 4;
-3.    if (num & 0xcU)         b += 2U, num >>= 2;
-2.    if (num & 0x2U)",Not Useful
/*And save it.*/,"-10.    ps->new.prev = NULL;
-9.    ps->writepos = 0;
-8.    ps->chunkpos = 8;
-7.    ps->chunktype = 0;
-6.    ps->chunklen = 16;
-5.    ps->IDAT_size = 0;
-4.    pf->palette = ps->palette;
-3.    pf->npalette = ps->npalette;
-2.    ps->palette = 0;
-1. ",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*PNG_NORETURN*/,"-1. static void PNGCBAPI

/*PNG_NORETURN*/

1. {
2.    png_const_structp pp = ppIn;
3.    png_store *ps = voidcast(png_store*, png_get_error_ptr(pp));
4.    if (!ps->expect_error)",Not Useful
/*warning*/,"-4. /* Error handling is particularly problematic in production code - error
-3.  * handlers often themselves have bugs which lead to programs that detect
-2.  * minor errors crashing.  The following functions deal with one very
-1.  * common class of err",Not Useful
/*The markers:*/,"-6.    while (--nImages >= 0)
-5.    {
-4.       png_uint_32 y;
-3.       for (y=0; y<cRows; ++y)
-2.       {
-1.          png_bytep row = store_image_row(ps, pp, nImages, y);

/*The markers:*/

1.          row[-2] = 190;
2.          row[-1] = 239;
3.    ",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*chunkpos >= 8*/,"-2.    char               error[256];

/*chunkpos >= 8*/

111",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*DOES NOTHING*/,"-8.    ps->writepos = writepos;
-7.    ps->chunkpos = chunkpos;
-6.    ps->chunktype = chunktype;
-5.    ps->chunklen = chunklen;
-4. }
-3. static void PNGCBAPI
-2. store_flush(png_structp ppIn)
-1. {

/*DOES NOTHING*/

1. }
2. #ifdef PNG_READ_SUPPORTED
3",Not Useful
/*I.e not the CRC*/,"-10.                b = IDAT_len - 12U;
-9.             else
-8.                b = CHUNK_IDAT;
-7.             shift = 3U & IDAT_pos;
-6.             ++IDAT_pos;
-5.             if (shift < 3U)
-4.                b >>= 8U*(3U-shift);
-3.             *pb+",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*4..1*/,"-2.          {
-1.             uLong b = ps->IDAT_crc;

/*4..1*/

1.             ++IDAT_pos;
2.             if (shift > 1U)
3.                b >>= 8U*(shift-1U);
4.             *pb++ = 0xffU & b;
5.          }
6.          while (--st > 0 && IDAT_pos < ID",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*Originating pool*/,"-2. typedef struct store_memory
-1. {

/*Originating pool*/

111",Not Useful
/*is_error*/,"-2. static void
-1. store_log(png_store* ps, png_const_structp pp, png_const_charp message,
   int is_error)

/*is_error*/

1. {",Not Useful
/*PNG_USER_MEM_SUPPORTED*/,"
#ifdef PNG_USER_MEM_SUPPORTED



/*PNG_USER_MEM_SUPPORTED*/

111",Not Useful
/*Setup functions.*/,"-5.    *test = this->next;
-4.    this->next = NULL;
-3.    store_memory_free(pp, pool, this);
-2. }

/*Setup functions.*/

111",Not Useful
/*just a cache*/,"-10. store_read_set(png_store *ps, png_uint_32 id)
-9. {
-8.    png_store_file *pf = ps->saved;
-7.    while (pf != NULL)
-6.    {
-5.       if (pf->id == id)
-4.       {
-3.          ps->current = pf;
-2.          ps->next = NULL;
-1.          ps->IDAT_s",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*Have a signature*/,"-10.  * png_store together with extra members to handle modification and a special
-9.  * read callback for libpng.  To use this the 'modifications' field must be set
-8.  * to a list of png_modification structures that actually perform the
-7.  * modific",Not Useful
/*Have an IHDR*/,"-10.  * read callback for libpng.  To use this the 'modifications' field must be set
-9.  * to a list of png_modification structures that actually perform the
-8.  * modification, otherwise a png_modifier is functionally equivalent to a
-7.  * png_store. ",Not Useful
/*READ_TRANSFORMS && READ_cHRM*/,"-10. }
-9. static CIE_color
-8. white_point(const color_encoding *encoding)
-7. {
-6.    CIE_color white;
-5.    white.X = encoding->red.X + encoding->green.X + encoding->blue.X;
-4.    white.Y = encoding->red.Y + encoding->green.Y + encoding->blue.Y;
-3.",Not Useful
/*READ_TRANSFORMS*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, ",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*I am a png_store*/,"-2. typedef struct png_modifier
-1. {

/*I am a png_store*/

111",Not Useful
/*My state*/,"-4. typedef struct png_modifier
-3. {

/*My state*/

111",Not Useful
/*Information from IHDR:*/,"-5. typedef struct png_modifier
-4. {

/*Information from IHDR:*/

111",Not Useful
/*From IHDR*/,"-6. typedef struct png_modifier
-5. {

/*From IHDR*/

111",Not Useful
/*From IHDR*/,"-6. typedef struct png_modifier
-5. {

/*From IHDR*/

111",Not Useful
/*Something overwrote it*/,"-4.    const color_encoding *encodings;
-3.    unsigned int              nencodings;

/*Something overwrote it*/

111",Not Useful
/*Flags:*/,"-7.    double                   error_gray_2;
-6.    double                   error_gray_4;
-5.    double                   error_gray_8;
-4.    double                   error_gray_16;
-3.    double                   error_color_8;
-2.    double          ",Not Useful
/*Whether or not to interlace.*/,"-1.    int                      use_update_info;

/*Whether or not to interlace.*/

111",Not Useful
/*Run the standard tests?*/,"-3.    int                      use_update_info;

/*Run the standard tests?*/

1.    unsigned int             test_standard :1;",Not Useful
/*main tests*/,"-1.    unsigned int             test_gamma_threshold :1;

/*main tests*/

1.    unsigned int             test_gamma_sbit :1;
2.    unsigned int             test_gamma_scale16 :1;
3.    unsigned int             test_gamma_background :1;
4.    unsigned int ",Not Useful
/*(1) nothing*/,"-10.  * that this function changes the colour space encoding so it must only be
-9.  * called on completion of the previous test.  This is what 'modifier_reset'
-8.  * does, below.
-7.  *
-6.  * After the function has been called the 'repeat' flag will st",Not Useful
/*signature.*/,"-10. {
-9.    while (st > 0)
-8.    {
-7.       size_t cb;
-6.       png_uint_32 len, chunk;
-5.       png_modification *mod;
-4.       if (pm->buffer_position >= pm->buffer_count) switch (pm->state)
-3.       {
-2.          static png_byte sign[8] = { 13",Not Useful
/*IHDR*/,"-8. #   define debugonly(something) something

/*IHDR*/

1. #define CHUNK_PLTE CHUNK(80,76,84,69)
2. #define CHUNK_IDAT CHUNK(73,68,65,84)
3. #define CHUNK_IEND CHUNK(73,69,78,68)
4. #define CHUNK_cHRM CHUNK(99,72,82,77)
5. #define CHUNK_gAMA CHUNK(103,65",Not Useful
/*The callback:*/,"-10.        */
-9.       cb = pm->buffer_count - pm->buffer_position;
-8.       if (cb > st)
-7.          cb = st;
-6.       memcpy(pb, pm->buffer + pm->buffer_position, cb);
-5.       st -= cb;
-4.       pb += cb;
-3.       pm->buffer_position += cb;
-2.",Not Useful
/*PNG_READ_TRANSFORMS_SUPPORTED*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, ",Not Useful
/***************************** STANDARD PNG FILES *****************************/,"-10.    modification_init(&me->this);
-9.    me->this.chunk = CHUNK_sBIT;
-8.    me->this.modify_fn = sbit_modify;
-7.    me->this.add = CHUNK_PLTE;
-6.    me->sbit = sbit;
-5.    me->this.next = pm->modifications;
-4.    pm->modifications = &me->this;
-3",Not Useful
/*got black*/,"-4.    {
-3.       int j = 0;
-2.       png_byte random_bytes[4];
-1.       png_byte need[256];

/*got black*/

111",Not Useful
/*need these*/,"-5.    {
-4.       int j = 0;
-3.       png_byte random_bytes[4];
-2.       png_byte need[256];

/*need these*/

111",Not Useful
/*but not white*/,"-6.    {
-5.       int j = 0;
-4.       png_byte random_bytes[4];
-3.       png_byte need[256];

/*but not white*/

1.       while (i<70)
2.       {
3.          png_byte b;
4.          if (j==0)
5.          {
6.             make_four_random_bytes(palette_",Not Useful
/*no transparency/tRNS chunk*/,"-10.     */
-9.    {
-8.       store_palette_entry *palette;
-7.       png_byte selector[4];
-6.       make_four_random_bytes(palette_seed, selector);
-5.       if (do_tRNS)
-4.          for (i=0; i<256; ++i)
-3.             values[i][0] = (png_byte)(i ^ ",Not Useful
/*bit_depth == 16*/,"((pm->bit_depth == 16 || pm->assume_16_bit_calculations) ?

/*bit_depth == 16*/

111",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*WRITE_INTERLACING tests*/,"-5. #  define set_write_interlace_handling(pp,type)\
-4.       npasses_from_interlace_type(pp,type)
-3. #  define check_interlace_type(type) ((void)(type))
-2. #  define INTERLACE_LAST PNG_INTERLACE_LAST
-1. #  define do_own_interlace 1

/*WRITE_INTERLACI",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*method*/,"-10.    }
-9. }
-8. #ifdef PNG_WRITE_tRNS_SUPPORTED
-7. static void
-6. set_random_tRNS(png_structp pp, png_infop pi, const png_byte colour_type,
-5.    const int bit_depth)
-4. {
-3.    /* To make this useful the tRNS color needs to match at least one pi",Not Useful
/*!WRITE_FILTER*/,"-2.    }
-1. }

/*!WRITE_FILTER*/

1. #  define choose_random_filter(pp, start) ((void)0)",Not Useful
/*!WRITE_FILTER*/,"-2.    }
-1. }

/*!WRITE_FILTER*/

1. #  define choose_random_filter(pp, start) ((void)0)",Not Useful
/*must be writeable*/,"-10.       h = transform_height(pp, colour_type, bit_depth);
-9.       png_set_IHDR(pp, pi, w, h, bit_depth, colour_type, interlace_type,
-8.          PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-7. #ifdef PNG_TEXT_SUPPORTED
-6. #  if defined(PNG_RE",Not Useful
/*Yuck: the text must be writable!*/,"-2.          text.compression = TEXT_COMPRESSION;
-1.          text.key = key;

/*Yuck: the text must be writable!*/

1.          pos = safecat(copy, sizeof copy, 0, ps->wname);
2.          text.text = copy;
3.          text.text_length = pos;
4.         ",Not Useful
/*do_own_interlace*/,"-4. #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-3. #  define INTERLACE_LAST PNG_INTERLACE_LAST
-2. #  define check_interlace_type(type) ((void)(type))
-1. #  define set_write_interlace_handling(pp,type) png_set_interlace_handling(pp)
#  define do_own_interlac",Not Useful
/*must be writeable*/,"-10.       h = transform_height(pp, colour_type, bit_depth);
-9.       png_set_IHDR(pp, pi, w, h, bit_depth, colour_type, interlace_type,
-8.          PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-7. #ifdef PNG_TEXT_SUPPORTED
-6. #  if defined(PNG_RE",Not Useful
/*Yuck: the text must be writable!*/,"-2.          text.compression = TEXT_COMPRESSION;
-1.          text.key = key;

/*Yuck: the text must be writable!*/

1.          pos = safecat(copy, sizeof copy, 0, ps->wname);
2.          text.text = copy;
3.          text.text_length = pos;
4.         ",Not Useful
/*method*/,"-10.    }
-9. }
-8. #ifdef PNG_WRITE_tRNS_SUPPORTED
-7. static void
-6. set_random_tRNS(png_structp pp, png_infop pi, const png_byte colour_type,
-5.    const int bit_depth)
-4. {
-3.    /* To make this useful the tRNS color needs to match at least one pi",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*0 is invalid...*/,"-4. #ifdef PNG_WARNINGS_SUPPORTED
-3. static void
-2. sBIT0_error_fn(png_structp pp, png_infop pi)
-1. {

/*0 is invalid...*/

1.    png_color_8 bad;
2.    bad.red = bad.green = bad.blue = bad.gray = bad.alpha = 0;
3.    png_set_sBIT(pp, pi, &bad);
4. }
5",Not Useful
/*do_own_interlace*/,"-4. #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-3. #  define INTERLACE_LAST PNG_INTERLACE_LAST
-2. #  define check_interlace_type(type) ((void)(type))
-1. #  define set_write_interlace_handling(pp,type) png_set_interlace_handling(pp)
#  define do_own_interlac",Not Useful
/*keep going*/,"-5. } store_memory;
-4. /* Handle a fatal error in memory allocation.  This calls png_error if the
-3.  * libpng struct is non-NULL, else it outputs a message and returns.  This means
-2.  * that a memory problem while libpng is running will abort (png_er",Not Useful
/*PNG_WARNINGS_SUPPORTED*/,"
#ifdef PNG_WARNINGS_SUPPORTED



/*PNG_WARNINGS_SUPPORTED*/

1. static void
2. sBIT0_error_fn(png_structp pp, png_infop pi)
3. {",Not Useful
/*Calculated file ID*/,"-5.    png_byte    green_sBIT;
-4.    png_byte    blue_sBIT;
-3.    png_byte    alpha_sBIT;
-2.    png_byte    interlace_type;

/*Calculated file ID*/

111",Not Useful
/*Transparency information was present.*/,"-10.    png_byte    filler;         /* Output has a filler */
-9.    png_uint_32 id;             /* Calculated file ID */
-8.    png_uint_32 w;              /* Width of image */
-7.    png_uint_32 h;              /* Height of image */
-6.    int         n",Not Useful
/*!png_get_PLTE*/,"-2.       memset(palette + *npalette, 126, (256-*npalette) * sizeof *palette);
-1.    }

/*!png_get_PLTE*/

1.    {
2.       if (*npalette != (-1))
3.          png_error(pp, ""validate: invalid PLTE result"");",Not Useful
/*transparency*/,"-10.     */
-9.    {
-8.       store_palette_entry *palette;
-7.       png_byte selector[4];
-6.       make_four_random_bytes(palette_seed, selector);
-5.       if (do_tRNS)
-4.          for (i=0; i<256; ++i)
-3.             values[i][0] = (png_byte)(i ^ ",Not Useful
/*no transparency*/,"-10.     */
-9.    {
-8.       store_palette_entry *palette;
-7.       png_byte selector[4];
-6.       make_four_random_bytes(palette_seed, selector);
-5.       if (do_tRNS)
-4.          for (i=0; i<256; ++i)
-3.             values[i][0] = (png_byte)(i ^ ",Not Useful
/*!READ_INTERLACING*/,"-6.    dp->npasses = npasses_from_interlace_type(pp, dp->interlace_type);
-5.    if (!dp->do_interlace)
-4.    {
-3. #     ifdef PNG_READ_INTERLACING_SUPPORTED
-2.          if (dp->npasses != png_set_interlace_handling(pp))
-1.             png_error(pp, """,Not Useful
/*!READ_INTERLACING*/,"-6.    dp->npasses = npasses_from_interlace_type(pp, dp->interlace_type);
-5.    if (!dp->do_interlace)
-4.    {
-3. #     ifdef PNG_READ_INTERLACING_SUPPORTED
-2.          if (dp->npasses != png_set_interlace_handling(pp))
-1.             png_error(pp, """,Not Useful
/*USER_TRANSFORM_INFO*/,"-2.       if (dp->do_interlace && dp->interlace_type == PNG_INTERLACE_ADAM7)
-1.       {
#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED

/*USER_TRANSFORM_INFO*/

111",Not Useful
/*READ_INTERLACING*/,"
#ifdef PNG_READ_INTERLACING_SUPPORTED



/*READ_INTERLACING*/

1. #  define do_read_interlace 0",Not Useful
/*PNG_READ_INTERLACING_SUPPORTED*/,"
#ifdef PNG_READ_INTERLACING_SUPPORTED



/*PNG_READ_INTERLACING_SUPPORTED*/

1. #  define do_read_interlace 0",Not Useful
/*keep going*/,"-5. } store_memory;
-4. /* Handle a fatal error in memory allocation.  This calls png_error if the
-3.  * libpng struct is non-NULL, else it outputs a message and returns.  This means
-2.  * that a memory problem while libpng is running will abort (png_er",Not Useful
/*do_interlace*/,"
/* A numeric ID based on PNG file characteristics.  The 'do_interlace' field



/*do_interlace*/

1.  * simply records whether pngvalid did the interlace itself or whether it
2.  * was done by libpng.  Width and height must be less than 256.  'palette' is an
3.  * index of the palette to use for formats with a palette otherwise a boolean
4.  * indicating if a tRNS chunk was generated.
5.  */
6. #define FILEID(col, depth, palette, interlace, width, height, do_interlace) \
7.    ((png_uint_32)((col) + ((depth)<<3) + ((palette)<<8) + ((interlace)<<13) + \
8.     (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))
9. #define COL_FROM_ID(id) ((png_byte)((id)& 0x7U))
10. #define DEPTH_FROM_ID(id) ((png_byte)(((id) >> 3) & 0x1fU))",Not Useful
/*do_interlace*/,"
/* A numeric ID based on PNG file characteristics.  The 'do_interlace' field



/*do_interlace*/

1.  * simply records whether pngvalid did the interlace itself or whether it
2.  * was done by libpng.  Width and height must be less than 256.  'palette' is an
3.  * index of the palette to use for formats with a palette otherwise a boolean
4.  * indicating if a tRNS chunk was generated.
5.  */
6. #define FILEID(col, depth, palette, interlace, width, height, do_interlace) \
7.    ((png_uint_32)((col) + ((depth)<<3) + ((palette)<<8) + ((interlace)<<13) + \
8.     (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))
9. #define COL_FROM_ID(id) ((png_byte)((id)& 0x7U))
10. #define DEPTH_FROM_ID(id) ((png_byte)(((id) >> 3) & 0x1fU))",Not Useful
/*do_interlace*/,"
/* A numeric ID based on PNG file characteristics.  The 'do_interlace' field



/*do_interlace*/

1.  * simply records whether pngvalid did the interlace itself or whether it
2.  * was done by libpng.  Width and height must be less than 256.  'palette' is an
3.  * index of the palette to use for formats with a palette otherwise a boolean
4.  * indicating if a tRNS chunk was generated.
5.  */
6. #define FILEID(col, depth, palette, interlace, width, height, do_interlace) \
7.    ((png_uint_32)((col) + ((depth)<<3) + ((palette)<<8) + ((interlace)<<13) + \
8.     (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))
9. #define COL_FROM_ID(id) ((png_byte)((id)& 0x7U))
10. #define DEPTH_FROM_ID(id) ((png_byte)(((id) >> 3) & 0x1fU))",Not Useful
/*do_interlace*/,"
/* A numeric ID based on PNG file characteristics.  The 'do_interlace' field



/*do_interlace*/

1.  * simply records whether pngvalid did the interlace itself or whether it
2.  * was done by libpng.  Width and height must be less than 256.  'palette' is an
3.  * index of the palette to use for formats with a palette otherwise a boolean
4.  * indicating if a tRNS chunk was generated.
5.  */
6. #define FILEID(col, depth, palette, interlace, width, height, do_interlace) \
7.    ((png_uint_32)((col) + ((depth)<<3) + ((palette)<<8) + ((interlace)<<13) + \
8.     (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))
9. #define COL_FROM_ID(id) ((png_byte)((id)& 0x7U))
10. #define DEPTH_FROM_ID(id) ((png_byte)(((id) >> 3) & 0x1fU))",Not Useful
/*do_interlace*/,"
/* A numeric ID based on PNG file characteristics.  The 'do_interlace' field



/*do_interlace*/

1.  * simply records whether pngvalid did the interlace itself or whether it
2.  * was done by libpng.  Width and height must be less than 256.  'palette' is an
3.  * index of the palette to use for formats with a palette otherwise a boolean
4.  * indicating if a tRNS chunk was generated.
5.  */
6. #define FILEID(col, depth, palette, interlace, width, height, do_interlace) \
7.    ((png_uint_32)((col) + ((depth)<<3) + ((palette)<<8) + ((interlace)<<13) + \
8.     (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))
9. #define COL_FROM_ID(id) ((png_byte)((id)& 0x7U))
10. #define DEPTH_FROM_ID(id) ((png_byte)(((id) >> 3) & 0x1fU))",Not Useful
/*READ_INTERLACING*/,"
#ifdef PNG_READ_INTERLACING_SUPPORTED



/*READ_INTERLACING*/

1. #  define do_read_interlace 0",Not Useful
/*do_interlace*/,"
/* A numeric ID based on PNG file characteristics.  The 'do_interlace' field



/*do_interlace*/

1.  * simply records whether pngvalid did the interlace itself or whether it
2.  * was done by libpng.  Width and height must be less than 256.  'palette' is an
3.  * index of the palette to use for formats with a palette otherwise a boolean
4.  * indicating if a tRNS chunk was generated.
5.  */
6. #define FILEID(col, depth, palette, interlace, width, height, do_interlace) \
7.    ((png_uint_32)((col) + ((depth)<<3) + ((palette)<<8) + ((interlace)<<13) + \
8.     (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))
9. #define COL_FROM_ID(id) ((png_byte)((id)& 0x7U))
10. #define DEPTH_FROM_ID(id) ((png_byte)(((id) >> 3) & 0x1fU))",Not Useful
/*Test both together:*/,"-6.             pm->use_update_info);
-5.          if (fail(pm))
-4.             return 0;
-3. #     endif
-2. #     ifdef PNG_READ_INTERLACING_SUPPORTED
-1. #     ifdef PNG_WRITE_INTERLACING_SUPPORTED

/*Test both together:*/

111",Not Useful
/*do_interlace*/,"
/* A numeric ID based on PNG file characteristics.  The 'do_interlace' field



/*do_interlace*/

1.  * simply records whether pngvalid did the interlace itself or whether it
2.  * was done by libpng.  Width and height must be less than 256.  'palette' is an
3.  * index of the palette to use for formats with a palette otherwise a boolean
4.  * indicating if a tRNS chunk was generated.
5.  */
6. #define FILEID(col, depth, palette, interlace, width, height, do_interlace) \
7.    ((png_uint_32)((col) + ((depth)<<3) + ((palette)<<8) + ((interlace)<<13) + \
8.     (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))
9. #define COL_FROM_ID(id) ((png_byte)((id)& 0x7U))
10. #define DEPTH_FROM_ID(id) ((png_byte)(((id) >> 3) & 0x1fU))",Not Useful
/*READ_INTERLACING*/,"
#ifdef PNG_READ_INTERLACING_SUPPORTED



/*READ_INTERLACING*/

1. #  define do_read_interlace 0",Not Useful
/*keep going*/,"-5. } store_memory;
-4. /* Handle a fatal error in memory allocation.  This calls png_error if the
-3.  * libpng struct is non-NULL, else it outputs a message and returns.  This means
-2.  * that a memory problem while libpng is running will abort (png_er",Not Useful
/******************************* TRANSFORM TESTS ******************************/,"-10.     */
-9. #if 0
-8.    if (!test_size(pm, 3, 0, 3))
-7.       return;
-6. #endif
-5.    if (!test_size(pm, 4, 3, READ_BDHI))
-4.       return;
-3.    if (!test_size(pm, 6, 3, READ_BDHI))
-2.       return;
-1. }

/******************************* TRAN",Not Useful
/*As in the spec.*/,"-10.  * fashion.  To deal with this some measure of restraint is required, otherwise
-9.  * the tests would take forever.
-8.  */
-7. typedef struct image_pixel
-6. {

/*As in the spec.*/

111",Not Useful
/*BGR*/,"-10. {

/*BGR*/

111",Not Useful
/*Local variables*/,"-3.    png_modifier*              pm;
-2.    const image_transform* transform_list;
-1.    unsigned int max_gamma_8;

/*Local variables*/

1.    png_byte output_colour_type;
2.    png_byte output_bit_depth;
3.    png_byte unpacked;",Not Useful
/*opaque*/,"-8.       for (; i<256; ++i)
-7.          palette[i].red = palette[i].green = palette[i].blue = 42;
-6.       png_set_PLTE(pp, pi, palette, npalette);
-5.    }
-4.    if (do_tRNS)
-3.    {
-2.       int i, j;
-1.       png_byte tRNS[256];

/*opaque*/

1. ",Not Useful
/*Override this.*/,"-10.    }
-9.    if ((that->colour_type & PNG_COLOR_MASK_ALPHA) ||
-8.       that->colour_type == PNG_COLOR_TYPE_PALETTE)
-7.    {
-6.       that->alpha = sample_scale(that->alphaf, scale);
-5.       that->alphae += 1./(2*((1U<<that->alpha_sBIT)-1));
-4. ",Not Useful
/*It's exact ;-)*/,"-10.    if ((that->colour_type & PNG_COLOR_MASK_ALPHA) ||
-9.       that->colour_type == PNG_COLOR_TYPE_PALETTE)
-8.    {
-7.       that->alpha = sample_scale(that->alphaf, scale);
-6.       that->alphae += 1./(2*((1U<<that->alpha_sBIT)-1));
-5.    }
-4. ",Not Useful
/*name*/,"-3. struct png_store;
-2. define_exception_type(struct png_store*);
-1. /* The following are macros to reduce typing everywhere where the well known
 * name 'the_exception_context' must be defined.

/*name*/

1.  */
2. #define anon_context(ps) struct exce",Not Useful
/*enable*/,"
   int enable;



/*enable*/

111",Not Useful
/*global_use*/,"
   unsigned int global_use;



/*global_use*/

111",Not Useful
/*local_use*/,"
   unsigned int local_use;



/*local_use*/

111",Not Useful
/*Standard fields*/,"-5. static void
-4. transform_display_init(transform_display *dp, png_modifier *pm, png_uint_32 id,
-3.     const image_transform *transform_list)
-2. {
-1.    memset(dp, 0, sizeof *dp);

/*Standard fields*/

1.    standard_display_init(&dp->this, &pm->th",Not Useful
/*not unpacked*/,"-6.    dp->pm = pm;
-5.    dp->transform_list = transform_list;
-4.    dp->max_gamma_8 = 16;

/*not unpacked*/

1. }
2. static void
3. transform_info_imp(transform_display *dp, png_structp pp, png_infop pi)
4. {",Not Useful
/*Reuse the standard stuff as appropriate.*/,"-4. }
-3. static void
-2. transform_info_imp(transform_display *dp, png_structp pp, png_infop pi)
-1. {

/*Reuse the standard stuff as appropriate.*/

1.    standard_info_part1(&dp->this, pp, pi);",Not Useful
/*FALLTHROUGH*/,"-4.    switch (dp->output_colour_type)
-3.    {
-2.    case PNG_COLOR_TYPE_PALETTE:
-1.       if (dp->output_bit_depth > 8) goto error;

/*FALLTHROUGH*/

1.    case PNG_COLOR_TYPE_GRAY:
2.       if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 |",Not Useful
/*FALLTHROUGH*/,"-4.    switch (dp->output_colour_type)
-3.    {
-2.    case PNG_COLOR_TYPE_PALETTE:
-1.       if (dp->output_bit_depth > 8) goto error;

/*FALLTHROUGH*/

1.    case PNG_COLOR_TYPE_GRAY:
2.       if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 |",Not Useful
/*FALLTHROUGH*/,"-4.    switch (dp->output_colour_type)
-3.    {
-2.    case PNG_COLOR_TYPE_PALETTE:
-1.       if (dp->output_bit_depth > 8) goto error;

/*FALLTHROUGH*/

1.    case PNG_COLOR_TYPE_GRAY:
2.       if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 |",Not Useful
"/*The original, standard, row pre-transforms.*/","-7.       else
-6.          digitization_error = .5 * 257;
-5.    }
-4.    for (y=0; y<h; ++y)
-3.    {
-2.       png_const_bytep const pRow = store_image_row(ps, pp, 0, y);
-1.       png_uint_32 x;

/*The original, standard, row pre-transforms.*/

1.    ",Not Useful
/*row (y) loop*/,"-10.                out_pixel.blue, sample_depth, in_pixel.bluee,
-9.                dp->pm->limit + 1./(2*((1U<<in_pixel.blue_sBIT)-1)), ""blue"",
-8.                digitization_error);
-7.          if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0 &&
-6.         ",Not Useful
/*modifier_read expects a png_modifier**/,"-4.          modifier_progressive_read(d.pm, pp, pi);
-3.       }
-2.       else
-1.       {

/*modifier_read expects a png_modifier**/

1.          png_set_read_fn(pp, d.pm, modifier_read);",Not Useful
/*The transforms:*/,"-10.          else
-9.             d.this.ps->validated = 1;
-8.       }
-7.       modifier_reset(d.pm);
-6.    }
-5.    Catch(fault)
-4.    {
-3.       modifier_reset(voidcast(png_modifier*,(void*)fault));
-2.    }
-1. }

/*The transforms:*/

1. #define ",Not Useful
/*enable*/,"
   int enable;



/*enable*/

111",Not Useful
/*global_use*/,"
   unsigned int global_use;



/*global_use*/

111",Not Useful
/*local_use*/,"
   unsigned int local_use;



/*local_use*/

111",Not Useful
/*To save code:*/,"-6.    image_transform_ini,\
-5.    image_transform_png_set_##name##_set,\
-4.    image_transform_png_set_##name##_mod,\
-3.    image_transform_png_set_##name##_add\
-2. }

/*To save code:*/

1. extern void image_transform_default_ini(const image_transfor",Not Useful
/*PNG_READ_EXPAND_SUPPORTED*/,"-10.    this->sample_depth = sample_depth;
-9.    this->have_tRNS = 0;
-8.    this->swap_rgb = 0;
-7.    this->alpha_first = 0;
-6.    this->alpha_inverted = 0;
-5.    this->mono_inverted = 0;
-4.    this->swap16 = 0;
-3.    this->littleendian = 0;
-2.   ",Not Useful
/*PNG_READ_EXPAND_SUPPORTED*/,"-10.    this->sample_depth = sample_depth;
-9.    this->have_tRNS = 0;
-8.    this->swap_rgb = 0;
-7.    this->alpha_first = 0;
-6.    this->alpha_inverted = 0;
-5.    this->mono_inverted = 0;
-4.    this->swap16 = 0;
-3.    this->littleendian = 0;
-2.   ",Not Useful
/*png_set_expand*/,"-1. #ifdef PNG_READ_EXPAND_SUPPORTED

/*png_set_expand*/

1. static void
2. image_transform_png_set_expand_set(const image_transform *this,
3.     transform_display *that, png_structp pp, png_infop pi)
4. {
5.    png_set_expand(pp);
6.    if (that->this.h",Not Useful
/*PNG_READ_EXPAND_SUPPORTED*/,"-10.    this->sample_depth = sample_depth;
-9.    this->have_tRNS = 0;
-8.    this->swap_rgb = 0;
-7.    this->alpha_first = 0;
-6.    this->alpha_inverted = 0;
-5.    this->mono_inverted = 0;
-4.    this->swap16 = 0;
-3.    this->littleendian = 0;
-2.   ",Not Useful
/*1.7 or later*/,"-4.    if (that->colour_type == PNG_COLOR_TYPE_GRAY &&
-3.        that->bit_depth < 8)
-2.       that->sample_depth = that->bit_depth = 8;
-1.    this->next->mod(this->next, that, pp, display);

/*1.7 or later*/

1. }
2. static int
3. image_transform_png_",Not Useful
/*1.7 or later*/,"-4.    if (that->colour_type == PNG_COLOR_TYPE_GRAY &&
-3.        that->bit_depth < 8)
-2.       that->sample_depth = that->bit_depth = 8;
-1.    this->next->mod(this->next, that, pp, display);

/*1.7 or later*/

1. }
2. static int
3. image_transform_png_",Not Useful
/*PNG_READ_EXPAND_SUPPORTED*/,"-10.    this->sample_depth = sample_depth;
-9.    this->have_tRNS = 0;
-8.    this->swap_rgb = 0;
-7.    this->alpha_first = 0;
-6.    this->alpha_inverted = 0;
-5.    this->mono_inverted = 0;
-4.    this->swap16 = 0;
-3.    this->littleendian = 0;
-2.   ",Not Useful
/*png_set_expand_16*/,"-1. #ifdef PNG_READ_EXPAND_16_SUPPORTED

/*png_set_expand_16*/

1. static void
2. image_transform_png_set_expand_16_set(const image_transform *this,
3.     transform_display *that, png_structp pp, png_infop pi)
4. {
5.    png_set_expand_16(pp);",Not Useful
/*PNG_READ_EXPAND_16_SUPPORTED*/,"-10.    this->have_tRNS = 0;
-9.    this->swap_rgb = 0;
-8.    this->alpha_first = 0;
-7.    this->alpha_inverted = 0;
-6.    this->mono_inverted = 0;
-5.    this->swap16 = 0;
-4.    this->littleendian = 0;
-3.    this->sig_bits = 0;
-2. }
-1. #if defined",Not Useful
/*png_set_scale_16*/,"-7.    return bit_depth < 16;
-6. }
-5. IT(expand_16);
-4. #undef PT
-3. #define PT ITSTRUCT(expand_16)

/*png_set_scale_16*/

1. static void
2. image_transform_png_set_scale_16_set(const image_transform *this,
3.     transform_display *that, png_structp ",Not Useful
/*PNG_READ_SCALE_16_TO_8_SUPPORTED (1.5.4 on)*/,"-10.     const image_transform **that, png_byte colour_type, png_byte bit_depth)
-9. {
-8.    UNUSED(colour_type)
-7.    this->next = *that;
-6.    *that = this;
-5.    return bit_depth > 8;
-4. }
-3. IT(scale_16);
-2. #undef PT
-1. #define PT ITSTRUCT(sc",Not Useful
/*png_set_strip_16*/,"-10.    UNUSED(colour_type)
-9.    this->next = *that;
-8.    *that = this;
-7.    return bit_depth > 8;
-6. }
-5. IT(scale_16);
-4. #undef PT
-3. #define PT ITSTRUCT(scale_16)

/*png_set_strip_16*/

1. static void
2. image_transform_png_set_strip_16_set(",Not Useful
/*PNG_READ_16_TO_8_SUPPORTED*/,"-10. {
-9.    UNUSED(colour_type)
-8.    this->next = *that;
-7.    *that = this;
-6.    return bit_depth > 8;
-5. }
-4. IT(scale_16);
-3. #undef PT
-2. #define PT ITSTRUCT(scale_16)

/*PNG_READ_16_TO_8_SUPPORTED*/

111",Not Useful
/*not used*/,"-7.       store_storefile(ps, FILEID(colour_type, bit_depth, palette_number,
-6.          interlace_type, 0, 0, 0));
-5.       store_write_reset(ps);
-4.    }
-3.    Catch(fault)
-2.    {
-1.       /* Use the png_store returned by the exception. This may ",Not Useful
/*READ_cHRM*/,"-2. } color_encoding;
-1. #ifdef PNG_READ_SUPPORTED
#if defined PNG_READ_TRANSFORMS_SUPPORTED && defined PNG_READ_cHRM_SUPPORTED

/*READ_cHRM*/

1. static double
2. chromaticity_x(CIE_color c)
3. {
4.    return c.X / (c.X + c.Y + c.Z);
5. }
6. static doub",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*truncate*/,"-10.  * called directly.
-9.  */
-8. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-7. #if DIGITIZE
-6. static double digitize(double value, int depth, int do_round)
-5. {
-4.    /* 'value' is in the range 0 to 1, the result is the same value rounded to a
-3.    ",Not Useful
/*!DIGITIZE*/,"-2.          }
-1.       }

/*!DIGITIZE*/

1.       {
2.          double r = that->redf;
3.          double re = that->rede;
4.          double g = that->greenf;
5.          double ge = that->greene;
6.          double b = that->bluef;
7.          double ",Not Useful
/*before 1.7*/,"-10.              * true, there was some if gamma correction was happening too.)
-9.              */
-8.             if (r == g && r == b)
-7.             {
-6.                gray = r;
-5.                err = re;
-4.                if (err < ge) err = g",Not Useful
/*!DIGITIZE*/,"-2.          }
-1.       }

/*!DIGITIZE*/

1.       {
2.          double r = that->redf;
3.          double re = that->rede;
4.          double g = that->greenf;
5.          double ge = that->greene;
6.          double b = that->bluef;
7.          double ",Not Useful
/*x*/,"-10.  * This code is released under the libpng license.
-9.  * For conditions of distribution and use, see the disclaimer
-8.  * and license in png.h
-7.  *
-6.  * NOTES:
-5.  *   This is a C program that is intended to be linked against libpng.  It
-4.  ",Not Useful
/*format*/,"-10.  * For conditions of distribution and use, see the disclaimer
-9.  * and license in png.h
-8.  *
-7.  * NOTES:
-6.  *   This is a C program that is intended to be linked against libpng.  It
-5.  *   generates bitmaps internally, stores them as PNG fi",Not Useful
/*NOTE: TBD NYI*/,"-10. #undef data
-9. IT(background);
-8. #undef PT
-7. #define PT ITSTRUCT(background)

/*NOTE: TBD NYI*/

111",Not Useful
/*png_set_bgr*/,"-6.    return (colour_type & 4) != 0;
-5. }
-4. IT(invert_alpha);
-3. #undef PT
-2. #define PT ITSTRUCT(invert_alpha)

/*png_set_bgr*/

1. #ifdef PNG_READ_BGR_SUPPORTED",Not Useful
/*PNG_READ_BGR_SUPPORTED*/,"
#ifdef PNG_READ_BGR_SUPPORTED



/*PNG_READ_BGR_SUPPORTED*/

111",Not Useful
/*png_set_swap*/,"-10.    UNUSED(bit_depth)
-9.    this->next = *that;
-8.    *that = this;
-7.    return colour_type == PNG_COLOR_TYPE_RGB ||
-6.        colour_type == PNG_COLOR_TYPE_RGBA;
-5. }
-4. IT(bgr);
-3. #undef PT
-2. #define PT ITSTRUCT(bgr)

/*png_set_swap*/

1.",Not Useful
/*PNG_READ_SWAP_SUPPORTED*/,"
#ifdef PNG_READ_SWAP_SUPPORTED



/*PNG_READ_SWAP_SUPPORTED*/

111",Not Useful
/*PNG_READ_FILLER_SUPPORTED*/,"-8. static png_uint_16
-7. random_u16(void)
-6. {
-5.    unsigned char b2[2];
-4.    randomize(b2, sizeof b2);
-3.    return png_get_uint_16(b2);
-2. }
-1. #if defined PNG_READ_RGB_TO_GRAY_SUPPORTED ||\
    defined PNG_READ_FILLER_SUPPORTED

/*PNG_READ_FI",Not Useful
/*png_set_packing*/,"-10.    this->next = *that;
-9.    *that = this;
-8.    return bit_depth >= 8 && (colour_type == PNG_COLOR_TYPE_RGB ||
-7.            colour_type == PNG_COLOR_TYPE_GRAY);
-6. }
-5. #undef data
-4. IT(add_alpha);
-3. #undef PT
-2. #define PT ITSTRUCT(add_a",Not Useful
/*PNG_READ_PACK_SUPPORTED*/,"
#ifdef PNG_READ_PACK_SUPPORTED



/*PNG_READ_PACK_SUPPORTED*/

111",Not Useful
/*png_set_packswap*/,"-6.    return bit_depth < 8;
-5. }
-4. IT(packing);
-3. #undef PT
-2. #define PT ITSTRUCT(packing)

/*png_set_packswap*/

1. #ifdef PNG_READ_PACKSWAP_SUPPORTED",Not Useful
/*PNG_READ_PACKSWAP_SUPPORTED*/,"
#ifdef PNG_READ_PACKSWAP_SUPPORTED



/*PNG_READ_PACKSWAP_SUPPORTED*/

111",Not Useful
/*png_set_invert_mono*/,"-10. {
-9.    UNUSED(colour_type)
-8.    this->next = *that;
-7.    *that = this;
-6.    return bit_depth < 8;
-5. }
-4. IT(packswap);
-3. #undef PT
-2. #define PT ITSTRUCT(packswap)

/*png_set_invert_mono*/

1. #ifdef PNG_READ_INVERT_MONO_SUPPORTED",Not Useful
/*PNG_READ_INVERT_MONO_SUPPORTED*/,"
#ifdef PNG_READ_INVERT_MONO_SUPPORTED



/*PNG_READ_INVERT_MONO_SUPPORTED*/

111",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*PNG_READ_SHIFT_SUPPORTED*/,"
#ifdef PNG_READ_SHIFT_SUPPORTED



/*PNG_READ_SHIFT_SUPPORTED*/

111",Not Useful
/*PNG_READ_TRANSFORMS_SUPPORTED*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, ",Not Useful
/*Local variables*/,"-3.    png_modifier*              pm;
-2.    const image_transform* transform_list;
-1.    unsigned int max_gamma_8;

/*Local variables*/

1.    png_byte output_colour_type;
2.    png_byte output_bit_depth;
3.    png_byte unpacked;",Not Useful
/*Standard fields*/,"-5. static void
-4. transform_display_init(transform_display *dp, png_modifier *pm, png_uint_32 id,
-3.     const image_transform *transform_list)
-2. {
-1.    memset(dp, 0, sizeof *dp);

/*Standard fields*/

1.    standard_display_init(&dp->this, &pm->th",Not Useful
/*Reuse the standard stuff as appropriate.*/,"-4. }
-3. static void
-2. transform_info_imp(transform_display *dp, png_structp pp, png_infop pi)
-1. {

/*Reuse the standard stuff as appropriate.*/

1.    standard_info_part1(&dp->this, pp, pi);",Not Useful
/*The following works both in 1.5.4 and earlier versions:*/,"-4.    if (dp->scale16)
-3. #     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-2.          png_set_scale_16(pp);
-1. #     else

/*The following works both in 1.5.4 and earlier versions:*/

1. #        ifdef PNG_READ_16_TO_8_SUPPORTED
2.             png_set_st",Not Useful
/*need_expand*/,"-2. #ifdef PNG_READ_BACKGROUND_SUPPORTED
-1. /* png_set_background(png_structp, png_const_color_16p background_color,
 *    int background_gamma_code, int need_expand, double background_gamma)

/*need_expand*/

1.  * png_set_background_fixed(png_structp, ",Not Useful
/*need_expand*/,"-2. #ifdef PNG_READ_BACKGROUND_SUPPORTED
-1. /* png_set_background(png_structp, png_const_color_16p background_color,
 *    int background_gamma_code, int need_expand, double background_gamma)

/*need_expand*/

1.  * png_set_background_fixed(png_structp, ",Not Useful
/*A component*/,"-5.             output_is_encoded = 0;
-4.             log_max_error = 0;
-3.          }
-2.       }
-1. #ifdef PNG_READ_ALPHA_MODE_SUPPORTED

/*A component*/

1.       {
2.          if (do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED &&",Not Useful
/*Quantize this appropriately:*/,"-10.           * this encode input_sample adjusted by the maximum error (tmp) above.
-9.           */
-8.          es_lo = encoded_sample - vi->maxout;
-7.          if (es_lo > 0 && input_sample-tmp > 0)
-6.          {
-5.             double low_value = i",Not Useful
/*!use_input_precision*/,"-10.                      if (!(od < is_lo || od > is_hi))
-9.                      {
-8.                         if (encoded_error < vi->outlog)
-7.                            return i;
-6.                         pass = ""within 8 bit limits:\n"";
-5.    ",Not Useful
/*FALLTHROUGH*/,"-4.    switch (dp->output_colour_type)
-3.    {
-2.    case PNG_COLOR_TYPE_PALETTE:
-1.       if (dp->output_bit_depth > 8) goto error;

/*FALLTHROUGH*/

1.    case PNG_COLOR_TYPE_GRAY:
2.       if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 |",Not Useful
/*name' is the component name*/,"-2.             if (compose != do_compose)
-1.                png_error(vi->pp, ""internal error (compose)"");

/*name' is the component name*/

1.             pos = safecat(msg, sizeof msg, pos, name);
2.             pos = safecat(msg, sizeof msg, pos, ""(""",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an",Not Useful
/*No transform is expected on the threshold tests.*/,"-6.             }
-5.          }
-4.       }
-3.       else if (memcmp(std, pRow, cbRow) != 0)
-2.       {
-1.          char msg[64];

/*No transform is expected on the threshold tests.*/

1.          sprintf(msg, ""gamma: below threshold row %lu changed"",",Not Useful
/*row (y) loop*/,"-10.                out_pixel.blue, sample_depth, in_pixel.bluee,
-9.                dp->pm->limit + 1./(2*((1U<<in_pixel.blue_sBIT)-1)), ""blue"",
-8.                digitization_error);
-7.          if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0 &&
-6.         ",Not Useful
/*modifier_read expects a png_modifier**/,"-4.          modifier_progressive_read(d.pm, pp, pi);
-3.       }
-2.       else
-1.       {

/*modifier_read expects a png_modifier**/

1.          png_set_read_fn(pp, d.pm, modifier_read);",Not Useful
/*sBIT*/,"-7. #define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
-6. #define CHUNK_IHDR CHUNK(73,72,68,82)
-5. #define CHUNK_PLTE CHUNK(80,76,84,69)
-4. #define CHUNK_IDAT CHUNK(73,68,65,84)
-3. #define CHUNK_IEND CHUNK(73,69,78,68)
-2. #define CHUNK_cHRM CH",Not Useful
/*threshold test*/,"-10.    {
-9.       vi->sbit = dp->sbit;
-8.       vi->isbit_shift = in_depth - dp->sbit;
-7.    }
-6.    else
-5.    {
-4.       vi->sbit = (png_byte)in_depth;
-3.       vi->isbit_shift = 0;
-2.    }
-1.    vi->sbit_max = (1U << vi->sbit)-1;
   /* This m",Not Useful
/*no scale16*/,"-10. {
-9.    size_t pos = 0;
-8.    char name[64];
-7.    pos = safecat(name, sizeof name, pos, ""threshold "");
-6.    pos = safecatd(name, sizeof name, pos, file_gamma, 3);
-5.    pos = safecat(name, sizeof name, pos, ""/"");
-4.    pos = safecatd(name, si",Not Useful
/*hence*/,"-8. static int
-7. test_size(png_modifier* const pm, png_byte const colour_type,
-6.     int bdlo, int const bdhi)
-5. {
-4.    /* Run the tests on each combination.
-3.     *
-2.     * NOTE: on my 32 bit x86 each of the following blocks takes
-1.     * a",Not Useful
/*sBIT*/,"-7. #define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
-6. #define CHUNK_IHDR CHUNK(73,72,68,82)
-5. #define CHUNK_PLTE CHUNK(80,76,84,69)
-4. #define CHUNK_IDAT CHUNK(73,68,65,84)
-3. #define CHUNK_IEND CHUNK(73,69,78,68)
-2. #define CHUNK_cHRM CH",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int      ",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int      ",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int      ",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int      ",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int      ",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          brea",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          brea",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          brea",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          brea",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          brea",Not Useful
/*sBIT*/,"-7. #define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
-6. #define CHUNK_IHDR CHUNK(73,72,68,82)
-5. #define CHUNK_PLTE CHUNK(80,76,84,69)
-4. #define CHUNK_IDAT CHUNK(73,68,65,84)
-3. #define CHUNK_IEND CHUNK(73,69,78,68)
-2. #define CHUNK_cHRM CH",Not Useful
/*strip 16*/,"-4. #     ifdef PNG_READ_ACCURATE_SCALE_SUPPORTED
-3. #        if PNG_LIBPNG_VER >= 10504
-2. #           error PNG_READ_ACCURATE_SCALE should not be set
-1. #        endif
         /* The strip 16 algorithm drops the low 8 bits rather than calculating

/",Not Useful
/*who*/,"-2.    ps->cb_row = cbRow;
-1.    ps->image_h = cRows;
   /* For error checking, the whole buffer is set to 10110010 (0xb2 - 178).

/*who*/

1.     * This deliberately doesn't match the bits in the size test image which are
2.     * outside the image; the",Not Useful
/*Should be READ_16BIT_SUPPORTED*/,"-3.       if (fail(pm))
-2.          return;
-1.    }

/*Should be READ_16BIT_SUPPORTED*/

1.    if (pm->test_gamma_scale16)
2.    {",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

111",Not Useful
/*Is row 'y' in pass 'pass'?*/,"-4. }
-3. static int
-2. png_row_in_interlace_pass(png_uint_32 y, int pass)
-1. {

/*Is row 'y' in pass 'pass'?*/

1.    int x;
2.    y &= 7;
3.    ++pass;
4.    for (x=0; x<8; ++x) if (adam7[y][x] == pass)
5.       return 1;
6.    return 0;
7. }
8. stati",Not Useful
/*Is column 'x' in pass 'pass'?*/,"-10.    int x;
-9.    y &= 7;
-8.    ++pass;
-7.    for (x=0; x<8; ++x) if (adam7[y][x] == pass)
-6.       return 1;
-5.    return 0;
-4. }
-3. static int
-2. png_col_in_interlace_pass(png_uint_32 x, int pass)
-1. {

/*Is column 'x' in pass 'pass'?*/

1. ",Not Useful
/*Kodak ProPhoto (wide gamut)*/,"-10.  * The png_modifier code assumes that encodings[0] is sRGB and treats it
-9.  * specially: do not change the first entry in this list!
-8.  */
-7. static const color_encoding test_encodings[] =
-6. {

/*Kodak ProPhoto (wide gamut)*/

111",Not Useful
/*png_structp*/,"
#  define png_const_structp png_structp



/*png_structp*/

1. #endif
2. #ifndef RELEASE_BUILD",Not Useful
/*main program*/,"-10.     */
-9.    if (signum != SIGTERM)
-8.    {
-7.       struct exception_context *the_exception_context =
-6.          &pm.this.exception_context;
-5.       Throw &pm.this;
-4.    }
-3.    else
-2.       exit(1);
-1. }

/*main program*/

1. int main(",Not Useful
/*And the test encodings*/,"-10.     * this is fixed turn them off for some gamma cases:
-9.     */
-8. #  ifdef PNG_WRITE_tRNS_SUPPORTED
-7.       pm.test_tRNS = 1;
-6. #  endif
-5.    pm.test_lbg = PNG_LIBPNG_VER >= 10600;
-4.    pm.test_lbg_gamma_threshold = 1;
-3.    pm.test_lbg",Not Useful
/*1/20000*/,"-10.    pm.use_input_precision_16to8 = 1U;

/*1/20000*/

111",Not Useful
/*1/20000*/,"-10.    pm.use_input_precision_16to8 = 1U;

/*1/20000*/

111",Not Useful
"/*I.e., 1/200% - 1/20000*/","-10.       pm.maxcalcG = 1./((1<<16)-1);
-9. #  endif

/*I.e., 1/200% - 1/20000*/

111",Not Useful
/*PNG_READ_TRANSFORMS_SUPPORTED*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, ",Not Useful
/*!CAN_WRITE_INTERLACE*/,"-4.       else if (strcmp(*argv, ""--interlace"") == 0)
-3.       {
-2. #        if CAN_WRITE_INTERLACE
-1.             pm.interlace_type = PNG_INTERLACE_ADAM7;

/*!CAN_WRITE_INTERLACE*/

1.             fprintf(stderr, ""pngvalid: no write interlace support\",Not Useful
/*!CAN_WRITE_INTERLACE*/,"-4.       else if (strcmp(*argv, ""--interlace"") == 0)
-3.       {
-2. #        if CAN_WRITE_INTERLACE
-1.             pm.interlace_type = PNG_INTERLACE_ADAM7;

/*!CAN_WRITE_INTERLACE*/

1.             fprintf(stderr, ""pngvalid: no write interlace support\",Not Useful
/*PNG_SET_OPTION_SUPPORTED*/,"-10. #     ifdef PNG_USER_MEM_SUPPORTED
-9.          if (!ps->speed)
-8.             ps->pwrite = png_create_write_struct_2(PNG_LIBPNG_VER_STRING,
-7.                ps, store_error, store_warning, &ps->write_memory_pool,
-6.                store_malloc, ",Not Useful
/*consumed an extra *argv*/,"-5.       else
-4.       {
-3.          fprintf(stderr, ""pngvalid: %s: unknown argument\n"", *argv);
-2.          exit(99);
-1.       }

/*consumed an extra *argv*/

1.       {
2.          cp = safecat(command, sizeof command, cp, "" "");
3.          cp = sa",Not Useful
/*Nothing to test so turn everything off:*/,"-10.    {
-9.       pm.test_gamma_threshold = 1;
-8.       pm.test_gamma_transform = 1;
-7.       pm.test_gamma_sbit = 1;
-6.       pm.test_gamma_scale16 = 1;
-5.       pm.test_gamma_background = 1;
-4.       pm.test_gamma_alpha_mode = 1;
-3.    }
-2.    ",Not Useful
/*Combinatorial transforms:*/,"-8.       if (pm.test_size)
-7.       {
-6.          make_size_images(&pm.this);
-5. #        ifdef PNG_READ_SUPPORTED
-4.             perform_size_test(&pm);
-3. #        endif
-2.       }
-1. #ifdef PNG_READ_TRANSFORMS_SUPPORTED

/*Combinatorial transfo",Not Useful
/*PNG_READ_TRANSFORMS_SUPPORTED*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, ",Not Useful
/*So the test is skipped:*/,"-4. int main(void)
-3. {
-2.    fprintf(stderr,
-1.       ""pngvalid: no low level write support in libpng, all tests skipped\n"");

/*So the test is skipped:*/

1.    return SKIP;
2. }
3. #endif",Not Useful
/*!EOF*/,"-5.    for (i=8; i; i--)
-4.    {
-3.       GETBREAK;
-2.       putchar(c);
-1.    }

/*!EOF*/

1. for (;;)
2.  {",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will ",Not Useful
/*Calculate the CRC*/,"-1.          break;

/*Calculate the CRC*/

1.       crc = crc32(crc, buf+4, (uInt)length+4);
2.       for (;;)
3.       {",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will ",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will ",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will ",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will ",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp+",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp+",Not Useful
"/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/","-5.             png_bytep sp, dp;
-4.             png_uint_32 i;
-3.             png_uint_32 row_width = row_info->width;
-2.             for (i = 0, sp = dp = row; i < row_width; i++)
-1.             {
               /* Does nothing
               *(dp++",Not Useful
"/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/","-5.             png_bytep sp, dp;
-4.             png_uint_32 i;
-3.             png_uint_32 row_width = row_info->width;
-2.             for (i = 0, sp = dp = row; i < row_width; i++)
-1.             {
               /* Does nothing
               *(dp++",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp+",Not Useful
"/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/","-5.             png_bytep sp, dp;
-4.             png_uint_32 i;
-3.             png_uint_32 row_width = row_info->width;
-2.             for (i = 0, sp = dp = row; i < row_width; i++)
-1.             {
               /* Does nothing
               *(dp++",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp+",Not Useful
/*png_ptr*/,"
png_do_write_transformations(png_structrp png_ptr, png_row_infop row_info)



/*png_ptr*/

1. {
2.    png_debug(1, ""in png_do_write_transformations"");
3.    if (png_ptr == NULL)
4.       return;
5. #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
6.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
7.       if (png_ptr->write_user_transform_fn != NULL)",Not Useful
/*row_info:*/,"-10. {
-9.    png_debug(1, ""in png_do_write_transformations"");
-8.    if (png_ptr == NULL)
-7.       return;
-6. #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-5.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-4.       if (png_ptr->write_user_t",Not Useful
/*png_uint_32 width;       width of row*/,"-10.    png_debug(1, ""in png_do_write_transformations"");
-9.    if (png_ptr == NULL)
-8.       return;
-7. #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-6.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-5.       if (png_ptr->write_user_transfo",Not Useful
/*WRITE_TRANSFORMS*/,"-10.  * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
-9.  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
-8.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
-7.  *
-6.  * This code is released under t",Not Useful
/*FLOATING_POINT*/,"-10.    XYZ.green_Y = int_green_Y;
-9.    XYZ.green_Z = int_green_Z;
-8.    XYZ.blue_X = int_blue_X;
-7.    XYZ.blue_Y = int_blue_Y;
-6.    XYZ.blue_Z = int_blue_Z;
-5.    if (png_colorspace_set_endpoints(png_ptr, &info_ptr->colorspace,
-4.        &XYZ, 2",Not Useful
/*cHRM*/,"-10. png_set_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_16p background)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""bKGD"");
-6.    if (png_ptr == NULL || info_ptr == NULL || background == NULL)
-5.       return",Not Useful
/*eXIf*/,"
#ifdef PNG_eXIf_SUPPORTED



/*eXIf*/

1. void PNGAPI
2. png_set_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,
3.     const png_bytep eXIf_buf)
4. {
5.   png_warning(png_ptr, ""png_set_eXIf does not work; use png_set_eXIf_1"");
6.   PNG_UNUSED(info_ptr)
7.   PNG_UNUSED(eXIf_buf)
8. }
9. void PNGAPI
10. png_set_eXIf_1(png_const_structrp png_ptr, png_inforp info_ptr,",Not Useful
/*Validate params[nparams]*/,"-10.       png_chunk_report(png_ptr, ""Invalid pCAL equation type"",
-9.             PNG_CHUNK_WRITE_ERROR);
-8.       return;
-7.    }
-6.    if (nparams < 0 || nparams > 255)
-5.    {
-4.       png_chunk_report(png_ptr, ""Invalid pCAL parameter count"",
-3.",Not Useful
/*-'*/,"-3.    if (unit != 1 && unit != 2)
-2.       png_error(png_ptr, ""Invalid sCAL unit"");
-1.    if (swidth == NULL || (lengthw = strlen(swidth)) == 0 ||

/*-'*/

1.       png_error(png_ptr, ""Invalid sCAL width"");
2.    if (sheight == NULL || (lengthh = strle",Not Useful
/*-'*/,"-3.    if (unit != 1 && unit != 2)
-2.       png_error(png_ptr, ""Invalid sCAL unit"");
-1.    if (swidth == NULL || (lengthw = strlen(swidth)) == 0 ||

/*-'*/

1.       png_error(png_ptr, ""Invalid sCAL width"");
2.    if (sheight == NULL || (lengthh = strle",Not Useful
/*sRGB*/,"-10. png_set_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_8p sig_bit)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""sBIT"");
-6.    if (png_ptr == NULL || info_ptr == NULL || sig_bit == NULL)
-5.       return;
-4.  ",Not Useful
/*iTXt*/,"-10.              PNG_CHUNK_WRITE_ERROR);
-9.          continue;
-8.       }
-7.       key_len = strlen(text_ptr[i].key);
-6.       if (text_ptr[i].compression <= 0)
-5.       {
-4.          lang_len = 0;
-3.          lang_key_len = 0;
-2.       }
-1.    ",Not Useful
/*sPLT*/,"-10.          num_trans = 1;
-9.    }
-8.    info_ptr->num_trans = (png_uint_16)num_trans;
-7.    if (num_trans != 0)
-6.    {
-5.       info_ptr->valid |= PNG_INFO_tRNS;
-4.       info_ptr->free_me |= PNG_FREE_TRNS;
-3.    }
-2. }
-1. #endif
#ifdef PNG_s",Not Useful
/*Use the old behavior*/,"-2.       png_app_warning(png_ptr,
-1.           ""png_set_unknown_chunks now expects a valid location"");

/*Use the old behavior*/

1.       location = (png_byte)(png_ptr->mode &
2.           (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT));
3.    }",Not Useful
/*But just skip storing the unknown chunk*/,"-10.          np->size = 0;
-9.       }
-8.       else
-7.       {
-6.          np->data = png_voidcast(png_bytep,
-5.              png_malloc_base(png_ptr, unknowns->size));
-4.          if (np->data == NULL)
-3.          {
-2.             png_chunk_repo",Not Useful
/*undocumented!*/,"-10.     *
-9.     * TODO: add a png_app_warning in 1.7
-8.     */
-7.    if (png_ptr != NULL && info_ptr != NULL && chunk >= 0 &&
-6.       chunk < info_ptr->unknown_chunks_num)
-5.    {
-4.       if ((location & (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_ID",Not Useful
/*also undocumented*/,"-2.             location = PNG_AFTER_IDAT;
-1.          else

/*also undocumented*/

1.       }
2.       info_ptr->unknown_chunks[chunk].location =
3.          check_location(png_ptr, location);
4.    }
5. }",Not Useful
/*STORE_UNKNOWN_CHUNKS*/,"
#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED



/*STORE_UNKNOWN_CHUNKS*/

1. static png_byte
2. check_location(png_const_structrp png_ptr, int location)
3. {
4.    location &= (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT);",Not Useful
/*bKGD*/,#NAME?,Not Useful
/*cHRM*/,"-10. png_set_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_16p background)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""bKGD"");
-6.    if (png_ptr == NULL || info_ptr == NULL || background == NULL)
-5.       return",Not Useful
/*eXIf*/,"
#ifdef PNG_eXIf_SUPPORTED



/*eXIf*/

1. void PNGAPI
2. png_set_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,
3.     const png_bytep eXIf_buf)
4. {
5.   png_warning(png_ptr, ""png_set_eXIf does not work; use png_set_eXIf_1"");
6.   PNG_UNUSED(info_ptr)
7.   PNG_UNUSED(eXIf_buf)
8. }
9. void PNGAPI
10. png_set_eXIf_1(png_const_structrp png_ptr, png_inforp info_ptr,",Not Useful
/*gAMA*/,"
#ifdef PNG_gAMA_SUPPORTED



/*gAMA*/

1. void PNGFAPI
2. png_set_gAMA_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_fixed_point file_gamma)
4. {
5.    png_debug1(1, ""in %s storage function"", ""gAMA"");
6.    if (png_ptr == NULL || info_ptr == NULL)
7.       return;
8.    png_colorspace_set_gamma(png_ptr, &info_ptr->colorspace, file_gamma);
9.    png_colorspace_sync_info(png_ptr, info_ptr);
10. }",Not Useful
/*hIST*/,"-10. }
-9. #  ifdef PNG_FLOATING_POINT_SUPPORTED
-8. void PNGAPI
-7. png_set_gAMA(png_const_structrp png_ptr, png_inforp info_ptr, double file_gamma)
-6. {
-5.    png_set_gAMA_fixed(png_ptr, info_ptr, png_fixed(png_ptr, file_gamma,
-4.        ""png_set_gAM",Not Useful
/*iCCP*/,"
#ifdef PNG_iCCP_SUPPORTED



/*iCCP*/

1. void PNGAPI
2. png_set_iCCP(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_const_charp name, int compression_type,
4.     png_const_bytep profile, png_uint_32 proflen)
5. {
6.    png_charp new_iccp_name;
7.    png_bytep new_iccp_profile;
8.    png_size_t length;
9.    png_debug1(1, ""in %s storage function"", ""iCCP"");
10.    if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)",Not Useful
/*iTXt*/,"-10.              PNG_CHUNK_WRITE_ERROR);
-9.          continue;
-8.       }
-7.       key_len = strlen(text_ptr[i].key);
-6.       if (text_ptr[i].compression <= 0)
-5.       {
-4.          lang_len = 0;
-3.          lang_key_len = 0;
-2.       }
-1.    ",Not Useful
/*oFFs*/,"-10.       info_ptr->channels = 1;
-9.    else if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
-8.       info_ptr->channels = 3;
-7.    else
-6.       info_ptr->channels = 1;
-5.    if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
-4.      ",Not Useful
/*pCAL*/,"-10. {
-9.    png_debug1(1, ""in %s storage function"", ""oFFs"");
-8.    if (png_ptr == NULL || info_ptr == NULL)
-7.       return;
-6.    info_ptr->x_offset = offset_x;
-5.    info_ptr->y_offset = offset_y;
-4.    info_ptr->offset_unit_type = (png_byte)unit",Not Useful
/*pHYs*/,"-9.       char swidth[PNG_sCAL_MAX_DIGITS+1];
-8.       char sheight[PNG_sCAL_MAX_DIGITS+1];
-7.       png_ascii_from_fixed(png_ptr, swidth, (sizeof swidth), width);
-6.       png_ascii_from_fixed(png_ptr, sheight, (sizeof sheight), height);
-5.       png",Not Useful
/*sBIT*/,"-10.    png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,
-9.        PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));
-8.    if (num_palette > 0)
-7.       memcpy(png_ptr->palette, palette, (unsigned int)num_palette *
-6.           (sizeof (",Not Useful
/*sCAL*/,"-10.       {
-9.          png_warning(png_ptr, ""Insufficient memory for pCAL parameter"");
-8.          return;
-7.       }
-6.       memcpy(info_ptr->pcal_params[i], params[i], length);
-5.    }
-4.    info_ptr->valid |= PNG_INFO_pCAL;
-3.    info_ptr->fr",Not Useful
/*sPLT*/,"-10.          num_trans = 1;
-9.    }
-8.    info_ptr->num_trans = (png_uint_16)num_trans;
-7.    if (num_trans != 0)
-6.    {
-5.       info_ptr->valid |= PNG_INFO_tRNS;
-4.       info_ptr->free_me |= PNG_FREE_TRNS;
-3.    }
-2. }
-1. #endif
#ifdef PNG_s",Not Useful
/*sTER*/,"-10.         103,  65,  77,  65, '\0',  /* gAMA */
-9.         104,  73,  83,  84, '\0',  /* hIST */
-8.         105,  67,  67,  80, '\0',  /* iCCP */
-7.         105,  84,  88, 116, '\0',  /* iTXt */
-6.         111,  70,  70, 115, '\0',  /* oFFs */
-5. ",Not Useful
/*sRGB*/,"-10. png_set_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_8p sig_bit)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""sBIT"");
-6.    if (png_ptr == NULL || info_ptr == NULL || sig_bit == NULL)
-5.       return;
-4.  ",Not Useful
/*tEXt*/,"-10.         105,  67,  67,  80, '\0',  /* iCCP */
-9.         105,  84,  88, 116, '\0',  /* iTXt */
-8.         111,  70,  70, 115, '\0',  /* oFFs */
-7.         112,  67,  65,  76, '\0',  /* pCAL */
-6.         112,  72,  89, 115, '\0',  /* pHYs */
-5. ",Not Useful
/*tIME*/,"-10.       {
-9.          textp->text_length = text_length;
-8.          textp->itxt_length = 0;
-7.       }
-6.       info_ptr->num_text++;
-5.       png_debug1(3, ""transferred text chunk %d"", info_ptr->num_text);
-4.    }
-3.    return(0);
-2. }
-1. #en",Not Useful
/*zTXt*/,"-10.         111,  70,  70, 115, '\0',  /* oFFs */
-9.         112,  67,  65,  76, '\0',  /* pCAL */
-8.         112,  72,  89, 115, '\0',  /* pHYs */
-7.         115,  66,  73,  84, '\0',  /* sBIT */
-6.         115,  67,  65,  76, '\0',  /* sCAL */
-5. ",Not Useful
/*SAFE*/,"-10.         115,  66,  73,  84, '\0',  /* sBIT */
-9.         115,  67,  65,  76, '\0',  /* sCAL */
-8.         115,  80,  76,  84, '\0',  /* sPLT */
-7.         115,  84,  69,  82, '\0',  /* sTER */
-6.         115,  82,  71,  66, '\0',  /* sRGB */
-5. ",Not Useful
/*num_chunks_in > 0*/,"-4.       };
-3.       chunk_list = chunks_to_ignore;

/*num_chunks_in > 0*/

1.    {
2.       if (chunk_list == NULL)
3.       {",Not Useful
/*must fit*/,"-4.       if (size > ZLIB_IO_MAX)
-3.       {
-2.          png_warning(png_ptr,
-1.              ""Compression buffer size limited to system maximum"");

/*must fit*/

1.       }
2. #endif
3.       if (size < 6)
4.       {",Not Useful
"/*Deflate will potentially go into an infinite loop on a SYNC_FLUSH
          * if this is permitted.*/","-4.       }
-3. #endif
-2.       if (size < 6)
-1.       {
         /* Deflate will potentially go into an infinite loop on a SYNC_FLUSH
          * if this is permitted.

/*Deflate will potentially go into an infinite loop on a SYNC_FLUSH
          * if ",Not Useful
/*?SET_USER_LIMITS*/,"-7. void PNGAPI
-6. png_set_chunk_malloc_max (png_structrp png_ptr,
-5.     png_alloc_size_t user_chunk_malloc_max)
-4. {
-3.    if (png_ptr != NULL)
-2.       png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;
-1. }

/*?SET_USER_LIMITS*/

1. #ifdef ",Not Useful
/*BENIGN_ERRORS*/,"
#ifdef PNG_BENIGN_ERRORS_SUPPORTED



/*BENIGN_ERRORS*/

1. void PNGAPI
2. png_set_benign_errors(png_structrp png_ptr, int allowed)
3. {
4.    png_debug(1, ""in png_set_benign_errors"");",Not Useful
/*&& ch <= 255*/,"-10.    int space = 1;
-9.    png_debug(1, ""in png_check_keyword"");
-8.    if (key == NULL)
-7.    {
-6.       *new_key = 0;
-5.       return 0;
-4.    }
-3.    while (*key && key_len < 79)
-2.    {
-1.       png_byte ch = (png_byte)*key++;

/*&& ch <= 25",Not Useful
/*Terminate the keyword*/,"-5.    {
-4.       --key_len; --new_key;
-3.       if (bad_character == 0)
-2.          bad_character = 32;
-1.    }

/*Terminate the keyword*/

1.    *new_key = 0;
2.    if (key_len == 0)
3.       return 0;
4. #ifdef PNG_WARNINGS_SUPPORTED",Not Useful
/*keyword too long*/,"-5.    *new_key = 0;
-4.    if (key_len == 0)
-3.       return 0;
-2. #ifdef PNG_WARNINGS_SUPPORTED

/*keyword too long*/

1.       png_warning(png_ptr, ""keyword truncated"");
2.    else if (bad_character != 0)
3.    {
4.       PNG_WARNING_PARAMETERS(p)
5.",Not Useful
/*!WARNINGS*/,"-8.       png_warning(png_ptr, ""keyword truncated"");
-7.    else if (bad_character != 0)
-6.    {
-5.       PNG_WARNING_PARAMETERS(p)
-4.       png_warning_parameter(p, 1, orig_key);
-3.       png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_02x, bad_",Not Useful
/*!WARNINGS*/,"-8.       png_warning(png_ptr, ""keyword truncated"");
-7.    else if (bad_character != 0)
-6.    {
-5.       PNG_WARNING_PARAMETERS(p)
-4.       png_warning_parameter(p, 1, orig_key);
-3.       png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_02x, bad_",Not Useful
/*TEXT || pCAL || iCCP || sPLT*/,"-2.    return key_len;
-1. }

/*TEXT || pCAL || iCCP || sPLT*/

111",Not Useful
/*pHYs*/,"-10. png_get_compression_type(png_const_structrp png_ptr, png_const_inforp info_ptr)
-9. {
-8.    if (png_ptr != NULL && info_ptr != NULL)
-7.       return info_ptr->compression_type;
-6.    return (0);
-5. }
-4. png_uint_32 PNGAPI
-3. png_get_x_pixels_pe",Not Useful
/*INCH_CONVERSIONS*/,"-10.       png_debug1(1, ""in %s retrieval function"", ""png_get_y_offset_pixels"");
-9.       if (info_ptr->offset_unit_type == PNG_OFFSET_PIXEL)
-8.          return (info_ptr->y_offset);
-7.    }
-6. #else
-5.    PNG_UNUSED(png_ptr)
-4.    PNG_UNUSED(info_p",Not Useful
/*EASY_ACCESS*/,"-10. }
-9. #ifdef PNG_INFO_IMAGE_SUPPORTED
-8. png_bytepp PNGAPI
-7. png_get_rows(png_const_structrp png_ptr, png_const_inforp info_ptr)
-6. {
-5.    if (png_ptr != NULL && info_ptr != NULL)
-4.       return(info_ptr->row_pointers);
-3.    return(0);
-2. ",Not Useful
/*FLOATING_ARITHMETIC*/,"-10.       *nparams = (int)info_ptr->pcal_nparams;
-9.       *units = info_ptr->pcal_units;
-8.       *params = info_ptr->pcal_params;
-7.       return (PNG_INFO_pCAL);
-6.    }
-5.    return (0);
-4. }
-3. #endif
-2. #ifdef PNG_sCAL_SUPPORTED
-1. #  ifde",Not Useful
/*FIXED_POINT*/,"-10.          return ((float)((float)info_ptr->y_pixels_per_unit
-9.              /(float)info_ptr->x_pixels_per_unit));
-8.    }
-7. #else
-6.    PNG_UNUSED(png_ptr)
-5.    PNG_UNUSED(info_ptr)
-4. #endif
-3.    return ((float)0.0);
-2. }
-1. #endif
#ifd",Not Useful
/*sCAL*/,"-10.       *X1 = info_ptr->pcal_X1;
-9.       *type = (int)info_ptr->pcal_type;
-8.       *nparams = (int)info_ptr->pcal_nparams;
-7.       *units = info_ptr->pcal_units;
-6.       *params = info_ptr->pcal_params;
-5.       return (PNG_INFO_pCAL);
-4.    ",Not Useful
/*pHYs*/,"-10. png_get_compression_type(png_const_structrp png_ptr, png_const_inforp info_ptr)
-9. {
-8.    if (png_ptr != NULL && info_ptr != NULL)
-7.       return info_ptr->compression_type;
-6.    return (0);
-5. }
-4. png_uint_32 PNGAPI
-3. png_get_x_pixels_pe",Not Useful
/*SET_USER_LIMITS*/,"-10.       return png_ptr->IDAT_read_size;
-9. #else
-8.       return PNG_IDAT_READ_SIZE;
-7. #endif
-6.    }
-5. #ifdef PNG_WRITE_SUPPORTED
-4.    else
-3.       return png_ptr->zbuffer_size;
-2. #endif
-1. }
#ifdef PNG_SET_USER_LIMITS_SUPPORTED

/*SET_U",Not Useful
/*IO_STATE*/,"
#ifdef PNG_IO_STATE_SUPPORTED



/*IO_STATE*/

1. png_uint_32 PNGAPI
2. png_get_io_state (png_const_structrp png_ptr)
3. {
4.    return png_ptr->io_state;
5. }
6. png_uint_32 PNGAPI
7. png_get_io_chunk_type (png_const_structrp png_ptr)
8. {
9.    return png_ptr->chunk_name;
10. }",Not Useful
/*1.6.3*/,"-2. /* pngfix.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*1.6.3*/

1.  * Copyright (c) 2014-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see the disc",Not Useful
/*__cplusplus*/,"
#ifdef __cplusplus



/*__cplusplus*/

1. #  define voidcast(type, value) static_cast<type>(value)
2. #  define constcast(type, value) const_cast<type>(value)
3. #  define aligncast(type, value) \
4.    static_cast<type>(static_cast<void*>(value))
5. #  define aligncastconst(type, value) \
6.    static_cast<type>(static_cast<const void*>(value))
7. #else
8. #  define voidcast(type, value) (value)
9. #  define constcast(type, value) ((type)(value))
10. #  define aligncast(type, value) ((void*)(value))",Not Useful
/*Chunk tags (copied from pngpriv.h)*/,"-1. #if PNG_LIBPNG_VER < 10700

/*Chunk tags (copied from pngpriv.h)*/

1. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
2. #define PNG_U32(b1,b2,b3,b4) \
3.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))",Not Useful
/*deprecated*/,"-2. #define png_gAMA PNG_U32(103,  65,  77,  65)
-1. #define png_gIFg PNG_U32(103,  73,  70, 103)

/*deprecated*/

1. #define png_gIFx PNG_U32(103,  73,  70, 120)
2. #define png_hIST PNG_U32(104,  73,  83,  84)
3. #define png_iCCP PNG_U32(105,  67,  67,  ",Not Useful
/*Is the chunk critical?*/,"-2. #define sig1 PNG_U32(137,  80,  78,  71)
-1. #define sig2 PNG_U32( 13,  10,  26,  10)

/*Is the chunk critical?*/

1. #define CRITICAL(chunk) (((chunk) & PNG_U32(32,0,0,0)) == 0)",Not Useful
/*Is it safe to copy?*/,"-1. #define CRITICAL(chunk) (((chunk) & PNG_U32(32,0,0,0)) == 0)

/*Is it safe to copy?*/

1. #define SAFE_TO_COPY(chunk) (((chunk) & PNG_U32(0,0,0,32)) != 0)",Not Useful
/*may be 0*/,"-10.    }
-9.    while (add != 0 && add != (-1))
-8.    {
-7.       num[out_digits++] = (png_uint_16)(add & 0xffff);
-6.       add >>= 16;
-5.    }
-4.    if (add == 0)
-3.    {
-2.       while (out_digits > 0 && num[out_digits-1] == 0)
-1.          --out",Not Useful
/*UNUSED*/,"-10.       return -1;
-9.    if (adigits > bdigits)
-8.       return 1;
-7.    while (adigits-- > 0)
-6.       if (a[adigits] < b[adigits])
-5.          return -1;
-4.       else if (a[adigits] > b[adigits])
-3.          return 1;
-2.    return 0;
-1. }

",Not Useful
/**************************** CONTROL INFORMATION *****************************/,"-4.    c -= PNG_U32(25,25,25,26);
-3.    t |= ~c;
-2.    return (t & 0xe0e0e0e0) == 0;
-1. }

/**************************** CONTROL INFORMATION *****************************/

111",Not Useful
/*Everything but tRNS and sBIT*/,"-6. #     define SKIP_NONE      0

/*Everything but tRNS and sBIT*/

111",Not Useful
/*0 to perform no re-chunking*/,"-7. #     define SKIP_NONE      0

/*0 to perform no re-chunking*/

111",Not Useful
/*truncated but still readable*/,"-10. #     define SKIP_UNSAFE    2    /* Chunks not safe to copy */
-9. #     define SKIP_UNUSED    3    /* Chunks not used by libpng */
-8. #     define SKIP_TRANSFORM 4    /* Chunks only used in transforms */
-7. #     define SKIP_COLOR     5    /* Ever",Not Useful
/*Never strip critical chunks:*/,"-1. {

/*Never strip critical chunks:*/

1.    if (CRITICAL(type))
2.       return 0;
3.    switch (type)
4.    {",Not Useful
/*as above*/,"-3.       default:
-2.          if (SAFE_TO_COPY(type))
-1.          {

/*as above*/

1.                return 1;
2.          }
3.          else if (global->skip >= SKIP_UNSAFE)
4.             return 1;
5.          return 0;
6.    }
7. }",Not Useful
/*IHDR information*/,"-7.    const char *   file_name;

/*IHDR information*/

1.    png_uint_32    width;
2.    png_uint_32    height;
3.    png_byte       bit_depth;
4.    png_byte       color_type;
5.    png_byte       compression_method;
6.    png_byte       filter_method;
",Not Useful
/*Open the files:*/,"-6.    file->read_count = 0;
-5.    file->state = STATE_SIGNATURE;
-4.    file->chunk = NULL;
-3.    file->idat = NULL;
-2.    file->alloc_ptr = alloc_ptr;
-1.    file->alloc = alloc;

/*Open the files:*/

1.    assert(file_name != NULL);
2.    file->file",Not Useful
/*need two quiets to stop this.*/,"-10.     * finding errors in the previous chunks.  We know that is happening because
-9.     * we are at the start of the IDAT (i.e. no IDAT data has yet been written.)
-8.     *
-7.     * SUMMARY FORMAT (stop):
-6.     *
-5.     * IDAT ERR status code re",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*Truncated*/,"-10.     * if the input is truncated.
-9.     */
-8. {
-7.    if (length > 0)
-6.    {
-5.       png_uint_32 crc = file->crc;
-4.       do
-3.       {
-2.          int ch = read_byte(file);
-1.          if (ch == EOF)

/*Truncated*/

1.          crc = crc",Not Useful
/*OK*/,"-5.          crc = crc_one_byte(crc, ch);
-4.       }
-3.       while (--length > 0);
-2.       file->crc = crc;
-1.    }

/*OK*/

1. }
2. static int
3. calc_image_size(struct file *file)",Not Useful
/*g*/,"
/* pngfix.c



/*g*/

1.  *
2.  * Last changed in libpng 1.6.31 [July 27, 2017]
3.  * Copyright (c) 2014-2017 John Cunningham Bowler
4.  *
5.  * This code is released under the libpng license.
6.  * For conditions of distribution and use, see the disclaimer
7.  * and license in png.h
8.  *
9.  * Tool to check and fix the zlib inflate 'too far back' problem.
10.  * See the usage message for more information.",Not Useful
/*ga*/,"-10.     * pngfix.c:
-9.     * In function 'zlib_advance':
-8.     * pngfix.c:181:13: error: assuming signed overflow does not
-7.     *   occur when simplifying conditional to constant [-Werror=strict-overflow]
-6.     */
-5. #  define FIX_GCC volatile
-",Not Useful
/*calculate 1+((pw*pd+7)>>3) in row_bytes*/,"-10.          {
-9.             int pass;
-8.             int image_digits = 0;
-7.             udigit row_width[2], row_bytes[3];
-6.             for (pass=0; pass<=6; ++pass)
-5.             {
-4.                png_uint_32 pw = PNG_PASS_COLS(file->widt",Not Useful
/*magic*/,"-4.       else
-3.          type = file->type;
-2.       if (type)
-1.          type_name(type, stdout);

/*magic*/

111",Not Useful
/*skip*/,"-10.       while (out_digits < n_digits || carry > 0)
-9.       {
-8.          if (out_digits < a_digits)
-7.             carry += acc[out_digits];
-6.          if (out_digits < n_digits)
-5.             carry += (png_uint_32)num[out_digits] * val;
-4.   ",Not Useful
/*Like zTXt but more fields.*/,"-4. }
-3. static int
-2. process_iTXt(struct file *file)
-1. {

/*Like zTXt but more fields.*/

1.    struct chunk *chunk = file->chunk;
2.    png_uint_32 length;
3.    png_uint_32 index = 0;
4.    assert(chunk != NULL && file->idat == NULL);
5.    length",Not Useful
/*Skip the translated keyword*/,"-1.             {

/*Skip the translated keyword*/

1.                while (length >= 8)
2.                {
3.                   --length;
4.                   ++index;",Not Useful
/*skip*/,"-10.       while (out_digits < n_digits || carry > 0)
-9.       {
-8.          if (out_digits < a_digits)
-7.             carry += acc[out_digits];
-6.          if (out_digits < n_digits)
-5.             carry += (png_uint_32)num[out_digits] * val;
-4.   ",Not Useful
/*chunk*/,"-3. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
-2. #define PNG_U32(b1,b2,b3,b4) \
-1.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))

/*chunk*/

1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
2. #define png_IEND PNG_U32( 73,  69",Not Useful
/*use the cache*/,"-4.    {
-3.       const struct IDAT_list *cur;
-2.       unsigned int count;
-1.       if (start)

/*use the cache*/

111",Not Useful
/*rechunking*/,"-5.    file->idat = idat;
-4. }
-3. static png_uint_32
-2. rechunk_length(struct IDAT *idat, int start)
-1.    /* Return the length for the next IDAT chunk, taking into account
    * rechunking.

/*rechunking*/

1.     */
2. {
3.    png_uint_32 len = idat",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*unset*/,"-1.    zlib->file_bits = 24;

/*unset*/

111",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLT",Not Useful
/*keep going*/,"-10.    if (cb >   256) return  9;
-9.    return 8;
-8. }
-7. static int
-6. zlib_advance(struct zlib *zlib, png_uint_32 nbytes)
-5.    /* Read nbytes compressed bytes; the stream will be initialized if required.
-4.     * Bytes are always being reread an",Not Useful
/*stop*/,"-1. };

/*stop*/

111",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLT",Not Useful
/*expected*/,"-8. };

/*expected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLT",Not Useful
/*The loop guarantees this*/,"-5.          {
-4.             zlib_end(&zlib);
-3.             return 0;
-2.          }
-1.       }

/*The loop guarantees this*/

1.       assert(zlib.ok_bits == max_bits);
2.       zlib_end(&zlib);
3.       return 1;
4.    }",Not Useful
/*This will cause an IEND with a bad CRC to stop*/,"-2.       if (file->global->skip != SKIP_BAD_CRC)
-1.          type_message(file, type, ""bad CRC"");

/*This will cause an IEND with a bad CRC to stop*/

1.       else if (CRITICAL(type))
2.          stop(file, READ_ERROR_CODE, ""bad CRC in critical chunk"")",Not Useful
/*chunk*/,"-3. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
-2. #define PNG_U32(b1,b2,b3,b4) \
-1.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))

/*chunk*/

1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
2. #define png_IEND PNG_U32( 73,  69",Not Useful
"/*or, nused &= 7 ;-)*/","-1.                nread -= nused & ~7;

/*or, nused &= 7 ;-)*/

111",Not Useful
/*IEND*/,"-1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
#define png_IEND PNG_U32( 73,  69,  78,  68)

/*IEND*/

1. #define png_IHDR PNG_U32( 73,  72,  68,  82)
2. #define png_PLTE PNG_U32( 80,  76,  84,  69)
3. #define png_bKGD PNG_U32( 98,  75,  71,  68)
4. #de",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLT",Not Useful
/*Advance one chunk*/,"-2.                      while (idat->idat_index >= idat->idat_length)
-1.                      {

/*Advance one chunk*/

1.                         struct IDAT_list *cur = idat->idat_cur;
2.                         assert(idat->idat_index == idat->idat_l",Not Useful
/*conditioning*/,"-10.    return crc_table[(crc ^ b) & 0xff] ^ (crc >> 8);
-9. }
-8. static png_uint_32
-7. crc_init_4(png_uint_32 value)
-6. {
-5.    /* This is an alternative to the algorithm used in zlib, which requires four
-4.     * separate tables to parallelize the ",Not Useful
/*chunk*/,"-3. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
-2. #define PNG_U32(b1,b2,b3,b4) \
-1.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))

/*chunk*/

1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
2. #define png_IEND PNG_U32( 73,  69",Not Useful
/*NYI*/,"-10. ""      Write the optimized/corrected version of the next PNG to <file>.  This"",
-9. ""      overrides the following two options"",
-8. ""    --suffix=<suffix>:"",
-7. ""      Set --out=<name><suffix> for all following files unless overridden on"",
-6. ""   ",Not Useful
/*NYI*/,"-10. ""      Write the optimized/corrected version of the next PNG to <file>.  This"",
-9. ""      overrides the following two options"",
-8. ""    --suffix=<suffix>:"",
-7. ""      Set --out=<name><suffix> for all following files unless overridden on"",
-6. ""   ",Not Useful
/*Consider the prefix/suffix options*/,"-1.          {

/*Consider the prefix/suffix options*/

1.             if (prefix != NULL)
2.             {
3.                size_t prefixlen = strlen(prefix);
4.                if (prefixlen+outlen > FILENAME_MAX)
5.                {
6.                 ",Not Useful
/*ZLIB_VERNUM < 0x1240*/,"-10.          }
-9.          (void)one_file(&global, *argv, outfile);
-8.          ++done;
-7.          outfile = NULL;
-6.       }
-5.    }
-4.    if (!done)
-3.       usage(prog);
-2.    return global_end(&global);
-1. }

/*ZLIB_VERNUM < 0x1240*/

1. in",Not Useful
/*ZLIB_VERNUM*/,"#if ZLIB_VERNUM < 0x1260

/*ZLIB_VERNUM*/

1. #  define PNGZ_MSG_CAST(s) constcast(char*,s)
2. #  define PNGZ_INPUT_CAST(b) constcast(png_bytep,b)
3. #else
4. #  define PNGZ_MSG_CAST(s) (s)
5. #  define PNGZ_INPUT_CAST(b) (b)
6. #endif
7. #ifndef PNG_MAXIMUM_INFLATE_WINDOW
8. #  error ""pngfix not supported in this libpng version""
9. #endif
10. #if ZLIB_VERNUM >= 0x1240",Not Useful
/*PNG_READ_SUPPORTED && PNG_EASY_ACCESS_SUPPORTED*/,"-6. int
-5. main(void)
-4. {
-3.    fprintf(stderr, ""pngfix does not work without read deinterlace support\n"");
-2.    return 77;
-1. }

/*PNG_READ_SUPPORTED && PNG_EASY_ACCESS_SUPPORTED*/

111",Not Useful
/*No setjmp support*/,"-7. int
-6. main(void)
-5. {
-4.    fprintf(stderr, ""pngfix does not work without read deinterlace support\n"");
-3.    return 77;
-2. }

/*No setjmp support*/

1. int
2. main(void)
3. {
4.    fprintf(stderr, ""pngfix does not work without setjmp support\n""",Not Useful
/*PNG_SETJMP_SUPPORTED*/,"-2. #  error ""pngfix will not work with libpng prior to 1.6.3""
-1. #endif
#ifdef PNG_SETJMP_SUPPORTED

/*PNG_SETJMP_SUPPORTED*/

1. #include <setjmp.h>
2. #if defined(PNG_READ_SUPPORTED) && defined(PNG_EASY_ACCESS_SUPPORTED) &&\
3.    (defined(PNG_READ_DE",Not Useful
/*non-negative*/,"-4. png_int_32 (PNGAPI
-3. png_get_int_32)(png_const_bytep buf)
-2. {
-1.    png_uint_32 uval = png_get_uint_32(buf);

/*non-negative*/

1.       return (png_int_32)uval;",Not Useful
/*get the file size of the local file*/,"-10. #endif
-9.     return TEST_ERR_USAGE;
-8.   }
-7.   hd_src = fopen(libtest_arg2, ""rb"");
-6.   if(!hd_src) {
-5.     fprintf(stderr, ""fopen failed with error: %d (%s)\n"",
-4.             errno, strerror(errno));
-3.     fprintf(stderr, ""Error opening ",Useful
"/*can't open file, bail out*/","-2.   hd = fstat(fileno(hd_src), &file_info);
-1.   if(hd == -1) {

 /*can't open file, bail out*/

1.     fprintf(stderr, ""fstat() failed with error: %d (%s)\n"",
2.             errno, strerror(errno));
3.     fprintf(stderr, ""ERROR: cannot open file (%s)",Useful
/*enable uploading*/,"-10.     fprintf(stderr, ""ERROR: cannot open file (%s)\n"", libtest_arg2);
-9.     fclose(hd_src);
-8.     return TEST_ERR_FSTAT;
-7.   }
-6.   res_global_init(CURL_GLOBAL_ALL);
-5.   if(res) {
-4.     fclose(hd_src);
-3.     return res;
-2.   }
-1.   easy",Useful
/*specify target*/,"-1.   easy_setopt(curl, CURLOPT_UPLOAD, 1L);

 /*specify target*/

1.   easy_setopt(curl, CURLOPT_URL, URL);",Useful
/*use active FTP*/,"-1.   easy_setopt(curl, CURLOPT_VERBOSE, 1L);

 /*use active FTP*/

1.   easy_setopt(curl, CURLOPT_FTPPORT, ""-"");",Useful
/*now specify which file to upload*/,"-1.   easy_setopt(curl, CURLOPT_FTPPORT, ""-"");

 /*now specify which file to upload*/

1.   easy_setopt(curl, CURLOPT_READDATA, hd_src);",Useful
"/*NOTE: if you want this code to work on Windows with libcurl as a DLL, you
     MUST also provide a read callback with CURLOPT_READFUNCTION. Failing to
     do so will give you a crash since a DLL may not use the variable's memory
     when passed in to it from an app like this.*/","-1.   easy_setopt(curl, CURLOPT_READDATA, hd_src);

 /*NOTE: if you want this code to work on Windows with libcurl as a DLL, you
     MUST also provide a read callback with CURLOPT_READFUNCTION. Failing to
     do so will give you a crash since a DLL may ",Useful
"/*Set the size of the file to upload (optional).  If you give a *_LARGE
     option you MUST make sure that the type of the passed-in argument is a
     curl_off_t. If you use CURLOPT_INFILESIZE (without _LARGE) you must
     make sure that to pass in a type 'long' argument.*/","-5.   easy_setopt(curl, CURLOPT_READDATA, hd_src);

 /*Set the size of the file to upload (optional).  If you give a *_LARGE
     option you MUST make sure that the type of the passed-in argument is a
     curl_off_t. If you use CURLOPT_INFILESIZE (withou",Useful
"/*Based on Alex Fishman's bug report on September 30, 2007*/",#NAME?,Useful
/*a huge number of file descriptors*/,"-3.     num_open.rlim_max = rl.rlim_cur - SAFETY_MARGIN;
-2.   }
-1.   else {

 /*a huge number of file descriptors*/

1.     for(nitems = i = 1; nitems <= i; i *= 2)
2.       nitems = i;
3.     if(nitems > 0x7fff)
4.       nitems = 0x40000;
5.     num_op",Useful
/*verify that we won't overflow size_t in malloc()*/,"-6.     for(nitems = i = 1; nitems <= i; i *= 2)
-5.       nitems = i;
-4.     if(nitems > 0x7fff)
-3.       nitems = 0x40000;
-2.     num_open.rlim_max = nitems;
-1.   }

 /*verify that we won't overflow size_t in malloc()*/

1.   if((size_t)(num_open.rl",Useful
/*open a dummy descriptor*/,"-7.   fprintf(stderr, ""initializing fd array\n"");
-6.   for(num_open.rlim_cur = 0;
-5.       num_open.rlim_cur < num_open.rlim_max;
-4.       num_open.rlim_cur++)
-3.     fd[num_open.rlim_cur] = -1;
-2.   msnprintf(strbuff, sizeof(strbuff), fmt, num_open.",Useful
"/** Old or 'backwards compatible' implementations of stdio do not allow
   * handling of streams with an underlying file descriptor number greater
   * than 255, even when allowing high numbered file descriptors for sockets.
   * At this point we have a big number of file descriptors which have been
   * opened using dup(), so lets test the stdio implementation and discover
   * if it is capable of fopen()ing some additional files.*/","-1.   /*
   * Old or 'backwards compatible' implementations of stdio do not allow
   * handling of streams with an underlying file descriptor number greater
   * than 255, even when allowing high numbered file descriptors for sockets.
   * At this point w",Useful
/*used by the test script to ask if we can run this test or not*/,"-10.   if(!keep_open) {
-9.     close_file_descriptors();
-8.   }
-7.   return 0;
-6. }
-5. int test(char *URL)
-4. {
-3.   CURLcode res;
-2.   CURL *curl;
-1.   if(!strcmp(URL, ""check"")) {

 /*used by the test script to ask if we can run this test or not",Useful
"/*sure, run this!*/","-4.     if(rlimit(FALSE)) {
-3.       fprintf(stdout, ""rlimit problem: %s\n"", msgbuff);
-2.       return 1;
-1.     }

 /*sure, run this!*/

1.   }
2.   if(rlimit(TRUE)) {",Useful
/*skip test*/,"-10.   msnprintf(strbuff, sizeof(strbuff), fmt, num_open.rlim_max);
-9.   fprintf(stderr, ""%s file descriptors open\n"", strbuff);
-8. #if !defined(HAVE_POLL_FINE) && !defined(USE_WINSOCK)
-7.   /*
-6.    * when using select() instead of poll() we cannot t",Useful
"/*This define is ""almost"" required to build on HPUX 11*/","-10.  *
-9.  ***************************************************************************/
-8. #include ""server_setup.h""
-7. #ifdef HAVE_SIGNAL_H
-6. #include <signal.h>
-5. #endif
-4. #ifdef HAVE_NETINET_IN_H
-3. #include <netinet/in.h>
-2. #endif
-1. #if",Useful
/*from the private lib dir*/,"-10. #include <poll.h>
-9. #elif defined(HAVE_SYS_POLL_H)
-8. #include <sys/poll.h>
-7. #endif
-6. #ifdef __MINGW32__
-5. #include <w32api.h>
-4. #endif
-3. #define ENABLE_CURLX_PRINTF

 /*from the private lib dir*/

1. #include ""getpart.h""
2. #include ""u",Useful
"/*MinGW with w32api version < 3.6 declared in6addr_any as extern,
   but lacked the definition*/","-1. #endif

 /*MinGW with w32api version < 3.6 declared in6addr_any as extern,
   but lacked the definition*/

1. #if defined(ENABLE_IPV6) && defined(__MINGW32__)
2. #if (__W32API_MAJOR_VERSION < 3) || \
3.     ((__W32API_MAJOR_VERSION == 3) && (__W32API_",Useful
/*w32api < 3.6*/,"-4. #if defined(ENABLE_IPV6) && defined(__MINGW32__)
-3. #if (__W32API_MAJOR_VERSION < 3) || \
-2.     ((__W32API_MAJOR_VERSION == 3) && (__W32API_MINOR_VERSION < 6))
-1. const struct in6_addr in6addr_any = {{ IN6ADDR_ANY_INIT }};

 /*w32api < 3.6*/

111",Useful
/*ENABLE_IPV6 && __MINGW32__*/,"-5. #if defined(ENABLE_IPV6) && defined(__MINGW32__)
-4. #if (__W32API_MAJOR_VERSION < 3) || \
-3.     ((__W32API_MAJOR_VERSION == 3) && (__W32API_MINOR_VERSION < 6))
-2. const struct in6_addr in6addr_any = {{ IN6ADDR_ANY_INIT }};

 /*ENABLE_IPV6 && __MIN",Useful
"/*This function returns a pointer to STATIC memory. It converts the given
 * binary lump to a hex formatted string usable for output in logs or
 * whatever.*/","-1. static struct timeval tvnow(void);
/* This function returns a pointer to STATIC memory. It converts the given
 * binary lump to a hex formatted string usable for output in logs or
 * whatever.

 /*This function returns a pointer to STATIC memory. It c",Useful
/*in case no sprintf was used*/,"-10.   if(len > 255)
-9.     len = 255;
-8.   for(i = 0; i < len; i++) {
-7.     if((data[i] >= 0x20) && (data[i] < 0x7f))
-6.       *optr++ = *iptr++;
-5.     else {
-4.       msnprintf(optr, 4, ""%%%02x"", *iptr++);
-3.       optr += 3;
-2.     }
-1.   }
",Useful
/*not thread safe but we don't care*/,"-10.     fprintf(stderr, ""Error: serverlogfile not set\n"");
-9.     return;
-8.   }
-7.   tv = tvnow();
-6.   if(!known_offset) {
-5.     epoch_offset = time(NULL) - tv.tv_sec;
-4.     known_offset = 1;
-3.   }
-2.   sec = epoch_offset + tv.tv_sec;

 /*no",Useful
/*use instead of perror() on generic windows*/,"-10.   }
-9.   else {
-8.     int error = errno;
-7.     fprintf(stderr, ""fopen() failed with error: %d %s\n"",
-6.             error, strerror(error));
-5.     fprintf(stderr, ""Error opening file: %s\n"", serverlogfile);
-4.     fprintf(stderr, ""Msg not lo",Useful
/*fail*/,"-10.   va_start(ap, msg);
-9.   mvsnprintf(buffer, sizeof(buffer), msg, ap);
-8.   va_end(ap);
-7.   logfp = fopen(serverlogfile, ""ab"");
-6.   if(logfp) {
-5.     fprintf(logfp, ""%s %s\n"", timebuf, buffer);
-4.     fclose(logfp);
-3.   }
-2.   else {
-1. ",Useful
/*success*/,"-4.   }
-3.   fprintf(pidfile, ""%"" CURL_FORMAT_CURL_OFF_T ""\n"", pid);
-2.   fclose(pidfile);
-1.   logmsg(""Wrote pid %"" CURL_FORMAT_CURL_OFF_T "" to %s"", pid, filename);

 /*success*/

1. }",Useful
"/*** Log all removal failures. Even those due to file not existing.
  ** This allows to detect if unexpectedly the file has already been
  ** removed by a process different than the one that should do this.*/","-10.   } while(res && ((error = errno) == EINTR));
-9.   if(res)
-8.     logmsg(""Error closing lock file %s error: %d %s"",
-7.            filename, error, strerror(error));
-6. }
-5. void clear_advisor_read_lock(const char *filename)
-4. {
-3.   int error",Useful
/*they are equal this far*/,"-10. {
-9.   while(*first && *second && max) {
-8.     if(raw_toupper(*first) != raw_toupper(*second)) {
-7.       break;
-6.     }
-5.     max--;
-4.     first++;
-3.     second++;
-2.   }
-1.   if(0 == max)

 /*they are equal this far*/

1.   return raw",Useful
"/*** GetTickCount() is available on _all_ Windows versions from W95 up
  ** to nowadays. Returns milliseconds elapsed since last system boot,
  ** increases monotonically and wraps once 49.7 days have elapsed.
  **
  ** GetTickCount64() is available on Windows version from Windows Vista
  ** and Windows Server 2008 up to nowadays. The resolution of the
  ** function is limited to the resolution of the system timer, which
  ** is typically in the range of 10 milliseconds to 16 milliseconds.*/","-6.   return raw_toupper(*first) == raw_toupper(*second);
-5. }
-4. #if defined(WIN32) && !defined(MSDOS)
-3. static struct timeval tvnow(void)
-2. {
-1.   /*
  ** GetTickCount() is available on _all_ Windows versions from W95 up
  ** to nowadays. Returns",Useful
"/*** clock_gettime() is granted to be increased monotonically when the
  ** monotonic clock is queried. Time starting point is unspecified, it
  ** could be the system start-up time, the Epoch, or something else,
  ** in any case the time starting point does not change once that the
  ** system has started up.*/","-10.   DWORD milliseconds = GetTickCount();
-9. #endif
-8.   now.tv_sec = (long)(milliseconds / 1000);
-7.   now.tv_usec = (long)((milliseconds % 1000) * 1000);
-6.   return now;
-5. }
-4. #elif defined(HAVE_CLOCK_GETTIME_MONOTONIC)
-3. static struct time",Useful
"/*** Even when the configure process has truly detected monotonic clock
  ** availability, it might happen that it is not actually available at
  ** run-time. When this occurs simply fallback to other time source.*/","-10.   ** in any case the time starting point does not change once that the
-9.   ** system has started up.
-8.   */
-7.   struct timeval now;
-6.   struct timespec tsnow;
-5.   if(0 == clock_gettime(CLOCK_MONOTONIC, &tsnow)) {
-4.     now.tv_sec = tsnow.",Useful
"/*** gettimeofday() is not granted to be increased monotonically, due to
  ** clock drifting and external source time synchronization it can jump
  ** forward or backward in time.*/","-10.     now.tv_sec = time(NULL);
-9.     now.tv_usec = 0;
-8.   }
-7. #endif
-6.   return now;
-5. }
-4. #elif defined(HAVE_GETTIMEOFDAY)
-3. static struct timeval tvnow(void)
-2. {
-1.   /*
  ** gettimeofday() is not granted to be increased monotonicall",Useful
/*Fill in the file upload part*/,"-10.     return TEST_ERR_MAJOR_BAD;
-9.   }
-8.   part = curl_mime_addpart(mime);
-7.   if(!part) {
-6.     fprintf(stderr, ""curl_mime_addpart(1) failed\n"");
-5.     curl_mime_free(mime);
-4.     curl_easy_cleanup(curl);
-3.     curl_global_cleanup();
-2.",Useful
/*Fill in the file upload part*/,"-10.     return TEST_ERR_MAJOR_BAD;
-9.   }
-8.   part = curl_mime_addpart(mime);
-7.   if(!part) {
-6.     fprintf(stderr, ""curl_mime_addpart(1) failed\n"");
-5.     curl_mime_free(mime);
-4.     curl_easy_cleanup(curl);
-3.     curl_global_cleanup();
-2.",Useful
/*Fill in a submit field too*/,"-6.   res = curl_mime_name(part, ""filename"");
-5.   if(!res)
-4.     res = curl_mime_data(part, ""postit2.c"",
-3.                          CURL_ZERO_TERMINATED);
-2.   if(res)
-1.     printf(""curl_mime_xxx(3) = %s\n"", curl_easy_strerror(res));

 /*Fill in ",Useful
/*that should have failed*/,"-10.   CURLcode a1 = curl_mime_subparts(part, mime);
-9.   if(a1 == CURLE_BAD_FUNCTION_ARGUMENT) {
-8.     curl_mime *submime = curl_mime_init(easy);
-7.     curl_mimepart *subpart = curl_mime_addpart(submime);
-6.     curl_mime_subparts(part, submime);
-",Useful
/*include memdebug.h last*/,"-10.  * copies of the Software, and permit persons to whom the Software is
-9.  * furnished to do so, under the terms of the COPYING file.
-8.  *
-7.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-6.  * KIND, either express ",Useful
"/*LD_PRELOAD used, but no hostname set, we'll just return a failure*/","-10.  * we force our own host name, in order to make some tests machine independent
-9.  */
-8. int gethostname(char *name, GETHOSTNAME_TYPE_ARG2 namelen)
-7. {
-6.   const char *force_hostname = getenv(""CURL_GETHOSTNAME"");
-5.   if(force_hostname) {
-4. ",Useful
"/*not interested in the downloaded bytes, return the size*/","-4. #define RUN_FOR_SECONDS 7
-3. static pthread_mutex_t connlock;
-2. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-1. {

 /*not interested in the downloaded bytes, return the size*/

111",Useful
/*get the file size of the local file*/,"-1.   }

 /*get the file size of the local file*/

1.   hd = fstat(fileno(hd_src), &file_info);
2.   if(hd == -1) {",Useful
/*get a curl handle*/,"-10.   if(!file_info.st_size) {
-9.     fprintf(stderr, ""ERROR: file %s has zero size!\n"", libtest_arg2);
-8.     fclose(hd_src);
-7.     return TEST_ERR_MAJOR_BAD;
-6.   }
-5.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-4.     fprintf(stderr, ",Useful
/*specify target*/,"-1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);

 /*specify target*/

1.   test_setopt(curl, CURLOPT_URL, URL);",Useful
"/***************************************************************************
 *                                  _   _ ____  _
 *  Project                     ___| | | |  _ \| |
 *                             / __| | | | |_) | |
 *                            | (__| |_| |  _ <| |___
 *                             \___|\___/|_| \_\_____|
 *
 *
 * Trivial file transfer protocol server.
 *
 * This code includes many modifications by Jim Guyton <guyton@rand-unix>
 *
 * This source file was started based on netkit-tftpd 0.17
 * Heavily modified for curl's test suite*/","/***************************************************************************
 *                                  _   _ ____  _
 *  Project                     ___| | | |  _ \| |
 *                             / __| | | | |_) | |
 *                            | (__| |_| |  _ <| |___
 *                             \___|\___/|_| \_\_____|
 *
 *
 * Trivial file transfer protocol server.
 *
 * This code includes many modifications by Jim Guyton <guyton@rand-unix>
 *
 * This source file was started based on netkit-tftpd 0.17
 * Heavily modified for curl's test suite

 /***************************************************************************
 *                                  _   _ ____  _
 *  Project                     ___| | | |  _ \| |
 *                             / __| | | | |_) | |
 *                            | (__| |_| |  _ <| |___
 *                             \___|\___/|_| \_\_____|
 *
 *
 * Trivial file transfer protocol server.
 *
 * This code includes many modifications by Jim Guyton <guyton@rand-unix>
 *
 * This source file was started based on netkit-tftpd 0.17
 * Heavily modified for curl's test suite*/

1.  */
2. /*
3.  * Copyright (C) 2005 - 2021, Daniel Stenberg, <daniel@haxx.se>, et al.
4.  * Copyright (c) 1983, Regents of the University of California.
5.  * All rights reserved.
6.  *
7.  * Redistribution and use in source and binary forms, with or without
8.  * modification, are permitted provided that the following conditions
9.  * are met:
10.  * 1. Redistributions of source code must retain the above copyright",Useful
/*FIONREAD on Solaris 7*/,"-10. #endif
-9. #ifdef HAVE_ARPA_TFTP_H
-8. #include <arpa/tftp.h>
-7. #else
-6. #include ""tftp.h""
-5. #endif
-4. #ifdef HAVE_NETDB_H
-3. #include <netdb.h>
-2. #endif
-1. #ifdef HAVE_SYS_FILIO_H

 /*FIONREAD on Solaris 7*/

1. #include <sys/filio.h>
2. #",Useful
/*from the private lib dir*/,"-10. #endif
-9. #ifdef HAVE_SETJMP_H
-8. #include <setjmp.h>
-7. #endif
-6. #ifdef HAVE_PWD_H
-5. #include <pwd.h>
-4. #endif
-3. #define ENABLE_CURLX_PRINTF

 /*from the private lib dir*/

1. #include ""getpart.h""
2. #include ""util.h""
3. #include ""server_",Useful
/*include memdebug.h last*/,"-3. #include ""getpart.h""
-2. #include ""util.h""
-1. #include ""server_sockaddr.h""

 /*include memdebug.h last*/

1. #include ""memdebug.h""",Useful
/*holds the file data to send to the client*/,"-2. #endif
-1. struct testcase {

 /*holds the file data to send to the client*/

111",Useful
/*file descriptor for output file when uploading to us*/,"-7. #endif
-6. struct testcase {

 /*file descriptor for output file when uploading to us*/

111",Useful
"/** bf.counter values in range [-1 .. SEGSIZE] represents size of data in the
 * bf.buf buffer. Additionally it can also hold flags BF_ALLOC or BF_FREE.*/","-10. };
-9. struct errmsg {
-8.   int e_code;
-7.   const char *e_msg;
-6. };
-5. typedef union {
-4.   struct tftphdr hdr;
-3.   char storage[PKTSIZE];
-2. } tftphdr_storage_t;
-1. /*
 * bf.counter values in range [-1 .. SEGSIZE] represents size of data ",Useful
/*failure!*/,"-10.   if(!test->ofile) {
-9.     char outfile[256];
-8.     msnprintf(outfile, sizeof(outfile), ""log/upload.%ld"", test->testno);
-7. #ifdef WIN32
-6.     test->ofile = open(outfile, O_CREAT|O_RDWR|O_BINARY, 0777);
-5. #else
-4.     test->ofile = open(out",Useful
/*nak logic?*/,"-2.   writebuf = dp->th_data;
-1.   if(count <= 0)

 /*nak logic?*/

1.   if(convert == 0)
2.     return write(test->ofile, writebuf, count);
3.   p = writebuf;
4.   ct = count;",Useful
/*socket to flush*/,"-10. /* When an error has occurred, it is possible that the two sides are out of
-9.  * synch.  Ie: that what I think is the other side's response to packet N is
-8.  * really their response to packet N-1.
-7.  *
-6.  * So, to try to prevent that, we flus",Useful
/*ENABLE_IPV6*/,"-7. static tftphdr_storage_t buf;
-6. static tftphdr_storage_t ackbuf;
-5. static srvr_sockaddr_union_t from;
-4. static curl_socklen_t fromlen;
-3. static curl_socket_t peer = CURL_SOCKET_BAD;
-2. static unsigned int timeout;
-1. static unsigned int maxt",Useful
"/** To properly set the return status of the process we
     * must raise the same signal SIGINT or SIGTERM that we
     * caught and let the old handler take care of it.*/","-10.     unlink(portname);
-9.   if(serverlogslocked) {
-8.     serverlogslocked = 0;
-7.     clear_advisor_read_lock(SERVERLOGS_LOCK);
-6.   }
-5.   restore_signal_handlers(true);
-4.   if(got_exit_signal) {
-3.     logmsg(""========> %s tftpd (port: %d p",Useful
/*Open request dump file.*/,"-1.   int toggle = 1;

 /*Open request dump file.*/

1.   FILE *server = fopen(REQUEST_DUMP, ""ab"");
2.   if(!server) {
3.     int error = errno;
4.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
5.     logmsg(""Error opening file: ",Useful
/*store the name pointer*/,"-2.         fprintf(server, ""%s = %s\n"", option, cp);
-1.       else {

 /*store the name pointer*/

1.         option = cp;
2.       }
3.       toggle ^= 1;
4.     }
5.     else",Useful
/*store input protocol*/,"-7.   FILE *server = fopen(REQUEST_DUMP, ""ab"");
-6.   if(!server) {
-5.     int error = errno;
-4.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-3.     logmsg(""Error opening file: %s"", REQUEST_DUMP);
-2.     return -1;
-1.   }

",Useful
/*store input protocol*/,"-7.   FILE *server = fopen(REQUEST_DUMP, ""ab"");
-6.   if(!server) {
-5.     int error = errno;
-4.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-3.     logmsg(""Error opening file: %s"", REQUEST_DUMP);
-2.     return -1;
-1.   }

",Useful
/*done*/,"-9. static int parse_servercmd(struct testcase *req)
-8. {
-7.   FILE *stream;
-6.   int error;
-5.   stream = test2fopen(req->testno);
-4.   if(!stream) {
-3.     error = errno;
-2.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
",Useful
"/*get the custom server control ""commands""*/","-6.   }
-5.   else {
-4.     char *orgcmd = NULL;
-3.     char *cmd = NULL;
-2.     size_t cmdsize = 0;
-1.     int num = 0;

 /*get the custom server control ""commands""*/

1.     error = getpart(&orgcmd, &cmdsize, ""reply"", ""servercmd"", stream);
2.     fc",Useful
/*done*/,"-9. static int parse_servercmd(struct testcase *req)
-8. {
-7.   FILE *stream;
-6.   int error;
-5.   stream = test2fopen(req->testno);
-4.   if(!stream) {
-3.     error = errno;
-2.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
",Useful
/*OK!*/,"-8.           break;
-7.         cmd = check;
-6.       }
-5.       else
-4.         break;
-3.     }
-2.     free(orgcmd);
-1.   }

 /*OK!*/

1. }",Useful
/*fine*/,"-8. #include <sys/filio.h>
-7. #endif
-6. #ifdef HAVE_SETJMP_H
-5. #include <setjmp.h>
-4. #endif
-3. #ifdef HAVE_PWD_H
-2. #include <pwd.h>
-1. #endif
#define ENABLE_CURLX_PRINTF

 /*fine*/

111",Useful
/*skip the slash*/,"-6.   ptr = strrchr(filename, '/');
-5.   if(ptr) {
-4.     char partbuf[80]=""data"";
-3.     long partno;
-2.     long testno;
-1.     FILE *stream;

 /*skip the slash*/

111",Useful
/*skip all non-numericals following the slash*/,"-7.   ptr = strrchr(filename, '/');
-6.   if(ptr) {
-5.     char partbuf[80]=""data"";
-4.     long partno;
-3.     long testno;
-2.     FILE *stream;

 /*skip all non-numericals following the slash*/

1.     while(*ptr && !ISDIGIT(*ptr))
2.       ptr++;",Useful
/*get the number*/,"-2.     while(*ptr && !ISDIGIT(*ptr))
-1.       ptr++;

 /*get the number*/

1.     testno = strtol(ptr, &ptr, 10);
2.     if(testno > 10000) {
3.       partno = testno % 10000;
4.       testno /= 10000;
5.     }
6.     else
7.       partno = 0;
8.     lo",Useful
/*failure*/,"-10.   if(!test->ofile) {
-9.     char outfile[256];
-8.     msnprintf(outfile, sizeof(outfile), ""log/upload.%ld"", test->testno);
-7. #ifdef WIN32
-6.     test->ofile = open(outfile, O_CREAT|O_RDWR|O_BINARY, 0777);
-5. #else
-4.     test->ofile = open(out",Useful
/*These are volatile to live through a siglongjmp*/,"-4. static void sendtftp(struct testcase *test, const struct formats *pf)
-3. {
-2.   int size;
-1.   ssize_t n;

 /*These are volatile to live through a siglongjmp*/

111",Useful
/*data buffer*/,"-6. static void sendtftp(struct testcase *test, const struct formats *pf)
-5. {
-4.   int size;
-3.   ssize_t n;

 /*data buffer*/

111",Useful
/*ack buffer*/,"-7. static void sendtftp(struct testcase *test, const struct formats *pf)
-6. {
-5.   int size;
-4.   ssize_t n;

 /*ack buffer*/

1.   sendblock = 1;
2. #if defined(HAVE_ALARM) && defined(SIGALRM)
3.   mysignal(SIGALRM, timer);
4. #endif
5.   do {
6.    ",Useful
/*read the ack*/,"-10.     }
-9.     send_data:
-8.     logmsg(""write"");
-7.     if(swrite(peer, sdp, size + 4) != size + 4) {
-6.       logmsg(""write: fail"");
-5.       return;
-4.     }
-3.     read_ahead(test, pf->f_convert);
-2.     for(;;) {
-1. #ifdef HAVE_ALARM

 /*",Useful
/*Re-synchronize with the other side*/,"-10.       sap->th_opcode = ntohs((unsigned short)sap->th_opcode);
-9.       sap->th_block = ntohs(sap->th_block);
-8.       if(sap->th_opcode == opcode_ERROR) {
-7.         logmsg(""got ERROR"");
-6.         return;
-5.       }
-4.       if(sap->th_opcode ",Useful
/*These are volatile to live through a siglongjmp*/,"-4. static void sendtftp(struct testcase *test, const struct formats *pf)
-3. {
-2.   int size;
-1.   ssize_t n;

 /*These are volatile to live through a siglongjmp*/

111",Useful
/*data buffer*/,"-6. static void sendtftp(struct testcase *test, const struct formats *pf)
-5. {
-4.   int size;
-3.   ssize_t n;

 /*data buffer*/

111",Useful
/*ack buffer*/,"-7. static void sendtftp(struct testcase *test, const struct formats *pf)
-6. {
-5.   int size;
-4.   ssize_t n;

 /*ack buffer*/

1.   sendblock = 1;
2. #if defined(HAVE_ALARM) && defined(SIGALRM)
3.   mysignal(SIGALRM, timer);
4. #endif
5.   do {
6.    ",Useful
/*normal*/,"-9.         logmsg(""read: fail"");
-8.         goto abort;
-7.       }
-6.       rdp->th_opcode = ntohs((unsigned short)rdp->th_opcode);
-5.       rdp->th_block = ntohs(rdp->th_block);
-4.       if(rdp->th_opcode == opcode_ERROR)
-3.         goto abort;
-2",Useful
/*Re-synchronize with the other side*/,"-10.       sap->th_opcode = ntohs((unsigned short)sap->th_opcode);
-9.       sap->th_block = ntohs(sap->th_block);
-8.       if(sap->th_opcode == opcode_ERROR) {
-7.         logmsg(""got ERROR"");
-6.         return;
-5.       }
-4.       if(sap->th_opcode ",Useful
/*just abort read on timeout*/,"-3.   rap->th_block = htons(recvblock);
-2.   (void) swrite(peer, &ackbuf.storage[0], 4);
-1. #if defined(HAVE_ALARM) && defined(SIGALRM)

 /*just abort read on timeout*/

1.   alarm(rexmtval);
2. #endif",Useful
/*normally times out and quits*/,"-2.   alarm(rexmtval);
-1. #endif

 /*normally times out and quits*/

1.   n = sread(peer, &buf.storage[0], sizeof(buf.storage));
2. #ifdef HAVE_ALARM
3.   alarm(0);
4. #endif
5.   if(got_exit_signal)
6.     goto abort;",Useful
/*then my last ack was lost*/,"-8.   n = sread(peer, &buf.storage[0], sizeof(buf.storage));
-7. #ifdef HAVE_ALARM
-6.   alarm(0);
-5. #endif
-4.   if(got_exit_signal)
-3.     goto abort;

 /*then my last ack was lost*/

111",Useful
/*resend final ack*/,"-9.   n = sread(peer, &buf.storage[0], sizeof(buf.storage));
-8. #ifdef HAVE_ALARM
-7.   alarm(0);
-6. #endif
-5.   if(got_exit_signal)
-4.     goto abort;

 /*resend final ack*/

1.   }
2. abort:",Useful
/*set 'undef' errorcode*/,"-10.   int length;
-9.   struct errmsg *pe;
-8.   tp = &buf.hdr;
-7.   tp->th_opcode = htons((unsigned short)opcode_ERROR);
-6.   tp->th_code = htons((unsigned short)error);
-5.   for(pe = errmsgs; pe->e_code >= 0; pe++)
-4.     if(pe->e_code == error)
-3",Useful
/** Begin with curl set to use a single CWD to the URL's directory.*/,"-10.      fprintf(stderr, ""curl_global_init() failed\n"");
-9.      return TEST_ERR_MAJOR_BAD;
-8.    }
-7.    curl = curl_easy_init();
-6.    if(!curl) {
-5.      fprintf(stderr, ""curl_easy_init() failed\n"");
-4.      curl_global_cleanup();
-3.      retur",Useful
"/** Change the FTP_FILEMETHOD option to use full paths rather than a CWD
    * command.  Alter the URL's path a bit, appending a ""./"".  Use an innocuous
    * QUOTE command, after which curl will CWD to ftp_conn->entrypath and then
    * (on the next call to ftp_statemach_act) find a non-zero ftpconn->dirdepth
    * even though no directories are stored in the ftpconn->dirs array (after a
    * call to freedirs).*/","-5.    test_setopt(curl, CURLOPT_URL, URL);
-4.    test_setopt(curl, CURLOPT_VERBOSE, 1L);
-3.    test_setopt(curl, CURLOPT_FTP_FILEMETHOD, (long) CURLFTPMETHOD_SINGLECWD);
-2.    res = curl_easy_perform(curl);
-1.    /*
    * Change the FTP_FILEMETHOD op",Useful
"/** Use global DNS cache (while deprecated it should still work), populate it
 * with CURLOPT_RESOLVE in the first request and then make sure a subsequent
 * easy transfer finds and uses the populated stuff.*/",#NAME?,Useful
/*URL is setup in the code*/,"-10. int test(char *URL)
-9. {
-8.   int res = 0;
-7.   CURL *curl[NUM_HANDLES] = {NULL, NULL};
-6.   char *port = libtest_arg3;
-5.   char *address = libtest_arg2;
-4.   char dnsentry[256];
-3.   struct curl_slist *slist = NULL;
-2.   int i;
-1.   char t",Useful
/*get an easy handle*/,"-1.   for(i = 0; i < NUM_HANDLES; i++) {

 /*get an easy handle*/

1.     easy_init(curl[i]);",Useful
/*specify target*/,"-1.     easy_init(curl[i]);

 /*specify target*/

1.     msnprintf(target_url, sizeof(target_url),",Useful
/*make the first one populate the GLOBAL cache*/,"-3.     easy_setopt(curl[i], CURLOPT_HEADER, 1L);
-2.     easy_setopt(curl[i], CURLOPT_DNS_USE_GLOBAL_CACHE, 1L);
-1.   }

 /*make the first one populate the GLOBAL cache*/

1.   easy_setopt(curl[0], CURLOPT_RESOLVE, slist);",Useful
/*run NUM_HANDLES transfers*/,"-1.   easy_setopt(curl[0], CURLOPT_RESOLVE, slist);

 /*run NUM_HANDLES transfers*/

1.   for(i = 0; (i < NUM_HANDLES) && !res; i++)
2.     res = curl_easy_perform(curl[i]);
3. test_cleanup:
4.   curl_easy_cleanup(curl[0]);
5.   curl_easy_cleanup(curl[1])",Useful
/*from the private lib dir*/,"-1. #define ENABLE_CURLX_PRINTF

 /*from the private lib dir*/

1. #include ""getpart.h""
2. #include ""util.h""",Useful
/*include memdebug.h last*/,"-2. #include ""getpart.h""
-1. #include ""util.h""

 /*include memdebug.h last*/

1. #include ""memdebug.h""
2. #define LOGFILE ""log/fake_ntlm%ld.log""
3. const char *serverlogfile;",Useful
/*get the ntlm_auth input/output*/,"-10.     path = env;
-9.   }
-8.   stream = test2fopen(testnum);
-7.   if(!stream) {
-6.     error = errno;
-5.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-4.     logmsg(""Couldn't open test file %ld"", testnum);
-3.     exit(1)",Useful
"/*547 style, which means reading the POST data from a callback*/","-2.   test_setopt(curl, CURLOPT_POSTFIELDS, UPLOADTHIS);
-1. #else

 /*547 style, which means reading the POST data from a callback*/

1.   test_setopt(curl, CURLOPT_IOCTLFUNCTION, ioctlcallback);
2.   test_setopt(curl, CURLOPT_IOCTLDATA, &counter);
3.   ",Useful
"/*We CANNOT do the POST fine without setting the size (or choose
     chunked)!*/","-4.   test_setopt(curl, CURLOPT_IOCTLFUNCTION, ioctlcallback);
-3.   test_setopt(curl, CURLOPT_IOCTLDATA, &counter);
-2.   test_setopt(curl, CURLOPT_READFUNCTION, readcallback);
-1.   test_setopt(curl, CURLOPT_READDATA, &counter);

 /*We CANNOT do the POS",Useful
/*First set the URL that is about to receive our POST.*/,"-10.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-9.     fprintf(stderr, ""curl_global_init() failed\n"");
-8.     return TEST_ERR_MAJOR_BAD;
-7.   }
-6.   curl = curl_easy_init();
-5.   if(!curl) {
-4.     fprintf(stderr, ""curl_easy_init() failed",Useful
/*Now specify we want to POST data*/,"-1.   test_setopt(curl, CURLOPT_URL, URL);

 /*Now specify we want to POST data*/

1.   test_setopt(curl, CURLOPT_POST, 1L);",Useful
/*Set the expected POST size*/,"-1.   test_setopt(curl, CURLOPT_POST, 1L);

 /*Set the expected POST size*/

1.   test_setopt(curl, CURLOPT_POSTFIELDSIZE, 1L);",Useful
/*we want to use our own read function*/,"-1.   test_setopt(curl, CURLOPT_POSTFIELDSIZE, 1L);

 /*we want to use our own read function*/

1.   test_setopt(curl, CURLOPT_READFUNCTION, read_callback);",Useful
/*pointer to pass to our read function*/,"-1.   test_setopt(curl, CURLOPT_READFUNCTION, read_callback);

 /*pointer to pass to our read function*/

1.   test_setopt(curl, CURLOPT_READDATA, NULL);",Useful
/*get verbose debug output please*/,"-1.   test_setopt(curl, CURLOPT_READDATA, NULL);

 /*get verbose debug output please*/

1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);",Useful
/*include headers in the output*/,"-1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);

 /*include headers in the output*/

1.   test_setopt(curl, CURLOPT_HEADER, 1L);",Useful
"/*Perform the request, res will get the return code*/","-1.   test_setopt(curl, CURLOPT_HEADER, 1L);

 /*Perform the request, res will get the return code*/

1.   res = curl_easy_perform(curl);
2. test_cleanup:",Useful
"/*Purpose
 *
 * 1. Accept a TCP connection on a custom port (IPv4 or IPv6), or connect
 *    to a given (localhost) port.
 *
 * 2. Get commands on STDIN. Pass data on to the TCP stream.
 *    Get data from TCP stream and pass on to STDOUT.
 *
 * This program is made to perform all the socket/stream/connection stuff for
 * the test suite's (perl) FTP server. Previously the perl code did all of
 * this by its own, but I decided to let this program do the socket layer
 * because of several things:
 *
 * o We want the perl code to work with rather old perl installations, thus
 *   we cannot use recent perl modules or features.
 *
 * o We want IPv6 support for systems that provide it, and doing optional IPv6
 *   support in perl seems if not impossible so at least awkward.
 *
 * o We want FTP-SSL support, which means that a connection that starts with
 *   plain sockets needs to be able to ""go SSL"" in the midst. This would also
 *   require some nasty perl stuff I'd rather avoid.
 *
 * (Source originally based on sws.c)*/",#NAME?,Useful
"/** Signal handling notes for sockfilt
 * ----------------------------------
 *
 * This program is a single-threaded process.
 *
 * This program is intended to be highly portable and as such it must be kept
 * as simple as possible, due to this the only signal handling mechanisms used
 * will be those of ANSI C, and used only in the most basic form which is good
 * enough for the purpose of this program.
 *
 * For the above reason and the specific needs of this program signals SIGHUP,
 * SIGPIPE and SIGALRM will be simply ignored on systems where this can be
 * done.  If possible, signals SIGINT and SIGTERM will be handled by this
 * program as an indication to cleanup and finish execution as soon as
 * possible.  This will be achieved with a single signal handler
 * 'exit_signal_handler' for both signals.
 *
 * The 'exit_signal_handler' upon the first SIGINT or SIGTERM received signal
 * will just set to one the global var 'got_exit_signal' storing in global var
 * 'exit_signal' the signal that triggered this change.
 *
 * Nothing fancy that could introduce problems is used, the program at certain
 * points in its normal flow checks if var 'got_exit_signal' is set and in
 * case this is true it just makes its way out of loops and functions in
 * structured and well behaved manner to achieve proper program cleanup and
 * termination.
 *
 * Even with the above mechanism implemented it is worthwile to note that
 * other signals might still be received, or that there might be systems on
 * which it is not possible to trap and ignore some of the above signals.
 * This implies that for increased portability and reliability the program
 * must be coded as if no signal was being ignored or handled at all.  Enjoy
 * it!*/",#NAME?,Useful
/*from the private lib dir*/,"-10. #endif
-9. #ifdef HAVE_ARPA_INET_H
-8. #include <arpa/inet.h>
-7. #endif
-6. #ifdef HAVE_NETDB_H
-5. #include <netdb.h>
-4. #endif
-3. #define ENABLE_CURLX_PRINTF

 /*from the private lib dir*/

1. #include ""getpart.h""
2. #include ""inet_pton.h""
3. #i",Useful
/*include memdebug.h last*/,"-6. #include ""getpart.h""
-5. #include ""inet_pton.h""
-4. #include ""util.h""
-3. #include ""server_sockaddr.h""
-2. #include ""timediff.h""
-1. #include ""warnless.h""

 /*include memdebug.h last*/

1. #include ""memdebug.h""
2. #ifdef USE_WINSOCK
3. #undef  EINTR",Useful
"/*if non-zero, we activate this mode*/","-10. #define DEFAULT_LOGFILE ""log/sockfilt.log""
-9. #endif
-8. const char *serverlogfile = DEFAULT_LOGFILE;
-7. static bool verbose = FALSE;
-6. static bool bind_only = FALSE;
-5. #ifdef ENABLE_IPV6
-4. static bool use_ipv6 = FALSE;
-3. #endif
-2. static ",Useful
/*as a server waiting for connections*/,"-1. enum sockmode {

 /*as a server waiting for connections*/

111",Useful
"/*as a server, connected to a client*/","-2. enum sockmode {

 /*as a server, connected to a client*/

111",Useful
"/*as a client, connected to a server*/","-3. enum sockmode {

 /*as a client, connected to a server*/

111",Useful
"/*as a client, disconnected from server*/","-4. enum sockmode {

 /*as a client, disconnected from server*/

1. };
2. #ifdef WIN32",Useful
"/** fullread is a wrapper around the read() function. This will repeat the call
 * to read() until it actually has read the complete number of bytes indicated
 * in nbytes or it fails with a condition that cannot be handled with a simple
 * retry of the read call.*/","-10.   if(success) {
-9.     return wcount;
-8.   }
-7.   errno = GetLastError();
-6.   return -1;
-5. }
-4. #undef  write
-3. #define write(a,b,c) write_wincon(a,b,c)
-2. #endif
-1. /*
 * fullread is a wrapper around the read() function. This will repeat",Useful
"/** fullwrite is a wrapper around the write() function. This will repeat the
 * call to write() until it actually has written the complete number of bytes
 * indicated in nbytes or it fails with a condition that cannot be handled
 * with a simple retry of the write call.*/","-10.       logmsg(""got 0 reading from stdin"");
-9.       return 0;
-8.     }
-7.     nread += rc;
-6.   } while((size_t)nread < nbytes);
-5.   if(verbose)
-4.     logmsg(""read %zd bytes"", nread);
-3.   return nread;
-2. }
-1. /*
 * fullwrite is a wrapper ",Useful
"/** read_stdin tries to read from stdin nbytes into the given buffer. This is a
 * blocking function that will only return TRUE when nbytes have actually been
 * read or FALSE when an unrecoverable error has been detected. Failure of this
 * function is an indication that the sockfilt process should terminate.*/","-10.       logmsg(""put 0 writing to stdout"");
-9.       return 0;
-8.     }
-7.     nwrite += wc;
-6.   } while((size_t)nwrite < nbytes);
-5.   if(verbose)
-4.     logmsg(""wrote %zd bytes"", nwrite);
-3.   return nwrite;
-2. }
-1. /*
 * read_stdin tries to",Useful
"/** write_stdout tries to write to stdio nbytes from the given buffer. This is a
 * blocking function that will only return TRUE when nbytes have actually been
 * written or FALSE when an unrecoverable error has been detected. Failure of
 * this function is an indication that the sockfilt process should terminate.*/","-10. static bool read_stdin(void *buffer, size_t nbytes)
-9. {
-8.   ssize_t nread = fullread(fileno(stdin), buffer, nbytes);
-7.   if(nread != (ssize_t)nbytes) {
-6.     logmsg(""exiting..."");
-5.     return FALSE;
-4.   }
-3.   return TRUE;
-2. }
-1. /*
",Useful
"/** WinSock select() does not support standard file descriptors,
 * it can only check SOCKETs. The following function is an attempt
 * to re-create a select() function with support for other handle types.
 *
 * select() function with support for WINSOCK2 sockets and all
 * other handle types supported by WaitForMultipleObjectsEx() as
 * well as disk files, anonymous and names pipes, and character input.
 *
 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms687028.aspx
 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms741572.aspx*/","-10.       width = 0;
-9.       optr = data;
-8.       left = sizeof(data);
-7.     }
-6.   }
-5.   if(width)
-4.     logmsg(""'%s'"", data);
-3. }
-2. #ifdef USE_WINSOCK
-1. /*
 * WinSock select() does not support standard file descriptors,
 * it can only ",Useful
/*retrieve handles from internal structure*/,"-8. };
-7. static DWORD WINAPI select_ws_wait_thread(LPVOID lpParameter)
-6. {
-5.   struct select_ws_wait_data *data;
-4.   HANDLE mutex, signal, handle, handles[2];
-3.   INPUT_RECORD inputrecord;
-2.   LARGE_INTEGER size, pos;
-1.   DWORD type, length,",Useful
"/*The handle represents a file on disk, this means:
        * - WaitForMultipleObjectsEx will always be signalled for it.
        * - comparison of current position in file and total size of
        *   the file can be used to check if we reached the end yet.
        *
        * Approach: Loop till either the internal event is signalled
        *           or if the end of the file has already been reached.*/","-3.   type = GetFileType(handle);
-2.   switch(type) {
-1.     case FILE_TYPE_DISK:
       /* The handle represents a file on disk, this means:
        * - WaitForMultipleObjectsEx will always be signalled for it.
        * - comparison of current positio",Useful
"/*The handle represents a character input, this means:
        * - WaitForMultipleObjectsEx will be signalled on any kind of input,
        *   including mouse and window size events we do not care about.
        *
        * Approach: Loop till either the internal event is signalled
        *           or we get signalled for an actual key-event.*/","-5.           break;
-4.         }
-3.       }
-2.       break;
-1.     case FILE_TYPE_CHAR:
       /* The handle represents a character input, this means:
        * - WaitForMultipleObjectsEx will be signalled on any kind of input,
        *   including ",Useful
"/*The handle represents an anonymous or named pipe, this means:
        * - WaitForMultipleObjectsEx will always be signalled for it.
        * - peek into the pipe and retrieve the amount of data available.
        *
        * Approach: Loop till either the internal event is signalled
        *           or there is data in the pipe available for reading.*/","-5.           break;
-4.         }
-3.       }
-2.       break;
-1.     case FILE_TYPE_PIPE:
       /* The handle represents an anonymous or named pipe, this means:
        * - WaitForMultipleObjectsEx will always be signalled for it.
        * - peek int",Useful
/*launch waiting thread*/,"-6.   data = malloc(sizeof(struct select_ws_wait_data));
-5.   if(data) {
-4.     data->handle = handle;
-3.     data->signal = signal;
-2.     data->abort = abort;
-1.     data->mutex = mutex;

 /*launch waiting thread*/

1.     thread = CreateThread(NUL",Useful
"/*check if we got descriptors, sleep in case we got none*/","-6.   if(tv) {
-5.     timeout_ms = (DWORD)curlx_tvtoms(tv);
-4.   }
-3.   else {
-2.     timeout_ms = INFINITE;
-1.   }

 /*check if we got descriptors, sleep in case we got none*/

1.   if(!nfds) {
2.     SleepEx(timeout_ms, FALSE);
3.     return 0;
4. ",Useful
/*allocate internal array for the internal data*/,"-6.   mutex = CreateMutex(NULL, FALSE, NULL);
-5.   if(!mutex) {
-4.     CloseHandle(abort);
-3.     errno = ENOMEM;
-2.     return -1;
-1.   }

 /*allocate internal array for the internal data*/

1.   data = calloc(nfds, sizeof(struct select_ws_data));
2",Useful
/*allocate internal array for the internal event handles*/,"-7.   data = calloc(nfds, sizeof(struct select_ws_data));
-6.   if(!data) {
-5.     CloseHandle(abort);
-4.     CloseHandle(mutex);
-3.     errno = ENOMEM;
-2.     return -1;
-1.   }

 /*allocate internal array for the internal event handles*/

1.   handl",Useful
/*wait for one of the internal handles to trigger*/,"-3.     handles[nfd] = exit_event;
-2.     wait += 1;
-1.   }

 /*wait for one of the internal handles to trigger*/

1.   wait = WaitForMultipleObjectsEx(wait, handles, FALSE, timeout_ms, FALSE);",Useful
/*check if the current internal handle was triggered*/,"-4.   for(i = 0; i < nfd; i++) {
-3.     fd = data[i].fd;
-2.     handle = handles[i];
-1.     wsasock = curlx_sitosk(fd);

 /*check if the current internal handle was triggered*/

1.     if(wait != WAIT_FAILED && (wait - WAIT_OBJECT_0) <= i &&
2.        ",Useful
/*stdin is never ready for write or exceptional*/,"-1.       if(fd == fileno(stdin)) {

 /*stdin is never ready for write or exceptional*/

1.         FD_CLR(wsasock, writefds);
2.         FD_CLR(wsasock, exceptfds);
3.       }
4.       else if(fd == fileno(stdout) || fd == fileno(stderr)) {",Useful
/*stdout and stderr are never ready for read or exceptional*/,"-4.         FD_CLR(wsasock, writefds);
-3.         FD_CLR(wsasock, exceptfds);
-2.       }
-1.       else if(fd == fileno(stdout) || fd == fileno(stderr)) {

 /*stdout and stderr are never ready for read or exceptional*/

1.         FD_CLR(wsasock, readfd",Useful
/*try to handle the event with the WINSOCK2 functions*/,"-4.         FD_CLR(wsasock, readfds);
-3.         FD_CLR(wsasock, exceptfds);
-2.       }
-1.       else {

 /*try to handle the event with the WINSOCK2 functions*/

1.         wsaevents.lNetworkEvents = 0;
2.         error = WSAEnumNetworkEvents(wsasock,",Useful
/*remove from descriptor set if not ready for read/accept/close*/,"-1.           wsaevents.lNetworkEvents |= data[i].wsastate;

 /*remove from descriptor set if not ready for read/accept/close*/

1.           if(!(wsaevents.lNetworkEvents & (FD_READ|FD_ACCEPT|FD_CLOSE)))
2.             FD_CLR(wsasock, readfds);",Useful
/*remove from descriptor set if not ready for write/connect*/,"-2.           if(!(wsaevents.lNetworkEvents & (FD_READ|FD_ACCEPT|FD_CLOSE)))
-1.             FD_CLR(wsasock, readfds);

 /*remove from descriptor set if not ready for write/connect*/

1.           if(!(wsaevents.lNetworkEvents & (FD_WRITE|FD_CONNECT|FD_CL",Useful
/*remove from descriptor set if not exceptional*/,"-2.           if(!(wsaevents.lNetworkEvents & (FD_WRITE|FD_CONNECT|FD_CLOSE)))
-1.             FD_CLR(wsasock, writefds);

 /*remove from descriptor set if not exceptional*/

1.           if(!(wsaevents.lNetworkEvents & FD_OOB))
2.             FD_CLR(wsas",Useful
/*check if the event has not been filtered using specific tests*/,"-4.           if(!(wsaevents.lNetworkEvents & FD_OOB))
-3.             FD_CLR(wsasock, exceptfds);
-2.         }
-1.       }

 /*check if the event has not been filtered using specific tests*/

1.       if(FD_ISSET(wsasock, readfds) || FD_ISSET(wsasock, w",Useful
/*remove from all descriptor sets since this handle did not trigger*/,"-6.       if(FD_ISSET(wsasock, readfds) || FD_ISSET(wsasock, writefds) ||
-5.          FD_ISSET(wsasock, exceptfds)) {
-4.         ret++;
-3.       }
-2.     }
-1.     else {

 /*remove from all descriptor sets since this handle did not trigger*/

1.     ",Useful
/*USE_WINSOCK*/,"-1. #include ""memdebug.h""
#ifdef USE_WINSOCK

 /*USE_WINSOCK*/

1. #undef  EINTR",Useful
"/*sockfdp is a pointer to an established stream or CURL_SOCKET_BAD

  if sockfd is CURL_SOCKET_BAD, listendfd is a listening socket we must
  accept()*/","-1. /*
  sockfdp is a pointer to an established stream or CURL_SOCKET_BAD

  if sockfd is CURL_SOCKET_BAD, listendfd is a listening socket we must
  accept()

 /*sockfdp is a pointer to an established stream or CURL_SOCKET_BAD

  if sockfd is CURL_SOCKET_",Useful
/*server mode*/,"-10.   }
-9. #endif
-8.   timeout.tv_sec = 120;
-7.   timeout.tv_usec = 0;
-6.   FD_ZERO(&fds_read);
-5.   FD_ZERO(&fds_write);
-4.   FD_ZERO(&fds_err);
-3.   FD_SET((curl_socket_t)fileno(stdin), &fds_read);
-2.   switch(*mode) {
-1.   case PASSIVE_LISTEN",Useful
/*there's always a socket to wait for*/,"-1.     sockfd = listenfd;

 /*there's always a socket to wait for*/

1.     FD_SET(sockfd, &fds_read);
2.     maxfd = (int)sockfd;
3.     break;
4.   case PASSIVE_CONNECT:
5.     sockfd = *sockfdp;
6.     if(CURL_SOCKET_BAD == sockfd) {",Useful
"/*eeek, we are supposedly connected and then this cannot be -1 !*/","-6.     FD_SET(sockfd, &fds_read);
-5.     maxfd = (int)sockfd;
-4.     break;
-3.   case PASSIVE_CONNECT:
-2.     sockfd = *sockfdp;
-1.     if(CURL_SOCKET_BAD == sockfd) {

 /*eeek, we are supposedly connected and then this cannot be -1 !*/

1.       lo",Useful
/*stdin*/,"-3. };
-2. #ifdef WIN32
-1. /*
 * read-wrapper to support reading from stdin on Windows.

 /*stdin*/

1.  */
2. static ssize_t read_wincon(int fd, void *buf, size_t count)
3. {
4.   HANDLE handle = NULL;
5.   DWORD mode, rcount = 0;
6.   BOOL success;
7. ",Useful
/*there's always a socket to wait for*/,"-1.     sockfd = listenfd;

 /*there's always a socket to wait for*/

1.     FD_SET(sockfd, &fds_read);
2.     maxfd = (int)sockfd;
3.     break;
4.   case PASSIVE_CONNECT:
5.     sockfd = *sockfdp;
6.     if(CURL_SOCKET_BAD == sockfd) {",Useful
"/*read from stdin, commands/data to be dealt with and possibly passed on
       to the socket

       protocol:

       4 letter command + LF [mandatory]

       4-digit hexadecimal data length + LF [if the command takes data]
       data                       [the data being as long as set above]

       Commands:

       DATA - plain pass-through data*/","-3.     return TRUE;
-2.   if(FD_ISSET(fileno(stdin), &fds_read)) {
-1.     ssize_t buffer_len;
    /* read from stdin, commands/data to be dealt with and possibly passed on
       to the socket

       protocol:

       4 letter command + LF [mandatory]
",Useful
/*data IN => data OUT*/,"-4.       logmsg(""quits"");
-3.       return FALSE;
-2.     }
-1.     else if(!memcmp(""DATA"", buffer, 4)) {

 /*data IN => data OUT*/

1.       if(!read_stdin(buffer, 5))
2.         return FALSE;
3.       buffer[5] = '\0';
4.       buffer_len = (ssize_t)st",Useful
/*send away on the socket*/,"-10.       logmsg(""> %zd bytes data, server => client"", buffer_len);
-9.       if(!read_stdin(buffer, buffer_len))
-8.         return FALSE;
-7.       lograw(buffer, buffer_len);
-6.       if(*mode == PASSIVE_LISTEN) {
-5.         logmsg(""*** We are disco",Useful
"/*The system was supposed to choose a port number, figure out which
       port we actually got and update the listener port value with it.*/","-8.   if(rc) {
-7.     error = SOCKERRNO;
-6.     logmsg(""Error binding socket on port %hu: (%d) %s"",
-5.            *listenport, error, strerror(error));
-4.     sclose(sock);
-3.     return CURL_SOCKET_BAD;
-2.   }
-1.   if(!*listenport) {

 /*The syste",Useful
/*bindonly option forces no listening*/,"-8.       logmsg(""Apparently getsockname() succeeded, with listener port zero."");
-7.       logmsg(""A valid reason for this failure is a binary built without"");
-6.       logmsg(""proper network library linkage. This might not be the only"");
-5.       logm",Useful
"/*for completeness, we support this option as well*/","-10.         serverlogfile = argv[arg++];
-9.     }
-8.     else if(!strcmp(""--ipv6"", argv[arg])) {
-7. #ifdef ENABLE_IPV6
-6.       ipv_inuse = ""IPv6"";
-5.       use_ipv6 = TRUE;
-4. #endif
-3.       arg++;
-2.     }
-1.     else if(!strcmp(""--ipv4"", arg",Useful
/*use this as stream*/,"-8.     if(rc) {
-7.       error = SOCKERRNO;
-6.       logmsg(""Error connecting to port %hu: (%d) %s"",
-5.              connectport, error, strerror(error));
-4.       write_stdout(""FAIL\n"", 5);
-3.       goto sockfilt_cleanup;
-2.     }
-1.     logmsg(""",Useful
/*passive daemon style*/,"-10.       else
-9.         *mode = ACTIVE_DISCONNECT;
-8.       return TRUE;
-7.     }
-6.   }
-5.   return TRUE;
-4. }
-3. static curl_socket_t sockdaemon(curl_socket_t sock,
-2.                                 unsigned short *listenport)
-1. {

 /*pass",Useful
/*no stream socket yet*/,"-5.     sock = sockdaemon(sock, &port);
-4.     if(CURL_SOCKET_BAD == sock) {
-3.       write_stdout(""FAIL\n"", 5);
-2.       goto sockfilt_cleanup;
-1.     }

 /*no stream socket yet*/

1.   }
2.   logmsg(""Running %s version"", ipv_inuse);
3.   if(connectp",Useful
"/** To properly set the return status of the process we
     * must raise the same signal SIGINT or SIGTERM that we
     * caught and let the old handler take care of it.*/","-10.   if(sock != CURL_SOCKET_BAD)
-9.     sclose(sock);
-8.   if(wrotepidfile)
-7.     unlink(pidname);
-6.   if(wroteportfile)
-5.     unlink(portname);
-4.   restore_signal_handlers(false);
-3.   if(got_exit_signal) {
-2.     logmsg(""============> sock",Useful
"/*sws.c: simple (silly?) web server

   This code was originally graciously donated to the project by Juergen
   Wilke. Thanks a bunch!*/",#NAME?,Useful
/*for TCP_NODELAY*/,"-10. #ifdef HAVE_NETINET_IN6_H
-9. #include <netinet/in6.h>
-8. #endif
-7. #ifdef HAVE_ARPA_INET_H
-6. #include <arpa/inet.h>
-5. #endif
-4. #ifdef HAVE_NETDB_H
-3. #include <netdb.h>
-2. #endif
-1. #ifdef HAVE_NETINET_TCP_H

 /*for TCP_NODELAY*/

1. #end",Useful
/*from the private lib dir*/,"-4. #endif
-3. #define ENABLE_CURLX_PRINTF

 /*from the private lib dir*/

1. #include ""getpart.h""
2. #include ""inet_pton.h""
3. #include ""util.h""
4. #include ""server_sockaddr.h""",Useful
/*include memdebug.h last*/,"-4. #include ""getpart.h""
-3. #include ""inet_pton.h""
-2. #include ""util.h""
-1. #include ""server_sockaddr.h""

 /*include memdebug.h last*/

1. #include ""memdebug.h""
2. #ifdef USE_WINSOCK
3. #undef  EINTR",Useful
"/*instructs the server to increase the part
                                   number for a test in case the identical
                                   testno+partno request shows up again*/","-10. #ifdef USE_UNIX_SOCKETS
-9.   , socket_domain_unix = AF_UNIX
-8. #endif
-7. } socket_domain = AF_INET;
-6. static bool use_gopher = FALSE;
-5. static int serverlogslocked = 0;
-4. static bool is_proxy = FALSE;
-3. #define REQBUFSIZ (2*1024*1024)

 /*",Useful
"/*default request, use the tests file normally*/","-10. } socket_domain = AF_INET;
-9. static bool use_gopher = FALSE;
-8. static int serverlogslocked = 0;
-7. static bool is_proxy = FALSE;
-6. #define REQBUFSIZ (2*1024*1024)

 /*default request, use the tests file normally*/

111",Useful
/*told to sit idle*/,"-10. static bool use_gopher = FALSE;
-9. static int serverlogslocked = 0;
-8. static bool is_proxy = FALSE;
-7. #define REQBUFSIZ (2*1024*1024)

 /*told to sit idle*/

111",Useful
/*told to stream*/,"-10. static int serverlogslocked = 0;
-9. static bool is_proxy = FALSE;
-8. #define REQBUFSIZ (2*1024*1024)

 /*told to stream*/

1. struct httprequest {",Useful
"/*keep connection open info, as found in the request*/","-8. struct httprequest {

 /*keep connection open info, as found in the request*/

111",Useful
"/*authentication required, don't wait for body unless
                     there's an Authorization header*/","-9. struct httprequest {

 /*authentication required, don't wait for body unless
                     there's an Authorization header*/

111",Useful
/*HTTP version * 10*/,"-10.   size_t cl;      /* Content-Length of the incoming request */
-9.   bool digest;    /* Authorization digest header found */
-8.   bool ntlm;      /* Authorization ntlm header found */
-7.   int writedelay; /* if non-zero, delay this number of second",Useful
"/*monitor the state of the connection, log disconnects*/","-10.                      writes in the response */

 /*monitor the state of the connection, log disconnects*/

111",Useful
/*test case allows upgrade to http2*/,"-10.   int skip;       /* if non-zero, the server is instructed to not read this
-9.                      many bytes from a PUT/POST request. Ie the client sends N
-8.                      bytes said in Content-Length, but the server only reads N
-7.     ",Useful
"/*when told to run as proxy, we store the logs in different files so that
   they can co-exist with the same program running as a ""server""*/","-10. static int ProcessRequest(struct httprequest *req);
-9. static void storerequest(const char *reqbuf, size_t totalsize);
-8. #define DEFAULT_PORT 8999
-7. #ifndef DEFAULT_LOGFILE
-6. #define DEFAULT_LOGFILE ""log/sws.log""
-5. #endif
-4. const char *ser",Useful
"/*idle' means that it will accept the request fine but never respond
   any data. Just keep the connection alive.*/","-5. #define MAXDOCNAMELEN 140000
-4. #define MAXDOCNAMELEN_TXT ""139999""
-3. #define REQUEST_KEYWORD_SIZE 256
-2. #define REQUEST_KEYWORD_SIZE_TXT ""255""
-1. #define CMD_AUTH_REQUIRED ""auth_required""

 /*idle' means that it will accept the request fine but ",Useful
/*stream' means to send a never-ending stream of data*/,"-1. #define CMD_IDLE ""idle""

 /*stream' means to send a never-ending stream of data*/

1. #define CMD_STREAM ""stream""",Useful
"/*connection-monitor' will output when a server/proxy connection gets
   disconnected as for some cases it is important that it gets done at the
   proper point - like with NTLM*/","-1. #define CMD_STREAM ""stream""

 /*connection-monitor' will output when a server/proxy connection gets
   disconnected as for some cases it is important that it gets done at the
   proper point - like with NTLM*/

1. #define CMD_CONNECTIONMONITOR ""connec",Useful
/*upgrade to http2*/,"-10.   int skip;       /* if non-zero, the server is instructed to not read this
-9.                      many bytes from a PUT/POST request. Ie the client sends N
-8.                      bytes said in Content-Length, but the server only reads N
-7.     ",Useful
/*sent as reply to a QUIT*/,"-9. #define CMD_NOEXPECT ""no-expect""
-8. #define END_OF_HEADERS ""\r\n\r\n""
-7. enum {
-6.   DOCNUMBER_NOTHING = -4,
-5.   DOCNUMBER_QUIT    = -3,
-4.   DOCNUMBER_WERULEZ = -2,
-3.   DOCNUMBER_404     = -1
-2. };
-1. static const char *end_of_headers = END",Useful
/*send back this on 404 file not found*/,"-2. static const char *docquit =
-1. ""HTTP/1.1 200 Goodbye"" END_OF_HEADERS;

 /*send back this on 404 file not found*/

1. static const char *doc404 = ""HTTP/1.1 404 Not Found\r\n""
2.     ""Server: "" SWSVERSION ""\r\n""
3.     ""Connection: close\r\n""
4.     """,Useful
/*work around for handling trailing headers*/,"-6.     ""<HTML><HEAD>\n""
-5.     ""<TITLE>404 Not Found</TITLE>\n""
-4.     ""</HEAD><BODY>\n""
-3.     ""<H1>Not Found</H1>\n""
-2.     ""The requested URL was not found on this server.\n""
-1.     ""<P><HR><ADDRESS>"" SWSVERSION ""</ADDRESS>\n"" ""</BODY></HTML>\n"";",Useful
/*done*/,"-10.   int rcmd;       /* doing a special command, see defines above */
-9.   int prot_version;  /* HTTP version * 10 */
-8.   int callcount;  /* times ProcessRequest() gets called */
-7.   bool skipall;   /* skip all incoming data */
-6.   bool noexpect;",Useful
"/*get the custom server control ""commands""*/","-6.   }
-5.   else {
-4.     char *orgcmd = NULL;
-3.     char *cmd = NULL;
-2.     size_t cmdsize = 0;
-1.     int num = 0;

 /*get the custom server control ""commands""*/

1.     error = getpart(&orgcmd, &cmdsize, ""reply"", ""servercmd"", stream);
2.     fc",Useful
/*done*/,"-10.   int rcmd;       /* doing a special command, see defines above */
-9.   int prot_version;  /* HTTP version * 10 */
-8.   int callcount;  /* times ProcessRequest() gets called */
-7.   bool skipall;   /* skip all incoming data */
-6.   bool noexpect;",Useful
/*OK!*/,"-8.           break;
-7.         cmd = check;
-6.       }
-5.       else
-4.         break;
-3.     }
-2.     free(orgcmd);
-1.   }

 /*OK!*/

1. }
2. static int ProcessRequest(struct httprequest *req)
3. {
4.   char *line = &req->reqbuf[req->checkindex];",Useful
/*done*/,"-10.   int rcmd;       /* doing a special command, see defines above */
-9.   int prot_version;  /* HTTP version * 10 */
-8.   int callcount;  /* times ProcessRequest() gets called */
-7.   bool skipall;   /* skip all incoming data */
-6.   bool noexpect;",Useful
/*done*/,"-10.   int rcmd;       /* doing a special command, see defines above */
-9.   int prot_version;  /* HTTP version * 10 */
-8.   int callcount;  /* times ProcessRequest() gets called */
-7.   bool skipall;   /* skip all incoming data */
-6.   bool noexpect;",Useful
/*done*/,"-10.   int rcmd;       /* doing a special command, see defines above */
-9.   int prot_version;  /* HTTP version * 10 */
-8.   int callcount;  /* times ProcessRequest() gets called */
-7.   bool skipall;   /* skip all incoming data */
-6.   bool noexpect;",Useful
/*HTTP 1.0 closes connection by default*/,"-10.          number placements */
-9.       if(sscanf(req->reqbuf, ""CONNECT %"" MAXDOCNAMELEN_TXT ""s HTTP/%d.%d"",
-8.                 doc, &prot_major, &prot_minor) == 3) {
-7.         char *portp = NULL;
-6.         msnprintf(logbuf, sizeof(logbuf),
-5. ",Useful
"/*scan through the hexgroups and store the value of the last group
             in the 'part' variable and use as test case number!!*/","-3.         if(doc[0] == '[') {
-2.           char *p = &doc[1];
-1.           unsigned long part = 0;

 /*scan through the hexgroups and store the value of the last group
             in the 'part' variable and use as test case number!!*/

1.           w",Useful
/*we don't have a complete request yet!*/,"-10.       req->testno = DOCNUMBER_404;
-9.     }
-8.     else
-7.       parse_servercmd(req);
-6.   }
-5.   else if((req->offset >= 3) && (req->testno == DOCNUMBER_NOTHING)) {
-4.     logmsg(""** Unusual request. Starts with %02x %02x %02x (%c%c%c)"",
-3. ",Useful
"/***** Persistence ****
   *
   * If the request is a HTTP/1.0 one, we close the connection unconditionally
   * when we're done.
   *
   * If the request is a HTTP/1.1 one, we MUST check for a ""Connection:""
   * header that might say ""close"". If it does, we close a connection when
   * this request is processed. Otherwise, we keep the connection alive for X
   * seconds.*/","-10.         req->testno /= 10000;
-9.       }
-8.       else
-7.         req->partno = 0;
-6.       msnprintf(logbuf, sizeof(logbuf),
-5.                 ""Requested GOPHER test number %ld part %ld"",
-4.                 req->testno, req->partno);
-3.     ",Useful
/*done*/,"-10.   int rcmd;       /* doing a special command, see defines above */
-9.   int prot_version;  /* HTTP version * 10 */
-8.   int callcount;  /* times ProcessRequest() gets called */
-7.   bool skipall;   /* skip all incoming data */
-6.   bool noexpect;",Useful
"/*If we don't ignore content-length, we read it and we read the whole
         request including the body before we return. If we've been told to
         ignore the content-length, we will return as soon as all headers
         have been received*/","-1.     if((req->cl == 0) && strncasecompare(""Content-Length:"", line, 15)) {

 /*If we don't ignore content-length, we read it and we read the whole
         request including the body before we return. If we've been told to
         ignore the content-le",Useful
/*this assumes that a zero Content-Length is valid*/,"-10.          have been received */
-9.       char *endptr;
-8.       char *ptr = line + 15;
-7.       unsigned long clen = 0;
-6.       while(*ptr && ISSPACE(*ptr))
-5.         ptr++;
-4.       endptr = ptr;
-3.       errno = 0;
-2.       clen = strtoul(",Useful
/*done*/,"-10.   int rcmd;       /* doing a special command, see defines above */
-9.   int prot_version;  /* HTTP version * 10 */
-8.   int callcount;  /* times ProcessRequest() gets called */
-7.   bool skipall;   /* skip all incoming data */
-6.   bool noexpect;",Useful
/*chunked data coming in*/,"-10.       if(req->skipall)
-9.         req->cl = 0;
-8.       else
-7.         req->cl = clen - req->skip;
-6.       logmsg(""Found Content-Length: %lu in the request"", clen);
-5.       if(req->skip)
-4.         logmsg(""... but will abort after %zu bytes""",Useful
/*end of chunks reached*/,"-10.     else if(req->noexpect &&
-9.             strncasecompare(""Expect: 100-continue"", line,
-8.                             strlen(""Expect: 100-continue""))) {
-7.       if(req->cl)
-6.         req->cl = 0;
-5.       req->skipall = TRUE;
-4.       logm",Useful
/*done*/,"-10.   int rcmd;       /* doing a special command, see defines above */
-9.   int prot_version;  /* HTTP version * 10 */
-8.   int callcount;  /* times ProcessRequest() gets called */
-7.   bool skipall;   /* skip all incoming data */
-6.   bool noexpect;",Useful
/*not done*/,"-10.         }
-9.         if(last_crlf_char &&
-8.            last_crlf_char > strstr(req->reqbuf, ""\r\n0\r\n""))
-7.           return 1;
-6.         already_recv_zeroed_chunk = TRUE;
-5.         return 0;
-4.       }
-3.       else if(already_recv_zeroed",Useful
/*Authorization: header present!*/,"-6.     }
-5.     line = strchr(line, '\n');
-4.     if(line)
-3.       line++;
-2.   } while(line);
-1.   if(!req->auth && strstr(req->reqbuf, ""Authorization:"")) {

 /*Authorization: header present!*/

1.     if(req->auth_req)
2.       logmsg(""Authorizat",Useful
"/*If the client is passing this Digest-header, we set the part number
       to 1000. Not only to spice up the complexity of this, but to make
       Digest stuff to work in the test suite.*/","-10.     logmsg(""Negotiate: prev_testno: %d, prev_partno: %d"",
-9.             prev_testno, prev_partno);
-8.     if(req->testno != prev_testno) {
-7.       prev_testno = req->testno;
-6.       prev_partno = req->partno;
-5.     }
-4.     prev_partno += 1",Useful
/*If the client is passing this type-3 NTLM header*/,"-4.     logmsg(""Received Digest request, sending back data %ld"", req->partno);
-3.   }
-2.   else if(!req->ntlm &&
-1.           strstr(req->reqbuf, ""Authorization: NTLM TlRMTVNTUAAD"")) {

 /*If the client is passing this type-3 NTLM header*/

1.     req-",Useful
/*If the client is passing this type-1 NTLM header*/,"-7.     logmsg(""Received NTLM type-3, sending back data %ld"", req->partno);
-6.     if(req->cl) {
-5.       logmsg(""  Expecting %zu POSTed bytes"", req->cl);
-4.     }
-3.   }
-2.   else if(!req->ntlm &&
-1.           strstr(req->reqbuf, ""Authorization: NT",Useful
"/*If the client is passing this Basic-header and the part number is
       already >=1000, we add 1 to the part number.  This allows simple Basic
       authentication negotiation to work in the test suite.*/","-4.     logmsg(""Received NTLM type-1, sending back data %ld"", req->partno);
-3.   }
-2.   else if((req->partno >= 1000) &&
-1.           strstr(req->reqbuf, ""Authorization: Basic"")) {

 /*If the client is passing this Basic-header and the part number is
 ",Useful
/*close connection after this request*/,"-4.     req->partno += 1;
-3.     logmsg(""Received Basic request, sending back data %ld"", req->partno);
-2.   }
-1.   if(strstr(req->reqbuf, ""Connection: close""))

 /*close connection after this request*/

1.   if(req->open &&
2.      req->prot_version >=",Useful
"/*If we have a persistent connection, HTTP version >= 1.1
       and GET/HEAD request, enable pipelining.*/","-6.   if(req->open &&
-5.      req->prot_version >= 11 &&
-4.      req->reqbuf + req->offset > end + strlen(end_of_headers) &&
-3.      !req->cl &&
-2.      (!strncmp(req->reqbuf, ""GET"", strlen(""GET"")) ||
-1.       !strncmp(req->reqbuf, ""HEAD"", strlen(""HE",Useful
"/*If authentication is required and no auth was provided, end now. This
     makes the server NOT wait for PUT/POST data and you can then make the
     test case send a rejection before any such data has been sent. Test case
     154 uses this.*/","-2.     req->checkindex = (end - req->reqbuf) + strlen(end_of_headers);
-1.   }

 /*If authentication is required and no auth was provided, end now. This
     makes the server NOT wait for PUT/POST data and you can then make the
     test case send a reje",Useful
/*done*/,"-10.   int rcmd;       /* doing a special command, see defines above */
-9.   int prot_version;  /* HTTP version * 10 */
-8.   int callcount;  /* times ProcessRequest() gets called */
-7.   bool skipall;   /* skip all incoming data */
-6.   bool noexpect;",Useful
/*done*/,"-10.   int rcmd;       /* doing a special command, see defines above */
-9.   int prot_version;  /* HTTP version * 10 */
-8.   int callcount;  /* times ProcessRequest() gets called */
-7.   bool skipall;   /* skip all incoming data */
-6.   bool noexpect;",Useful
/*not complete yet*/,"
    logmsg(""request not complete yet"");



 /*not complete yet*/

111",Useful
/*done*/,"-10.   int rcmd;       /* doing a special command, see defines above */
-9.   int prot_version;  /* HTTP version * 10 */
-8.   int callcount;  /* times ProcessRequest() gets called */
-7.   bool skipall;   /* skip all incoming data */
-6.   bool noexpect;",Useful
"/*returns 1 if the connection should be serviced again immediately, 0 if there
   is no data waiting, or < 0 if it should be closed*/","-10.   req->noexpect = FALSE;
-9.   req->writedelay = 0;
-8.   req->rcmd = RCMD_NORMALREQ;
-7.   req->prot_version = 0;
-6.   req->callcount = 0;
-5.   req->connect_port = 0;
-4.   req->done_processing = 0;
-3.   req->upgrade = 0;
-2.   req->upgrade_reque",Useful
/*buffer is already full; do nothing*/,"-7. static int get_request(curl_socket_t sock, struct httprequest *req)
-6. {
-5.   int fail = 0;
-4.   char *reqbuf = req->reqbuf;
-3.   ssize_t got = 0;
-2.   int overflow = 0;
-1.   if(req->offset >= REQBUFSIZ-1) {

 /*buffer is already full; do nothin",Useful
"/*we are instructed to not read the entire thing, so we make sure to
         only read what we're supposed to and NOT read the enire thing the
         client wants to send!*/","-4.     overflow = 1;
-3.   }
-2.   else {
-1.     if(req->skip)

 /*we are instructed to not read the entire thing, so we make sure to
         only read what we're supposed to and NOT read the enire thing the
         client wants to send!*/

1.       g",Useful
/*nothing to read at the moment*/,"-10.       got = sread(sock, reqbuf + req->offset, REQBUFSIZ-1 - req->offset);
-9.     if(got_exit_signal)
-8.       return -1;
-7.     if(got == 0) {
-6.       logmsg(""Connection closed by client"");
-5.       fail = 1;
-4.     }
-3.     else if(got < 0) ",Useful
/*dump the request received so far to the external file*/,"-6.         return 0;
-5.       }
-4.       logmsg(""recv() returned error: (%d) %s"", error, strerror(error));
-3.       fail = 1;
-2.     }
-1.     if(fail) {

 /*dump the request received so far to the external file*/

1.       reqbuf[req->offset] = '\0'",Useful
/*dump request received so far to external file anyway*/,"-10.     }
-9.     logmsg(""Read %zd bytes"", got);
-8.     req->offset += (size_t)got;
-7.     reqbuf[req->offset] = '\0';
-6.     req->done_processing = ProcessRequest(req);
-5.     if(got_exit_signal)
-4.       return -1;
-3.   }
-2.   if(overflow || (re",Useful
/*dump request received so far to external file anyway*/,"-10.     }
-9.     logmsg(""Read %zd bytes"", got);
-8.     req->offset += (size_t)got;
-7.     reqbuf[req->offset] = '\0';
-6.     req->done_processing = ProcessRequest(req);
-5.     if(got_exit_signal)
-4.       return -1;
-3.   }
-2.   if(overflow || (re",Useful
/*at the end of a request dump it to an external file*/,"-5.     reqbuf[REQBUFSIZ-1] = '\0';
-4.     fail = 1;
-3.   }
-2.   else
-1.     reqbuf[req->offset] = '\0';

 /*at the end of a request dump it to an external file*/

1.   if(fail || req->done_processing)
2.     storerequest(reqbuf, req->offset);
3.   if",Useful
/*returns -1 on failure*/,"-6.   if(fail || req->done_processing)
-5.     storerequest(reqbuf, req->offset);
-4.   if(got_exit_signal)
-3.     return -1;
-2.   return fail ? -1 : 1;
-1. }

 /*returns -1 on failure*/

1. static int send_doc(curl_socket_t sock, struct httprequest *re",Useful
"/*we got a ""friends?"" question, reply back that we sure are*/","-10.   req->open = FALSE;
-9.   if(req->testno < 0) {
-8.     size_t msglen;
-7.     char msgbuf[64];
-6.     switch(req->testno) {
-5.     case DOCNUMBER_QUIT:
-4.       logmsg(""Replying to QUIT"");
-3.       buffer = docquit;
-2.       break;
-1.     cas",Useful
"/*get the custom server control ""commands""*/","-6.   }
-5.   else {
-4.     char *orgcmd = NULL;
-3.     char *cmd = NULL;
-2.     size_t cmdsize = 0;
-1.     int num = 0;

 /*get the custom server control ""commands""*/

1.     error = getpart(&orgcmd, &cmdsize, ""reply"", ""servercmd"", stream);
2.     fc",Useful
"/*If the word 'swsclose' is present anywhere in the reply chunk, the
     connection will be closed after the data has been sent to the requesting
     client...*/","-10.         free(ptr);
-9.         return 0;
-8.       }
-7.     }
-6.   }
-5.   if(got_exit_signal) {
-4.     free(ptr);
-3.     free(cmd);
-2.     return -1;
-1.   }

 /*If the word 'swsclose' is present anywhere in the reply chunk, the
     connection",Useful
"/*Ok, we send no more than N bytes at a time, just to make sure that
       larger chunks are split up so that the client will need to do multiple
       recv() calls to get it and thus we exercise that code better*/","-10.   if(!dump) {
-9.     error = errno;
-8.     logmsg(""fopen() failed with error: %d %s"", error, strerror(error));
-7.     logmsg(""  [5] Error opening file: %s"", responsedump);
-6.     free(ptr);
-5.     free(cmd);
-4.     return -1;
-3.   }
-2.   resp",Useful
/*should not happen*/,"-10.     ptr = cmd;
-9.     do {
-8.       if(2 == sscanf(ptr, ""%31s %d"", command, &num)) {
-7.         if(!strcmp(""wait"", command)) {
-6.           logmsg(""Told to sleep for %d seconds"", num);
-5.           quarters = num * 4;
-4.           while((quarte",Useful
/*Disable the Nagle algorithm*/,"-10.          op_br, ipaddr, cl_br, port);
-9.   serverfd = socket(socket_domain, SOCK_STREAM, 0);
-8.   if(CURL_SOCKET_BAD == serverfd) {
-7.     error = SOCKERRNO;
-6.     logmsg(""Error creating socket for server connection: (%d) %s"",
-5.            err",Useful
/*ENABLE_IPV6*/,"-3. #endif
-2. static enum {
-1.   socket_domain_inet = AF_INET
#ifdef ENABLE_IPV6

 /*ENABLE_IPV6*/

1.   , socket_domain_inet6 = AF_INET6
2. #endif
3. #ifdef USE_UNIX_SOCKETS
4.   , socket_domain_unix = AF_UNIX
5. #endif
6. } socket_domain = AF_INET;
7.",Useful
"/** A CONNECT has been received, a CONNECT response has been sent.
 *
 * This function needs to connect to the server, and then pass data between
 * the client and the server back and forth until the connection is closed by
 * either end.
 *
 * When doing FTP through a CONNECT proxy, we expect that the data connection
 * will be setup while the first connect is still being kept up. Therefore we
 * must accept a new connection and deal with it appropriately.*/","-10.     logmsg(""Error connecting to server port %hu: (%d) %s"",
-9.            port, error, strerror(error));
-8.     sclose(serverfd);
-7.     return CURL_SOCKET_BAD;
-6.   }
-5.   logmsg(""connected fine to %s%s%s:%hu, now tunnel"",
-4.          op_br, ip",Useful
/*CTRL or DATA*/,"-8.   char readclient[2][256];
-7.   char readserver[2][256];
-6.   bool poll_client_rd[2] = { TRUE, TRUE };
-5.   bool poll_server_rd[2] = { TRUE, TRUE };
-4.   bool poll_client_wr[2] = { TRUE, TRUE };
-3.   bool poll_server_wr[2] = { TRUE, TRUE };
-2.  ",Useful
"/*Sleep here to make sure the client reads CONNECT response's
     'end of headers' separate from the server data that follows.
     This is done to prevent triggering libcurl known bug #39.*/","-1.   clientfd[CTRL] = *infdp;

 /*Sleep here to make sure the client reads CONNECT response's
     'end of headers' separate from the server data that follows.
     This is done to prevent triggering libcurl known bug #39.*/

1.   for(loop = 2; (loop > 0",Useful
"/*Primary tunnel socket endpoints are now connected. Tunnel data back and
     forth over the primary tunnel until client or server breaks the primary
     tunnel, simultaneously allowing establishment, operation and teardown of
     a secondary tunnel that may be used for passive FTP data connection.*/","-7.   for(loop = 2; (loop > 0) && !got_exit_signal; loop--)
-6.     wait_ms(250);
-5.   if(got_exit_signal)
-4.     goto http_connect_cleanup;
-3.   serverfd[CTRL] = connect_to(ipaddr, ipport);
-2.   if(serverfd[CTRL] == CURL_SOCKET_BAD)
-1.     goto http",Useful
"/*listener socket is monitored to allow client to establish
         secondary tunnel only when this tunnel is not established
         and primary one is fully operational*/","-8.     ssize_t rc;
-7.     curl_socket_t maxfd = (curl_socket_t)-1;
-6.     FD_ZERO(&input);
-5.     FD_ZERO(&output);
-4.     if((clientfd[DATA] == CURL_SOCKET_BAD) &&
-3.        (serverfd[DATA] == CURL_SOCKET_BAD) &&
-2.        poll_client_rd[CTRL] && ",Useful
/*set tunnel sockets to wait for*/,"-3.       FD_SET(rootfd, &input);
-2.       maxfd = rootfd;
-1.     }

 /*set tunnel sockets to wait for*/

1.     for(i = 0; i <= max_tunnel_idx; i++) {",Useful
/*client side socket monitoring*/,"-1.     for(i = 0; i <= max_tunnel_idx; i++) {

 /*client side socket monitoring*/

1.       if(clientfd[i] != CURL_SOCKET_BAD) {
2.         if(poll_client_rd[i]) {",Useful
"/*unless told not to do so, monitor readability*/","-2.       if(clientfd[i] != CURL_SOCKET_BAD) {
-1.         if(poll_client_rd[i]) {

 /*unless told not to do so, monitor readability*/

1.           FD_SET(clientfd[i], &input);
2.           if(clientfd[i] > maxfd)
3.             maxfd = clientfd[i];
4.  ",Useful
"/*unless told not to do so, monitor writability
             if there is data ready to be sent to client*/","-5.           FD_SET(clientfd[i], &input);
-4.           if(clientfd[i] > maxfd)
-3.             maxfd = clientfd[i];
-2.         }
-1.         if(poll_client_wr[i] && toc[i]) {

 /*unless told not to do so, monitor writability
             if there is da",Useful
/*server side socket monitoring*/,"-5.           FD_SET(clientfd[i], &output);
-4.           if(clientfd[i] > maxfd)
-3.             maxfd = clientfd[i];
-2.         }
-1.       }

 /*server side socket monitoring*/

1.       if(serverfd[i] != CURL_SOCKET_BAD) {
2.         if(poll_server_r",Useful
"/*unless told not to do so, monitor readability*/","-2.       if(clientfd[i] != CURL_SOCKET_BAD) {
-1.         if(poll_client_rd[i]) {

 /*unless told not to do so, monitor readability*/

1.           FD_SET(clientfd[i], &input);
2.           if(clientfd[i] > maxfd)
3.             maxfd = clientfd[i];
4.  ",Useful
"/*unless told not to do so, monitor writability
             if there is data ready to be sent to server*/","-5.           FD_SET(serverfd[i], &input);
-4.           if(serverfd[i] > maxfd)
-3.             maxfd = serverfd[i];
-2.         }
-1.         if(poll_server_wr[i] && tos[i]) {

 /*unless told not to do so, monitor writability
             if there is da",Useful
/*socket action*/,"-10.       }
-9.     }
-8.     if(got_exit_signal)
-7.       break;
-6.     do {
-5.       rc = select((int)maxfd + 1, &input, &output, NULL, &timeout);
-4.     } while(rc < 0 && errno == EINTR && !got_exit_signal);
-3.     if(got_exit_signal)
-2.       b",Useful
/*Disable the Nagle algorithm*/,"-10.          op_br, ipaddr, cl_br, port);
-9.   serverfd = socket(socket_domain, SOCK_STREAM, 0);
-8.   if(CURL_SOCKET_BAD == serverfd) {
-7.     error = SOCKERRNO;
-6.     logmsg(""Error creating socket for server connection: (%d) %s"",
-5.            err",Useful
"/*this socket must be closed, done or not*/","-10.             curl_socklen_t flag = 1;
-9.             if(0 != setsockopt(datafd, IPPROTO_TCP, TCP_NODELAY,
-8.                                (void *)&flag, sizeof(flag)))
-7.               logmsg(""====> TCP_NODELAY for client DATA connection failed"")",Useful
/*sleep to prevent triggering libcurl known bug #39.*/,"-3.           if(err >= 0) {
-2.             err = send_doc(datafd, req2);
-1.             if(!err && req2->connect_request) {

 /*sleep to prevent triggering libcurl known bug #39.*/

1.               for(loop = 2; (loop > 0) && !got_exit_signal; loop--)",Useful
/*connect to the server*/,"-10.     sclose(serverfd);
-9.     return CURL_SOCKET_BAD;
-8.   }
-7.   logmsg(""connected fine to %s%s%s:%hu, now tunnel"",
-6.          op_br, ipaddr, cl_br, port);
-5.   return serverfd;
-4. }
-3. /*
-2.  * A CONNECT has been received, a CONNECT respons",Useful
/*secondary tunnel not established*/,"-10.                   secondary = TRUE;
-9.                   toc[DATA] = 0;
-8.                   tos[DATA] = 0;
-7.                   clientfd[DATA] = datafd;
-6.                   datafd = CURL_SOCKET_BAD;
-5.                 }
-4.               }
-3.",Useful
/*allow kernel to place FIN bit packet on the wire*/,"-10.             if(poll_server_wr[i] && !poll_client_rd[i] && !tos[i]) {
-9.               logmsg(""[%s] DISABLED WRITING server"", data_or_ctrl(i));
-8.               shutdown(serverfd[i], SHUT_WR);
-7.               poll_server_wr[i] = FALSE;
-6.        ",Useful
/*exit loop upon primary tunnel teardown*/,"-2.       max_tunnel_idx = secondary ? DATA : CTRL;
-1.       if(!primary)

 /*exit loop upon primary tunnel teardown*/

1.         break;",Useful
"/*returns a socket handle, or 0 if there are no more waiting sockets,
   or < 0 if there was an error*/","-1. }

 /*returns a socket handle, or 0 if there are no more waiting sockets,
   or < 0 if there was an error*/

1. static curl_socket_t accept_connection(curl_socket_t sock)
2. {
3.   curl_socket_t msgsock = CURL_SOCKET_BAD;
4.   int error;
5.   int flag",Useful
"/*** As soon as this server accepts a connection from the test harness it
  ** must set the server logs advisor read lock to indicate that server
  ** logs should not be read until this lock is removed by this server.*/","-10.   }
-9.   if(0 != setsockopt(msgsock, SOL_SOCKET, SO_KEEPALIVE,
-8.                      (void *)&flag, sizeof(flag))) {
-7.     error = SOCKERRNO;
-6.     logmsg(""setsockopt(SO_KEEPALIVE) failed with error: (%d) %s"",
-5.            error, strerror(e",Useful
"/*returns 1 if the connection should be serviced again immediately, 0 if there
   is no data waiting, or < 0 if it should be closed*/","-10.   req->noexpect = FALSE;
-9.   req->writedelay = 0;
-8.   req->rcmd = RCMD_NORMALREQ;
-7.   req->prot_version = 0;
-6.   req->callcount = 0;
-5.   req->connect_port = 0;
-4.   req->done_processing = 0;
-3.   req->upgrade = 0;
-2.   req->upgrade_reque",Useful
"/*Nothing further to read now, possibly because the socket was closed*/","-10.    is no data waiting, or < 0 if it should be closed */
-9. static int service_connection(curl_socket_t msgsock, struct httprequest *req,
-8.                               curl_socket_t listensock,
-7.                               const char *connec",Useful
"/*a CONNECT request, setup and talk the tunnel*/","-10.     return -1;
-9.   if(req->testno < 0) {
-8.     logmsg(""special request received, no persistency"");
-7.     return -1;
-6.   }
-5.   if(!req->open) {
-4.     logmsg(""instructed to close connection after server-reply"");
-3.     return -1;
-2.   }
-",Useful
"/*if we got a CONNECT, loop and get another request as well!*/","-3.     http2(req);
-2.     return -1;
-1.   }

 /*if we got a CONNECT, loop and get another request as well!*/

1.   if(req->open) {
2.     logmsg(""=> persistent connection request ended, awaits new request\n"");
3.     return 1;
4.   }
5.   return -1;
6.",Useful
"/*The connect host IP number that the proxy will connect to no matter
         what the client asks for, but also use this as a hint that we run as
         a proxy and do a few different internal choices*/","-10.       }
-9.     }
-8.     else if(!strcmp(""--srcdir"", argv[arg])) {
-7.       arg++;
-6.       if(argc>arg) {
-5.         path = argv[arg];
-4.         arg++;
-3.       }
-2.     }
-1.     else if(!strcmp(""--connect"", argv[arg])) {

 /*The connect ho",Useful
/*ENABLE_IPV6*/,"-3. #endif
-2. static enum {
-1.   socket_domain_inet = AF_INET
#ifdef ENABLE_IPV6

 /*ENABLE_IPV6*/

1.   , socket_domain_inet6 = AF_INET6
2. #endif
3. #ifdef USE_UNIX_SOCKETS
4.   , socket_domain_unix = AF_UNIX
5. #endif
6. } socket_domain = AF_INET;
7.",Useful
/*USE_UNIX_SOCKETS*/,"-6. #endif
-5. static enum {
-4.   socket_domain_inet = AF_INET
-3. #ifdef ENABLE_IPV6
-2.   , socket_domain_inet6 = AF_INET6
-1. #endif
#ifdef USE_UNIX_SOCKETS

 /*USE_UNIX_SOCKETS*/

1.   , socket_domain_unix = AF_UNIX
2. #endif
3. } socket_domain = AF_",Useful
/*start accepting connections*/,"-10.       sclose(sock);
-9.       goto sws_cleanup;
-8.     }
-7.   }
-6. #ifdef USE_UNIX_SOCKETS
-5.   if(socket_domain != AF_UNIX)
-4. #endif
-3.     msnprintf(port_str, sizeof(port_str), ""port %hu"", port);
-2.   logmsg(""Running %s %s version on %s"",
-",Useful
/*Set up for select*/,"-10.       if(CURL_SOCKET_BAD == all_sockets[socket_idx]) {
-9.         char *dst = (char *) (all_sockets + socket_idx);
-8.         char *src = (char *) (all_sockets + socket_idx + 1);
-7.         char *end = (char *) (all_sockets + num_sockets);
-6.    ",Useful
/*Check if the listening socket is ready to accept*/,"-3.       continue;
-2.     }

 /*Check if the listening socket is ready to accept*/

1.     if(FD_ISSET(all_sockets[0], &input)) {",Useful
/*Service all queued connections*/,"-1.     if(FD_ISSET(all_sockets[0], &input)) {

 /*Service all queued connections*/

1.       curl_socket_t msgsock;
2.       do {
3.         msgsock = accept_connection(sock);
4.         logmsg(""accept_connection %d returned %d"", sock, msgsock);
5.      ",Useful
/*Service this connection until it has nothing available*/,"-5.     for(socket_idx = 1; (socket_idx < num_sockets) && active; ++socket_idx) {
-4.       if(FD_ISSET(all_sockets[socket_idx], &input)) {
-3.         active--;
-2.         if(got_exit_signal)
-1.           goto sws_cleanup;

 /*Service this connection u",Useful
"/*Reset the request, unless we're still in the middle of reading*/","-10.             if(all_sockets[socket_idx] != CURL_SOCKET_BAD) {
-9.               sclose(all_sockets[socket_idx]);
-8.               all_sockets[socket_idx] = CURL_SOCKET_BAD;
-7.             }
-6.             serverlogslocked -= 1;
-5.             if(!",Useful
"/** To properly set the return status of the process we
     * must raise the same signal SIGINT or SIGTERM that we
     * caught and let the old handler take care of it.*/","-10.     unlink(portname);
-9.   if(serverlogslocked) {
-8.     serverlogslocked = 0;
-7.     clear_advisor_read_lock(SERVERLOGS_LOCK);
-6.   }
-5.   restore_signal_handlers(false);
-4.   if(got_exit_signal) {
-3.     logmsg(""========> %s sws (%s pid: %ld",Useful
/*we return 1 byte at a time!*/,"-10.   struct WriteThis *pooh = (struct WriteThis *)userp;
-9.   int eof = !*pooh->readptr;
-8.   if(size*nmemb < 1)
-7.     return 0;
-6.   eof = pooh->sizeleft <= 0;
-5.   if(!eof)
-4.     pooh->sizeleft--;
-3.   if(!eof) {

 /*we return 1 byte at a tim",Useful
/*no more data left to deliver*/,"-1.   }

 /*no more data left to deliver*/

1. }
2. int test(char *URL)
3. {
4.   CURL *easy = NULL;
5.   CURL *easy2 = NULL;
6.   curl_mime *mime = NULL;
7.   curl_mimepart *part;
8.   struct curl_slist *hdrs = NULL;
9.   CURLcode result;
10.   int res =",Useful
/*First set the URL that is about to receive our POST.*/,"-5.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-4.     fprintf(stderr, ""curl_global_init() failed\n"");
-3.     return TEST_ERR_MAJOR_BAD;
-2.   }
-1.   easy = curl_easy_init();

 /*First set the URL that is about to receive our POST.*/

1.   te",Useful
/*include headers in the output*/,"-1.   test_setopt(easy, CURLOPT_VERBOSE, 1L);

 /*include headers in the output*/

1.   test_setopt(easy, CURLOPT_HEADER, 1L);",Useful
/*Bind mime data to its easy handle.*/,"-10.   curl_mime_name(part, ""greeting"");
-9.   curl_mime_type(part, ""application/X-Greeting"");
-8.   curl_mime_encoder(part, ""base64"");
-7.   hdrs = curl_slist_append(hdrs, ""X-Test-Number: 654"");
-6.   curl_mime_headers(part, hdrs, TRUE);
-5.   part = cur",Useful
/*Duplicate the handle.*/,"-1.   test_setopt(easy, CURLOPT_MIMEPOST, mime);

 /*Duplicate the handle.*/

1.   easy2 = curl_easy_duphandle(easy);
2.   if(!easy2) {
3.     fprintf(stderr, ""curl_easy_duphandle() failed\n"");
4.     res = TEST_ERR_FAILURE;
5.     goto test_cleanup;
6.  ",Useful
/*Perform on the first handle: should not send any data.*/,"-2.   curl_mime_free(mime);

 /*Perform on the first handle: should not send any data.*/

1.   result = curl_easy_perform(easy);
2.   if(result) {
3.     fprintf(stderr, ""curl_easy_perform(original) failed\n"");
4.     res = (int) result;
5.     goto test_",Useful
"/*Perform on the second handle: if the bound mime structure has not been
     duplicated properly, it should cause a valgrind error.*/","-6.   result = curl_easy_perform(easy);
-5.   if(result) {
-4.     fprintf(stderr, ""curl_easy_perform(original) failed\n"");
-3.     res = (int) result;
-2.     goto test_cleanup;
-1.   }

 /*Perform on the second handle: if the bound mime structure has no",Useful
"/**
 * Remove a file descriptor from a sockets array.*/","-6. };
-5. struct ReadWriteSockets
-4. {
-3.   struct Sockets read, write;
-2. };
-1. /**
 * Remove a file descriptor from a sockets array.

 /**
 * Remove a file descriptor from a sockets array.*/

1.  */
2. static void removeFd(struct Sockets *sockets, ",Useful
"/**
   * To ensure we only have each file descriptor once, we remove it then add
   * it again.*/","-4. static void addFd(struct Sockets *sockets, curl_socket_t fd, const char *what)
-3. {
-2.   /**
-1.    * To ensure we only have each file descriptor once, we remove it then add
   * it again.

 /**
   * To ensure we only have each file descriptor once,",Useful
/** Allocate array storage when required.*/,"-3.   fprintf(stderr, ""Add socket fd %d for %s\n"", (int) fd, what);
-2.   removeFd(sockets, fd, 0);
-1.   /*
   * Allocate array storage when required.

 /** Allocate array storage when required.*/

1.    */
2.   if(!sockets->sockets) {
3.     sockets->so",Useful
/** Add file descriptor to array.*/,"-6.       sockets->sockets = oldptr;
-5.       return;
-4.     }
-3.     sockets->max_count += 20;
-2.   }
-1.   /*
   * Add file descriptor to array.

 /** Add file descriptor to array.*/

1.    */
2.   sockets->sockets[sockets->count] = fd;
3.   ++socke",Useful
"/**
 * Callback invoked by curl to set a timeout.*/","-10.     addFd(&sockets->read, s, ""read"");
-9.   if(action == CURL_POLL_OUT || action == CURL_POLL_INOUT)
-8.     addFd(&sockets->write, s, ""write"");
-7.   if(action == CURL_POLL_REMOVE) {
-6.     removeFd(&sockets->read, s, 1);
-5.     removeFd(&sockets-",Useful
"/**
 * Update a fd_set with all of the sockets in use.*/","-10.   struct timeval now;
-9.   ssize_t result;
-8.   now = tutil_tvnow();
-7.   result = (ssize_t)((timeout->tv_sec - now.tv_sec) * 1000000 +
-6.     timeout->tv_usec - now.tv_usec);
-5.   if(result < 0)
-4.     result = 0;
-3.   return curlx_sztosi(res",Useful
"/**
 * Invoke curl when a file descriptor is set.*/","-10.                        const char *info)
-9. {
-8.   int numhandles = 0;
-7.   CURLMcode result = curl_multi_socket_action(curl, s, evBitmask, &numhandles);
-6.   if(result != CURLM_OK) {
-5.     fprintf(stderr, ""Curl error on %s: %i (%s)\n"",
-4.    ",Useful
/*Check the sockets for reading / writing*/,"-10.     if(timeout.tv_sec != -1) {
-9.       int usTimeout = getMicroSecondTimeout(&timeout);
-8.       tv.tv_sec = usTimeout / 1000000;
-7.       tv.tv_usec = usTimeout % 1000000;
-6.     }
-5.     else if(maxFd <= 0) {
-4.       tv.tv_sec = 0;
-3.     ",Useful
/*just a value*/,"-3.   ptr = curl_easy_escape(NULL, (char *)a, -1);
-2.   printf(""escape -1 length: %s\n"", ptr);

 /*just a value*/

1.   ptr = curl_easy_unescape(NULL, (char *)""moahahaha"", -1, &outlen);
2.   printf(""unescape -1 length: %s %d\n"", ptr, outlen);
3. test_cle",Useful
"/*Get socket being used for this easy handle, otherwise CURL_SOCKET_BAD*/","-10. static int res = 0;
-9. static size_t callback(char *ptr, size_t size, size_t nmemb, void *data)
-8. {
-7.   ssize_t idx = ((CURL **) data) - easy;
-6.   curl_socket_t sock;
-5.   long longdata;
-4.   CURLcode code;
-3.   const size_t failure = (size",Useful
/*Track relationship between this easy handle and the socket.*/,"-10.             ""with code %d (%s)\n"",
-9.             __FILE__, __LINE__, (int)code, curl_easy_strerror(code));
-8.     res = TEST_ERR_MAJOR_BAD;
-7.     return failure;
-6.   }
-5.   if(longdata == -1L)
-4.     sock = CURL_SOCKET_BAD;
-3.   else
-2.   ",Useful
"/*An easy handle without previous socket, record the socket.*/","-1.     if(sockets[idx] == CURL_SOCKET_BAD) {

 /*An easy handle without previous socket, record the socket.*/

1.       sockets[idx] = sock;
2.     }
3.     else if(sock != sockets[idx]) {",Useful
"/*An easy handle with a socket different to previously
         tracked one, log and fail right away. Known bug #37.*/","-3.       sockets[idx] = sock;
-2.     }
-1.     else if(sock != sockets[idx]) {

 /*An easy handle with a socket different to previously
         tracked one, log and fail right away. Known bug #37.*/

1.       fprintf(stderr, ""Handle %d started on socke",Useful
"/*if there's no timeout and we get here on the last handle, we may
         already have read the last part of the stream so waiting makes no
         sense*/","-10.     fprintf(stderr, ""%s:%d num_handles %d timeout %ld running %d\n"",
-9.             __FILE__, __LINE__, num_handles, timeout, running);
-8.     if(timeout != -1L) {
-7.       int itimeout = (timeout > (long)INT_MAX) ? INT_MAX : (int)timeout;
-6.    ",Useful
"/*more addresses can be added here
     rcpt_list = curl_slist_append(rcpt_list, ""<others@example.com>"");*/","-10.     fprintf(stderr, ""curl_global_init() failed\n"");
-9.     return TEST_ERR_MAJOR_BAD;
-8.   }
-7.   curl = curl_easy_init();
-6.   if(!curl) {
-5.     fprintf(stderr, ""curl_easy_init() failed\n"");
-4.     curl_global_cleanup();
-3.     return TEST_E",Useful
/*for setlocale()*/,#NAME?,Useful
/*for setmode()*/,"-2. #endif
-1. #ifdef HAVE_IO_H

 /*for setmode()*/

1. #endif
2. #ifdef HAVE_FCNTL_H",Useful
/*for setmode()*/,"-2. #endif
-1. #ifdef HAVE_IO_H

 /*for setmode()*/

1. #endif
2. #ifdef HAVE_FCNTL_H",Useful
/*use the value as file name*/,"-2.   env = curl_getenv(""CURL_MEMDEBUG"");
-1.   if(env) {

 /*use the value as file name*/

1.     char fname[CURL_MT_LOGFNAME_BUFSIZE];
2.     if(strlen(env) >= CURL_MT_LOGFNAME_BUFSIZE)
3.       env[CURL_MT_LOGFNAME_BUFSIZE-1] = '\0';
4.     strcpy(fnam",Useful
"/*this weird stuff here is to make curl_free() get called before
       curl_dbg_memdebug() as otherwise memory tracking will log a free()
       without an alloc!*/","-6.     char fname[CURL_MT_LOGFNAME_BUFSIZE];
-5.     if(strlen(env) >= CURL_MT_LOGFNAME_BUFSIZE)
-4.       env[CURL_MT_LOGFNAME_BUFSIZE-1] = '\0';
-3.     strcpy(fname, env);
-2.     curl_free(env);
-1.     curl_dbg_memdebug(fname);

 /*this weird stuff ",Useful
"/** Setup proper locale from environment. This is needed to enable locale-
   * specific behaviour by the C library in order to test for undesired side
   * effects that could cause in libcurl.*/","-10.   int result;
-9. #ifdef O_BINARY
-8. #  ifdef __HIGHC__
-7.   _setmode(stdout, O_BINARY);
-6. #  else
-5.   setmode(fileno(stdout), O_BINARY);
-4. #  endif
-3. #endif
-2.   memory_tracking_init();
-1.   /*
   * Setup proper locale from environment. ",Useful
/*from the private lib dir*/,"-10.  *
-9.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-8.  * KIND, either express or implied.
-7.  *
-6.  ***************************************************************************/
-5. #include ""server_setup.h""
-4. #in",Useful
/*include memdebug.h last*/,"-5. struct Curl_easy {
-4.   int fake;
-3. };
-2. #include ""curl_base64.h""
-1. #include ""curl_memory.h""

 /*include memdebug.h last*/

1. #include ""memdebug.h""
2. #define EAT_SPACE(p) while(*(p) && ISSPACE(*(p))) (p)++
3. #define EAT_WORD(p)  while(*(p) &",Useful
"/*MSVC extension, dllimport identity*/","-9. #include ""memdebug.h""
-8. #define EAT_SPACE(p) while(*(p) && ISSPACE(*(p))) (p)++
-7. #define EAT_WORD(p)  while(*(p) && !ISSPACE(*(p)) && ('>' != *(p))) (p)++
-6. #ifdef DEBUG_GETPART
-5. #define show(x) printf x
-4. #else
-3. #define show(x) Curl_no",Useful
"/*MSVC extension, dllimport identity*/","-9. #include ""memdebug.h""
-8. #define EAT_SPACE(p) while(*(p) && ISSPACE(*(p))) (p)++
-7. #define EAT_WORD(p)  while(*(p) && !ISSPACE(*(p)) && ('>' != *(p))) (p)++
-6. #ifdef DEBUG_GETPART
-5. #define show(x) printf x
-4. #else
-3. #define show(x) Curl_no",Useful
"/** readline()
 *
 * Reads a complete line from a file into a dynamically allocated buffer.
 *
 * Calling function may call this multiple times with same 'buffer'
 * and 'bufsize' pointers to avoid multiple buffer allocations. Buffer
 * will be reallocated and 'bufsize' increased until whole line fits in
 * buffer before returning it.
 *
 * Calling function is responsible to free allocated buffer.
 *
 * This function may return:
 *   GPE_OUT_OF_MEMORY
 *   GPE_END_OF_FILE
 *   GPE_OK*/","-5.     length--;
-4.   }
-3.   return length;
-2. }
-1. /*
 * readline()
 *
 * Reads a complete line from a file into a dynamically allocated buffer.
 *
 * Calling function may call this multiple times with same 'buffer'
 * and 'bufsize' pointers to avoi",Useful
"/** appenddata()
 *
 * This appends data from a given source buffer to the end of the used part of
 * a destination buffer. Arguments relative to the destination buffer are, the
 * address of a pointer to the destination buffer 'dst_buf', the length of data
 * in destination buffer excluding potential null string termination 'dst_len',
 * the allocated size of destination buffer 'dst_alloc'. All three destination
 * buffer arguments may be modified by this function. Arguments relative to the
 * source buffer are, a pointer to the source buffer 'src_buf' and indication
 * whether the source buffer is base64 encoded or not 'src_b64'.
 *
 * If the source buffer is indicated to be base64 encoded, this appends the
 * decoded data, binary or whatever, to the destination. The source buffer
 * may not hold binary data, only a null terminated string is valid content.
 *
 * Destination buffer will be enlarged and relocated as needed.
 *
 * Calling function is responsible to provide preallocated destination
 * buffer and also to deallocate it when no longer needed.
 *
 * This function may return:
 *   GPE_OUT_OF_MEMORY
 *   GPE_OK*/","-10.       continue;
-9.     newptr = realloc(*buffer, *bufsize * 2);
-8.     if(!newptr)
-7.       return GPE_OUT_OF_MEMORY;
-6.     *buffer = newptr;
-5.     *bufsize *= 2;
-4.   }
-3.   return GPE_OK;
-2. }

 /** appenddata()
 *
 * This appends data fr",Useful
/*Do we need to base64 decode the data?*/,"-1.           in_wanted_part = 0;

 /*Do we need to base64 decode the data?*/

1.           if(base64) {
2.             error = decodedata(outbuf, outlen);
3.             if(error)
4.               return error;
5.           }
6.           if(nonewline)
7",Useful
/*Do we need to base64 decode the data?*/,"-1.           in_wanted_part = 0;

 /*Do we need to base64 decode the data?*/

1.           if(base64) {
2.             error = decodedata(outbuf, outlen);
3.             if(error)
4.               return error;
5.           }
6.           if(nonewline)
7",Useful
"/*ignore comments, doctypes and xml declarations*/","-9.       end = ptr;
-8.       EAT_WORD(end);
-7.       len.sig = end - ptr;
-6.       if(len.sig > MAX_TAG_LEN) {
-5.         error = GPE_NO_BUFFER_SPACE;
-4.         break;
-3.       }
-2.       memcpy(ptag, ptr, len.uns);
-1.       ptag[len.uns] = '\0'",Useful
/*outermost element (<testcase>)*/,"-10.       while(*end && ('>' != *end))
-9.         end++;
-8.       len.sig = end - ptr;
-7.       if(len.sig > MAX_TAG_LEN) {
-6.         error = GPE_NO_BUFFER_SPACE;
-5.         break;
-4.       }
-3.       memcpy(patt, ptr, len.uns);
-2.       patt[le",Useful
"/*bit rough test, but ""mostly"" functional,*/","-2.           in_wanted_part = 1;
-1.           if(strstr(patt, ""base64=""))

 /*bit rough test, but ""mostly"" functional,*/

111",Useful
"/*this tests if removing an easy handle immediately after multi
     perform has been called succeeds or not.*/","-10.   multi_init(multiHandle);
-9.   easy_init(curl);
-8.   easy_setopt(curl, CURLOPT_USERPWD, libtest_arg2);
-7.   easy_setopt(curl, CURLOPT_SSH_PUBLIC_KEYFILE, ""curl_client_key.pub"");
-6.   easy_setopt(curl, CURLOPT_SSH_PRIVATE_KEYFILE, ""curl_client_ke",Useful
/*try a single wakeup*/,"-10.   time_before_wait = tutil_tvnow();
-9.   multi_poll(multi, NULL, 0, 1000, &numfds);
-8.   time_after_wait = tutil_tvnow();
-7.   if(tutil_tvdiff(time_after_wait, time_before_wait) < 500) {
-6.     fprintf(stderr, ""%s:%d curl_multi_poll returned too ",Useful
/*previous wakeup should not wake up this*/,"-10.   time_before_wait = tutil_tvnow();
-9.   multi_poll(multi, NULL, 0, 1000, &numfds);
-8.   time_after_wait = tutil_tvnow();
-7.   if(tutil_tvdiff(time_after_wait, time_before_wait) > 500) {
-6.     fprintf(stderr, ""%s:%d curl_multi_poll returned too ",Useful
/*try lots of wakeup*/,"-10.   time_before_wait = tutil_tvnow();
-9.   multi_poll(multi, NULL, 0, 1000, &numfds);
-8.   time_after_wait = tutil_tvnow();
-7.   if(tutil_tvdiff(time_after_wait, time_before_wait) < 500) {
-6.     fprintf(stderr, ""%s:%d curl_multi_poll returned too ",Useful
/*Server returns http code 416.*/,"-2. #include ""memdebug.h""

 /*Server returns http code 416.*/

111",Useful
/*Server sends content-range hdr.*/,"-10.   The input parameters are:
-9.   - CURLOPT_RANGE/CURLOPT_RESUME_FROM
-8.   - CURLOPT_FAILONERROR
-7.   - Returned http code (2xx/416)
-6.   - Content-Range header present in reply.
-5. */
-4. #include ""memdebug.h""

 /*Server sends content-range hdr.",Useful
/*Code that should be returned by curl_easy_perform().*/,"-2. struct testparams {

 /*Code that should be returned by curl_easy_perform().*/

1. };
2. static const struct testparams params[] = {
3.   { 0,                                                             CURLE_OK },
4.   {                              ",Useful
/*set in first.c*/,"-10. size_t WriteHeader(void *ptr, size_t size, size_t nmemb, void *stream);
-9. static unsigned long realHeaderSize = 0;
-8. int test(char *URL)
-7. {
-6.   long headerSize;
-5.   CURLcode code;
-4.   CURL *curl = NULL;
-3.   int res = 0;
-2.   global_in",Useful
"/*This test case and code is based on the bug recipe Joe Malicki provided for
 * bug report #1871269, fixed on Jan 14 2008 before the 7.18.0 release.*/",#NAME?,Useful
/*not correct*/,"-6.   easy_setopt(curl, CURLOPT_TIMEVALUE, 1566210680L);
-5.   res = curl_easy_perform(curl);
-4.   if(res)
-3.     goto test_cleanup;
-2.   curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &unmet);
-1.   if(unmet != 1L) {

 /*not correct*/

1.     goto ",Useful
/*not correct*/,"-6.   easy_setopt(curl, CURLOPT_TIMEVALUE, 1566210680L);
-5.   res = curl_easy_perform(curl);
-4.   if(res)
-3.     goto test_cleanup;
-2.   curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &unmet);
-1.   if(unmet != 1L) {

 /*not correct*/

1.     goto ",Useful
/*build request url*/,"-10.  *
-9.  ***************************************************************************/
-8. #include ""test.h""
-7. #ifdef HAVE_SYS_STAT_H
-6. #include <sys/stat.h>
-5. #endif
-4. #ifdef HAVE_FCNTL_H
-3. #include <fcntl.h>
-2. #endif
-1. #include ""memdebu",Useful
/** Test the Client->Server ANNOUNCE functionality (PUT style)*/,"-5. static char *suburl(const char *base, int i)
-4. {
-3.   return curl_maprintf(""%s%.4d"", base, i);
-2. }
-1. /*
 * Test the Client->Server ANNOUNCE functionality (PUT style)

 /** Test the Client->Server ANNOUNCE functionality (PUT style)*/

1.  */
2. ",Useful
/*Do the ANNOUNCE*/,"-10.   sdpf = fopen(""log/file568.txt"", ""rb"");
-9.   if(!sdpf) {
-8.     fprintf(stderr, ""can't open log/file568.txt\n"");
-7.     res = TEST_ERR_MAJOR_BAD;
-6.     goto test_cleanup;
-5.   }
-4.   test_setopt(curl, CURLOPT_RTSP_REQUEST, CURL_RTSPREQ_ANNOUN",Useful
/*Make sure we can do a normal request now*/,"-6.   res = curl_easy_perform(curl);
-5.   if(res)
-4.     goto test_cleanup;
-3.   test_setopt(curl, CURLOPT_UPLOAD, 0L);
-2.   fclose(sdpf);
-1.   sdpf = NULL;

 /*Make sure we can do a normal request now*/

1.   stream_uri = suburl(URL, request++);
2. ",Useful
/*Now do a POST style one*/,"-10.     res = TEST_ERR_MAJOR_BAD;
-9.     goto test_cleanup;
-8.   }
-7.   test_setopt(curl, CURLOPT_RTSP_STREAM_URI, stream_uri);
-6.   free(stream_uri);
-5.   stream_uri = NULL;
-4.   test_setopt(curl, CURLOPT_RTSP_REQUEST, CURL_RTSPREQ_DESCRIBE);
-3. ",Useful
/*Make sure we can do a normal request now*/,"-6.   res = curl_easy_perform(curl);
-5.   if(res)
-4.     goto test_cleanup;
-3.   test_setopt(curl, CURLOPT_UPLOAD, 0L);
-2.   fclose(sdpf);
-1.   sdpf = NULL;

 /*Make sure we can do a normal request now*/

1.   stream_uri = suburl(URL, request++);
2. ",Useful
/*wait until the server has sent all response headers*/,"-10. {
-9.   data->easy_handle = curl;
-8.   data->response_received = 0;
-7.   data->paused = 0;
-6.   data->remaining_bytes = 3;
-5. }
-4. static size_t read_callback(char *ptr, size_t size, size_t nitems,
-3.                             void *userdata)",Useful
/*all response headers have been received*/,"-1.   (void)ptr;

 /*all response headers have been received*/

1.   data->response_received = 1;
2.   if(data->paused) {",Useful
/*continue to send request body data*/,"-2.   data->response_received = 1;
-1.   if(data->paused) {

 /*continue to send request body data*/

1.     data->paused = 0;
2.     curl_easy_pause(data->easy_handle, CURLPAUSE_CONT);
3.   }
4.   return totalsize;
5. }
6. static int perform_and_check_co",Useful
"/** curl's test suite Real Time Streaming Protocol (RTSP) server.
 *
 * This source file was started based on curl's HTTP test suite server.*/",#NAME?,Useful
/*for TCP_NODELAY*/,"-10. #ifdef HAVE_NETINET_IN6_H
-9. #include <netinet/in6.h>
-8. #endif
-7. #ifdef HAVE_ARPA_INET_H
-6. #include <arpa/inet.h>
-5. #endif
-4. #ifdef HAVE_NETDB_H
-3. #include <netdb.h>
-2. #endif
-1. #ifdef HAVE_NETINET_TCP_H

 /*for TCP_NODELAY*/

1. #end",Useful
/*from the private lib dir*/,"-4. #endif
-3. #define ENABLE_CURLX_PRINTF

 /*from the private lib dir*/

1. #include ""getpart.h""
2. #include ""util.h""
3. #include ""server_sockaddr.h""",Useful
/*include memdebug.h last*/,"-3. #include ""getpart.h""
-2. #include ""util.h""
-1. #include ""server_sockaddr.h""

 /*include memdebug.h last*/

1. #include ""memdebug.h""
2. #ifdef USE_WINSOCK
3. #undef  EINTR",Useful
"/*instructs the server to increase the part
                                   number for a test in case the identical
                                   testno+partno request shows up again*/","-10. #endif
-9. #ifdef ENABLE_IPV6
-8. static bool use_ipv6 = FALSE;
-7. #endif
-6. static const char *ipv_inuse = ""IPv4"";
-5. static int serverlogslocked = 0;
-4. #define REQBUFSIZ 150000
-3. #define REQBUFSIZ_TXT ""149999""

 /*instructs the server to inc",Useful
"/*default request, use the tests file normally*/","-10. #endif
-9. static const char *ipv_inuse = ""IPv4"";
-8. static int serverlogslocked = 0;
-7. #define REQBUFSIZ 150000
-6. #define REQBUFSIZ_TXT ""149999""

 /*default request, use the tests file normally*/

111",Useful
/*told to sit idle*/,"-10. static const char *ipv_inuse = ""IPv4"";
-9. static int serverlogslocked = 0;
-8. #define REQBUFSIZ 150000
-7. #define REQBUFSIZ_TXT ""149999""

 /*told to sit idle*/

111",Useful
/*told to stream*/,"-10. static int serverlogslocked = 0;
-9. #define REQBUFSIZ 150000
-8. #define REQBUFSIZ_TXT ""149999""

 /*told to stream*/

1. typedef enum {
2.   RPROT_NONE = 0,
3.   RPROT_RTSP = 1,
4.   RPROT_HTTP = 2
5. } reqprot_t;
6. #define SET_RTP_PKT_CHN(p,c)  ((",Useful
"/*keep connection open info, as found in the request*/","-10. } reqprot_t;
-9. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-8. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)), \
-7.                               ((p)[3] = (unsigned char)((l) & 0xFF)))
-6. str",Useful
"/*authentication required, don't wait for body unless
                     there's an Authorization header*/","-10. #define SET_RTP_PKT_CHN(p,c)  ((p)[1] = (unsigned char)((c) & 0xFF))
-9. #define SET_RTP_PKT_LEN(p,l) (((p)[2] = (unsigned char)(((l) >> 8) & 0xFF)), \
-8.                               ((p)[3] = (unsigned char)((l) & 0xFF)))
-7. struct httprequest {",Useful
/*HTTP or RTSP version (major*10 + minor)*/,"-10.   bool digest;    /* Authorization digest header found */
-9.   bool ntlm;      /* Authorization ntlm header found */
-8.   int pipe;       /* if non-zero, expect this many requests to do a ""piped""
-7.                      request/response */
-6.   i",Useful
/*true if request is pipelined*/,"-10.   bool ntlm;      /* Authorization ntlm header found */
-9.   int pipe;       /* if non-zero, expect this many requests to do a ""piped""
-8.                      request/response */
-7.   int skip;       /* if non-zero, the server is instructed to not",Useful
"/*idle' means that it will accept the request fine but never respond
   any data. Just keep the connection alive.*/","-5. #define MAXDOCNAMELEN 140000
-4. #define MAXDOCNAMELEN_TXT ""139999""
-3. #define REQUEST_KEYWORD_SIZE 256
-2. #define REQUEST_KEYWORD_SIZE_TXT ""255""
-1. #define CMD_AUTH_REQUIRED ""auth_required""

 /*idle' means that it will accept the request fine but ",Useful
/*stream' means to send a never-ending stream of data*/,"-1. #define CMD_IDLE ""idle""

 /*stream' means to send a never-ending stream of data*/

1. #define CMD_STREAM ""stream""
2. #define END_OF_HEADERS ""\r\n\r\n""
3. enum {
4.   DOCNUMBER_NOTHING = -7,
5.   DOCNUMBER_QUIT    = -6,
6.   DOCNUMBER_BADCONNECT = -5,
",Useful
/*sent as reply to a QUIT*/,"-10. #define END_OF_HEADERS ""\r\n\r\n""
-9. enum {
-8.   DOCNUMBER_NOTHING = -7,
-7.   DOCNUMBER_QUIT    = -6,
-6.   DOCNUMBER_BADCONNECT = -5,
-5.   DOCNUMBER_INTERNAL = -4,
-4.   DOCNUMBER_CONNECT = -3,
-3.   DOCNUMBER_WERULEZ = -2,
-2.   DOCNUMBER_404  ",Useful
/*sent as reply to a CONNECT*/,"-2. static const char *docquit =
-1. ""HTTP/1.1 200 Goodbye"" END_OF_HEADERS;

 /*sent as reply to a CONNECT*/

1. static const char *docconnect =
2. ""HTTP/1.1 200 Mighty fine indeed"" END_OF_HEADERS;",Useful
"/*sent as reply to a ""bad"" CONNECT*/","-2. static const char *docconnect =
-1. ""HTTP/1.1 200 Mighty fine indeed"" END_OF_HEADERS;

 /*sent as reply to a ""bad"" CONNECT*/

1. static const char *docbadconnect =
2. ""HTTP/1.1 501 Forbidden you fool"" END_OF_HEADERS;",Useful
/*send back this on RTSP 404 file not found*/,"-6.     ""<HTML><HEAD>\n""
-5.     ""<TITLE>404 Not Found</TITLE>\n""
-4.     ""</HEAD><BODY>\n""
-3.     ""<H1>Not Found</H1>\n""
-2.     ""The requested URL was not found on this server.\n""
-1.     ""<P><HR><ADDRESS>"" RTSPDVERSION ""</ADDRESS>\n"" ""</BODY></HTML>\n",Useful
/*Default size to send away fake RTP data*/,"-3. static const char *doc404_RTSP = ""RTSP/1.0 404 Not Found\r\n""
-2.     ""Server: "" RTSPDVERSION
-1.     END_OF_HEADERS;

 /*Default size to send away fake RTP data*/

1. #define RTP_DATA_SIZE 12
2. static const char *RTP_DATA = ""$_1234\n\0asdf"";
3. stat",Useful
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(lo",Useful
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(lo",Useful
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(lo",Useful
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(lo",Useful
"/*decrease by one since we don't count the
                                      first request in this number*/","-10.             }
-9.             else if(!strncmp(CMD_STREAM, ptr, strlen(CMD_STREAM))) {
-8.               logmsg(""instructed to stream"");
-7.               req->rcmd = RCMD_STREAM;
-6.             }
-5.             else if(1 == sscanf(ptr, ""pipe: %d"",",Useful
/*The channel follows and is one byte*/,"1.                 SET_RTP_PKT_CHN(rtp_scratch, rtp_channel);",Useful
/*Length follows and is a two byte short in network order*/,"-1.                 SET_RTP_PKT_CHN(rtp_scratch, rtp_channel);

 /*Length follows and is a two byte short in network order*/

1.                 SET_RTP_PKT_LEN(rtp_scratch, rtp_size);",Useful
"/*if the host name starts with bad, we fake an error here*/","-1.         if(!strncmp(doc, ""bad"", 3))

 /*if the host name starts with bad, we fake an error here*/

1.           req->testno = DOCNUMBER_BADCONNECT;
2.         else if(!strncmp(doc, ""test"", 4)) {",Useful
"/*we do have a full set, advance the checkindex to after the end of the
       headers, for the pipelining case mostly*/","-3.   }
-2.   logmsg(""ProcessRequest found a complete request"");
-1.   if(req->pipe)

 /*we do have a full set, advance the checkindex to after the end of the
       headers, for the pipelining case mostly*/

1.     req->checkindex += (end - line) + strle",Useful
"/***** Persistence ****
   *
   * If the request is a HTTP/1.0 one, we close the connection unconditionally
   * when we're done.
   *
   * If the request is a HTTP/1.1 one, we MUST check for a ""Connection:""
   * header that might say ""close"". If it does, we close a connection when
   * this request is processed. Otherwise, we keep the connection alive for X
   * seconds.*/","-1.     req->checkindex += (end - line) + strlen(END_OF_HEADERS);
  /* **** Persistence ****
   *
   * If the request is a HTTP/1.0 one, we close the connection unconditionally
   * when we're done.
   *
   * If the request is a HTTP/1.1 one, we MUST chec",Useful
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(lo",Useful
/*this assumes that a zero Content-Length is valid*/,"-10.          have been received */
-9.       char *endptr;
-8.       char *ptr = line + 15;
-7.       unsigned long clen = 0;
-6.       while(*ptr && ISSPACE(*ptr))
-5.         ptr++;
-4.       endptr = ptr;
-3.       errno = 0;
-2.       clen = strtoul(",Useful
/*end of chunks reached*/,"-4.       chunked = TRUE;
-3.     }
-2.     if(chunked) {
-1.       if(strstr(req->reqbuf, ""\r\n0\r\n\r\n""))

 /*end of chunks reached*/

111",Useful
/*done*/,"-10.       if((strlen(doc) + strlen(request)) < 200)
-9.         msnprintf(logbuf, sizeof(logbuf), ""Got request: %s %s %s/%d.%d"",
-8.                   request, doc, prot_str, prot_major, prot_minor);
-7.       else
-6.         msnprintf(logbuf, sizeof(lo",Useful
/*not done*/,"-1.       else

 /*not done*/

1.     }
2.     line = strchr(line, '\n');
3.     if(line)
4.       line++;
5.   } while(line);
6.   if(!req->auth && strstr(req->reqbuf, ""Authorization:"")) {",Useful
"/*return 0 on success, non-zero on failure*/","-10.            totalsize-writeleft, totalsize, REQUEST_DUMP);
-9.   }
-8. storerequest_cleanup:
-7.   do {
-6.     res = fclose(dump);
-5.   } while(res && ((error = errno) == EINTR));
-4.   if(res)
-3.     logmsg(""Error closing file %s error: %d %s"",
-2",Useful
/*dump the request received so far to the external file*/,"-10.     if(got == 0) {
-9.       logmsg(""Connection closed by client"");
-8.       fail = 1;
-7.     }
-6.     else if(got < 0) {
-5.       error = SOCKERRNO;
-4.       logmsg(""recv() returned error: (%d) %s"", error, strerror(error));
-3.       fail = 1;
",Useful
/*dump request received so far to external file anyway*/,"-10.     if(got_exit_signal)
-9.       return 1;
-8.     if(done_processing && req->pipe) {
-7.       logmsg(""Waiting for another piped request"");
-6.       done_processing = 0;
-5.       req->pipe--;
-4.     }
-3.   }
-2.   if((req->offset == REQBUFSIZ-1",Useful
/*dump request received so far to external file anyway*/,"-10.     if(got_exit_signal)
-9.       return 1;
-8.     if(done_processing && req->pipe) {
-7.       logmsg(""Waiting for another piped request"");
-6.       done_processing = 0;
-5.       req->pipe--;
-4.     }
-3.   }
-2.   if((req->offset == REQBUFSIZ-1",Useful
/*dump the request to an external file*/,"-5.     reqbuf[REQBUFSIZ-1] = '\0';
-4.     fail = 1;
-3.   }
-2.   else
-1.     reqbuf[req->offset] = '\0';

 /*dump the request to an external file*/

1.   storerequest(reqbuf, req->pipelining ? req->checkindex : req->offset);
2.   if(got_exit_signal)
3",Useful
/*return 0 on success*/,"-10.            totalsize-writeleft, totalsize, REQUEST_DUMP);
-9.   }
-8. storerequest_cleanup:
-7.   do {
-6.     res = fclose(dump);
-5.   } while(res && ((error = errno) == EINTR));
-4.   if(res)
-3.     logmsg(""Error closing file %s error: %d %s"",
-2",Useful
/*returns -1 on failure*/,"-1. }

 /*returns -1 on failure*/

1. static int send_doc(curl_socket_t sock, struct httprequest *req)
2. {
3.   ssize_t written;
4.   size_t count;
5.   const char *buffer;
6.   char *ptr = NULL;
7.   char *cmd = NULL;
8.   size_t cmdsize = 0;
9.   FILE ",Useful
"/*get the custom server control ""commands""*/","-9.       }
-8.       else {
-7.         char *cmd = NULL;
-6.         size_t cmdsize = 0;
-5.         int num = 0;
-4.         int rtp_channel = 0;
-3.         int rtp_size = 0;
-2.         int rtp_partno = -1;
-1.         char *rtp_scratch = NULL;

 /*g",Useful
/*write to file as well*/,"-10.     if(num > 200)
-9.       num = 200;
-8.     written = swrite(sock, buffer, num);
-7.     if(written < 0) {
-6.       sendfailure = TRUE;
-5.       break;
-4.     }
-3.     else {
-2.       logmsg(""Sent off %zd bytes"", written);
-1.     }

 /*write",Useful
/*should not happen*/,"-10.       if(2 == sscanf(ptr, ""%31s %d"", command, &num)) {
-9.         if(!strcmp(""wait"", command)) {
-8.           logmsg(""Told to sleep for %d seconds"", num);
-7.           quarters = num * 4;
-6.           while(quarters > 0) {
-5.             quarter",Useful
/*ENABLE_IPV6*/,"-1. #endif
#ifdef ENABLE_IPV6

 /*ENABLE_IPV6*/

1. static bool use_ipv6 = FALSE;
2. #endif
3. static const char *ipv_inuse = ""IPv4"";
4. static int serverlogslocked = 0;
5. #define REQBUFSIZ 150000
6. #define REQBUFSIZ_TXT ""149999""",Useful
/*start accepting connections*/,"-9.       logmsg(""Apparently getsockname() succeeded, with listener port zero."");
-8.       logmsg(""A valid reason for this failure is a binary built without"");
-7.       logmsg(""proper network library linkage. This might not be the only"");
-6.       logm",Useful
"/*if we got a CONNECT, loop and get another request as well!*/","-10.       if((req.testno < 0) && (req.testno != DOCNUMBER_CONNECT)) {
-9.         logmsg(""special request received, no persistency"");
-8.         break;
-7.       }
-6.       if(!req.open) {
-5.         logmsg(""instructed to close connection after server",Useful
"/** To properly set the return status of the process we
     * must raise the same signal SIGINT or SIGTERM that we
     * caught and let the old handler take care of it.*/","-10.     unlink(portname);
-9.   if(serverlogslocked) {
-8.     serverlogslocked = 0;
-7.     clear_advisor_read_lock(SERVERLOGS_LOCK);
-6.   }
-5.   restore_signal_handlers(false);
-4.   if(got_exit_signal) {
-3.     logmsg(""========> %s rtspd (port: %d ",Useful
"/*Perform the request, res will get the return code*/","-1.       curl_easy_setopt(curl, CURLOPT_SHARE, share);

 /*Perform the request, res will get the return code*/

1.       res = curl_easy_perform(curl);",Useful
/*we return 1 byte at a time!*/,"-10. };
-9. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-8. {
-7.   struct WriteThis *pooh = (struct WriteThis *)userp;
-6.   if(size*nmemb < 1)
-5.     return 0;
-4.   if(pooh->sizeleft) {

 /*we return 1 byte at a time",Useful
/*no more data left to deliver*/,"-1.   }

 /*no more data left to deliver*/

1. }
2. int test(char *URL)
3. {
4.   CURL *curl;
5.   CURLcode result = CURLE_OK;
6.   int res = 0;
7.   struct WriteThis pooh = { data, sizeof(data)-1 };
8.   global_init(CURL_GLOBAL_ALL);
9.   easy_init(curl)",Useful
/*Purposely omit to set CURLOPT_POSTFIELDSIZE*/,"-10. int test(char *URL)
-9. {
-8.   CURL *curl;
-7.   CURLcode result = CURLE_OK;
-6.   int res = 0;
-5.   struct WriteThis pooh = { data, sizeof(data)-1 };
-4.   global_init(CURL_GLOBAL_ALL);
-3.   easy_init(curl);
-2.   easy_setopt(curl, CURLOPT_URL, U",Useful
/*this should not happen with test case 599*/,"-10.  ***************************************************************************/
-9. #include ""test.h""
-8. #include ""memdebug.h""
-7. static int progress_callback(void *clientp, double dltotal,
-6.                              double dlnow, double ultota",Useful
/*http and proxy header list*/,"-10.     return strlen(data);
-9.   }
-8.   (void)stream;
-7.   memcpy(ptr, data, strlen(data));
-6.   return strlen(data);
-5. }
-4. int test(char *URL)
-3. {
-2.   CURL *curl = NULL;
-1.   CURLcode res = CURLE_FAILED_INIT;

 /*http and proxy header list",Useful
/*Create fake DNS entries for serverX.example.com for all handles*/,"-10.   CURL *curl[NUM_HANDLES] = {0};
-9.   int running;
-8.   CURLM *m = NULL;
-7.   int i;
-6.   char target_url[256];
-5.   char dnsentry[256];
-4.   struct curl_slist *slist = NULL, *slist2;
-3.   char *port = libtest_arg3;
-2.   char *address = libte",Useful
/*get an easy handle*/,"-1.   for(i = 0; i < NUM_HANDLES; i++) {

 /*get an easy handle*/

1.     easy_init(curl[i]);",Useful
/*specify target*/,"-1.     easy_init(curl[i]);

 /*specify target*/

1.     msnprintf(target_url, sizeof(target_url),",Useful
/*add handle to multi*/,"-5.     easy_setopt(curl[i], CURLOPT_HEADER, 1L);
-4.     easy_setopt(curl[i], CURLOPT_RESOLVE, slist);
-3.   }
-2.   fprintf(stderr, ""Start at URL 0\n"");
-1.   for(i = 0; i < NUM_HANDLES; i++) {

 /*add handle to multi*/

1.     multi_add_handle(m, curl[",Useful
/*The last #include files should be:*/,"-10. #include ""curl_setup.h""
-9. #if defined(HAVE_GSSAPI) && defined(USE_SPNEGO)
-8. #include <curl/curl.h>
-7. #include ""vauth/vauth.h""
-6. #include ""urldata.h""
-5. #include ""curl_base64.h""
-4. #include ""curl_gssapi.h""
-3. #include ""warnless.h""
-2. #incl",Useful
"/** Curl_auth_is_spnego_supported()
 *
 * This is used to evaluate if SPNEGO (Negotiate) is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if Negotiate supported by the GSS-API library.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_is_spnego_supported()
 *
 * This is used to evaluate if SPNEGO (Negotiate) is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if Negotiate supported by the GSS-API library.

 ",Useful
"/** Curl_auth_decode_spnego_message()
 *
 * This is used to decode an already encoded SPNEGO (Negotiate) challenge
 * message.
 *
 * Parameters:
 *
 * data        [in]     - The session handle.
 * userp       [in]     - The user name in the format User or Domain\User.
 * passwdp     [in]     - The user's password.
 * service     [in]     - The service type such as http, smtp, pop or imap.
 * host        [in]     - The host name.
 * chlg64      [in]     - The optional base64 encoded challenge message.
 * nego        [in/out] - The Negotiate data struct being used and modified.
 *
 * Returns CURLE_OK on success.*/","-10.  *
-9.  * Parameters: None
-8.  *
-7.  * Returns TRUE if Negotiate supported by the GSS-API library.
-6.  */
-5. bool Curl_auth_is_spnego_supported(void)
-4. {
-3.   return TRUE;
-2. }
-1. /*
 * Curl_auth_decode_spnego_message()
 *
 * This is used to",Useful
"/*We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better*/","-10.   unsigned char *chlg = NULL;
-9.   OM_uint32 major_status;
-8.   OM_uint32 minor_status;
-7.   OM_uint32 unused_status;
-6.   gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
-5.   gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
-4.   gss_buffer_de",Useful
/*Ensure we have a valid challenge message*/,"-5.     if(*chlg64 != '=') {
-4.       result = Curl_base64_decode(chlg64, &chlg, &chlglen);
-3.       if(result)
-2.         return result;
-1.     }

 /*Ensure we have a valid challenge message*/

1.     if(!chlg) {
2.       infof(data, ""SPNEGO handshak",Useful
/*Generate our challenge-response message*/,"-3.     input_token.value = chlg;
-2.     input_token.length = chlglen;
-1.   }

 /*Generate our challenge-response message*/

1.   major_status = Curl_gss_init_sec_context(data,
2.                                            &minor_status,
3.             ",Useful
"/** Curl_auth_create_spnego_message()
 *
 * This is used to generate an already encoded SPNEGO (Negotiate) response
 * message ready for sending to the recipient.
 *
 * Parameters:
 *
 * data        [in]     - The session handle.
 * nego        [in/out] - The Negotiate data struct being used and modified.
 * outptr      [in/out] - The address where a pointer to newly allocated memory
 *                        holding the result will be stored upon completion.
 * outlen      [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-6.   if(nego->output_token.length && nego->output_token.value)
-5.     gss_release_buffer(&unused_status, &nego->output_token);
-4.   nego->output_token = output_token;
-3.   return CURLE_OK;
-2. }
-1. /*
 * Curl_auth_create_spnego_message()
 *
 * This i",Useful
/*Base64 encode the already generated response*/,"-10.  *                        holding the result will be stored upon completion.
-9.  * outlen      [out]    - The length of the output message.
-8.  *
-7.  * Returns CURLE_OK on success.
-6.  */
-5. CURLcode Curl_auth_create_spnego_message(struct negoti",Useful
/*Reset any variables*/,"-4.   if(nego->spn != GSS_C_NO_NAME) {
-3.     gss_release_name(&minor_status, &nego->spn);
-2.     nego->spn = GSS_C_NO_NAME;
-1.   }

 /*Reset any variables*/

1.   nego->status = 0;
2.   nego->noauthpersist = FALSE;
3.   nego->havenoauthpersist = FALSE",Useful
/*The last #include files should be:*/,"-10.  *
-9.  ***************************************************************************/
-8. #include ""curl_setup.h""
-7. #if !defined(CURL_DISABLE_IMAP) || !defined(CURL_DISABLE_SMTP) || \
-6.   !defined(CURL_DISABLE_POP3)
-5. #include <curl/curl.h>
-4. ",Useful
"/** Curl_auth_create_oauth_bearer_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data[in]         - The session handle.
 * user[in]         - The user name.
 * host[in]         - The host name.
 * port[in]         - The port(when not Port 80).
 * bearer[in]       - The bearer token.
 * outptr[in / out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen[out]      - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_create_oauth_bearer_message()
 *
 * This is used to generate an OAuth 2.0 message ready for sending to the
 * recipient.
 *
 * Parameters:
 *
 * user[in]         - The user name.
 ",Useful
/*Generate the message*/,"-10.  *
-9.  * Returns CURLE_OK on success.
-8.  */
-7. CURLcode Curl_auth_create_oauth_bearer_message(const char *user,
-6.                                                const char *host,
-5.                                                const long por",Useful
"/** Curl_auth_create_xoauth_bearer_message()
 *
 * This is used to generate an already encoded XOAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data[in]         - The session handle.
 * user[in]         - The user name.
 * bearer[in]       - The bearer token.
 * outptr[in / out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen[out]      - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-10.                     bearer);
-9.   else
-8.     oauth = aprintf(""n,a=%s,\1host=%s\1port=%ld\1auth=Bearer %s\1\1"", user,
-7.                     host, port, bearer);
-6.   if(!oauth)
-5.     return CURLE_OUT_OF_MEMORY;
-4.   Curl_bufref_set(out, oauth",Useful
/*The last #include files should be:*/,"-10. #include ""curl_setup.h""
-9. #if defined(USE_WINDOWS_SSPI) && defined(USE_SPNEGO)
-8. #include <curl/curl.h>
-7. #include ""vauth/vauth.h""
-6. #include ""urldata.h""
-5. #include ""curl_base64.h""
-4. #include ""warnless.h""
-3. #include ""curl_multibyte.h""
-",Useful
"/** Curl_auth_is_spnego_supported()
 *
 * This is used to evaluate if SPNEGO (Negotiate) is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if Negotiate is supported by Windows SSPI.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_is_spnego_supported()
 *
 * This is used to evaluate if SPNEGO (Negotiate) is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if Negotiate is supported by Windows SSPI.

 /** ",Useful
/*Release the package buffer as it is not required anymore*/,"-3.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
-2.                                               TEXT(SP_NAME_NEGOTIATE),
-1.                                               &SecurityPackage);

 /*Release the package buffer as it is not require",Useful
"/** Curl_auth_decode_spnego_message()
 *
 * This is used to decode an already encoded SPNEGO (Negotiate) challenge
 * message.
 *
 * Parameters:
 *
 * data        [in]     - The session handle.
 * user        [in]     - The user name in the format User or Domain\User.
 * password    [in]     - The user's password.
 * service     [in]     - The service type such as http, smtp, pop or imap.
 * host        [in]     - The host name.
 * chlg64      [in]     - The optional base64 encoded challenge message.
 * nego        [in/out] - The Negotiate data struct being used and modified.
 *
 * Returns CURLE_OK on success.*/","-6.   if(status == SEC_E_OK) {
-5.     s_pSecFn->FreeContextBuffer(SecurityPackage);
-4.   }
-3.   return (status == SEC_E_OK ? TRUE : FALSE);
-2. }
-1. /*
 * Curl_auth_decode_spnego_message()
 *
 * This is used to decode an already encoded SPNEGO (Negoti",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10. {
-9.   CURLcode result = CURLE_OK;
-8.   size_t chlglen = 0;
-7.   unsigned char *chlg = NULL;
-6.   PSecPkgInfo SecurityPackage;
-5.   SecBuffer chlg_buf[2];
-4.   SecBuffer resp_buf;
-3.   SecBufferDesc chlg_desc;
-2.   SecBufferDesc resp_desc;
-1",Useful
"/*We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better*/","-4. #if defined(CURL_DISABLE_VERBOSE_STRINGS)
-3.   (void) data;
-2. #endif
-1.   if(nego->context && nego->status == SEC_E_OK) {

 /*We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an",Useful
/*Generate our SPN*/,"-4.     Curl_auth_cleanup_spnego(nego);
-3.     return CURLE_LOGIN_DENIED;
-2.   }
-1.   if(!nego->spn) {

 /*Generate our SPN*/

1.     nego->spn = Curl_auth_build_spn(service, host, NULL);
2.     if(!nego->spn)
3.       return CURLE_OUT_OF_MEMORY;
4.   ",Useful
/*Release the package buffer as it is not required anymore*/,"-3.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
-2.                                               TEXT(SP_NAME_NEGOTIATE),
-1.                                               &SecurityPackage);

 /*Release the package buffer as it is not require",Useful
/*Populate our identity structure*/,"-1.     if(user && *user) {

 /*Populate our identity structure*/

1.       result = Curl_create_sspi_identity(user, password, &nego->identity);
2.       if(result)
3.         return result;",Useful
/*Use the current Windows user*/,"-3.       nego->p_identity = &nego->identity;
-2.     }
-1.     else

 /*Use the current Windows user*/

1.       nego->p_identity = NULL;",Useful
/*Ensure we have a valid challenge message*/,"-5.     if(*chlg64 != '=') {
-4.       result = Curl_base64_decode(chlg64, &chlg, &chlglen);
-3.       if(result)
-2.         return result;
-1.     }

 /*Ensure we have a valid challenge message*/

1.     if(!chlg) {
2.       infof(data, ""SPNEGO handshak",Useful
"/*Setup the challenge ""input"" security buffer*/","-4.     if(!chlg) {
-3.       infof(data, ""SPNEGO handshake failure (empty challenge message)"");
-2.       return CURLE_BAD_CONTENT_ENCODING;
-1.     }

 /*Setup the challenge ""input"" security buffer*/

1.     chlg_desc.ulVersion    = SECBUFFER_VERSION;
2",Useful
"/*ssl context comes from Schannel.
    * When extended protection is used in IIS server,
    * we have to pass a second SecBuffer to the SecBufferDesc
    * otherwise IIS will not pass the authentication (401 response).
    * Minimum supported version is Windows 7.
    * https://docs.microsoft.com/en-us/security-updates
    * /SecurityAdvisories/2009/973811*/","* /SecurityAdvisories/2009/973811

 /*ssl context comes from Schannel.
    * When extended protection is used in IIS server,
    * we have to pass a second SecBuffer to the SecBufferDesc
    * otherwise IIS will not pass the authentication (401 response).
    * Minimum supported version is Windows 7.
    * https://docs.microsoft.com/en-us/security-updates
    * /SecurityAdvisories/2009/973811*/

1.     */
2.     if(nego->sslContext) {
3.       SEC_CHANNEL_BINDINGS channelBindings;
4.       SecPkgContext_Bindings pkgBindings;
5.       pkgBindings.Bindings = &channelBindings;
6.       nego->status = s_pSecFn->QueryContextAttributes(
7.           nego->sslContext,
8.           SECPKG_ATTR_ENDPOINT_BINDINGS,
9.           &pkgBindings
10.       );",Useful
"/*Setup the response ""output"" security buffer*/","-10.       );
-9.       if(nego->status == SEC_E_OK) {
-8.         chlg_desc.cBuffers++;
-7.         chlg_buf[1].BufferType = SECBUFFER_CHANNEL_BINDINGS;
-6.         chlg_buf[1].cbBuffer   = pkgBindings.BindingsLength;
-5.         chlg_buf[1].pvBuffer   =",Useful
/*Generate our challenge-response message*/,"-6.   resp_desc.ulVersion = SECBUFFER_VERSION;
-5.   resp_desc.cBuffers  = 1;
-4.   resp_desc.pBuffers  = &resp_buf;
-3.   resp_buf.BufferType = SECBUFFER_TOKEN;
-2.   resp_buf.pvBuffer   = nego->output_token;
-1.   resp_buf.cbBuffer   = curlx_uztoul(nego",Useful
/*Free the decoded challenge as it is not required anymore*/,"-10.   nego->status = s_pSecFn->InitializeSecurityContext(nego->credentials,
-9.                                                      chlg ? nego->context :
-8.                                                             NULL,
-7.                         ",Useful
"/** Curl_auth_create_spnego_message()
 *
 * This is used to generate an already encoded SPNEGO (Negotiate) response
 * message ready for sending to the recipient.
 *
 * Parameters:
 *
 * data        [in]     - The session handle.
 * nego        [in/out] - The Negotiate data struct being used and modified.
 * outptr      [in/out] - The address where a pointer to newly allocated memory
 *                        holding the result will be stored upon completion.
 * outlen      [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-10.             Curl_sspi_strerror(nego->status, buffer, sizeof(buffer)));
-9.       if(nego->status == (DWORD)SEC_E_INSUFFICIENT_MEMORY)
-8.         return CURLE_OUT_OF_MEMORY;
-7.       return CURLE_AUTH_ERROR;
-6.     }
-5.   }
-4.   nego->output_toke",Useful
/*Reset any variables*/,"-2.   Curl_safefree(nego->spn);
-1.   Curl_safefree(nego->output_token);

 /*Reset any variables*/

1.   nego->status = 0;
2.   nego->token_max = 0;
3.   nego->noauthpersist = FALSE;
4.   nego->havenoauthpersist = FALSE;
5.   nego->havenegdata = FALSE;
6.",Useful
/*keep this as LAST include*/,#NAME?,Useful
/*The last #include file should be:*/,"-10.  * furnished to do so, under the terms of the COPYING file.
-9.  *
-8.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-7.  * KIND, either express or implied.
-6.  *
-5.  **************************************************",Useful
"/** Curl_memrchr()
 *
 * Our memrchr() function clone for systems which lack this function. The
 * memrchr() function is like the memchr() function, except that it searches
 * backwards from the end of the n bytes pointed to by s instead of forward
 * from the beginning.*/","-3. #include ""memdebug.h""
-2. #ifndef HAVE_MEMRCHR
-1. /*
 * Curl_memrchr()
 *
 * Our memrchr() function clone for systems which lack this function. The
 * memrchr() function is like the memchr() function, except that it searches
 * backwards from the end",Useful
/*The last #include files should be:*/,"-10. #if !defined(CURL_DISABLE_IMAP) || !defined(CURL_DISABLE_SMTP) ||       \
-9.   !defined(CURL_DISABLE_POP3)
-8. #include <curl/curl.h>
-7. #include ""urldata.h""
-6. #include ""vauth/vauth.h""
-5. #include ""curl_md5.h""
-4. #include ""warnless.h""
-3. #incl",Useful
"/** Curl_auth_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * authzid [in]     - The authorization identity.
 * authcid [in]     - The authentication identity.
 * passwd  [in]     - The password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * authzid [in]     - The authori",Useful
/*Compute binary message length. Check for overflows.*/,"-10.                                         struct bufref *out)
-9. {
-8.   char *plainauth;
-7.   size_t plainlen;
-6.   size_t zlen;
-5.   size_t clen;
-4.   size_t plen;
-3.   zlen = (authzid == NULL ? 0 : strlen(authzid));
-2.   clen = strlen(authcid",Useful
/*Calculate the reply*/,"-7.   if((zlen > SIZE_T_MAX/4) || (clen > SIZE_T_MAX/4) ||
-6.      (plen > (SIZE_T_MAX/2 - 2)))
-5.     return CURLE_OUT_OF_MEMORY;
-4.   plainlen = zlen + clen + plen + 2;
-3.   plainauth = malloc(plainlen + 1);
-2.   if(!plainauth)
-1.     return CURLE",Useful
"/** Curl_auth_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","
CURLcode Curl_auth_create_login_message(const char *valuep, struct bufref *out)
{
  Curl_bufref_set(out, valuep, strlen(valuep), NULL);
  return CURLE_OK;
}

/*
 * Curl_auth_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * user    [in]     - The user name.
 * out     [out]    - The result storage.
 *
 * Returns CURLE_OK on success.



 /** Curl_auth_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/

1.  */
2. CURLcode Curl_auth_create_external_message(const char *user,
3.                                            struct bufref *out)
4. {",Useful
"/** Curl_auth_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-10.  * out     [out]    - The result storage.
-9.  *
-8.  * Returns CURLE_OK on success.
-7.  */
-6. CURLcode Curl_auth_create_login_message(const char *valuep, struct bufref *out)
-5. {
-4.   Curl_bufref_set(out, valuep, strlen(valuep), NULL);
-3.   ret",Useful
/*This is the same formatting as the login message*/,"-10.  * Parameters:
-9.  *
-8.  * user    [in]     - The user name.
-7.  * out     [out]    - The result storage.
-6.  *
-5.  * Returns CURLE_OK on success.
-4.  */
-3. CURLcode Curl_auth_create_external_message(const char *user,
-2.                      ",Useful
/*keep this as LAST include*/,"-5. #include ""curlx.h""
-4. #include ""tool_panykey.h""
-3. #include ""tool_help.h""
-2. #include ""tool_libinfo.h""
-1. #include ""tool_version.h""

 /*keep this as LAST include*/

1. #ifdef MSDOS
2. #  define USE_WATT32
3. #endif
4. struct category_descriptors {",Useful
"/*The arguments to this function are ""pointers to pointers to char"", but
     the comparison arguments are ""pointers to char"", hence the following cast
     plus dereference*/","-9.   else if(get_category_content(category)) {
-8.     puts(""Invalid category provided, here is a list of all categories:\n"");
-7.     get_categories();
-6.   }
-5.   free(category);
-4. }
-3. static int
-2. featcomp(const void *p1, const void *p2)
-1. {",Useful
/*newline*/,"-10.   printf(""Release-Date: %s, security patched: %s\n"",
-9.          LIBCURL_TIMESTAMP, CURL_PATCHSTAMP);
-8. #else
-7.   printf(""Release-Date: %s\n"", LIBCURL_TIMESTAMP);
-6. #endif
-5.   if(curlinfo->protocols) {
-4.     printf(""Protocols: "");
-3.     ",Useful
/*newline*/,"-10.   printf(""Release-Date: %s, security patched: %s\n"",
-9.          LIBCURL_TIMESTAMP, CURL_PATCHSTAMP);
-8. #else
-7.   printf(""Release-Date: %s\n"", LIBCURL_TIMESTAMP);
-6. #endif
-5.   if(curlinfo->protocols) {
-4.     printf(""Protocols: "");
-3.     ",Useful
/*Get the list of engines*/,"-10.   }
-9.   if(strcmp(CURL_VERSION, curlinfo->version)) {
-8.     printf(""WARNING: curl and libcurl versions do not match. ""
-7.            ""Functionality may be affected.\n"");
-6.   }
-5. }
-4. void tool_list_engines(void)
-3. {
-2.   CURL *curl = cur",Useful
/*Cleanup the list of engines*/,"-9.   curl_easy_getinfo(curl, CURLINFO_SSL_ENGINES, &engines);
-8.   puts(""Build-time engines:"");
-7.   if(engines) {
-6.     for(; engines; engines = engines->next)
-5.       printf(""  %s\n"", engines->data);
-4.   }
-3.   else {
-2.     puts(""  <none>"");",Useful
/*The last #include files should be:*/,"-10.  ***************************************************************************/
-9. #include ""curl_setup.h""
-8. #if !defined(CURL_DISABLE_CRYPTO_AUTH)
-7. #include <curl/curl.h>
-6. #include ""urldata.h""
-5. #include ""vauth/vauth.h""
-4. #include ""curl_h",Useful
"/** Curl_auth_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passwdp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_create_cram_md5_message()
 *
 * This is used to generate a CRAM-MD5 response message ready for sending to
 * the recipient.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge",Useful
/*Compute the digest using the password as the key*/,"-10.  * Returns CURLE_OK on success.
-9.  */
-8. CURLcode Curl_auth_create_cram_md5_message(const struct bufref *chlg,
-7.                                            const char *userp,
-6.                                            const char *passwdp,
-5",Useful
/*The last #include files should be:*/,"-10. #include <curl/curl.h>
-9. #include ""vauth/vauth.h""
-8. #include ""vauth/digest.h""
-7. #include ""urldata.h""
-6. #include ""warnless.h""
-5. #include ""curl_multibyte.h""
-4. #include ""sendf.h""
-3. #include ""strdup.h""
-2. #include ""strcase.h""
-1. #include ",Useful
"/** Curl_auth_is_digest_supported()
*
* This is used to evaluate if DIGEST is supported.
*
* Parameters: None
*
* Returns TRUE if DIGEST is supported by Windows SSPI.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
* Curl_auth_is_digest_supported()
*
* This is used to evaluate if DIGEST is supported.
*
* Parameters: None
*
* Returns TRUE if DIGEST is supported by Windows SSPI.

 /** Curl_auth_is_digest_su",Useful
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
-1.                                               &SecurityPackage);

 /*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_p",Useful
"/** Curl_auth_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name in the format User or Domain\User.
 * passwdp [in]     - The user's password.
 * service [in]     - The service type such as http, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-6.   if(status == SEC_E_OK) {
-5.     s_pSecFn->FreeContextBuffer(SecurityPackage);
-4.   }
-3.   return (status == SEC_E_OK ? TRUE : FALSE);
-2. }
-1. /*
 * Curl_auth_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-M",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10.   CtxtHandle context;
-9.   PSecPkgInfo SecurityPackage;
-8.   SEC_WINNT_AUTH_IDENTITY identity;
-7.   SEC_WINNT_AUTH_IDENTITY *p_identity;
-6.   SecBuffer chlg_buf;
-5.   SecBuffer resp_buf;
-4.   SecBufferDesc chlg_desc;
-3.   SecBufferDesc resp_de",Useful
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
-1.                                               &SecurityPackage);

 /*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_p",Useful
/*Generate our SPN*/,"-3.   output_token = malloc(token_max);
-2.   if(!output_token)
-1.     return CURLE_OUT_OF_MEMORY;

 /*Generate our SPN*/

1.   spn = Curl_auth_build_spn(service, data->conn->host.name, NULL);
2.   if(!spn) {
3.     free(output_token);
4.     return CURL",Useful
/*Use the current Windows user*/,"-3.     p_identity = &identity;
-2.   }
-1.   else

 /*Use the current Windows user*/

1.     p_identity = NULL;",Useful
"/*Setup the challenge ""input"" security buffer*/","-10.                                               (TCHAR *) TEXT(SP_NAME_DIGEST),
-9.                                               SECPKG_CRED_OUTBOUND, NULL,
-8.                                               p_identity, NULL, NULL,
-7.                 ",Useful
"/*Setup the response ""output"" security buffer*/","-6.   chlg_desc.ulVersion = SECBUFFER_VERSION;
-5.   chlg_desc.cBuffers  = 1;
-4.   chlg_desc.pBuffers  = &chlg_buf;
-3.   chlg_buf.BufferType = SECBUFFER_TOKEN;
-2.   chlg_buf.pvBuffer   = (void *) Curl_bufref_ptr(chlg);
-1.   chlg_buf.cbBuffer   = curlx",Useful
/*Generate our response message*/,"-6.   resp_desc.ulVersion = SECBUFFER_VERSION;
-5.   resp_desc.cBuffers  = 1;
-4.   resp_desc.pBuffers  = &resp_buf;
-3.   resp_buf.BufferType = SECBUFFER_TOKEN;
-2.   resp_buf.pvBuffer   = output_token;
-1.   resp_buf.cbBuffer   = curlx_uztoul(token_max)",Useful
/*Free the response buffer*/,"-2.   *outptr = resp;
-1.   *outlen = output_token_len;

 /*Free the response buffer*/

1.   free(output_token);
2.   return CURLE_OK;
3. }
4. /*
5.  * Curl_auth_digest_cleanup()
6.  *
7.  * This is used to clean up the digest specific data.
8.  *
9.  * P",Useful
"/** Curl_override_sspi_http_realm()
 *
 * This is used to populate the domain in a SSPI identity structure
 * The realm is extracted from the challenge message and used as the
 * domain if it is not already explicitly set.
 *
 * Parameters:
 *
 * chlg     [in]     - The challenge message.
 * identity [in/out] - The identity structure.
 *
 * Returns CURLE_OK on success.*/","
      while(*chlg && ISSPACE(*chlg))
        chlg++;



 /** Curl_override_sspi_http_realm()
 *
 * This is used to populate the domain in a SSPI identity structure
 * The realm is extracted from the challenge message and used as the
 * domain if it is not already explicitly set.
 *
 * Parameters:
 *
 * chlg     [in]     - The challenge message.
 * identity [in/out] - The identity structure.
 *
 * Returns CURLE_OK on success.*/

1.  */
2. CURLcode Curl_auth_create_digest_http_message(struct Curl_easy *data,
3.                                               const char *userp,
4.                                               const char *passwdp,
5.                                               const unsigned char *request,
6.                                               const unsigned char *uripath,
7.                                               struct digestdata *digest,
8.                                               char **outptr, size_t *outlen)
9. {
10.   size_t token_max;",Useful
/*Setup identity's domain and length*/,"-2.       if(Curl_auth_digest_get_pair(chlg, value, content, &chlg)) {
-1.         if(strcasecompare(value, ""realm"")) {

 /*Setup identity's domain and length*/

1.           domain.tchar_ptr = curlx_convert_UTF8_to_tchar((char *) content);
2.           i",Useful
"/*Unknown specifier, ignore it!*/","-10.             curlx_unicodefree(domain.tchar_ptr);
-9.             return CURLE_OUT_OF_MEMORY;
-8.           }
-7.           free(identity->Domain);
-6.           identity->Domain = dup_domain.tbyte_ptr;
-5.           identity->DomainLength = curlx_uzt",Useful
/*We're done here*/,"-3.         }
-2.       }
-1.       else

 /*We're done here*/

111",Useful
/*Allow the list to be comma-separated*/,"-2.       while(*chlg && ISSPACE(*chlg))
-1.         chlg++;

 /*Allow the list to be comma-separated*/

1.       if(',' == *chlg)
2.         chlg++;
3.     }
4.   }
5.   return CURLE_OK;
6. }
7. /*
8.  * Curl_auth_decode_digest_http_message()
9.  *
10.  ",Useful
"/** Curl_auth_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the separate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.*/","digest->input_token = (BYTE *) Curl_memdup(chlg, chlglen + 1);
  if(!digest->input_token)
    return CURLE_OUT_OF_MEMORY;

  digest->input_token_len = chlglen;

  return CURLE_OK;
}

/*
 * Curl_auth_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name in the format User or Domain\User.
 * passwdp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.

 /** Curl_auth_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the separate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.*/

1.  */
2. CURLcode Curl_auth_create_digest_http_message(struct Curl_easy *data,
3.                                               const char *userp,
4.                                               const char *passwdp,
5.                                               const unsigned char *request,
6.                                               const unsigned char *uripath,
7.                                               struct digestdata *digest,
8.                                               char **outptr, size_t *outlen)
9. {
10.   size_t token_max;",Useful
/*Store the challenge for use later*/,"-10.       while(*p && ISSPACE(*p))
-9.         p++;
-8.       if(',' == *p)
-7.         p++;
-6.     }
-5.     if(stale)
-4.       Curl_auth_digest_cleanup(digest);
-3.     else
-2.       return CURLE_LOGIN_DENIED;
-1.   }

 /*Store the challenge for use",Useful
"/** Curl_auth_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name in the format User or Domain\User.
 * passwdp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-7.   digest->input_token = (BYTE *) Curl_memdup(chlg, chlglen + 1);
-6.   if(!digest->input_token)
-5.     return CURLE_OUT_OF_MEMORY;
-4.   digest->input_token_len = chlglen;
-3.   return CURLE_OK;
-2. }
-1. /*
 * Curl_auth_create_digest_http_message()
",Useful
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_DIGEST),
-1.                                               &SecurityPackage);

 /*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_p",Useful
"/*Allocate the output buffer according to the max token size as indicated
     by the security package*/","-1.   s_pSecFn->FreeContextBuffer(SecurityPackage);

 /*Allocate the output buffer according to the max token size as indicated
     by the security package*/

1.   output_token = malloc(token_max);
2.   if(!output_token) {
3.     return CURLE_OUT_OF_MEMO",Useful
/*delete the context so a new one can be made*/,"-10.     chlg_buf[2].cbBuffer   = curlx_uztoul(strlen((const char *) uripath));
-9.     chlg_buf[3].BufferType = SECBUFFER_PKG_PARAMS;
-8.     chlg_buf[3].pvBuffer   = NULL;
-7.     chlg_buf[3].cbBuffer   = 0;
-6.     chlg_buf[4].BufferType = SECBUFFER_PA",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10.   CtxtHandle context;
-9.   PSecPkgInfo SecurityPackage;
-8.   SEC_WINNT_AUTH_IDENTITY identity;
-7.   SEC_WINNT_AUTH_IDENTITY *p_identity;
-6.   SecBuffer chlg_buf;
-5.   SecBuffer resp_buf;
-4.   SecBufferDesc chlg_desc;
-3.   SecBufferDesc resp_de",Useful
/*Populate our identity domain*/,"-4.       if(Curl_create_sspi_identity(userp, passwdp, &identity)) {
-3.         free(output_token);
-2.         return CURLE_OUT_OF_MEMORY;
-1.       }

 /*Populate our identity domain*/

1.       if(Curl_override_sspi_http_realm((const char *) digest->i",Useful
/*Use the current Windows user*/,"-3.     p_identity = &identity;
-2.   }
-1.   else

 /*Use the current Windows user*/

1.     p_identity = NULL;",Useful
"/*Setup the challenge ""input"" security buffer if present*/","-10.     status = s_pSecFn->AcquireCredentialsHandle(NULL,
-9.                                                 (TCHAR *) TEXT(SP_NAME_DIGEST),
-8.                                                 SECPKG_CRED_OUTBOUND, NULL,
-7.                             ",Useful
"/*Setup the response ""output"" security buffer*/","-6.   chlg_desc.ulVersion = SECBUFFER_VERSION;
-5.   chlg_desc.cBuffers  = 1;
-4.   chlg_desc.pBuffers  = &chlg_buf;
-3.   chlg_buf.BufferType = SECBUFFER_TOKEN;
-2.   chlg_buf.pvBuffer   = (void *) Curl_bufref_ptr(chlg);
-1.   chlg_buf.cbBuffer   = curlx",Useful
/*Generate our response message*/,"-6.   resp_desc.ulVersion = SECBUFFER_VERSION;
-5.   resp_desc.cBuffers  = 1;
-4.   resp_desc.pBuffers  = &resp_buf;
-3.   resp_buf.BufferType = SECBUFFER_TOKEN;
-2.   resp_buf.pvBuffer   = output_token;
-1.   resp_buf.cbBuffer   = curlx_uztoul(token_max)",Useful
/*Return the response*/,"-10.     s_pSecFn->FreeCredentialsHandle(&credentials);
-9.     Curl_sspi_free_identity(p_identity);
-8.     free(spn);
-7.     free(output_token);
-6.     if(status == SEC_E_INSUFFICIENT_MEMORY)
-5.       return CURLE_OUT_OF_MEMORY;
-4.     infof(data, """,Useful
/*Free the response buffer*/,"-2.   *outptr = resp;
-1.   *outlen = output_token_len;

 /*Free the response buffer*/

1.   free(output_token);
2.   return CURLE_OK;
3. }
4. /*
5.  * Curl_auth_digest_cleanup()
6.  *
7.  * This is used to clean up the digest specific data.
8.  *
9.  * P",Useful
/*Reset any variables*/,"-1.   Curl_safefree(digest->input_token);

 /*Reset any variables*/

1.   digest->input_token_len = 0;",Useful
"/**
 * Now implemented:
 *
 * 1) Unix version 1
 * drwxr-xr-x 1 user01 ftp  512 Jan 29 23:32 prog
 * 2) Unix version 2
 * drwxr-xr-x 1 user01 ftp  512 Jan 29 1997  prog
 * 3) Unix version 3
 * drwxr-xr-x 1      1   1  512 Jan 29 23:32 prog
 * 4) Unix symlink
 * lrwxr-xr-x 1 user01 ftp  512 Jan 29 23:32 prog -> prog2000
 * 5) DOS style
 * 01-29-97 11:32PM <DIR> prog*/","-10.  *
-9.  * 1) Unix version 1
-8.  * drwxr-xr-x 1 user01 ftp  512 Jan 29 23:32 prog
-7.  * 2) Unix version 2
-6.  * drwxr-xr-x 1 user01 ftp  512 Jan 29 1997  prog
-5.  * 3) Unix version 3
-4.  * drwxr-xr-x 1      1   1  512 Jan 29 23:32 prog
-3.  * 4) ",Useful
/*The last #include file should be:*/,"-10. #include <curl/curl.h>
-9. #include ""urldata.h""
-8. #include ""fileinfo.h""
-7. #include ""llist.h""
-6. #include ""strtoofft.h""
-5. #include ""ftp.h""
-4. #include ""ftplistparser.h""
-3. #include ""curl_fnmatch.h""
-2. #include ""curl_memory.h""
-1. #include ""m",Useful
/*allocs buffer which will contain one line of LIST command response*/,"-1. #include ""memdebug.h""

 /*allocs buffer which will contain one line of LIST command response*/

1. #define FTP_BUFFER_ALLOCSIZE 160
2. typedef enum {
3.   PL_UNIX_TOTALSIZE = 0,
4.   PL_UNIX_FILETYPE,
5.   PL_UNIX_PERMISSION,
6.   PL_UNIX_HLINKS,
7.  ",Useful
/*USER*/,"-6. #define FTP_BUFFER_ALLOCSIZE 160
-5. typedef enum {
-4.   PL_UNIX_TOTALSIZE = 0,
-3.   PL_UNIX_FILETYPE,
-2.   PL_UNIX_PERMISSION,
-1.   PL_UNIX_HLINKS,
  PL_UNIX_USER,

 /*USER*/

1.   PL_UNIX_GROUP,
2.   PL_UNIX_SIZE,
3.   PL_UNIX_TIME,
4.   PL_UNIX",Useful
/*GROUP*/,"-7. #define FTP_BUFFER_ALLOCSIZE 160
-6. typedef enum {
-5.   PL_UNIX_TOTALSIZE = 0,
-4.   PL_UNIX_FILETYPE,
-3.   PL_UNIX_PERMISSION,
-2.   PL_UNIX_HLINKS,
-1.   PL_UNIX_USER,
  PL_UNIX_GROUP,

 /*GROUP*/

1.   PL_UNIX_SIZE,
2.   PL_UNIX_TIME,
3.   PL_UN",Useful
/*others*/,"-10.   if(str[5] == 'x')
-9.     permissions |= 1 << 3;
-8.   else if(str[5] == 's') {
-7.     permissions |= 1 << 3;
-6.     permissions |= 1 << 10;
-5.   }
-4.   else if(str[5] == 'S')
-3.     permissions |= 1 << 10;
-2.   else if(str[5] != '-')
-1.    ",Useful
"/*discard symlink which is containing multiple "" -> ""*/","-3.   Curl_set_in_callback(data, true);
-2.   if(compare(data->set.fnmatch_data, wc->pattern,
-1.              finfo->filename) == 0) {

 /*discard symlink which is containing multiple "" -> ""*/

1.     if((finfo->filetype == CURLFILETYPE_SYMLINK) && finfo",Useful
"/*scenario:
     * 1. call => OK..
     * 2. call => OUT_OF_MEMORY (or other error)
     * 3. (last) call => is skipped RIGHT HERE and the error is hadled later
     *    in wc_statemach()*/","/* scenario:
     * 1. call => OK..
     * 2. call => OUT_OF_MEMORY (or other error)
     * 3. (last) call => is skipped RIGHT HERE and the error is hadled later
     *    in wc_statemach()

 /*scenario:
     * 1. call => OK..
     * 2. call => OUT_OF_MEMORY (or other error)
     * 3. (last) call => is skipped RIGHT HERE and the error is hadled later
     *    in wc_statemach()*/

1.      */
2.     goto fail;
3.   }
4.   if(parser->os_type == OS_TYPE_UNKNOWN && bufflen > 0) {",Useful
/*considering info about FILE response format*/,"-3.     goto fail;
-2.   }
-1.   if(parser->os_type == OS_TYPE_UNKNOWN && bufflen > 0) {

 /*considering info about FILE response format*/

1.     parser->os_type = (buffer[0] >= '0' && buffer[0] <= '9') ?
2.                        OS_TYPE_WIN_NT : OS_TYP",Useful
/*FSM*/,"-3.     parser->os_type = (buffer[0] >= '0' && buffer[0] <= '9') ?
-2.                        OS_TYPE_WIN_NT : OS_TYPE_UNIX;
-1.   }

 /*FSM*/

1.     char c = buffer[i];",Useful
/*start FSM again not considering size of directory*/,"-10.       switch(parser->state.UNIX.main) {
-9.       case PL_UNIX_TOTALSIZE:
-8.         switch(parser->state.UNIX.sub.total_dirsize) {
-7.         case PL_UNIX_TOTALSIZE_INIT:
-6.           if(c == 't') {
-5.             parser->state.UNIX.sub.total_di",Useful
/*terminate permissions*/,"-10.             parser->error = CURLE_FTP_BAD_FILE_LIST;
-9.             goto fail;
-8.           }
-7.         }
-6.         else if(parser->item_length == 10) {
-5.           unsigned int perm;
-4.           if(c != ' ') {
-3.             parser->error",Useful
"/*if(ftp_pl_gettime(parser, finfo->b_data + parser->item_offset)) {
                parser->file_data->flags |= CURLFINFOFLAG_KNOWN_TIME;
              }*/","parser->error = CURLE_FTP_BAD_FILE_LIST;
            goto fail;
          }
        }
        else if(parser->item_length == 9) {
          if(c == ' ') {
            parser->state.NT.main = PL_WINNT_TIME;
            parser->state.NT.sub.time = PL_WINNT_TIME_PRESPACE;
          }
          else {
            parser->error = CURLE_FTP_BAD_FILE_LIST;
            goto fail;
          }
        }
        else {
          parser->error = CURLE_FTP_BAD_FILE_LIST;
          goto fail;
        }
        break;
      case PL_WINNT_TIME:
        parser->item_length++;
        switch(parser->state.NT.sub.time) {
        case PL_WINNT_TIME_PRESPACE:
          if(!ISSPACE(c)) {
            parser->state.NT.sub.time = PL_WINNT_TIME_TIME;
          }
          break;
        case PL_WINNT_TIME_TIME:
          if(c == ' ') {
            parser->offsets.time = parser->item_offset;
            finfo->b_data[parser->item_offset + parser->item_length -1] = 0;
            parser->state.NT.main = PL_WINNT_DIRORSIZE;
            parser->state.NT.sub.dirorsize = PL_WINNT_DIRORSIZE_PRESPACE;
            parser->item_length = 0;
          }
          else if(!strchr(""APM0123456789:"", c)) {
            parser->error = CURLE_FTP_BAD_FILE_LIST;
            goto fail;
          }
          break;
        }
        break;
      case PL_WINNT_DIRORSIZE:
        switch(parser->state.NT.sub.dirorsize) {
        case PL_WINNT_DIRORSIZE_PRESPACE:
          if(c != ' ') {
            parser->item_offset = finfo->b_used - 1;
            parser->item_length = 1;
            parser->state.NT.sub.dirorsize = PL_WINNT_DIRORSIZE_CONTENT;
          }
          break;
        case PL_WINNT_DIRORSIZE_CONTENT:
          parser->item_length ++;
          if(c == ' ') {
            finfo->b_data[parser->item_offset + parser->item_length - 1] = 0;
            if(strcmp(""<DIR>"", finfo->b_data + parser->item_offset) == 0) {
              finfo->filetype = CURLFILETYPE_DIRECTORY;
              finfo->size = 0;
            }
            else {
              char *endptr;
              if(curlx_strtoofft(finfo->b_data +
                                 parser->item_offset,
                                 &endptr, 10, &finfo->size)) {
                parser->error = CURLE_FTP_BAD_FILE_LIST;
                goto fail;
              }

 /*if(ftp_pl_gettime(parser, finfo->b_data + parser->item_offset)) {
                parser->file_data->flags |= CURLFINFOFLAG_KNOWN_TIME;
              }*/

111",Useful
/*now place where is symlink following*/,"-10.             goto fail;
-9.           }
-8.           else {
-7.             parser->state.UNIX.sub.symlink = PL_UNIX_SYMLINK_NAME;
-6.           }
-5.           break;
-4.         case PL_UNIX_SYMLINK_PRETARGET3:
-3.           parser->item_length++;
",Useful
/*only simple control*/,"-10.           break;
-9.         }
-8.         break;
-7.       }
-6.       break;
-5.     case OS_TYPE_WIN_NT:
-4.       switch(parser->state.NT.main) {
-3.       case PL_WINNT_DATE:
-2.         parser->item_length++;
-1.         if(parser->item_length ",Useful
/*Clean up any allocated memory.*/,"-10.       }
-9.       break;
-8.     default:
-7.       retsize = bufflen + 1;
-6.       goto fail;
-5.     }
-4.     i++;
-3.   }
-2.   return retsize;
-1. fail:

 /*Clean up any allocated memory.*/

1.   if(parser->file_data) {
2.     Curl_fileinfo_cle",Useful
/*The last #include files should be:*/,"-10.  ***************************************************************************/
-9. #include ""curl_setup.h""
-8. #if defined(USE_WINDOWS_SSPI) && defined(USE_NTLM)
-7. #include <curl/curl.h>
-6. #include ""vauth/vauth.h""
-5. #include ""urldata.h""
-4. #inc",Useful
"/** Curl_auth_is_ntlm_supported()
 *
 * This is used to evaluate if NTLM is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if NTLM is supported by Windows SSPI.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_is_ntlm_supported()
 *
 * This is used to evaluate if NTLM is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if NTLM is supported by Windows SSPI.

 /** Curl_auth_is_ntlm_sup",Useful
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_NTLM),
-1.                                               &SecurityPackage);

 /*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_pSe",Useful
"/** Curl_auth_create_ntlm_type1_message()
 *
 * This is used to generate an already encoded NTLM type-1 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name in the format User or Domain\User.
 * passwdp [in]     - The user's password.
 * service [in]     - The service type such as http, smtp, pop or imap.
 * host    [in]     - The host name.
 * ntlm    [in/out] - The NTLM data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-6.   if(status == SEC_E_OK) {
-5.     s_pSecFn->FreeContextBuffer(SecurityPackage);
-4.   }
-3.   return (status == SEC_E_OK ? TRUE : FALSE);
-2. }
-1. /*
 * Curl_auth_create_ntlm_type1_message()
 *
 * This is used to generate an already encoded NTLM typ",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10.                                              const char *service,
-9.                                              const char *host,
-8.                                              struct ntlmdata *ntlm,
-7.                                          ",Useful
/*Release the package buffer as it is not required anymore*/,"-2.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *) TEXT(SP_NAME_NTLM),
-1.                                               &SecurityPackage);

 /*Release the package buffer as it is not required anymore*/

1.   if(status == SEC_E_OK) {
2.     s_pSe",Useful
/*Use the current Windows user*/,"-3.     ntlm->p_identity = &ntlm->identity;
-2.   }
-1.   else

 /*Use the current Windows user*/

1.     ntlm->p_identity = NULL;",Useful
"/*Setup the type-1 ""output"" security buffer*/","-6.   ntlm->context = calloc(1, sizeof(CtxtHandle));
-5.   if(!ntlm->context)
-4.     return CURLE_OUT_OF_MEMORY;
-3.   ntlm->spn = Curl_auth_build_spn(service, host, NULL);
-2.   if(!ntlm->spn)
-1.     return CURLE_OUT_OF_MEMORY;

 /*Setup the type-1 ""ou",Useful
/*Generate our type-1 message*/,"-6.   type_1_desc.ulVersion = SECBUFFER_VERSION;
-5.   type_1_desc.cBuffers  = 1;
-4.   type_1_desc.pBuffers  = &type_1_buf;
-3.   type_1_buf.BufferType = SECBUFFER_TOKEN;
-2.   type_1_buf.pvBuffer   = ntlm->output_token;
-1.   type_1_buf.cbBuffer   = cur",Useful
"/** Curl_auth_decode_ntlm_type2_message()
 *
 * This is used to decode an already encoded NTLM type-2 message.
 *
 * Parameters:
 *
 * data     [in]     - The session handle.
 * type2msg [in]     - The base64 encoded type-2 message.
 * ntlm     [in/out] - The NTLM data struct being used and modified.
 *
 * Returns CURLE_OK on success.*/","ntlm->input_token = malloc(Curl_bufref_len(type2) + 1);
  if(!ntlm->input_token)
    return CURLE_OUT_OF_MEMORY;
  memcpy(ntlm->input_token, Curl_bufref_ptr(type2), Curl_bufref_len(type2));
  ntlm->input_token[Curl_bufref_len(type2)] = '\0';
  ntlm->input_token_len = Curl_bufref_len(type2);

  return CURLE_OK;
}

/*
* Curl_auth_create_ntlm_type3_message()
 * Curl_auth_create_ntlm_type3_message()
 *
 * This is used to generate an already encoded NTLM type-3 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name in the format User or Domain\User.
 * passwdp [in]     - The user's password.
 * ntlm    [in/out] - The NTLM data struct being used and modified.
 * out     [out]    - The result storage.
 *
 * Returns CURLE_OK on success.

 /** Curl_auth_decode_ntlm_type2_message()
 *
 * This is used to decode an already encoded NTLM type-2 message.
 *
 * Parameters:
 *
 * data     [in]     - The session handle.
 * type2msg [in]     - The base64 encoded type-2 message.
 * ntlm     [in/out] - The NTLM data struct being used and modified.
 *
 * Returns CURLE_OK on success.*/

1.  */
2. CURLcode Curl_auth_create_ntlm_type3_message(struct Curl_easy *data,
3.                                              const char *userp,
4.                                              const char *passwdp,
5.                                              struct ntlmdata *ntlm,
6.                                              struct bufref *out)
7. {
8.   CURLcode result = CURLE_OK;
9.   SecBuffer type_2_bufs[2];
10.   SecBuffer type_3_buf;",Useful
/*Ensure we have a valid type-2 message*/,"-10.  *
-9.  * Returns CURLE_OK on success.
-8.  */
-7. CURLcode Curl_auth_decode_ntlm_type2_message(struct Curl_easy *data,
-6.                                              const struct bufref *type2,
-5.                                              stru",Useful
"/** Curl_auth_create_ntlm_type3_message()
 * Curl_auth_create_ntlm_type3_message()
 *
 * This is used to generate an already encoded NTLM type-3 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name in the format User or Domain\User.
 * passwdp [in]     - The user's password.
 * ntlm    [in/out] - The NTLM data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-10.   ntlm->input_token = malloc(Curl_bufref_len(type2) + 1);
-9.   if(!ntlm->input_token)
-8.     return CURLE_OUT_OF_MEMORY;
-7.   memcpy(ntlm->input_token, Curl_bufref_ptr(type2), Curl_bufref_len(type2));
-6.   ntlm->input_token[Curl_bufref_len(type2)",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10.                                              const char *service,
-9.                                              const char *host,
-8.                                              struct ntlmdata *ntlm,
-7.                                          ",Useful
"/*Setup the type-2 ""input"" security buffer*/","-5. #if defined(CURL_DISABLE_VERBOSE_STRINGS)
-4.   (void) data;
-3. #endif
-2.   (void) passwdp;
-1.   (void) userp;

 /*Setup the type-2 ""input"" security buffer*/

1.   type_2_desc.ulVersion     = SECBUFFER_VERSION;
2.   type_2_desc.cBuffers      = 1;
3",Useful
"/*ssl context comes from schannel.
  * When extended protection is used in IIS server,
  * we have to pass a second SecBuffer to the SecBufferDesc
  * otherwise IIS will not pass the authentication (401 response).
  * Minimum supported version is Windows 7.
  * https://docs.microsoft.com/en-us/security-updates
  * /SecurityAdvisories/2009/973811*/","* /SecurityAdvisories/2009/973811

 /*ssl context comes from schannel.
  * When extended protection is used in IIS server,
  * we have to pass a second SecBuffer to the SecBufferDesc
  * otherwise IIS will not pass the authentication (401 response).
  * Minimum supported version is Windows 7.
  * https://docs.microsoft.com/en-us/security-updates
  * /SecurityAdvisories/2009/973811*/

1.   */
2.   if(ntlm->sslContext) {
3.     SEC_CHANNEL_BINDINGS channelBindings;
4.     SecPkgContext_Bindings pkgBindings;
5.     pkgBindings.Bindings = &channelBindings;
6.     status = s_pSecFn->QueryContextAttributes(
7.       ntlm->sslContext,
8.       SECPKG_ATTR_ENDPOINT_BINDINGS,
9.       &pkgBindings
10.     );",Useful
"/*Setup the type-3 ""output"" security buffer*/","-10.       &pkgBindings
-9.     );
-8.     if(status == SEC_E_OK) {
-7.       type_2_desc.cBuffers++;
-6.       type_2_bufs[1].BufferType = SECBUFFER_CHANNEL_BINDINGS;
-5.       type_2_bufs[1].cbBuffer = pkgBindings.BindingsLength;
-4.       type_2_bufs[1",Useful
/*Generate our type-3 message*/,"-6.   type_3_desc.ulVersion = SECBUFFER_VERSION;
-5.   type_3_desc.cBuffers  = 1;
-4.   type_3_desc.pBuffers  = &type_3_buf;
-3.   type_3_buf.BufferType = SECBUFFER_TOKEN;
-2.   type_3_buf.pvBuffer   = ntlm->output_token;
-1.   type_3_buf.cbBuffer   = cur",Useful
/*Free our security context*/,"-10.  *
-9.  * This is used to clean up the NTLM specific data.
-8.  *
-7.  * Parameters:
-6.  *
-5.  * ntlm    [in/out] - The NTLM data struct being cleaned up.
-4.  *
-3.  */
-2. void Curl_auth_cleanup_ntlm(struct ntlmdata *ntlm)
-1. {

 /*Free our secu",Useful
/*Reset any variables*/,"-2.   Curl_safefree(ntlm->input_token);
-1.   Curl_safefree(ntlm->output_token);

 /*Reset any variables*/

1.   ntlm->token_max = 0;
2.   Curl_safefree(ntlm->spn);
3. }",Useful
/*use our own printf() functions*/,"-10.  *
-9.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-8.  * KIND, either express or implied.
-7.  *
-6.  ***************************************************************************/
-5. #include ""tool_setup.h""
-4. #ifde",Useful
"/*200 values generated by this perl code:

   my $pi = 3.1415;
   foreach my $i (1 .. 200) {
     printf ""%d, "", sin($i/200 * 2 * $pi) * 5000 + 5000;
   }*/","-5. #ifdef HAVE_TERMIOS_H
-4. #  include <termios.h>
-3. #elif defined(HAVE_TERMIO_H)
-2. #  include <termio.h>
-1. #endif
/* 200 values generated by this perl code:

   my $pi = 3.1415;
   foreach my $i (1 .. 200) {
     printf ""%d, "", sin($i/200 * 2 * $",Useful
/*** callback for CURLOPT_XFERINFOFUNCTION*/,"-10.   if(bar->bar >= (bar->width - 6)) {
-9.     bar->barmove = -1;
-8.     bar->bar = bar->width - 6;
-7.   }
-6.   else if(bar->bar < 0) {
-5.     bar->barmove = 1;
-4.     bar->bar = 0;
-3.   }
-2. }
-1. /*
** callback for CURLOPT_XFERINFOFUNCTION

 /",Useful
"/*Calculate the current progress. initial_size can be less than zero when
     indicating that we are expecting to get the filesize from the remote*/","-10.   if(bar->initial_size < 0) {
-9.     if(dltotal || ultotal)
-8.       total = dltotal + ultotal;
-7.     else
-6.       total = CURL_OFF_T_MAX;
-5.   }
-4.   else if((CURL_OFF_T_MAX - bar->initial_size) < (dltotal + ultotal))
-3.     total = CURL_OF",Useful
/*after first call...*/,"-10.     if(dltotal || ultotal)
-9.       point = dlnow + ulnow;
-8.     else
-7.       point = CURL_OFF_T_MAX;
-6.   }
-5.   else if((CURL_OFF_T_MAX - bar->initial_size) < (dlnow + ulnow))
-4.     point = CURL_OFF_T_MAX;
-3.   else
-2.     point = dlnow ",Useful
/*we know the total data to get...*/,"-1.     if(total) {

 /*we know the total data to get...*/

1.       if(bar->prev == point)",Useful
/*progress didn't change since last invoke*/,"-1.       if(bar->prev == point)

 /*progress didn't change since last invoke*/

1.         return 0;
2.       else if((tvdiff(now, bar->prevtime) < 100L) && point < total)",Useful
/*limit progress-bar updating to 10 Hz except when we're at 100%*/,"-2.         return 0;
-1.       else if((tvdiff(now, bar->prevtime) < 100L) && point < total)

 /*limit progress-bar updating to 10 Hz except when we're at 100%*/

1.         return 0;
2.     }
3.     else {",Useful
/*total is unknown*/,"-3.         return 0;
-2.     }
-1.     else {

 /*total is unknown*/

1.       if(tvdiff(now, bar->prevtime) < 100L)",Useful
/*limit progress-bar updating to 10 Hz*/,"-2.         return 0;
-1.       else if((tvdiff(now, bar->prevtime) < 100L) && point < total)

 /*limit progress-bar updating to 10 Hz*/

1.         return 0;
2.     }
3.     else {",Useful
/*simply count invokes*/,"-4.         return 0;
-3.       fly(bar, point != bar->prev);
-2.     }
-1.   }

 /*simply count invokes*/

1.   bar->calls++;
2.   if((total > 0) && (point != bar->prev)) {
3.     char line[MAX_BARLENGTH + 1];
4.     char format[40];
5.     double frac;
",Useful
"/** Do not use +1 to get the true screen-width since writing a
         * character at the right edge will cause a line wrap.*/","-10.     struct winsize ts;
-9.     if(!ioctl(STDIN_FILENO, TIOCGWINSZ, &ts))
-8.       cols = ts.ws_col;
-7. #elif defined(WIN32)
-6.     {
-5.       HANDLE  stderr_hnd = GetStdHandle(STD_ERROR_HANDLE);
-4.       CONSOLE_SCREEN_BUFFER_INFO console_info;
",Useful
/*use our own printf() functions*/,"-10.  * copies of the Software, and permit persons to whom the Software is
-9.  * furnished to do so, under the terms of the COPYING file.
-8.  *
-7.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-6.  * KIND, either express ",Useful
"/*non-HTTP upload, probably no output should be expected*/","-10.     }
-9.     config->url_list = NULL;
-8.   }
-7. }
-6. bool output_expected(const char *url, const char *uploadfile)
-5. {
-4.   if(!uploadfile)

 /*non-HTTP upload, probably no output should be expected*/

1. }
2. bool stdin_upload(const char *upl",Useful
"/** Adds the file name to the URL if it doesn't already have one.
 * url will be freed before return if the returned pointer is different*/","-7. }
-6. bool stdin_upload(const char *uploadfile)
-5. {
-4.   return (!strcmp(uploadfile, ""-"") ||
-3.           !strcmp(uploadfile, ""."")) ? TRUE : FALSE;
-2. }
-1. /*
 * Adds the file name to the URL if it doesn't already have one.
 * url will be freed ",Useful
"/*If no file name part is given in the URL, we add this file name*/","-2. char *add_file_name_to_url(char *url, const char *filename)
-1. {

 /*If no file name part is given in the URL, we add this file name*/

111",Useful
"/*If the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

      A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    If the algorithm is ""MD5-sess"" then:

      A1 = H(unq(username-value) "":"" unq(realm-value) "":"" passwd) "":""
           unq(nonce-value) "":"" unq(cnonce-value)*/","-10.   }
-9.   if(digest->userhash) {
-8.     hashthis = aprintf(""%s:%s"", userp, digest->realm);
-7.     if(!hashthis)
-6.       return CURLE_OUT_OF_MEMORY;
-5.     hash(hashbuf, (unsigned char *) hashthis, strlen(hashthis));
-4.     free(hashthis);
-3.  ",Useful
"/*If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2 = Method "":"" digest-uri-value

    If the ""qop"" value is ""auth-int"", then A2 is:

      A2 = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)*/","-8.     tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
-7.     if(!tmp)
-6.       return CURLE_OUT_OF_MEMORY;
-5.     hash(hashbuf, (unsigned char *) tmp, strlen(tmp));
-4.     free(tmp);
-3.     convert_to_ascii(hashbuf, ha1);
-2.   }
-1.",Useful
/*We don't support auth-int for PUT or POST*/,"-10.       A2 = Method "":"" digest-uri-value
-9.     If the ""qop"" value is ""auth-int"", then A2 is:
-8.       A2 = Method "":"" digest-uri-value "":"" H(entity-body)
-7.     (The ""Method"" value is the HTTP request method as specified in section
-6.     5.1.1 of",Useful
"/*For test case 64 (snooped from a Mozilla 1.3a request)

     Authorization: Digest username=""testuser"", realm=""testrealm"", \
     nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

     Digest parameters are all quoted strings.  Username which is provided by
     the user will need double quotes and backslashes within it escaped.  For
     the other fields, this shouldn't be an issue.  realm, nonce, and opaque
     are copied as is from the server, escapes and all.  cnonce is generated
     with web-safe characters.  uri is already percent encoded.  nc is 8 hex
     characters.  algorithm and qop with standard values only contain web-safe
     characters.*/","-10.                        digest->cnonce, digest->qop, ha2);
-9.   }
-8.   else {
-7.     hashthis = aprintf(""%s:%s:%s"", ha1, digest->nonce, ha2);
-6.   }
-5.   if(!hashthis)
-4.     return CURLE_OUT_OF_MEMORY;
-3.   hash(hashbuf, (unsigned char *) hash",Useful
"/*The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode*/","-10.                        ""response=\""%s\"""",
-9.                        userp_quoted,
-8.                        digest->realm,
-7.                        digest->nonce,
-6.                        uripath,
-5.                        digest->cnonce,
-4. ",Useful
/*Add the optional fields*/,"-10.                        ""response=\""%s\"""",
-9.                        userp_quoted,
-8.                        digest->realm,
-7.                        digest->nonce,
-6.                        uripath,
-5.                        request_digest);
-4.",Useful
/*Return the output*/,"-6.     tmp = aprintf(""%s, userhash=true"", response);
-5.     free(response);
-4.     if(!tmp)
-3.       return CURLE_OUT_OF_MEMORY;
-2.     response = tmp;
-1.   }

 /*Return the output*/

1.   *outptr = response;
2.   *outlen = strlen(response);
3.   re",Useful
"/** Curl_auth_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passwdp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-5.   *outptr = response;
-4.   *outlen = strlen(response);
-3.   return CURLE_OK;
-2. }
-1. /*
 * Curl_auth_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters",Useful
/*default algorithm*/,"-10.  */
-9. void Curl_auth_digest_cleanup(struct digestdata *digest)
-8. {
-7.   Curl_safefree(digest->nonce);
-6.   Curl_safefree(digest->cnonce);
-5.   Curl_safefree(digest->realm);
-4.   Curl_safefree(digest->opaque);
-3.   Curl_safefree(digest->qop);",Useful
/*when SFTP is used*/,"-1. CURLcode Curl_getworkingpath(struct Curl_easy *data,

 /*when SFTP is used*/

111",Useful
"/*returns the  allocated
                                             real path to work with*/","-2. CURLcode Curl_getworkingpath(struct Curl_easy *data,

 /*returns the  allocated
                                             real path to work with*/

1. {
2.   char *real_path = NULL;
3.   char *working_path;
4.   size_t working_path_len;
5.   CURLco",Useful
"/*Check for /~/, indicating relative to the user's home directory*/","-10.                                              real path to work with */
-9. {
-8.   char *real_path = NULL;
-7.   char *working_path;
-6.   size_t working_path_len;
-5.   CURLcode result =
-4.     Curl_urldecode(data->state.up.path, 0, &working_path,
",Useful
"/*It is referenced to the home directory, so strip the leading '/~/'*/","-7.   if(data->conn->handler->protocol & CURLPROTO_SCP) {
-6.     real_path = malloc(working_path_len + 1);
-5.     if(!real_path) {
-4.       free(working_path);
-3.       return CURLE_OUT_OF_MEMORY;
-2.     }
-1.     if((working_path_len > 3) && (!memcm",Useful
/*store the pointer for the caller to receive*/,"-10.     else {
-9.       real_path = malloc(working_path_len + 1);
-8.       if(!real_path) {
-7.         free(working_path);
-6.         return CURLE_OUT_OF_MEMORY;
-5.       }
-4.       memcpy(real_path, working_path, 1 + working_path_len);
-3.     }
-",Useful
"/*The get_pathname() function is being borrowed from OpenSSH sftp.c
   version 4.6p1.*/","-3.   *path = real_path;
-2.   return CURLE_OK;
-1. }

 /*The get_pathname() function is being borrowed from OpenSSH sftp.c
   version 4.6p1.*/

1. /*
2.  * Copyright (c) 2001-2004 Damien Miller <djm@openbsd.org>
3.  *
4.  * Permission to use, copy, modif",Useful
/*Do we have a untagged response?*/,"-9. static CURLcode imap_state_capability_resp(struct Curl_easy *data,
-8.                                            int imapcode,
-7.                                            imapstate instate)
-6. {
-5.   CURLcode result = CURLE_OK;
-4.   struct conn",Useful
/*Extract the word*/,"-9.     for(;;) {
-8.       size_t wordlen;
-7.       while(*line &&
-6.             (*line == ' ' || *line == '\t' ||
-5.               *line == '\r' || *line == '\n')) {
-4.         line++;
-3.       }
-2.       if(!*line)
-1.         break;

 /*Extract",Useful
/*Does the server support the STARTTLS capability?*/,"-4.       for(wordlen = 0; line[wordlen] && line[wordlen] != ' ' &&
-3.             line[wordlen] != '\t' && line[wordlen] != '\r' &&
-2.             line[wordlen] != '\n';)
-1.         wordlen++;

 /*Does the server support the STARTTLS capability?*/

1.",Useful
/*Has the server explicitly disabled clear text authentication?*/,"-2.       if(wordlen == 8 && !memcmp(line, ""STARTTLS"", 8))
-1.         imapc->tls_supported = TRUE;

 /*Has the server explicitly disabled clear text authentication?*/

1.       else if(wordlen == 13 && !memcmp(line, ""LOGINDISABLED"", 13))
2.         imapc",Useful
/*Does the server support the SASL-IR capability?*/,"-2.       else if(wordlen == 13 && !memcmp(line, ""LOGINDISABLED"", 13))
-1.         imapc->login_disabled = TRUE;

 /*Does the server support the SASL-IR capability?*/

1.       else if(wordlen == 7 && !memcmp(line, ""SASL-IR"", 7))
2.         imapc->ir_supp",Useful
/*Do we have a SASL based authentication mechanism?*/,"-2.       else if(wordlen == 7 && !memcmp(line, ""SASL-IR"", 7))
-1.         imapc->ir_supported = TRUE;

 /*Do we have a SASL based authentication mechanism?*/

1.       else if(wordlen > 5 && !memcmp(line, ""AUTH="", 5)) {
2.         size_t llen;
3.        ",Useful
/*Test the word for a matching authentication mechanism*/,"-5.       else if(wordlen > 5 && !memcmp(line, ""AUTH="", 5)) {
-4.         size_t llen;
-3.         unsigned short mechbit;
-2.         line += 5;
-1.         wordlen -= 5;

 /*Test the word for a matching authentication mechanism*/

1.         mechbit = C",Useful
/*Switch to TLS connection now*/,"-1.     if(imapcode == IMAP_RESP_OK && imapc->tls_supported && !imapc->preauth) {

 /*Switch to TLS connection now*/

1.       result = imap_perform_starttls(data);
2.     }
3.     else if(data->set.use_ssl <= CURLUSESSL_TRY)
4.       result = imap_perfor",Useful
/*Authenticated*/,"-4.   result = Curl_sasl_continue(&imapc->sasl, data, imapcode, &progress);
-3.   if(!result)
-2.     switch(progress) {
-1.     case SASL_DONE:

 /*Authenticated*/

1.       break;",Useful
/*No mechanism left after cancellation*/,"-1.       break;

 /*No mechanism left after cancellation*/

1.       if((!imapc->login_disabled) && (imapc->preftype & IMAP_TYPE_CLEARTEXT))",Useful
/*End of connect phase*/,"-5.   if(imapcode != IMAP_RESP_OK) {
-4.     failf(data, ""Access denied. %c"", imapcode);
-3.     result = CURLE_LOGIN_DENIED;
-2.   }
-1.   else

 /*End of connect phase*/

1.     state(data, IMAP_STOP);
2.   return result;
3. }",Useful
/*Temporarily add the LF character back and send as body to the client*/,"-1.   if(imapcode == '*') {

 /*Temporarily add the LF character back and send as body to the client*/

1.     line[len] = '\n';
2.     result = Curl_client_write(data, CLIENTWRITE_BODY, line, len + 1);
3.     line[len] = '\0';
4.   }
5.   else if(imapcod",Useful
/*End of DO phase*/,"-7.     line[len] = '\n';
-6.     result = Curl_client_write(data, CLIENTWRITE_BODY, line, len + 1);
-5.     line[len] = '\0';
-4.   }
-3.   else if(imapcode != IMAP_RESP_OK)
-2.     result = CURLE_QUOTE_ERROR;
-1.   else

 /*End of DO phase*/

1.     sta",Useful
/*See if this is an UIDVALIDITY response*/,"-1.   if(imapcode == '*') {

 /*See if this is an UIDVALIDITY response*/

1.     char tmp[20];
2.     if(sscanf(line + 2, ""OK [UIDVALIDITY %19[0123456789]]"", tmp) == 1) {
3.       Curl_safefree(imapc->mailbox_uidvalidity);
4.       imapc->mailbox_uidvalid",Useful
/*Check if the UIDVALIDITY has been specified and matches*/,"-7.     char tmp[20];
-6.     if(sscanf(line + 2, ""OK [UIDVALIDITY %19[0123456789]]"", tmp) == 1) {
-5.       Curl_safefree(imapc->mailbox_uidvalidity);
-4.       imapc->mailbox_uidvalidity = strdup(tmp);
-3.     }
-2.   }
-1.   else if(imapcode == IMAP_RE",Useful
"/*Something like this is received ""* 1 FETCH (BODY[TEXT] {2021}\r"" so parse
     the continuation data contained within the curly brackets*/","-5.   if(imapcode != '*') {
-4.     Curl_pgrsSetDownloadSize(data, -1);
-3.     state(data, IMAP_STOP);
-2.     return CURLE_REMOTE_FILE_NOT_FOUND;
-1.   }

 /*Something like this is received ""* 1 FETCH (BODY[TEXT] {2021}\r"" so parse
     the continuation",Useful
"/*At this point there is a bunch of data in the header ""cache"" that is
         actually body content, send it as body and then skip it. Do note
         that there may even be additional ""headers"" after the body.*/","-10.       if(endptr - ptr > 1 && endptr[0] == '}' &&
-9.          endptr[1] == '\r' && endptr[2] == '\0')
-8.         parsed = TRUE;
-7.     }
-6.   }
-5.   if(parsed) {
-4.     infof(data, ""Found %"" CURL_FORMAT_CURL_OFF_T "" bytes to download"",
-3.      ",Useful
"/*no size, we're done with the data*/","-2.         chunk = (size_t)size;
-1.       if(!chunk) {

 /*no size, we're done with the data*/

1.         state(data, IMAP_STOP);
2.         return CURLE_OK;
3.       }
4.       result = Curl_client_write(data, CLIENTWRITE_BODY, pp->cache, chunk);
5.  ",Useful
/*IMAP download*/,"-2.       Curl_setup_transfer(data, -1, -1, FALSE, -1);
-1.     else {

 /*IMAP download*/

1.       data->req.maxdownload = size;",Useful
/*We don't know how to parse this line*/,"-5.       data->conn->cselect_bits = CURL_CSELECT_IN;
-4.       Curl_setup_transfer(data, FIRSTSOCKET, size, FALSE, -1);
-3.     }
-2.   }
-1.   else {

 /*We don't know how to parse this line*/

1.     failf(data, ""Failed to parse FETCH response."");
2.  ",Useful
/*End of DO phase*/,"-7.     line[len] = '\n';
-6.     result = Curl_client_write(data, CLIENTWRITE_BODY, line, len + 1);
-5.     line[len] = '\0';
-4.   }
-3.   else if(imapcode != IMAP_RESP_OK)
-2.     result = CURLE_QUOTE_ERROR;
-1.   else

 /*End of DO phase*/

1.     sta",Useful
/*End of DONE phase*/,"-3.   if(imapcode != IMAP_RESP_OK)
-2.     result = CURLE_WEIRD_SERVER_REPLY;
-1.   else

 /*End of DONE phase*/

1.     state(data, IMAP_STOP);
2.   return result;
3. }",Useful
/*IMAP upload*/,"-1.     Curl_pgrsSetUploadSize(data, data->state.infilesize);

 /*IMAP upload*/

1.     Curl_setup_transfer(data, -1, -1, FALSE, FIRSTSOCKET);",Useful
/*End of DO phase*/,"-7.     line[len] = '\n';
-6.     result = Curl_client_write(data, CLIENTWRITE_BODY, line, len + 1);
-5.     line[len] = '\0';
-4.   }
-3.   else if(imapcode != IMAP_RESP_OK)
-2.     result = CURLE_QUOTE_ERROR;
-1.   else

 /*End of DO phase*/

1.     sta",Useful
/*End of DONE phase*/,"-3.   if(imapcode != IMAP_RESP_OK)
-2.     result = CURLE_WEIRD_SERVER_REPLY;
-1.   else

 /*End of DONE phase*/

1.     state(data, IMAP_STOP);
2.   return result;
3. }",Useful
"/*Busy upgrading the connection; right now all I/O is SSL/TLS, not IMAP*/","-10. static CURLcode imap_statemachine(struct Curl_easy *data,
-9.                                   struct connectdata *conn)
-8. {
-7.   CURLcode result = CURLE_OK;
-6.   curl_socket_t sock = conn->sock[FIRSTSOCKET];
-5.   int imapcode;
-4.   struct ima",Useful
/*Was there an error parsing the response line?*/,"-3.     result = Curl_pp_readresp(data, sock, pp, &imapcode, &nread);
-2.     if(result)
-1.       return result;

 /*Was there an error parsing the response line?*/

1.     if(imapcode == -1)
2.       return CURLE_WEIRD_SERVER_REPLY;
3.     if(!imapcode)",Useful
/*We have now received a full IMAP server response*/,"-4.     if(imapcode == -1)
-3.       return CURLE_WEIRD_SERVER_REPLY;
-2.     if(!imapcode)
-1.       break;

 /*We have now received a full IMAP server response*/

1.     switch(imapc->state) {
2.     case IMAP_SERVERGREET:
3.       result = imap_state_s",Useful
"/*fallthrough, just stop!*/","-10.     case IMAP_FETCH_FINAL:
-9.       result = imap_state_fetch_final_resp(data, imapcode, imapc->state);
-8.       break;
-7.     case IMAP_APPEND:
-6.       result = imap_state_append_resp(data, imapcode, imapc->state);
-5.       break;
-4.     case",Useful
/*internal error*/,"-1.     default:

 /*internal error*/

1.       state(data, IMAP_STOP);
2.       break;
3.     }
4.   } while(!result && imapc->state != IMAP_STOP && Curl_pp_moredata(pp));
5.   return result;
6. }",Useful
/*Called repeatedly until done from multi.c*/,"-6.       state(data, IMAP_STOP);
-5.       break;
-4.     }
-3.   } while(!result && imapc->state != IMAP_STOP && Curl_pp_moredata(pp));
-2.   return result;
-1. }

 /*Called repeatedly until done from multi.c*/

1. static CURLcode imap_multi_statemach(s",Useful
"/***********************************************************************
 *
 * imap_connect()
 *
 * This function should do everything that is to be considered a part of the
 * connection phase.
 *
 * The variable 'done' points to will be TRUE if the protocol-layer connect
 * phase is done when this function returns, or FALSE if not.*/","-6. static int imap_getsock(struct Curl_easy *data,
-5.                         struct connectdata *conn,
-4.                         curl_socket_t *socks)
-3. {
-2.   return Curl_pp_getsock(data, &conn->proto.imapc.pp, socks);
-1. }
/********************",Useful
/*Set the default preferred authentication type and mechanism*/,"-2.   connkeep(conn, ""IMAP default"");
-1.   PINGPONG_SETUP(pp, imap_statemachine, imap_endofresp);

 /*Set the default preferred authentication type and mechanism*/

1.   imapc->preftype = IMAP_TYPE_ANY;
2.   Curl_sasl_init(&imapc->sasl, data, &saslimap);",Useful
/*Initialise the pingpong layer*/,"-3.   imapc->preftype = IMAP_TYPE_ANY;
-2.   Curl_sasl_init(&imapc->sasl, data, &saslimap);
-1.   Curl_dyn_init(&imapc->dyn, DYN_IMAP_CMD);

 /*Initialise the pingpong layer*/

1.   Curl_pp_setup(pp);
2.   Curl_pp_init(data, pp);",Useful
/*Start off waiting for the server greeting response*/,"-3.   result = imap_parse_url_options(conn);
-2.   if(result)
-1.     return result;

 /*Start off waiting for the server greeting response*/

1.   state(data, IMAP_SERVERGREET);",Useful
/*Start off with an response id of '*'*/,"-1.   state(data, IMAP_SERVERGREET);

 /*Start off with an response id of '*'*/

1.   strcpy(imapc->resptag, ""*"");
2.   result = imap_multi_statemach(data, done);
3.   return result;
4. }
5. /***************************************************************",Useful
/*marked for closure*/,"-10. static CURLcode imap_done(struct Curl_easy *data, CURLcode status,
-9.                           bool premature)
-8. {
-7.   CURLcode result = CURLE_OK;
-6.   struct connectdata *conn = data->conn;
-5.   struct IMAP *imap = data->req.p.imap;
-4.   (v",Useful
/*use the already set error code*/,"-10.                           bool premature)
-9. {
-8.   CURLcode result = CURLE_OK;
-7.   struct connectdata *conn = data->conn;
-6.   struct IMAP *imap = data->req.p.imap;
-5.   (void)premature;
-4.   if(!imap)
-3.     return CURLE_OK;
-2.   if(status",Useful
/*Handle responses after FETCH or APPEND transfer has finished*/,"-4.   }
-3.   else if(!data->set.connect_only && !imap->custom &&
-2.           (imap->uid || imap->mindex || data->set.upload ||
-1.           data->set.mimepost.kind != MIMEKIND_NONE)) {

 /*Handle responses after FETCH or APPEND transfer has finished*/",Useful
/*Run the state-machine*/,"-4.       result = Curl_pp_sendf(data, &conn->proto.imapc.pp, ""%s"", """");
-3.       if(!result)
-2.         state(data, IMAP_APPEND_FINAL);
-1.     }

 /*Run the state-machine*/

1.     if(!result)
2.       result = imap_block_statemach(data, conn, FALSE);",Useful
/*Start the first command in the DO phase*/,"-5.   if(imap->mailbox && imapc->mailbox &&
-4.      strcasecompare(imap->mailbox, imapc->mailbox) &&
-3.      (!imap->uidvalidity || !imapc->mailbox_uidvalidity ||
-2.       strcasecompare(imap->uidvalidity, imapc->mailbox_uidvalidity)))
-1.     selected",Useful
/*APPEND can be executed directly*/,"-1.   if(data->set.upload || data->set.mimepost.kind != MIMEKIND_NONE)

 /*APPEND can be executed directly*/

1.     result = imap_perform_append(data);
2.   else if(imap->custom && (selected || !imap->mailbox))",Useful
/*Custom command using the same mailbox or no mailbox*/,"-2.     result = imap_perform_append(data);
-1.   else if(imap->custom && (selected || !imap->mailbox))

 /*Custom command using the same mailbox or no mailbox*/

1.     result = imap_perform_list(data);
2.   else if(!imap->custom && selected && (imap->ui",Useful
/*Run the state-machine*/,"-4.       result = Curl_pp_sendf(data, &conn->proto.imapc.pp, ""%s"", """");
-3.       if(!result)
-2.         state(data, IMAP_APPEND_FINAL);
-1.     }

 /*Run the state-machine*/

1.     if(!result)
2.       result = imap_block_statemach(data, conn, FALSE);",Useful
"/*We cannot send quit unconditionally. If this connection is stale or
     bad in any way, sending quit and waiting around here will make the
     disconnect wait in vain and cause more problems than we need to.*/","-10.  * imap_disconnect()
-9.  *
-8.  * Disconnect from an IMAP server. Cleanup protocol-specific per-connection
-7.  * resources. BLOCKING.
-6.  */
-5. static CURLcode imap_disconnect(struct Curl_easy *data,
-4.                                 struct con",Useful
"/*The IMAP session may or may not have been allocated/setup at this
     point!*/","-10.  * resources. BLOCKING.
-9.  */
-8. static CURLcode imap_disconnect(struct Curl_easy *data,
-7.                                 struct connectdata *conn, bool dead_connection)
-6. {
-5.   struct imap_conn *imapc = &conn->proto.imapc;
-4.   (void)data",Useful
/*Call this when the DO phase has completed*/,"-4.   Curl_safefree(imapc->mailbox);
-3.   Curl_safefree(imapc->mailbox_uidvalidity);
-2.   return CURLE_OK;
-1. }

 /*Call this when the DO phase has completed*/

1. static CURLcode imap_dophase_done(struct Curl_easy *data, bool connected)
2. {
3.   stru",Useful
/*Called from multi.c while DOing*/,"-3.     Curl_setup_transfer(data, -1, -1, FALSE, -1);
-2.   return CURLE_OK;
-1. }

 /*Called from multi.c while DOing*/

1. static CURLcode imap_doing(struct Curl_easy *data, bool *dophase_done)
2. {
3.   CURLcode result = imap_multi_statemach(data, doph",Useful
/*not connected*/,"-6. static CURLcode imap_doing(struct Curl_easy *data, bool *dophase_done)
-5. {
-4.   CURLcode result = imap_multi_statemach(data, dophase_done);
-3.   if(result)
-2.     DEBUGF(infof(data, ""DO phase failed""));
-1.   else if(*dophase_done) {

 /*not conn",Useful
/*Set the progress data*/,"-1.   data->req.size = -1;

 /*Set the progress data*/

1.   Curl_pgrsSetUploadCounter(data, 0);
2.   Curl_pgrsSetDownloadCounter(data, 0);
3.   Curl_pgrsSetUploadSize(data, -1);
4.   Curl_pgrsSetDownloadSize(data, -1);",Useful
/*Calculate the tag based on the connection ID and command ID*/,"-10.  *
-9.  * Sends the formatted string as an IMAP command to the server.
-8.  *
-7.  * Designed to never block.
-6.  */
-5. static CURLcode imap_sendf(struct Curl_easy *data, const char *fmt, ...)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   struct im",Useful
"/***********************************************************************
 *
 * imap_atom()
 *
 * Checks the input string for characters that need escaping and returns an
 * atom ready for sending to the server.
 *
 * The returned string needs to be freed.
 **/","
/***************************************************************************
 *                                  _   _ ____  _



 /***********************************************************************
 *
 * imap_atom()
 *
 * Checks the input string for characters that need escaping and returns an
 * atom ready for sending to the server.
 *
 * The returned string needs to be freed.
 **/

1.  *  Project                     ___| | | |  _ \| |
2.  *                             / __| | | | |_) | |
3.  *                            | (__| |_| |  _ <| |___
4.  *                             \___|\___/|_| \_\_____|
5.  *
6.  * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
7.  *
8.  * This software is licensed as described in the file COPYING, which
9.  * you should have received as part of this distribution. The terms",Useful
"/*Does the input contain any ""atom-special"" characters?*/","-10.     else if(!escape_only) {
-9.       const char *p3 = atom_specials;
-8.       while(*p3 && !others_exists) {
-7.         if(*p1 == *p3)
-6.           others_exists = TRUE;
-5.         p3++;
-4.       }
-3.     }
-2.     p1++;
-1.   }

 /*Does the i",Useful
/*Calculate the new string length*/,"-2.   if(!backsp_count && !quote_count && !others_exists)
-1.     return strdup(str);

 /*Calculate the new string length*/

1.   newlen = strlen(str) + backsp_count + quote_count + (escape_only ? 0 : 2);",Useful
/*Surround the string in quotes if necessary*/,"-3.   newstr = (char *) malloc((newlen + 1) * sizeof(char));
-2.   if(!newstr)
-1.     return NULL;

 /*Surround the string in quotes if necessary*/

1.   p2 = newstr;
2.   if(!escape_only) {
3.     newstr[0] = '""';
4.     newstr[newlen - 1] = '""';
5.    ",Useful
"/*Copy the string, escaping backslash and quote characters along the way*/","-6.   p2 = newstr;
-5.   if(!escape_only) {
-4.     newstr[0] = '""';
-3.     newstr[newlen - 1] = '""';
-2.     p2++;
-1.   }

 /*Copy the string, escaping backslash and quote characters along the way*/

1.   p1 = str;
2.   while(*p1) {
3.     if(*p1 == '\",Useful
/*bchar*/,"-5.   newstr[newlen] = '\0';
-4.   return newstr;
-3. }
-2. /***********************************************************************
-1.  *
 * imap_is_bchar()

 /*bchar*/

1.  *
2.  * Portable test of whether the specified char is a ""bchar"" as defined in ",Useful
/*bchar -> achar*/,"-1.     case ':': case '@': case '/':

 /*bchar -> achar*/

1.     case '&': case '=':",Useful
/*bchar -> achar -> uchar -> unreserved*/,"-1.     case '&': case '=':

 /*bchar -> achar -> uchar -> unreserved*/

1.     case '0': case '1': case '2': case '3': case '4': case '5': case '6':
2.     case '7': case '8': case '9':
3.     case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': c",Useful
/*bchar -> achar -> uchar -> sub-delims-sh*/,"-10.     case '7': case '8': case '9':
-9.     case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':
-8.     case 'H': case 'I': case 'J': case 'K': case 'L': case 'M': case 'N':
-7.     case 'O': case 'P': case 'Q': case 'R': case 'S': ca",Useful
/*bchar -> achar -> uchar -> pct-encoded*/,"-2.     case '!': case '$': case '\'': case '(': case ')': case '*':
-1.     case '+': case ',':

 /*bchar -> achar -> uchar -> pct-encoded*/

111",Useful
/*HEXDIG chars are already included above*/,"-3.     case '!': case '$': case '\'': case '(': case ')': case '*':
-2.     case '+': case ',':

 /*HEXDIG chars are already included above*/

1.       return true;
2.     default:
3.       return false;
4.   }
5. }
6. /**********************************",Useful
/*skip leading slash*/,"-2.   CURLcode result = CURLE_OK;
-1.   struct IMAP *imap = data->req.p.imap;

 /*skip leading slash*/

1.   const char *ptr = begin;",Useful
/*See how much of the URL is a valid path and decode it*/,"-1.   const char *ptr = begin;

 /*See how much of the URL is a valid path and decode it*/

1.   while(imap_is_bchar(*ptr))
2.     ptr++;
3.   if(ptr != begin) {",Useful
/*Find the length of the name parameter*/,"-4.   while(*ptr == ';') {
-3.     char *name;
-2.     char *value;
-1.     size_t valuelen;

 /*Find the length of the name parameter*/

1.     begin = ++ptr;
2.     while(*ptr && *ptr != '=')
3.       ptr++;
4.     if(!*ptr)
5.       return CURLE_URL_MA",Useful
/*Find the length of the value parameter*/,"-4.     result = Curl_urldecode(begin, ptr - begin, &name, NULL,
-3.                             REJECT_CTRL);
-2.     if(result)
-1.       return result;

 /*Find the length of the value parameter*/

1.     begin = ++ptr;
2.     while(imap_is_bchar(*ptr)",Useful
"/*Process the known hierarchical parameters (UIDVALIDITY, UID, SECTION and
       PARTIAL) stripping of the trailing slash character if it is present.

       Note: Unknown parameters trigger a URL_MALFORMAT error.*/","-7.     result = Curl_urldecode(begin, ptr - begin, &value, &valuelen,
-6.                             REJECT_CTRL);
-5.     if(result) {
-4.       free(name);
-3.       return result;
-2.     }
-1.     DEBUGF(infof(data, ""IMAP URL parameter '%s' = '%s'"",",Useful
"/*Does the URL contain a query parameter? Only valid when we have a mailbox
     and no UID as per RFC-5092*/","-10.       value = NULL;
-9.     }
-8.     else {
-7.       free(name);
-6.       free(value);
-5.       return CURLE_URL_MALFORMAT;
-4.     }
-3.     free(name);
-2.     free(value);
-1.   }

 /*Does the URL contain a query parameter? Only valid when we ",Useful
/*Any extra stuff at the end of the URL is an error*/,"-3.     (void)curl_url_get(data->state.uh, CURLUPART_QUERY, &imap->query,
-2.                        CURLU_URLDECODE);
-1.   }

 /*Any extra stuff at the end of the URL is an error*/

1.   if(*ptr)
2.     return CURLE_URL_MALFORMAT;
3.   return CURLE_OK;
",Useful
/*Extract the parameters if specified*/,"-1.     result = Curl_urldecode(custom, 0, &imap->custom, NULL, REJECT_CTRL);

 /*Extract the parameters if specified*/

1.     if(!result) {
2.       const char *params = imap->custom;
3.       while(*params && *params != ' ')
4.         params++;
5.    ",Useful
/*these backends use functions from this file*/,"-10.  * furnished to do so, under the terms of the COPYING file.
-9.  *
-8.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-7.  * KIND, either express or implied.
-6.  *
-5.  **************************************************",Useful
/*The last #include file should be:*/,"-10. #include <netinet/in.h>
-9. #endif
-8. #ifdef HAVE_NETINET_IN6_H
-7. #include <netinet/in6.h>
-6. #endif
-5. #include ""curl_memrchr.h""
-4. #include ""hostcheck.h""
-3. #include ""strcase.h""
-2. #include ""hostip.h""
-1. #include ""curl_memory.h""

 /*The la",Useful
/*detect IP address as hostname and fail the match if so*/,"-8.   DEBUGASSERT(patternlen);
-7.   if(hostname[hostlen-1]=='.')
-6.     hostlen--;
-5.   if(pattern[patternlen-1]=='.')
-4.     patternlen--;
-3.   wildcard = memchr(pattern, '*', patternlen);
-2.   if(!wildcard)
-1.     return pmatch(hostname, hostlen,",Useful
"/*The wildcard must match at least one character, so the left-most
     label of the hostname is at least as large as the left-most label
     of the pattern.*/","-10.   hostname_label_end = memchr(hostname, '.', hostlen);
-9.   if(!hostname_label_end)
-8.     return FALSE;
-7.   else {
-6.     size_t skiphost = hostname_label_end - hostname;
-5.     size_t skiplen = pattern_label_end - pattern;
-4.     if(!pmatch(",Useful
/*use our own printf() functions*/,"-10.  * copies of the Software, and permit persons to whom the Software is
-9.  * furnished to do so, under the terms of the COPYING file.
-8.  *
-7.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-6.  * KIND, either express ",Useful
"/*Switch off bold by setting ""all attributes off"" since the explicit
   bold-off code (21) isn't supported everywhere - like in the mac
   Terminal.*/","-6. static char *parse_filename(const char *ptr, size_t len);
-5. #ifdef WIN32
-4. #define BOLD
-3. #define BOLDOFF
-2. #else
-1. #define BOLD ""\x1b[1m""

 /*Switch off bold by setting ""all attributes off"" since the explicit
   bold-off code (21) isn't sup",Useful
/*** callback for CURLOPT_HEADERFUNCTION*/,"-9. #define LINK ""\x1b]8;;""
-8. #define LINKST ""\x1b\\""
-7. #define LINKOFF LINK LINKST
-6. #endif
-5. #ifdef LINK
-4. static void write_linked_location(CURL *curl, const char *location,
-3.     size_t loclen, FILE *stream);
-2. #endif
-1. /*
** callback ",Useful
"/** Once that libcurl has called back tool_header_cb() the returned value
   * is checked against the amount that was intended to be written, if
   * it does not match then it fails with CURLE_WRITE_ERROR. So at this
   * point returning a value different from sz*nmemb indicates failure.*/","-10.   struct per_transfer *per = userdata;
-9.   struct HdrCbData *hdrcbdata = &per->hdrcbdata;
-8.   struct OutStruct *outs = &per->outs;
-7.   struct OutStruct *heads = &per->heads;
-6.   struct OutStruct *etag_save = &per->etag_save;
-5.   const char ",Useful
/** Write header data when curl option --dump-header (-D) is given.*/,"-10.   if(!per->config)
-9.     return failure;
-8. #ifdef DEBUGBUILD
-7.   if(size * nmemb > (size_t)CURL_MAX_HTTP_HEADER) {
-6.     warnf(per->config->global, ""Header data exceeds single call write ""
-5.           ""limit!\n"");
-4.     return failure;
-3",Useful
"/** This callback sets the filename where output shall be written when
   * curl options --remote-name (-O) and --remote-header-name (-J) have
   * been simultaneously given and additionally server returns an HTTP
   * Content-Disposition header specifying a filename property.*/","-7.           fputc('\n', etag_save->stream);
-6.           (void)fflush(etag_save->stream);
-5.         }
-4.       }
-3.     }
-2.   }
-1.   /*
   * This callback sets the filename where output shall be written when
   * curl options --remote-name (-O) ",Useful
"/*no match, find next parameter*/","-8.     for(;;) {
-7.       char *filename;
-6.       size_t len;
-5.       while(*p && (p < end) && !ISALPHA(*p))
-4.         p++;
-3.       if(p > end - 9)
-2.         break;
-1.       if(memcmp(p, ""filename="", 9)) {

 /*no match, find next parameter*/
",Useful
/*bold headers only for selected protocols*/,"-10.         per->num_headers = 0;
-9.       per->was_last_header_empty = FALSE;
-8.       per->num_headers++;
-7.     }
-6.     else if(ptr[0] == '\r' || ptr[0] == '\n')
-5.       per->was_last_header_empty = TRUE;
-4.   }
-3.   if(hdrcbdata->config->sho",Useful
"/*not ""handled"", just show it*/","-10. #else
-9.       if(curl_strnequal(""Location"", ptr, namelen)) {
-8.         write_linked_location(per->curl, &value[1], cb - namelen - 1,
-7.             outs->stream);
-6.       }
-5.       else
-4.         fwrite(&value[1], cb - namelen - 1, 1, outs",Useful
/** Copies a file name part and returns an ALLOCATED data buffer.*/,"-5.       fwrite(ptr, cb, 1, outs->stream);
-4.   }
-3.   return cb;
-2. }
-1. /*
 * Copies a file name part and returns an ALLOCATED data buffer.

 /** Copies a file name part and returns an ALLOCATED data buffer.*/

1.  */
2. static char *parse_filename",Useful
/*simple implementation of strndup()*/,"-6. static char *parse_filename(const char *ptr, size_t len)
-5. {
-4.   char *copy;
-3.   char *p;
-2.   char *q;
-1.   char  stop = '\0';

 /*simple implementation of strndup()*/

1.   copy = malloc(len + 1);
2.   if(!copy)
3.     return NULL;
4.   memc",Useful
/*store the starting quote*/,"-7.   copy = malloc(len + 1);
-6.   if(!copy)
-5.     return NULL;
-4.   memcpy(copy, ptr, len);
-3.   copy[len] = '\0';
-2.   p = copy;
-1.   if(*p == '\'' || *p == '""') {

 /*store the starting quote*/

1.     stop = *p;
2.     p++;
3.   }
4.   else
5. ",Useful
/*scan for the end letter and stop there*/,"-5.     stop = *p;
-4.     p++;
-3.   }
-2.   else
-1.     stop = ';';

 /*scan for the end letter and stop there*/

1.   q = strchr(p, stop);
2.   if(q)
3.     *q = '\0';",Useful
"/*if the filename contains a path, only use filename portion*/","-3.   q = strchr(p, stop);
-2.   if(q)
-1.     *q = '\0';

 /*if the filename contains a path, only use filename portion*/

1.   q = strrchr(p, '/');
2.   if(q) {
3.     p = q + 1;
4.     if(!*p) {
5.       Curl_safefree(copy);
6.       return NULL;
7.   ",Useful
"/*If the filename contains a backslash, only use filename portion. The idea
     is that even systems that don't handle backslashes as path separators
     probably want the path removed for convenience.*/","-8.   q = strrchr(p, '/');
-7.   if(q) {
-6.     p = q + 1;
-5.     if(!*p) {
-4.       Curl_safefree(copy);
-3.       return NULL;
-2.     }
-1.   }

 /*If the filename contains a backslash, only use filename portion. The idea
     is that even systems t",Useful
/*make sure the file name doesn't end in \r or \n*/,"-10.      is that even systems that don't handle backslashes as path separators
-9.      probably want the path removed for convenience. */
-8.   q = strrchr(p, '\\');
-7.   if(q) {
-6.     p = q + 1;
-5.     if(!*p) {
-4.       Curl_safefree(copy);
-3.  ",Useful
"/*in case we built debug enabled, we allow an environment variable
   * named CURL_TESTDIR to prefix the given file name to put it into a
   * specific directory*/","
  /* in case we built debug enabled, we allow an environment variable
   * named CURL_TESTDIR to prefix the given file name to put it into a
   * specific directory



 /*in case we built debug enabled, we allow an environment variable
   * named CURL_TESTDIR to prefix the given file name to put it into a
   * specific directory*/

1.    */
2. #ifdef DEBUGBUILD
3.   {
4.     char *tdir = curlx_getenv(""CURL_TESTDIR"");
5.     if(tdir) {",Useful
"/*clone the buffer, we don't use the libcurl
                                aprintf() or similar since we want to use the
                                same memory code as the ""real"" parse_filename
                                function*/","-2.       msnprintf(buffer, sizeof(buffer), ""%s/%s"", tdir, copy);
-1.       Curl_safefree(copy);

 /*clone the buffer, we don't use the libcurl
                                aprintf() or similar since we want to use the
                                s",Useful
/*The last #include files should be:*/,"-10.  *
-9.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-8.  * KIND, either express or implied.
-7.  *
-6.  ***************************************************************************/
-5. #include ""curl_setup.h""
-4. #incl",Useful
"/** Curl_auth_build_spn()
 *
 * This is used to build a SPN string in the following formats:
 *
 * service/host@realm (Not currently used)
 * service/host       (Not used by GSS-API)
 * service@realm      (Not used by Windows SSPI)
 *
 * Parameters:
 *
 * service  [in] - The service type such as http, smtp, pop or imap.
 * host     [in] - The host name.
 * realm    [in] - The realm.
 *
 * Returns a pointer to the newly allocated SPN.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_build_spn()
 *
 * This is used to build a SPN string in the following formats:
 *
 * service/host@realm (Not currently used)
 * service/host       (Not used by GSS-API)
 * service@",Useful
/*Generate our SPN*/,"-10.  * host     [in] - The host name.
-9.  * realm    [in] - The realm.
-8.  *
-7.  * Returns a pointer to the newly allocated SPN.
-6.  */
-5. #if !defined(USE_WINDOWS_SSPI)
-4. char *Curl_auth_build_spn(const char *service, const char *host,
-3.       ",Useful
/*Return our newly allocated SPN*/,"-6.   if(host && realm)
-5.     spn = aprintf(""%s/%s@%s"", service, host, realm);
-4.   else if(host)
-3.     spn = aprintf(""%s/%s"", service, host);
-2.   else if(realm)
-1.     spn = aprintf(""%s@%s"", service, realm);

 /*Return our newly allocated SPN*/

",Useful
"/*Note: We could use DsMakeSPN() or DsClientMakeSpnForTargetServer() rather
     than doing this ourselves but the first is only available in Windows XP
     and Windows Server 2003 and the latter is only available in Windows 2000
     but not Windows95/98/ME or Windows NT4.0 unless the Active Directory
     Client Extensions are installed. As such it is far simpler for us to
     formulate the SPN instead.*/","-10.   return spn;
-9. }
-8. #else
-7. TCHAR *Curl_auth_build_spn(const char *service, const char *host,
-6.                            const char *realm)
-5. {
-4.   char *utf8_spn = NULL;
-3.   TCHAR *tchar_spn = NULL;
-2.   TCHAR *dupe_tchar_spn = NULL",Useful
/*Return our newly allocated SPN*/,"-6.   if(host && realm)
-5.     spn = aprintf(""%s/%s@%s"", service, host, realm);
-4.   else if(host)
-3.     spn = aprintf(""%s/%s"", service, host);
-2.   else if(realm)
-1.     spn = aprintf(""%s@%s"", service, realm);

 /*Return our newly allocated SPN*/

",Useful
"/** Curl_auth_user_contains_domain()
 *
 * This is used to test if the specified user contains a Windows domain name as
 * follows:
 *
 * Domain\User (Down-level Logon Name)
 * Domain/User (curl Down-level format - for compatibility with existing code)
 * User@Domain (User Principal Name)
 *
 * Note: The user name may be empty when using a GSS-API library or Windows
 * SSPI as the user and domain are either obtained from the credentials cache
 * when using GSS-API or via the currently logged in user's credentials when
 * using Windows SSPI.
 *
 * Parameters:
 *
 * user  [in] - The user name.
 *
 * Returns TRUE on success; otherwise FALSE.*/","-1. /*
 * Curl_auth_user_contains_domain()
 *
 * This is used to test if the specified user contains a Windows domain name as
 * follows:
 *
 * Domain\User (Down-level Logon Name)
 * Domain/User (curl Down-level format - for compatibility with existing co",Useful
/*Check we have a domain name or UPN present*/,"-10.  * Parameters:
-9.  *
-8.  * user  [in] - The user name.
-7.  *
-6.  * Returns TRUE on success; otherwise FALSE.
-5.  */
-4. bool Curl_auth_user_contains_domain(const char *user)
-3. {
-2.   bool valid = FALSE;
-1.   if(user && *user) {

 /*Check we ",Useful
"/*User and domain are obtained from the GSS-API credentials cache or the
       currently logged in user from Windows*/","-6.     char *p = strpbrk(user, ""\\/@"");
-5.     valid = (p != NULL && p > user && p < user + strlen(user) - 1 ? TRUE :
-4.                                                                     FALSE);
-3.   }
-2. #if defined(HAVE_GSSAPI) || defined(USE_WIN",Useful
/*use our own printf() functions*/,"-10.  * copies of the Software, and permit persons to whom the Software is
-9.  * furnished to do so, under the terms of the COPYING file.
-8.  *
-7.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-6.  * KIND, either express ",Useful
/*keep this as LAST include*/,"-10. #include ""tool_cb_prg.h""
-9. #include ""tool_filetime.h""
-8. #include ""tool_formparse.h""
-7. #include ""tool_getparam.h""
-6. #include ""tool_helpers.h""
-5. #include ""tool_libinfo.h""
-4. #include ""tool_msgs.h""
-3. #include ""tool_paramhlp.h""
-2. #include ",Useful
/*short name option*/,"-10.     free(*(str)); \
-9.     *(str) = NULL; \
-8.   } \
-7.   if((val)) {              \
-6.     *(str) = strdup((val)); \
-5.     if(!(*(str)))          \
-4.       return PARAM_NO_MEM; \
-3.   } \
-2. } while(0)
-1. struct LongShort {

 /*short name",Useful
/*long name option*/,"-10.     *(str) = NULL; \
-9.   } \
-8.   if((val)) {              \
-7.     *(str) = strdup((val)); \
-6.     if(!(*(str)))          \
-5.       return PARAM_NO_MEM; \
-4.   } \
-3. } while(0)
-2. struct LongShort {

 /*long name option*/

1.   enum {",Useful
/*accepts a --no-[name] prefix*/,"-2.   enum {

 /*accepts a --no-[name] prefix*/

111",Useful
/*requires an argument*/,"-3.   enum {

 /*requires an argument*/

111",Useful
"/*requires an argument, usually a file name*/","-4.   enum {

 /*requires an argument, usually a file name*/

1.   } desc;
2. };
3. static const struct LongShort aliases[]= {",Useful
"/*letter' strings with more than one character have *no* short option to
     mention.*/","-3.   } desc;
-2. };
-1. static const struct LongShort aliases[]= {

 /*letter' strings with more than one character have *no* short option to
     mention.*/

1.   {""*@"", ""url"",                      ARG_STRING},
2.   {""*4"", ""dns-ipv4-addr"",            AR",Useful
/*ftp-ssl' deprecated name since 7.20.0*/,"-2.   {""*~"", ""xattr"",                    ARG_BOOL},
-1.   {""$a"", ""ftp-ssl"",                  ARG_BOOL},

 /*ftp-ssl' deprecated name since 7.20.0*/

1.   {""$a"", ""ssl"",                      ARG_BOOL},",Useful
"/*ssl' new option name in 7.20.0, previously this was ftp-ssl*/","-1.   {""$a"", ""ssl"",                      ARG_BOOL},

 /*ssl' new option name in 7.20.0, previously this was ftp-ssl*/

1.   {""$b"", ""ftp-pasv"",                 ARG_BOOL},
2.   {""$c"", ""socks5"",                   ARG_STRING},
3.   {""$d"", ""tcp-nodelay"",      ",Useful
/*ftp-ssl-reqd' deprecated name since 7.20.0*/,"-10.   {""$n"", ""proxy-anyauth"",            ARG_BOOL},
-9.   {""$o"", ""trace-time"",               ARG_BOOL},
-8.   {""$p"", ""ignore-content-length"",    ARG_BOOL},
-7.   {""$q"", ""ftp-skip-pasv-ip"",         ARG_BOOL},
-6.   {""$r"", ""ftp-method"",               ARG_S",Useful
"/*ssl-reqd' new in 7.20.0, previously this was ftp-ssl-reqd*/","-1.   {""$v"", ""ssl-reqd"",                 ARG_BOOL},

 /*ssl-reqd' new in 7.20.0, previously this was ftp-ssl-reqd*/

1.   {""$w"", ""sessionid"",                ARG_BOOL},",Useful
"/*socks5-gssapi-service' merged with'proxy-service-name' and
            deprecated since 7.49.0*/","-10.   {""$G"", ""delegation"",               ARG_STRING},
-9.   {""$H"", ""mail-auth"",                ARG_STRING},
-8.   {""$I"", ""post303"",                  ARG_BOOL},
-7.   {""$J"", ""metalink"",                 ARG_BOOL},
-6.   {""$6"", ""sasl-authzid"",             A",Useful
"/*Split the argument of -E to 'certname' and 'passphrase' separated by colon.
 * We allow ':' and '\' to be escaped by '\' so that we can use certificate
 * nicknames containing ':'.  See <https://sourceforge.net/p/curl/bugs/1196/>
 * for details.*/","-10.   {""Y"",  ""speed-limit"",              ARG_STRING},
-9.   {""y"",  ""speed-time"",               ARG_STRING},
-8.   {""z"",  ""time-cond"",                ARG_STRING},
-7.   {""Z"",  ""parallel"",                 ARG_BOOL},
-6.   {""Zb"", ""parallel-max"",            ",Useful
/*most trivial assumption: cert_parameter is empty*/,"-10. void parse_cert_parameter(const char *cert_parameter,
-9.                           char **certname,
-8.                           char **passphrase)
-7. {
-6.   size_t param_length = strlen(cert_parameter);
-5.   size_t span;
-4.   const char *param",Useful
/*deal with escaped chars; find unescaped colon if it exists*/,"-5.   if(curl_strnequal(cert_parameter, ""pkcs11:"", 7) ||
-4.      !strpbrk(cert_parameter, "":\\"")) {
-3.     *certname = strdup(cert_parameter);
-2.     return;
-1.   }

 /*deal with escaped chars; find unescaped colon if it exists*/

1.   certname_place ",Useful
"/*we just ate all the non-special chars. now we're on either a special
     * char or the end of the string.*/","-10.   certname_place = malloc(param_length + 1);
-9.   if(!certname_place)
-8.     return;
-7.   *certname = certname_place;
-6.   param_place = cert_parameter;
-5.   while(*param_place) {
-4.     span = strcspn(param_place, "":\\"");
-3.     strncpy(certn",Useful
"/*Since we live in a world of weirdness and confusion, the win32
         dudes can use : when using drive letters and thus c:\file:password
         needs to work. In order not to break compatibility, we still use : as
         separator, but we try to detect when it is used for a file name! On
         windows.*/","-10.           param_place++;
-9.           break;
-8.         default:
-7.           *certname_place++ = '\\';
-6.           *certname_place++ = *param_place;
-5.           param_place++;
-4.           break;
-3.       }
-2.       break;
-1.     case ':'",Useful
"/*colon in the second column, followed by a backslash, and the
           first character is an alphabetic letter:

           this is a drive letter colon*/","-5. #ifdef WIN32
-4.       if(param_place &&
-3.           (param_place == &cert_parameter[1]) &&
-2.           (cert_parameter[2] == '\\' || cert_parameter[2] == '/') &&
-1.           (ISALPHA(cert_parameter[0])) ) {

 /*colon in the second column, follo",Useful
"/*escaped colons and Windows drive letter colons were handled
       * above; if we're still here, this is a separating colon*/","-5.         *certname_place++ = ':';
-4.         param_place++;
-3.         break;
-2.       }
-1. #endif

 /*escaped colons and Windows drive letter colons were handled
       * above; if we're still here, this is a separating colon*/

1.       param_pla",Useful
"/*for plain bytes, leave as-is*/","-10.     value *= 1024*1024;
-9.     break;
-8.   case 'K':
-7.   case 'k':
-6.     if(value > (CURL_OFF_T_MAX / 1024))
-5.       return PARAM_NUMBER_TOO_LARGE;
-4.     value *= 1024;
-3.     break;
-2.   case 'b':
-1.   case 'B':

 /*for plain bytes, lea",Useful
/*NULL if unset*/,"-9.     break;
-8.   default:
-7.     warnf(global, ""unsupported %s unit. Use G, M, K or B!\n"", which);
-6.     return PARAM_BAD_USE;
-5.   }
-4.   *value_out = value;
-3.   return PARAM_OK;
-2. }

 /*NULL if unset*/

111",Useful
/*when true means '-o foo' used '-ofoo'*/,"-6.   int rc;
-5.   const char *parse = NULL;
-4.   unsigned int j;
-3.   time_t now;
-2.   int hit = -1;
-1.   bool longopt = FALSE;

 /*when true means '-o foo' used '-ofoo'*/

1.   ParameterError err;",Useful
"/*how to switch boolean options, on or off. Controlled
                         by using --OPTION or --no-OPTION*/","-1.   ParameterError err;

 /*how to switch boolean options, on or off. Controlled
                         by using --OPTION or --no-OPTION*/

111",Useful
/*this should be a long name*/,"-1.   if(('-' != flag[0]) || ('-' == flag[1])) {

 /*this should be a long name*/

1.     const char *word = ('-' == flag[0]) ? flag + 2 : flag;
2.     size_t fnam = strlen(word);
3.     int numhits = 0;
4.     bool noflagged = FALSE;
5.     if(!strncmp(w",Useful
"/*disable this option but ignore the ""no-"" part when looking for it*/","-5.     const char *word = ('-' == flag[0]) ? flag + 2 : flag;
-4.     size_t fnam = strlen(word);
-3.     int numhits = 0;
-2.     bool noflagged = FALSE;
-1.     if(!strncmp(word, ""no-"", 3)) {

 /*disable this option but ignore the ""no-"" part when looki",Useful
/*a single unique hit*/,"-10.       toggle = FALSE;
-9.       noflagged = TRUE;
-8.     }
-7.     for(j = 0; j < sizeof(aliases)/sizeof(aliases[0]); j++) {
-6.       if(curl_strnequal(aliases[j].lname, word, fnam)) {
-5.         longopt = TRUE;
-4.         numhits++;
-3.         ",Useful
/*this is at least the second match!*/,"-7.           break;
-6.         }
-5.         parse = aliases[j].letter;
-4.         hit = j;
-3.       }
-2.     }
-1.     if(numhits > 1) {

 /*this is at least the second match!*/

1.       return PARAM_OPTION_AMBIGUOUS;
2.     }
3.     if(hit < 0) {
",Useful
"/*prefixed with one dash, pass it*/","-3.       return PARAM_NO_NOT_BOOLEAN;
-2.   }
-1.   else {

 /*prefixed with one dash, pass it*/

1.     hit = -1;
2.     parse = flag;
3.   }
4.   do {",Useful
/*this option requires an extra parameter*/,"-10.         if(letter == aliases[j].letter[0]) {
-9.           hit = j;
-8.           break;
-7.         }
-6.       }
-5.       if(hit < 0) {
-4.         return PARAM_OPTION_UNKNOWN;
-3.       }
-2.     }
-1.     if(aliases[hit].desc >= ARG_STRING) {

 ",Useful
/*this is the actual extra parameter*/,"-1.       if(!longopt && parse[1]) {

 /*this is the actual extra parameter*/

111",Useful
/*if the file name looks like a command line option*/,"-2.       if((aliases[hit].desc == ARG_FILENAME) &&
-1.          (nextarg[0] == '-') && nextarg[1]) {

 /*if the file name looks like a command line option*/

1.         warnf(global, ""The file name argument '%s' looks like a flag.\n"",
2.               ne",Useful
/*options without a short option*/,"-7.         warnf(global, ""The file name argument '%s' looks like a flag.\n"",
-6.               nextarg);
-5.       }
-4.     }
-3.     else if((aliases[hit].desc == ARG_NONE) && !toggle)
-2.       return PARAM_NO_PREFIX;
-1.     switch(letter) {

 /*opti",Useful
/*addr in dot notation*/,"-1.           return PARAM_LIBCURL_DOESNT_SUPPORT;

 /*addr in dot notation*/

1.         GetStr(&config->dns_ipv4_addr, nextarg);
2.         break;",Useful
/*addr in dot notation*/,"-1.           return PARAM_LIBCURL_DOESNT_SUPPORT;

 /*addr in dot notation*/

1.         GetStr(&config->dns_ipv4_addr, nextarg);
2.         break;",Useful
/*OAuth 2.0 bearer token*/,"-2.         GetStr(&config->egd_file, nextarg);
-1.         break;

 /*OAuth 2.0 bearer token*/

1.         GetStr(&config->oauth_bearer, nextarg);
2.         cleanarg(nextarg);
3.         config->authtype |= CURLAUTH_BEARER;
4.         break;",Useful
/*ciphers*/,"-8.   {""*@"", ""url"",                      ARG_STRING},
-7.   {""*4"", ""dns-ipv4-addr"",            ARG_STRING},
-6.   {""*6"", ""dns-ipv6-addr"",            ARG_STRING},
-5.   {""*a"", ""random-file"",              ARG_FILENAME},
-4.   {""*b"", ""egd-file"",             ",Useful
/*IP addrs of DNS servers*/,"-1.           return PARAM_LIBCURL_DOESNT_SUPPORT;

 /*IP addrs of DNS servers*/

1.         GetStr(&config->dns_servers, nextarg);
2.         break;",Useful
/*--digest*/,"-2.         config->tr_encoding = toggle;
-1.         break;

 /*--digest*/

1.         if(toggle)
2.           config->authtype |= CURLAUTH_DIGEST;
3.         else
4.           config->authtype &= ~CURLAUTH_DIGEST;
5.         break;",Useful
"/*specified max no of redirects (http(s)), this accepts -1 as a
           special condition*/","-5.         err = oct2nummax(&config->create_file_mode, nextarg, 0777);
-4.         if(err)
-3.           return err;
-2.         break;

 /*specified max no of redirects (http(s)), this accepts -1 as a
           special condition*/

1.         err = str",Useful
/*kerberos level string*/,"-3.         GetStr(&config->iface, nextarg);
-2.         break;

 /*kerberos level string*/

1.         if(curlinfo->features & CURL_VERSION_SPNEGO)
2.           GetStr(&config->krblevel, nextarg);
3.         else
4.           return PARAM_LIBCURL_DOESNT_",Useful
"/*there's a node here, if it already is filled-in continue to find
             an ""empty"" node*/","-5.       {
-4.         struct getout *url;
-3.         if(!config->url_get)
-2.           config->url_get = config->url_list;
-1.         if(config->url_get) {

 /*there's a node here, if it already is filled-in continue to find
             an ""empty"" n",Useful
/*now there might or might not be an available node to fill in!*/,"-3.           while(config->url_get && (config->url_get->flags & GETOUT_URL))
-2.             config->url_get = config->url_get->next;
-1.         }

 /*now there might or might not be an available node to fill in!*/

1.         if(config->url_get)",Useful
/*existing node*/,"-1.         if(config->url_get)

 /*existing node*/

1.           url = config->url_get;
2.         else",Useful
"/*there was no free node, create one!*/","-2.           url = config->url_get;
-1.         else

 /*there was no free node, create one!*/

1.           config->url_get = url = new_getout(config);
2.         if(!url)
3.           return PARAM_NO_MEM;",Useful
/*more options without a short option*/,"-5.         GetStr(&url->url, nextarg);
-4.         url->flags |= GETOUT_URL;
-3.       }
-2.       }
-1.       break;

 /*more options without a short option*/

1.       switch(subletter) {",Useful
/*--ssl*/,"-1.       switch(subletter) {

 /*--ssl*/

1.         if(toggle && !(curlinfo->features & CURL_VERSION_SSL))
2.           return PARAM_LIBCURL_DOESNT_SUPPORT;
3.         config->ftp_ssl = toggle;
4.         break;",Useful
/*--ftp-pasv*/,"-4.         if(toggle && !(curlinfo->features & CURL_VERSION_SSL))
-3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-2.         config->ftp_ssl = toggle;
-1.         break;

 /*--ftp-pasv*/

1.         Curl_safefree(config->ftpport);
2.         break;",Useful
/*--socks4 specifies a socks4 proxy to use*/,"-3.         GetStr(&config->proxy, nextarg);
-2.         config->proxyver = CURLPROXY_SOCKS5;
-1.         break;

 /*--socks4 specifies a socks4 proxy to use*/

1.         GetStr(&config->proxy, nextarg);
2.         config->proxyver = CURLPROXY_SOCKS4;
3.",Useful
/*--socks4a specifies a socks4a proxy to use*/,"-3.         GetStr(&config->proxy, nextarg);
-2.         config->proxyver = CURLPROXY_SOCKS4;
-1.         break;

 /*--socks4a specifies a socks4a proxy to use*/

1.         GetStr(&config->proxy, nextarg);
2.         config->proxyver = CURLPROXY_SOCKS4A;",Useful
/*--retry*/,"-2.         config->proxybasic = toggle;
-1.         break;

 /*--retry*/

1.         err = str2unum(&config->req_retry, nextarg);
2.         if(err)
3.           return err;
4.         break;",Useful
/*--ftp-method (undocumented at this point)*/,"-2.         config->ftp_skip_ip = toggle;
-1.         break;

 /*--ftp-method (undocumented at this point)*/

1.         config->ftp_filemethod = ftpfilemethod(config, nextarg);
2.         break;",Useful
/*if there's anything more than a plain decimal number*/,"-5.         char lrange[7]="""";
-4.         char *p = nextarg;
-3.         while(ISDIGIT(*p))
-2.           p++;
-1.         if(*p) {

 /*if there's anything more than a plain decimal number*/

1.           rc = sscanf(p, "" - %6s"", lrange);",Useful
/*default number of ports to try*/,"-7.         }
-6.         else
-5.           rc = 0;
-4.         err = str2unum(&config->localport, nextarg);
-3.         if(err || (config->localport > 65535))
-2.           return PARAM_BAD_USE;
-1.         if(!rc)

 /*default number of ports to try*/

",Useful
/*--ssl-reqd*/,"-2.         GetStr(&config->ftp_alternative_to_user, nextarg);
-1.         break;

 /*--ssl-reqd*/

1.         if(toggle && !(curlinfo->features & CURL_VERSION_SSL))
2.           return PARAM_LIBCURL_DOESNT_SUPPORT;
3.         config->ftp_ssl_reqd = toggl",Useful
/*--no-sessionid*/,"-1.   {""$w"", ""sessionid"",                ARG_BOOL},

 /*--no-sessionid*/

1.   {""$x"", ""ftp-ssl-control"",          ARG_BOOL},
2.   {""$y"", ""ftp-ssl-ccc"",              ARG_BOOL},
3.   {""$j"", ""ftp-ssl-ccc-mode"",         ARG_STRING},
4.   {""$z"", ""libcurl"",    ",Useful
/*This specifies the noproxy list*/,"-3.         config->post303 = toggle;
-2.         break;

 /*This specifies the noproxy list*/

1.         GetStr(&config->noproxy, nextarg);
2.         break;",Useful
/*append receiver to a list*/,"-3.         GetStr(&config->mail_from, nextarg);
-2.         break;

 /*append receiver to a list*/

1.         err = add2list(&config->mail_rcpt, nextarg);
2.         if(err)
3.           return err;
4.         break;",Useful
/*0 is a valid value for this timeout*/,"-3.         err = str2unum(&config->happy_eyeballs_timeout_ms, nextarg);
-2.         if(err)
-1.           return err;

 /*0 is a valid value for this timeout*/

1.         break;
2.       }
3.       break;
4.     case '#':
5.       switch(subletter) {",Useful
/*--progress-bar*/,"-2.         global->noprogress = !toggle;
-1.         break;

 /*--progress-bar*/

1.         global->progressmode =
2.           toggle ? CURL_PROGRESS_BAR : CURL_PROGRESS_STATS;
3.         break;
4.       }
5.       break;",Useful
/*HTTP version 1.0*/,"-2.       switch(subletter) {
-1.       case '\0':

 /*HTTP version 1.0*/

1.         config->httpversion = CURL_HTTP_VERSION_1_0;
2.         break;
3.       case '1':",Useful
/*HTTP version 1.1*/,"-3.         config->httpversion = CURL_HTTP_VERSION_1_0;
-2.         break;
-1.       case '1':

 /*HTTP version 1.1*/

1.         config->httpversion = CURL_HTTP_VERSION_1_1;
2.         break;
3.       case '2':",Useful
/*HTTP version 2.0*/,"-3.         config->httpversion = CURL_HTTP_VERSION_1_1;
-2.         break;
-1.       case '2':

 /*HTTP version 2.0*/

1.         config->httpversion = CURL_HTTP_VERSION_2_0;
2.         break;",Useful
/*HTTP version 2.0 over clean TCP*/,"-3.         config->httpversion = CURL_HTTP_VERSION_2_0;
-2.         break;

 /*HTTP version 2.0 over clean TCP*/

1.         config->httpversion = CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE;
2.         break;",Useful
/*--http3*/,"-2.         config->httpversion = CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE;
-1.         break;

 /*--http3*/

111",Useful
/*HTTP version 3 go over QUIC - at once*/,"-3.         config->httpversion = CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE;
-2.         break;

 /*HTTP version 3 go over QUIC - at once*/

1.         if(curlinfo->features & CURL_VERSION_HTTP3)
2.           config->httpversion = CURL_HTTP_VERSION_3;
3.       ",Useful
/*Allow HTTP/0.9 responses!*/,"-6.         if(curlinfo->features & CURL_VERSION_HTTP3)
-5.           config->httpversion = CURL_HTTP_VERSION_3;
-4.         else
-3.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-2.         break;
-1.       case '9':

 /*Allow HTTP/0.9 responses!*/

1.",Useful
/*TLS version 1.x*/,"-2.       switch(subletter) {
-1.       case '\0':

 /*TLS version 1.x*/

1.         config->ssl_version = CURL_SSLVERSION_TLSv1;
2.         break;
3.       case '0':",Useful
/*TLS version 1.0*/,"-3.         config->ssl_version = CURL_SSLVERSION_TLSv1;
-2.         break;
-1.       case '0':

 /*TLS version 1.0*/

1.         config->ssl_version = CURL_SSLVERSION_TLSv1_0;
2.         break;
3.       case '1':",Useful
/*TLS version 1.1*/,"-3.         config->ssl_version = CURL_SSLVERSION_TLSv1_0;
-2.         break;
-1.       case '1':

 /*TLS version 1.1*/

1.         config->ssl_version = CURL_SSLVERSION_TLSv1_1;
2.         break;
3.       case '2':",Useful
/*TLS version 1.2*/,"-3.         config->ssl_version = CURL_SSLVERSION_TLSv1_1;
-2.         break;
-1.       case '2':

 /*TLS version 1.2*/

1.         config->ssl_version = CURL_SSLVERSION_TLSv1_2;
2.         break;
3.       case '3':",Useful
/*TLS version 1.3*/,"-3.         config->ssl_version = CURL_SSLVERSION_TLSv1_2;
-2.         break;
-1.       case '3':

 /*TLS version 1.3*/

1.         config->ssl_version = CURL_SSLVERSION_TLSv1_3;
2.         break;",Useful
/*SSL version 2*/,"-5.         GetStr(&config->proxy_cipher13_list, nextarg);
-4.         break;
-3.       }
-2.       break;
-1.     case '2':

 /*SSL version 2*/

1.       warnf(global, ""Ignores instruction to use SSLv2\n"");
2.       break;
3.     case '3':",Useful
/*SSL version 3*/,"-3.       warnf(global, ""Ignores instruction to use SSLv2\n"");
-2.       break;
-1.     case '3':

 /*SSL version 3*/

1.       warnf(global, ""Ignores instruction to use SSLv3\n"");
2.       break;
3.     case '4':",Useful
/*IPv4*/,"-3.       warnf(global, ""Ignores instruction to use SSLv3\n"");
-2.       break;
-1.     case '4':

 /*IPv4*/

1.       config->ip_version = CURL_IPRESOLVE_V4;
2.       break;
3.     case '6':",Useful
/*IPv6*/,"-3.       config->ip_version = CURL_IPRESOLVE_V4;
-2.       break;
-1.     case '6':

 /*IPv6*/

1.       config->ip_version = CURL_IPRESOLVE_V6;
2.       break;
3.     case 'a':",Useful
/*This makes the FTP sessions use APPE instead of STOR*/,"-3.       config->ip_version = CURL_IPRESOLVE_V6;
-2.       break;
-1.     case 'a':

 /*This makes the FTP sessions use APPE instead of STOR*/

1.       config->ftp_append = toggle;
2.       break;
3.     case 'A':",Useful
/*--cookie string coming up:*/,"-5.         if(curlinfo->features & CURL_VERSION_HSTS)
-4.           GetStr(&config->hsts, nextarg);
-3.         else
-2.           return PARAM_LIBCURL_DOESNT_SUPPORT;
-1.         break;

 /*--cookie string coming up:*/

1.         if(nextarg[0] == '@') ",Useful
/*A cookie string must have a =-letter*/,"-4.         if(nextarg[0] == '@') {
-3.           nextarg++;
-2.         }
-1.         else if(strchr(nextarg, '=')) {

 /*A cookie string must have a =-letter*/

1.           err = add2list(&config->cookies, nextarg);
2.           if(err)
3.             ",Useful
/*get the file name to dump all cookies in*/,"-3.       config->use_ascii = toggle;
-2.       break;
-1.     case 'c':

 /*get the file name to dump all cookies in*/

1.       GetStr(&config->cookiejar, nextarg);
2.       break;
3.     case 'C':",Useful
/*This makes us continue an ftp transfer at given position*/,"-3.       GetStr(&config->cookiejar, nextarg);
-2.       break;
-1.     case 'C':

 /*This makes us continue an ftp transfer at given position*/

1.       if(strcmp(nextarg, ""-"")) {
2.         err = str2offset(&config->resume_from, nextarg);
3.         if",Useful
"/*[name]=[content], we encode the content part only
         * [name]@[file name]
         *
         * Case 2: we first load the file using that name and then encode
         * the content.*/","/* [name]=[content], we encode the content part only
         * [name]@[file name]
         *
         * Case 2: we first load the file using that name and then encode
         * the content.

 /*[name]=[content], we encode the content part only
         * [name]@[file name]
         *
         * Case 2: we first load the file using that name and then encode
         * the content.*/

1.          */
2.         const char *p = strchr(nextarg, '=');
3.         size_t nlen;
4.         char is_file;
5.         if(!p)",Useful
"/*there was no '=' letter, check for a '@' instead*/","-4.         const char *p = strchr(nextarg, '=');
-3.         size_t nlen;
-2.         char is_file;
-1.         if(!p)

 /*there was no '=' letter, check for a '@' instead*/

1.           p = strchr(nextarg, '@');
2.         if(p) {",Useful
/*length of the name part*/,"-2.           p = strchr(nextarg, '@');
-1.         if(p) {

 /*length of the name part*/

111",Useful
/*pass the separator*/,"-3.           p = strchr(nextarg, '@');
-2.         if(p) {

 /*pass the separator*/

1.         }
2.         else {",Useful
"/*no data from the file, point to a zero byte string to make this
             get sent as a POST anyway*/","-10.             fclose(file);
-9.           if(err)
-8.             return err;
-7.         }
-6.         else {
-5.           GetStr(&postdata, p);
-4.           if(postdata)
-3.             size = strlen(postdata);
-2.         }
-1.         if(!postdat",Useful
/*no matter if it worked or not*/,"-7.           postdata = strdup("""");
-6.           if(!postdata)
-5.             return PARAM_NO_MEM;
-4.           size = 0;
-3.         }
-2.         else {
-1.           char *enc = curl_easy_escape(NULL, postdata, (int)size);

 /*no matter if it worke",Useful
"/*now make a string with the name from above and append the
               encoded string*/","-1.             size_t enclen = replace_url_encoded_space_by_plus(enc);

 /*now make a string with the name from above and append the
               encoded string*/

1.             size_t outlen = nlen + enclen + 2;
2.             char *n = malloc(outlen",Useful
/*only append '=' if we have a name*/,"-6.             size_t outlen = nlen + enclen + 2;
-5.             char *n = malloc(outlen);
-4.             if(!n) {
-3.               curl_free(enc);
-2.               return PARAM_NO_MEM;
-1.             }

 /*only append '=' if we have a name*/

1.   ",Useful
/*since no '=' was inserted*/,"-5.               msnprintf(n, outlen, ""%.*s=%s"", nlen, nextarg, enc);
-4.               size = outlen-1;
-3.             }
-2.             else {
-1.               strcpy(n, enc);

 /*since no '=' was inserted*/

1.             }
2.             curl_free",Useful
"/*the data begins with a '@' letter, it means that a file name
           or - (stdin) follows*/","-9.             }
-8.             curl_free(enc);
-7.             postdata = n;
-6.           }
-5.           else
-4.             return PARAM_NO_MEM;
-3.         }
-2.       }
-1.       else if('@' == *nextarg && !raw_mode) {

 /*the data begins with a ",Useful
/*forced binary*/,"-10.             set_binmode(stdin);
-9.         }
-8.         else {
-7.           file = fopen(nextarg, ""rb"");
-6.           if(!file)
-5.             warnf(global, ""Couldn't read data from file \""%s\"", this makes ""
-4.                   ""an empty POST.",Useful
"/*no data from the file, point to a zero byte string to make this
             get sent as a POST anyway*/","-10.             fclose(file);
-9.           if(err)
-8.             return err;
-7.         }
-6.         else {
-5.           GetStr(&postdata, p);
-4.           if(postdata)
-3.             size = strlen(postdata);
-2.         }
-1.         if(!postdat",Useful
"/*we already have a string, we append this one with a separating
           &-letter*/","-10.         }
-9.       }
-8.       else {
-7.         GetStr(&postdata, nextarg);
-6.         if(postdata)
-5.           size = strlen(postdata);
-4.       }
-3.       if(subletter == 'f')
-2.         config->jsoned = TRUE;
-1.       if(config->postfiel",Useful
/*use byte value 0x26 for '&' to accommodate non-ASCII platforms*/,"-10.         curl_off_t newlen = oldlen + curlx_uztoso(size) + 2;
-9.         config->postfields = malloc((size_t)newlen);
-8.         if(!config->postfields) {
-7.           Curl_safefree(oldpost);
-6.           Curl_safefree(postdata);
-5.           ret",Useful
"/*We can't set the request type here, as this data might be used in
      a simple GET if -G is used. Already or soon.

      if(SetHTTPrequest(HTTPREQ_SIMPLEPOST, &config->httpreq)) {
        Curl_safefree(postdata);
        return PARAM_BAD_USE;
      }*/","
        GetStr(&config->cacert, nextarg);
        break;


 /*We can't set the request type here, as this data might be used in
      a simple GET if -G is used. Already or soon.

      if(SetHTTPrequest(HTTPREQ_SIMPLEPOST, &config->httpreq)) {
        Curl_safefree(postdata);
        return PARAM_BAD_USE;
      }*/

1.     }
2.     else {
3.       bool used;",Useful
/*dump-header to given file name*/,"-2.     break;
-1.     case 'D':

 /*dump-header to given file name*/

1.       GetStr(&config->headerfile, nextarg);
2.       break;
3.     case 'e':
4.     {
5.       char *ptr = strstr(nextarg, "";auto"");
6.       if(ptr) {",Useful
/*certificate file*/,"-9.       }
-8.       else
-7.         config->autoreferer = FALSE;
-6.       ptr = *nextarg ? nextarg : NULL;
-5.       GetStr(&config->referer, ptr);
-4.     }
-3.     break;
-2.     case 'E':
-1.       switch(subletter) {

 /*certificate file*/

1.    ",Useful
/*CA info PEM file*/,"-2.         GetFileAndPassword(nextarg, &config->cert, &config->key_passwd);
-1.         break;

 /*CA info PEM file*/

1.         GetStr(&config->cacert, nextarg);
2.         break;",Useful
/*private key file*/,"-2.         GetStr(&config->cert_type, nextarg);
-1.         break;

 /*private key file*/

1.         GetStr(&config->key, nextarg);
2.         break;",Useful
/*private key file type*/,"-2.         GetStr(&config->key, nextarg);
-1.         break;

 /*private key file type*/

1.         GetStr(&config->key_type, nextarg);
2.         break;",Useful
/*CA cert directory*/,"-4.         GetStr(&config->engine, nextarg);
-3.         if(config->engine && curl_strequal(config->engine, ""list""))
-2.           return PARAM_ENGINES_REQUESTED;
-1.         break;

 /*CA cert directory*/

1.         GetStr(&config->capath, nextarg);
2.",Useful
/*--pubkey public key file*/,"-2.         GetStr(&config->capath, nextarg);
-1.         break;

 /*--pubkey public key file*/

1.         GetStr(&config->pubkey, nextarg);
2.         break;",Useful
/*only support TLS-SRP*/,"-3.         if(curlinfo->features & CURL_VERSION_TLSAUTH_SRP) {
-2.           GetStr(&config->tls_authtype, nextarg);
-1.           if(!curl_strequal(config->tls_authtype, ""SRP""))

 /*only support TLS-SRP*/

1.         }
2.         else
3.           retur",Useful
/*only support TLS-SRP*/,"-3.         if(curlinfo->features & CURL_VERSION_TLSAUTH_SRP) {
-2.           GetStr(&config->tls_authtype, nextarg);
-1.           if(!curl_strequal(config->tls_authtype, ""SRP""))

 /*only support TLS-SRP*/

1.         }
2.         else
3.           retur",Useful
/*no empty SSL fragments for proxy*/,"-2.         GetStr(&config->proxy_crlfile, nextarg);
-1.         break;

 /*no empty SSL fragments for proxy*/

1.         if(curlinfo->features & CURL_VERSION_SSL)
2.           config->proxy_ssl_allow_beast = toggle;
3.         break;",Useful
/*CA info PEM file for proxy*/,"-2.         GetStr(&config->login_options, nextarg);
-1.         break;

 /*CA info PEM file for proxy*/

1.         GetStr(&config->proxy_cacert, nextarg);
2.         break;",Useful
/*CA cert directory for proxy*/,"-2.         GetStr(&config->proxy_cacert, nextarg);
-1.         break;

 /*CA cert directory for proxy*/

1.         GetStr(&config->proxy_capath, nextarg);
2.         break;",Useful
/*allow insecure SSL connects for proxy*/,"-2.         GetStr(&config->proxy_capath, nextarg);
-1.         break;

 /*allow insecure SSL connects for proxy*/

1.         config->proxy_insecure_ok = toggle;
2.         break;",Useful
/*TLS version 1 for proxy*/,"-3.         config->proxy_insecure_ok = toggle;
-2.         break;

 /*TLS version 1 for proxy*/

1.         config->proxy_ssl_version = CURL_SSLVERSION_TLSv1;
2.         break;
3.       case 'A':",Useful
"/*""form data"" simulation, this is a little advanced so lets do our best
         to sort this out slowly and carefully*/","-10.         config->failonerror = toggle;
-9.         break;
-8.       }
-7.       if(config->failonerror && config->failwithbody) {
-6.         errorf(config->global, ""You must select either --fail or ""
-5.                ""--fail-with-body, not both.\n""",Useful
/*s' is literal string*/,"-4.       if(formparse(config,
-3.                    nextarg,
-2.                    &config->mimeroot,
-1.                    &config->mimecurrent,

 /*s' is literal string*/

1.         return PARAM_BAD_USE;
2.       if(SetHTTPrequest(config, HTTPREQ_M",Useful
/*we now actually support --no-help too!*/,"-8.       if(toggle) {
-7.         if(nextarg) {
-6.           global->help_category = strdup(nextarg);
-5.           if(!global->help_category)
-4.             return PARAM_NO_MEM;
-3.         }
-2.         return PARAM_HELP_REQUESTED;
-1.       }

 /*we",Useful
/*A custom header to append to a list*/,"-2.       break;
-1.     case 'H':

 /*A custom header to append to a list*/

1.       if(nextarg[0] == '@') {",Useful
/*read many headers from a file or stdin*/,"-1.       if(nextarg[0] == '@') {

 /*read many headers from a file or stdin*/

1.         char *string;
2.         size_t len;
3.         bool use_stdin = !strcmp(&nextarg[1], ""-"");
4.         FILE *file = use_stdin?stdin:fopen(&nextarg[1], FOPEN_READTEX",Useful
"/*show the headers as well in the
                                        general output stream*/","-8.           err = add2list(&config->proxyheaders, nextarg);
-7.         else
-6.           err = add2list(&config->headers, nextarg);
-5.         if(err)
-4.           return err;
-3.       }
-2.       break;
-1.     case 'i':

 /*show the headers as we",Useful
/*--head*/,"-4.       break;
-3.     case 'j':
-2.       config->cookiesession = toggle;
-1.       break;

 /*--head*/

1.       config->no_body = toggle;
2.       config->show_headers = toggle;
3.       if(SetHTTPrequest(config,
4.                         (config->n",Useful
/*--remote-header-name*/,"-7.       config->no_body = toggle;
-6.       config->show_headers = toggle;
-5.       if(SetHTTPrequest(config,
-4.                         (config->no_body)?HTTPREQ_HEAD:HTTPREQ_GET,
-3.                         &config->httpreq))
-2.         return PARA",Useful
/*allow insecure SSL connects*/,"-2.         GetStr(&config->proxy_capath, nextarg);
-1.         break;

 /*allow insecure SSL connects*/

1.         config->proxy_insecure_ok = toggle;
2.         break;",Useful
/*only list the names of the FTP dir*/,"-6.       if(parseconfig(nextarg, global)) {
-5.         errorf(global, ""cannot read config from '%s'\n"", nextarg);
-4.         return PARAM_READ_ERROR;
-3.       }
-2.       break;
-1.     case 'l':

 /*only list the names of the FTP dir*/

1.       brea",Useful
"/*Continue to send authentication (user+password) when following
         * locations, even when hostname changed*/","-2.       switch(subletter) {
-1.       case 't':

 /*Continue to send authentication (user+password) when following
         * locations, even when hostname changed*/

1.         config->unrestricted_auth = toggle;
2.         break;
3.       }
4.       b",Useful
/*use .netrc or URL*/,"-10.         return PARAM_MANUAL_REQUESTED;
-9. #else
-8.         warnf(global,
-7.               ""built-in manual was disabled at build-time!\n"");
-6.         return PARAM_OPTION_UNKNOWN;
-5. #endif
-4.       }
-3.       break;
-2.     case 'n':
-1.     ",Useful
"/*disable the output I/O buffering. note that the option is called
         --buffer but is mostly used in the negative form: --no-buffer*/","-5.         config->netrc = toggle;
-4.         break;
-3.       }
-2.       break;
-1.     case 'N':

 /*disable the output I/O buffering. note that the option is called
         --buffer but is mostly used in the negative form: --no-buffer*/

1.       c",Useful
/*--remote-name*/,"-2.       config->nobuffer = longopt ? !toggle : TRUE;
-1.       break;

 /*--remote-name*/

111",Useful
/*--remote-name-all*/,"-3.       config->nobuffer = longopt ? !toggle : TRUE;
-2.       break;

 /*--remote-name-all*/

1.         config->default_node_flags = toggle?GETOUT_USEREMOTE:0;
2.         break;
3.       }",Useful
/*--output*/,"-3.         config->default_node_flags = toggle?GETOUT_USEREMOTE:0;
-2.         break;
-1.       }

 /*--output*/

1.         GetStr(&config->output_dir, nextarg);
2.         break;
3.       }",Useful
/*output file*/,"-5.         config->file_clobber_mode = toggle ? CLOBBER_ALWAYS : CLOBBER_NEVER;
-4.         break;
-3.       }

 /*output file*/

1.     {
2.       struct getout *url;
3.       if(!config->url_out)
4.         config->url_out = config->url_list;
5.       ",Useful
"/*there's a node here, if it already is filled-in continue to find
           an ""empty"" node*/","-5.       {
-4.         struct getout *url;
-3.         if(!config->url_get)
-2.           config->url_get = config->url_list;
-1.         if(config->url_get) {

 /*there's a node here, if it already is filled-in continue to find
           an ""empty"" nod",Useful
/*now there might or might not be an available node to fill in!*/,"-3.           while(config->url_get && (config->url_get->flags & GETOUT_URL))
-2.             config->url_get = config->url_get->next;
-1.         }

 /*now there might or might not be an available node to fill in!*/

1.         if(config->url_get)",Useful
/*existing node*/,"-1.         if(config->url_get)

 /*existing node*/

1.           url = config->url_get;
2.         else",Useful
"/*there was no free node, create one!*/","-2.           url = config->url_get;
-1.         else

 /*there was no free node, create one!*/

1.           config->url_get = url = new_getout(config);
2.         if(!url)
3.           return PARAM_NO_MEM;",Useful
/*switch off*/,"-6.       if('o' == letter) {
-5.         if(!*nextarg) {
-4.           warnf(global, ""output file name has no length\n"");
-3.           return PARAM_BAD_USE;
-2.         }
-1.         GetStr(&url->outfile, nextarg);

 /*switch off*/

1.       }
2.       ",Useful
/*switch on*/,"-1.         if(toggle)

 /*switch on*/

1.         else",Useful
/*switch off*/,"-6.       if('o' == letter) {
-5.         if(!*nextarg) {
-4.           warnf(global, ""output file name has no length\n"");
-3.           return PARAM_BAD_USE;
-2.         }
-1.         GetStr(&url->outfile, nextarg);

 /*switch off*/

1.       }
2.       ",Useful
/*This makes the FTP sessions use PORT instead of PASV*/,"-5.       }
-4.       url->flags |= GETOUT_OUTFILE;
-3.     }
-2.     break;
-1.     case 'P':

 /*This makes the FTP sessions use PORT instead of PASV*/

111",Useful
"/*if used first, already taken care of, we do it like
                 this so we don't cause an error!*/","-2.       config->proxytunnel = toggle;
-1.       break;

 /*if used first, already taken care of, we do it like
                 this so we don't cause an error!*/

1.       break;
2.     case 'Q':",Useful
/*QUOTE command to send to FTP server*/,"-2.       break;
-1.     case 'Q':

 /*QUOTE command to send to FTP server*/

1.       switch(nextarg[0]) {
2.       case '-':",Useful
/*prefixed with a dash makes it a POST TRANSFER one*/,"-2.       switch(nextarg[0]) {
-1.       case '-':

 /*prefixed with a dash makes it a POST TRANSFER one*/

1.         nextarg++;
2.         err = add2list(&config->postquote, nextarg);
3.         break;
4.       case '+':",Useful
/*prefixed with a plus makes it a just-before-transfer one*/,"-4.         nextarg++;
-3.         err = add2list(&config->postquote, nextarg);
-2.         break;
-1.       case '+':

 /*prefixed with a plus makes it a just-before-transfer one*/

1.         nextarg++;
2.         err = add2list(&config->prequote, nexta",Useful
"/*Specifying a range WITHOUT A DASH will create an illegal HTTP range
         (and won't actually be range by definition). The man page previously
         claimed that to be a good way, why this code is added to work-around
         it.*/","-10.         err = add2list(&config->prequote, nextarg);
-9.         break;
-8.       default:
-7.         err = add2list(&config->quote, nextarg);
-6.         break;
-5.       }
-4.       if(err)
-3.         return err;
-2.       break;
-1.     case 'r':",Useful
/*byte range requested*/,"-10.         warnf(global,
-9.               ""A specified range MUST include at least one dash (-). ""
-8.               ""Appending one for you!\n"");
-7.         msnprintf(buffer, sizeof(buffer), ""%"" CURL_FORMAT_CURL_OFF_T ""-"", off);
-6.         Curl_safef",Useful
"/*if still on the default value, set showerror to the reverse of
           toggle. This is to allow -S and -s to be used in an independent
           order but still have the same effect.*/","-5.       if(toggle)
-4.         global->mute = global->noprogress = TRUE;
-3.       else
-2.         global->mute = global->noprogress = FALSE;
-1.       if(global->showerror < 0)

 /*if still on the default value, set showerror to the reverse of
       ",Useful
"/*there's a node here, if it already is filled-in continue to find
           an ""empty"" node*/","-5.       {
-4.         struct getout *url;
-3.         if(!config->url_get)
-2.           config->url_get = config->url_list;
-1.         if(config->url_get) {

 /*there's a node here, if it already is filled-in continue to find
           an ""empty"" nod",Useful
/*now there might or might not be an available node to fill in!*/,"-3.           while(config->url_get && (config->url_get->flags & GETOUT_URL))
-2.             config->url_get = config->url_get->next;
-1.         }

 /*now there might or might not be an available node to fill in!*/

1.         if(config->url_get)",Useful
/*existing node*/,"-1.         if(config->url_get)

 /*existing node*/

1.           url = config->url_get;
2.         else",Useful
"/*there was no free node, create one!*/","-2.           url = config->url_get;
-1.         else

 /*there was no free node, create one!*/

1.           config->url_get = url = new_getout(config);
2.         if(!url)
3.           return PARAM_NO_MEM;",Useful
"/*""-"" equals stdin, but keep the string around for now*/","-3.       if(!*nextarg)
-2.         url->flags |= GETOUT_NOUPLOAD;
-1.       else {

 /*""-"" equals stdin, but keep the string around for now*/

1.         GetStr(&url->infile, nextarg);
2.       }
3.     }
4.     break;
5.     case 'u':",Useful
/*user:password*/,"-5.         GetStr(&url->infile, nextarg);
-4.       }
-3.     }
-2.     break;
-1.     case 'u':

 /*user:password*/

1.       GetStr(&config->userpwd, nextarg);
2.       cleanarg(nextarg);
3.       break;
4.     case 'U':",Useful
/*Proxy user:password*/,"-4.       GetStr(&config->userpwd, nextarg);
-3.       cleanarg(nextarg);
-2.       break;
-1.     case 'U':

 /*Proxy user:password*/

1.       GetStr(&config->proxyuserpwd, nextarg);
2.       cleanarg(nextarg);
3.       break;
4.     case 'v':
5.       ",Useful
/*the '%' thing here will cause the trace get sent to stderr*/,"-5.       GetStr(&config->proxyuserpwd, nextarg);
-4.       cleanarg(nextarg);
-3.       break;
-2.     case 'v':
-1.       if(toggle) {

 /*the '%' thing here will cause the trace get sent to stderr*/

1.         Curl_safefree(global->trace_dump);
2.    ",Useful
/*--no-version yields no output!*/,"-3.         global->tracetype = TRACE_NONE;
-2.       break;
-1.     case 'V':

 /*--no-version yields no output!*/

1.         return PARAM_VERSION_INFO_REQUESTED;
2.       break;
3.     case 'w':",Useful
/*get the output string*/,"-3.         return PARAM_VERSION_INFO_REQUESTED;
-2.       break;
-1.     case 'w':

 /*get the output string*/

1.       if('@' == *nextarg) {",Useful
"/*the data begins with a '@' letter, it means that a file name
           or - (stdin) follows*/","-9.             }
-8.             curl_free(enc);
-7.             postdata = n;
-6.           }
-5.           else
-4.             return PARAM_NO_MEM;
-3.         }
-2.       }
-1.       else if('@' == *nextarg && !raw_mode) {

 /*the data begins with a ",Useful
/*If-Modified-Since: (section 14.28 in RFC2068)*/,"-1.       default:

 /*If-Modified-Since: (section 14.28 in RFC2068)*/

1.         config->timecond = CURL_TIMECOND_IFMODSINCE;
2.         break;
3.       case '-':",Useful
/*If-Unmodified-Since:  (section 14.24 in RFC2068)*/,"-3.         config->timecond = CURL_TIMECOND_IFMODSINCE;
-2.         break;
-1.       case '-':

 /*If-Unmodified-Since:  (section 14.24 in RFC2068)*/

1.         config->timecond = CURL_TIMECOND_IFUNMODSINCE;
2.         nextarg++;
3.         break;
4.   ",Useful
/*Last-Modified:  (section 14.29 in RFC2068)*/,"-4.         config->timecond = CURL_TIMECOND_IFUNMODSINCE;
-3.         nextarg++;
-2.         break;
-1.       case '=':

 /*Last-Modified:  (section 14.29 in RFC2068)*/

1.         config->timecond = CURL_TIMECOND_LASTMOD;
2.         nextarg++;
3.       ",Useful
"/*failed, remove time condition*/","-3.           config->condtime = filetime;
-2.         }
-1.         else {

 /*failed, remove time condition*/

1.           config->timecond = CURL_TIMECOND_NONE;
2.           warnf(global,
3.                 ""Illegal date format for -z, --time-cond (an",Useful
"/*This indicates the end of the flags and thus enables the
           following (URL) argument to start with -.*/","-10.   char *orig_opt = NULL;
-9.   ParameterError result = PARAM_OK;
-8.   struct OperationConfig *config = global->first;
-7.   for(i = 1, stillflags = TRUE; i < argc && !result; i++) {
-6.     orig_opt = curlx_convert_tchar_to_UTF8(argv[i]);
-5.     if",Useful
/*Just add the URL please*/,"-4.       }
-3.     }
-2.     else {
-1.       bool used;

 /*Just add the URL please*/

1.       result = getparameter(""--url"", orig_opt, &used, global,
2.                             config);
3.     }
4.     if(!result)
5.       curlx_unicodefree(orig_o",Useful
/*The last #include files should be:*/,"-10.  *
-9.  ***************************************************************************/
-8. #include ""curl_setup.h""
-7. #if defined(USE_WINDOWS_SSPI) && defined(USE_KERBEROS5)
-6. #include <curl/curl.h>
-5. #include ""vauth/vauth.h""
-4. #include ""urldata",Useful
"/** Curl_auth_is_gssapi_supported()
 *
 * This is used to evaluate if GSSAPI (Kerberos V5) is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if Kerberos V5 is supported by Windows SSPI.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_is_gssapi_supported()
 *
 * This is used to evaluate if GSSAPI (Kerberos V5) is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if Kerberos V5 is supported by Windows SSPI.

 ",Useful
/*Release the package buffer as it is not required anymore*/,"-3.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
-2.                                               TEXT(SP_NAME_KERBEROS),
-1.                                               &SecurityPackage);

 /*Release the package buffer as it is not required",Useful
"/** Curl_auth_create_gssapi_user_message()
 *
 * This is used to generate an already encoded GSSAPI (Kerberos V5) user token
 * message ready for sending to the recipient.
 *
 * Parameters:
 *
 * data        [in]     - The session handle.
 * userp       [in]     - The user name in the format User or Domain\User.
 * passwdp     [in]     - The user's password.
 * service     [in]     - The service type such as http, smtp, pop or imap.
 * host        [in]     - The host name.
 * mutual_auth [in]     - Flag specifying whether or not mutual authentication
 *                        is enabled.
 * chlg64      [in]     - The optional base64 encoded challenge message.
 * krb5        [in/out] - The Kerberos 5 data struct being used and modified.
 * outptr      [in/out] - The address where a pointer to newly allocated memory
 *                        holding the result will be stored upon completion.
 * outlen      [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-6.   if(status == SEC_E_OK) {
-5.     s_pSecFn->FreeContextBuffer(SecurityPackage);
-4.   }
-3.   return (status == SEC_E_OK ? TRUE : FALSE);
-2. }
-1. /*
 * Curl_auth_create_gssapi_user_message()
 *
 * This is used to generate an already encoded GSSAPI ",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10. {
-9.   CURLcode result = CURLE_OK;
-8.   CtxtHandle context;
-7.   PSecPkgInfo SecurityPackage;
-6.   SecBuffer chlg_buf;
-5.   SecBuffer resp_buf;
-4.   SecBufferDesc chlg_desc;
-3.   SecBufferDesc resp_desc;
-2.   SECURITY_STATUS status;
-1.   uns",Useful
/*Generate our SPN*/,"-1.   if(!krb5->spn) {

 /*Generate our SPN*/

1.     krb5->spn = Curl_auth_build_spn(service, host, NULL);
2.     if(!krb5->spn)
3.       return CURLE_OUT_OF_MEMORY;
4.   }
5.   if(!krb5->output_token) {",Useful
/*Release the package buffer as it is not required anymore*/,"-3.   status = s_pSecFn->QuerySecurityPackageInfo((TCHAR *)
-2.                                               TEXT(SP_NAME_KERBEROS),
-1.                                               &SecurityPackage);

 /*Release the package buffer as it is not required",Useful
/*Populate our identity structure*/,"-1.     if(userp && *userp) {

 /*Populate our identity structure*/

1.       result = Curl_create_sspi_identity(userp, passwdp, &krb5->identity);
2.       if(result)
3.         return result;",Useful
/*Use the current Windows user*/,"-3.       krb5->p_identity = &krb5->identity;
-2.     }
-1.     else

 /*Use the current Windows user*/

1.       krb5->p_identity = NULL;",Useful
/*Ensure we have a valid challenge message*/,"-10.   SecBufferDesc wrap_desc;
-9.   unsigned char *indata;
-8.   unsigned long qop = 0;
-7.   unsigned long sec_layer = 0;
-6.   unsigned long max_size = 0;
-5.   SecPkgContext_Sizes sizes;
-4.   SECURITY_STATUS status;
-3. #if defined(CURL_DISABLE_VERB",Useful
"/*Setup the challenge ""input"" security buffer*/","-9.     krb5->context = calloc(1, sizeof(CtxtHandle));
-8.     if(!krb5->context)
-7.       return CURLE_OUT_OF_MEMORY;
-6.   }
-5.   if(chlg) {
-4.     if(!Curl_bufref_len(chlg)) {
-3.       infof(data, ""GSSAPI handshake failure (empty challenge message)",Useful
"/*Setup the response ""output"" security buffer*/","-7.     chlg_desc.ulVersion = SECBUFFER_VERSION;
-6.     chlg_desc.cBuffers  = 1;
-5.     chlg_desc.pBuffers  = &chlg_buf;
-4.     chlg_buf.BufferType = SECBUFFER_TOKEN;
-3.     chlg_buf.pvBuffer   = (void *) Curl_bufref_ptr(chlg);
-2.     chlg_buf.cbBuff",Useful
/*Generate our challenge-response message*/,"-6.   resp_desc.ulVersion = SECBUFFER_VERSION;
-5.   resp_desc.cBuffers  = 1;
-4.   resp_desc.pBuffers  = &resp_buf;
-3.   resp_buf.BufferType = SECBUFFER_TOKEN;
-2.   resp_buf.pvBuffer   = krb5->output_token;
-1.   resp_buf.cbBuffer   = curlx_uztoul(krb5",Useful
"/** Curl_auth_create_gssapi_security_message()
 *
 * This is used to generate an already encoded GSSAPI (Kerberos V5) security
 * token message ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The optional base64 encoded challenge message.
 * krb5    [in/out] - The Kerberos 5 data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.*/","-10.   if(resp_buf.cbBuffer) {
-9.     result = Curl_bufref_memdup(out, resp_buf.pvBuffer, resp_buf.cbBuffer);
-8.   }
-7.   else if(mutual_auth)
-6.     Curl_bufref_set(out, """", 0, NULL);
-5.   else
-4.     Curl_bufref_set(out, NULL, 0, NULL);
-3.   retu",Useful
/*Ensure we have a valid challenge message*/,"-10.   SecBufferDesc wrap_desc;
-9.   unsigned char *indata;
-8.   unsigned long qop = 0;
-7.   unsigned long sec_layer = 0;
-6.   unsigned long max_size = 0;
-5.   SecPkgContext_Sizes sizes;
-4.   SECURITY_STATUS status;
-3. #if defined(CURL_DISABLE_VERB",Useful
/*Get our response size information*/,"-4.   if(!Curl_bufref_len(chlg)) {
-3.     infof(data, ""GSSAPI handshake failure (empty security message)"");
-2.     return CURLE_BAD_CONTENT_ENCODING;
-1.   }

 /*Get our response size information*/

1.   status = s_pSecFn->QueryContextAttributes(krb5->c",Useful
"/*Setup the ""input"" security buffer*/","-7.   status = s_pSecFn->QueryContextAttributes(krb5->context,
-6.                                             SECPKG_ATTR_SIZES,
-5.                                             &sizes);
-4.   if(status == SEC_E_INSUFFICIENT_MEMORY)
-3.     return CURLE_O",Useful
/*Decrypt the inbound challenge and obtain the qop*/,"-9.   input_desc.ulVersion = SECBUFFER_VERSION;
-8.   input_desc.cBuffers = 2;
-7.   input_desc.pBuffers = input_buf;
-6.   input_buf[0].BufferType = SECBUFFER_STREAM;
-5.   input_buf[0].pvBuffer = (void *) Curl_bufref_ptr(chlg);
-4.   input_buf[0].cbBuff",Useful
/*Not 4 octets long so fail as per RFC4752 Section 3.1*/,"-5.   status = s_pSecFn->DecryptMessage(krb5->context, &input_desc, 0, &qop);
-4.   if(status != SEC_E_OK) {
-3.     infof(data, ""GSSAPI handshake failure (empty security message)"");
-2.     return CURLE_BAD_CONTENT_ENCODING;
-1.   }

 /*Not 4 octets long",Useful
/*Extract the security layer*/,"-4.   if(input_buf[1].cbBuffer != 4) {
-3.     infof(data, ""GSSAPI handshake failure (invalid security data)"");
-2.     return CURLE_BAD_CONTENT_ENCODING;
-1.   }

 /*Extract the security layer*/

1.   indata = input_buf[1].pvBuffer;
2.   sec_layer = inda",Useful
"/*The server has told us it supports a maximum receive buffer, however, as
       we don't require one unless we are encrypting data, we tell the server
       our receive buffer is zero.*/","-1.   if(max_size > 0) {

 /*The server has told us it supports a maximum receive buffer, however, as
       we don't require one unless we are encrypting data, we tell the server
       our receive buffer is zero.*/

1.     max_size = 0;
2.   }",Useful
"/*Setup the ""authentication data"" security buffer*/","-6.   padding = malloc(sizes.cbBlockSize);
-5.   if(!padding) {
-4.     free(message);
-3.     free(trailer);
-2.     return CURLE_OUT_OF_MEMORY;
-1.   }

 /*Setup the ""authentication data"" security buffer*/

1.   wrap_desc.ulVersion    = SECBUFFER_VERSIO",Useful
/*Allocate the encryption (wrap) buffer*/,"-10.   status = s_pSecFn->EncryptMessage(krb5->context, KERB_WRAP_NO_ENCRYPT,
-9.                                     &wrap_desc, 0);
-8.   if(status != SEC_E_OK) {
-7.     free(padding);
-6.     free(message);
-5.     free(trailer);
-4.     if(status == ",Useful
/*Populate the encryption buffer*/,"-9.   appdatalen = wrap_buf[0].cbBuffer + wrap_buf[1].cbBuffer +
-8.                wrap_buf[2].cbBuffer;
-7.   appdata = malloc(appdatalen);
-6.   if(!appdata) {
-5.     free(padding);
-4.     free(message);
-3.     free(trailer);
-2.     return CURLE_OU",Useful
/*Free all of our local buffers*/,"-5.   memcpy(appdata, wrap_buf[0].pvBuffer, wrap_buf[0].cbBuffer);
-4.   offset += wrap_buf[0].cbBuffer;
-3.   memcpy(appdata + offset, wrap_buf[1].pvBuffer, wrap_buf[1].cbBuffer);
-2.   offset += wrap_buf[1].cbBuffer;
-1.   memcpy(appdata + offset, wrap_",Useful
/*Reset any variables*/,"-2.   Curl_safefree(krb5->spn);
-1.   Curl_safefree(krb5->output_token);

 /*Reset any variables*/

1.   krb5->token_max = 0;
2. }",Useful
/*The last #include files should be:*/,"-10. #include ""curl_setup.h""
-9. #if defined(HAVE_GSSAPI) && defined(USE_SPNEGO)
-8. #include <curl/curl.h>
-7. #include ""vauth/vauth.h""
-6. #include ""urldata.h""
-5. #include ""curl_base64.h""
-4. #include ""curl_gssapi.h""
-3. #include ""warnless.h""
-2. #incl",Useful
"/** Curl_auth_is_spnego_supported()
 *
 * This is used to evaluate if SPNEGO (Negotiate) is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if Negotiate supported by the GSS-API library.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_is_spnego_supported()
 *
 * This is used to evaluate if SPNEGO (Negotiate) is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if Negotiate supported by the GSS-API library.

 ",Useful
"/*We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better*/","-10.   unsigned char *chlg = NULL;
-9.   OM_uint32 major_status;
-8.   OM_uint32 minor_status;
-7.   OM_uint32 unused_status;
-6.   gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
-5.   gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
-4.   gss_buffer_de",Useful
/*Ensure we have a valid challenge message*/,"-5.     if(*chlg64 != '=') {
-4.       result = Curl_base64_decode(chlg64, &chlg, &chlglen);
-3.       if(result)
-2.         return result;
-1.     }

 /*Ensure we have a valid challenge message*/

1.     if(!chlg) {
2.       infof(data, ""SPNEGO handshak",Useful
/*Generate our challenge-response message*/,"-3.     input_token.value = chlg;
-2.     input_token.length = chlglen;
-1.   }

 /*Generate our challenge-response message*/

1.   major_status = Curl_gss_init_sec_context(data,
2.                                            &minor_status,
3.             ",Useful
/*Reset any variables*/,"-4.   if(nego->spn != GSS_C_NO_NAME) {
-3.     gss_release_name(&minor_status, &nego->spn);
-2.     nego->spn = GSS_C_NO_NAME;
-1.   }

 /*Reset any variables*/

1.   nego->status = 0;
2.   nego->noauthpersist = FALSE;
3.   nego->havenoauthpersist = FALSE",Useful
/*The last #include files should be:*/,"-10.  *
-9.  ***************************************************************************/
-8. #include ""curl_setup.h""
-7. #if !defined(CURL_DISABLE_IMAP) || !defined(CURL_DISABLE_SMTP) || \
-6.   !defined(CURL_DISABLE_POP3)
-5. #include <curl/curl.h>
-4. ",Useful
/*Generate the message*/,"-10.  *
-9.  * Returns CURLE_OK on success.
-8.  */
-7. CURLcode Curl_auth_create_oauth_bearer_message(const char *user,
-6.                                                const char *host,
-5.                                                const long por",Useful
/*Generate the message*/,"-10.  *
-9.  * Returns CURLE_OK on success.
-8.  */
-7. CURLcode Curl_auth_create_oauth_bearer_message(const char *user,
-6.                                                const char *host,
-5.                                                const long por",Useful
/*The last #include files should be:*/,"-10. #include ""curl_setup.h""
-9. #if defined(USE_WINDOWS_SSPI) && defined(USE_SPNEGO)
-8. #include <curl/curl.h>
-7. #include ""vauth/vauth.h""
-6. #include ""urldata.h""
-5. #include ""curl_base64.h""
-4. #include ""warnless.h""
-3. #include ""curl_multibyte.h""
-",Useful
"/** Curl_auth_is_spnego_supported()
 *
 * This is used to evaluate if SPNEGO (Negotiate) is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if Negotiate is supported by Windows SSPI.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_is_spnego_supported()
 *
 * This is used to evaluate if SPNEGO (Negotiate) is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if Negotiate is supported by Windows SSPI.

 /** ",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10. {
-9.   CURLcode result = CURLE_OK;
-8.   size_t chlglen = 0;
-7.   unsigned char *chlg = NULL;
-6.   PSecPkgInfo SecurityPackage;
-5.   SecBuffer chlg_buf[2];
-4.   SecBuffer resp_buf;
-3.   SecBufferDesc chlg_desc;
-2.   SecBufferDesc resp_desc;
-1",Useful
"/*We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better*/","-4. #if defined(CURL_DISABLE_VERBOSE_STRINGS)
-3.   (void) data;
-2. #endif
-1.   if(nego->context && nego->status == SEC_E_OK) {

 /*We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an",Useful
/*Allocate our output buffer*/,"-1.     s_pSecFn->FreeContextBuffer(SecurityPackage);

 /*Allocate our output buffer*/

1.     nego->output_token = malloc(nego->token_max);
2.     if(!nego->output_token)
3.       return CURLE_OUT_OF_MEMORY;
4.  }
5.   if(!nego->credentials) {",Useful
/*Use the current Windows user*/,"-3.       nego->p_identity = &nego->identity;
-2.     }
-1.     else

 /*Use the current Windows user*/

1.       nego->p_identity = NULL;",Useful
"/*ssl context comes from Schannel.
    * When extended protection is used in IIS server,
    * we have to pass a second SecBuffer to the SecBufferDesc
    * otherwise IIS will not pass the authentication (401 response).
    * Minimum supported version is Windows 7.
    * https://docs.microsoft.com/en-us/security-updates
    * /SecurityAdvisories/2009/973811*/","* /SecurityAdvisories/2009/973811

 /*ssl context comes from Schannel.
    * When extended protection is used in IIS server,
    * we have to pass a second SecBuffer to the SecBufferDesc
    * otherwise IIS will not pass the authentication (401 response).
    * Minimum supported version is Windows 7.
    * https://docs.microsoft.com/en-us/security-updates
    * /SecurityAdvisories/2009/973811*/

1.     */
2.     if(nego->sslContext) {
3.       SEC_CHANNEL_BINDINGS channelBindings;
4.       SecPkgContext_Bindings pkgBindings;
5.       pkgBindings.Bindings = &channelBindings;
6.       nego->status = s_pSecFn->QueryContextAttributes(
7.           nego->sslContext,
8.           SECPKG_ATTR_ENDPOINT_BINDINGS,
9.           &pkgBindings
10.       );",Useful
/*Reset any variables*/,"-2.   Curl_safefree(nego->spn);
-1.   Curl_safefree(nego->output_token);

 /*Reset any variables*/

1.   nego->status = 0;
2.   nego->token_max = 0;
3.   nego->noauthpersist = FALSE;
4.   nego->havenoauthpersist = FALSE;
5.   nego->havenegdata = FALSE;
6.",Useful
/*for struct Curl_easy*/,"-10.  * KIND, either express or implied.
-9.  *
-8.  ***************************************************************************/
-7. #include ""curl_setup.h""
-6. #include <curl/curl.h>
-5. #include ""formdata.h""
-4. #if !defined(CURL_DISABLE_HTTP) && !defi",Useful
"/***************************************************************************
 *
 * AddHttpPost()
 *
 * Adds a HttpPost structure to the list, if parent_post is given becomes
 * a subpost of parent_post instead of a direct list element.
 *
 * Returns newly allocated HttpPost on success and NULL if malloc failed.
 *
 ***************************************************************************/",#NAME?,Useful
/*make the previous point to this*/,"-3.     parent_post->more = post;
-2.   }
-1.   else {

 /*make the previous point to this*/

1.     if(*last_post)
2.       (*last_post)->next = post;
3.     else
4.       (*httppost) = post;
5.     (*last_post) = post;
6.   }
7.   return post;
8. }
9. /",Useful
"/***************************************************************************
 *
 * AddFormInfo()
 *
 * Adds a FormInfo structure to the list presented by parent_form_info.
 *
 * Returns newly allocated FormInfo on success and NULL if malloc failed/
 * parent_form_info is NULL.
 *
 ***************************************************************************/",#NAME?,Useful
/*then move the original 'more' to point to ourselves*/,"-1.     post->more = parent_post->more;

 /*then move the original 'more' to point to ourselves*/

1.     parent_post->more = post;
2.   }
3.   else {",Useful
/*value read from an array*/,"-10. CURLFORMcode FormAdd(struct curl_httppost **httppost,
-9.                      struct curl_httppost **last_post,
-8.                      va_list params)
-7. {
-6.   struct FormInfo *first_form, *current_form, *form = NULL;
-5.   CURLFORMcode return_",Useful
/** We need to allocate the first struct to fill in.*/,"-2.   bool array_state = FALSE;
-1.   /*
   * We need to allocate the first struct to fill in.

 /** We need to allocate the first struct to fill in.*/

1.    */
2.   first_form = calloc(1, sizeof(struct FormInfo));
3.   if(!first_form)
4.     return CURL",Useful
/** Loop through all the options set. Break if we have an error to report.*/,"-5.   first_form = calloc(1, sizeof(struct FormInfo));
-4.   if(!first_form)
-3.     return CURL_FORMADD_MEMORY;
-2.   current_form = first_form;
-1.   /*
   * Loop through all the options set. Break if we have an error to report.

 /** Loop through all t",Useful
/*first see if we have more parts of the array param*/,"-1.   while(return_value == CURL_FORMADD_OK) {

 /*first see if we have more parts of the array param*/

1.     if(array_state && forms) {",Useful
/*get the upcoming option from the given array*/,"-1.     if(array_state && forms) {

 /*get the upcoming option from the given array*/

1.       option = forms->option;
2.       array_value = (char *)forms->value;",Useful
/*fall through*/,"-1.     case CURLFORM_PTRNAME:

 /*fall through*/

111",Useful
/*FALLTHROUGH*/,"-2.     case CURLFORM_PTRNAME:

 /*FALLTHROUGH*/

1.     case CURLFORM_COPYNAME:
2.       if(current_form->name)
3.         return_value = CURL_FORMADD_OPTION_TWICE;
4.       else {
5.         char *name = array_state?
6.           array_value:va_arg(para",Useful
/*The last #include file should be:*/,"-10.  * furnished to do so, under the terms of the COPYING file.
-9.  *
-8.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-7.  * KIND, either express or implied.
-6.  *
-5.  **************************************************",Useful
/*HAVE_MEMRCHR*/,"-1. #include ""memdebug.h""
#ifndef HAVE_MEMRCHR

 /*HAVE_MEMRCHR*/

111",Useful
/*@unittest 1655*/,"-10.   if((code >= DOH_OK) && (code <= DOH_DNS_NAME_TOO_LONG))
-9.     return errors[code];
-8.   return ""bad error code"";
-7. }
-6. #endif
-5. #ifdef DEBUGBUILD
-4. #define UNITTEST
-3. #else
-2. #define UNITTEST static
-1. #endif
/* @unittest 1655

 /*@",Useful
/*buffer*/,"-2. UNITTEST DOHcode doh_encode(const char *host,
-1.                             DNStype dnstype,

 /*buffer*/

111",Useful
/*buffer size*/,"-3. UNITTEST DOHcode doh_encode(const char *host,
-2.                             DNStype dnstype,

 /*buffer size*/

111",Useful
/*output length*/,"-4. UNITTEST DOHcode doh_encode(const char *host,
-3.                             DNStype dnstype,

 /*output length*/

1. {
2.   const size_t hostlen = strlen(host);
3.   unsigned char *orig = dnsp;
4.   const char *hostp = host;
5.   /* The expected out",Useful
"/*The expected output length is 16 bytes more than the length of
   * the QNAME-encoding of the host name.
   *
   * A valid DNS name may not contain a zero-length label, except at
   * the end.  For this reason, a name beginning with a dot, or
   * containing a sequence of two or more consecutive dots, is invalid
   * and cannot be encoded as a QNAME.
   *
   * If the host name ends with a trailing dot, the corresponding
   * QNAME-encoding is one byte longer than the host name. If (as is
   * also valid) the hostname is shortened by the omission of the
   * trailing dot, then its QNAME-encoding will be two bytes longer
   * than the host name.
   *
   * Each [ label, dot ] pair is encoded as [ length, label ],
   * preserving overall length.  A final [ label ] without a dot is
   * also encoded as [ length, label ], increasing overall length
   * by one. The encoding is completed by appending a zero byte,
   * representing the zero-length root label, again increasing
   * the overall length by one.*/","-4. {
-3.   const size_t hostlen = strlen(host);
-2.   unsigned char *orig = dnsp;
-1.   const char *hostp = host;
  /* The expected output length is 16 bytes more than the length of
   * the QNAME-encoding of the host name.
   *
   * A valid DNS name may",Useful
"/*label is too long or too short, error out*/","-8.   while(*hostp) {
-7.     size_t labellen;
-6.     char *dot = strchr(hostp, '.');
-5.     if(dot)
-4.       labellen = dot - hostp;
-3.     else
-2.       labellen = strlen(hostp);
-1.     if((labellen > 63) || (!labellen)) {

 /*label is too long or",Useful
"/*advance past dot, but only if there is one*/","-4.     *dnsp++ = (unsigned char)labellen;
-3.     memcpy(dnsp, hostp, labellen);
-2.     dnsp += labellen;
-1.     hostp += labellen;

 /*advance past dot, but only if there is one*/

1.     if(dot)
2.       hostp++;",Useful
/*append zero-length label for root*/,"-3.     if(dot)
-2.       hostp++;

 /*append zero-length label for root*/

111",Useful
/*upper 8 bit TYPE*/,"-5.     if(dot)
-4.       hostp++;

 /*upper 8 bit TYPE*/

111",Useful
/*lower 8 bit TYPE*/,"-6.     if(dot)
-5.       hostp++;

 /*lower 8 bit TYPE*/

111",Useful
/*upper 8 bit CLASS*/,"-7.     if(dot)
-6.       hostp++;

 /*upper 8 bit CLASS*/

111",Useful
"/*IN - ""the Internet""*/","-8.     if(dot)
-7.       hostp++;

 /*IN - ""the Internet""*/

1.   *olen = dnsp - orig;",Useful
/*Curl_open() is the internal version of curl_easy_init()*/,"-10.     failf(data, ""Failed to encode DoH packet [%d]"", d);
-9.     return CURLE_OUT_OF_MEMORY;
-8.   }
-7.   p->dnstype = dnstype;
-6.   Curl_dyn_init(&p->serverdoh, DYN_DOH_RESPONSE);
-5.   timeout_ms = Curl_timeleft(data, NULL, TRUE);
-4.   if(timeout",Useful
"/*Inherit *some* SSL options from the user's transfer. This is a
       best-guess as to which options are needed for compatibility. #3661*/","-10.     if(data->set.verbose)
-9.       ERROR_CHECK_SETOPT(CURLOPT_VERBOSE, 1L);
-8.     if(data->set.no_signal)
-7.       ERROR_CHECK_SETOPT(CURLOPT_NOSIGNAL, 1L);
-6.     ERROR_CHECK_SETOPT(CURLOPT_SSL_VERIFYHOST,
-5.       data->set.doh_verifyhost ? 2",Useful
/*identify for which transfer this is done*/,"-10.          CURLSSLOPT_NO_PARTIALCHAIN : 0) |
-9.         (data->set.ssl.revoke_best_effort ?
-8.          CURLSSLOPT_REVOKE_BEST_EFFORT : 0) |
-7.         (data->set.ssl.native_ca_store ?
-6.          CURLSSLOPT_NATIVE_CA : 0) |
-5.         (data->set.",Useful
/*this never returns synchronously*/,"-10.  */
-9. struct Curl_addrinfo *Curl_doh(struct Curl_easy *data,
-8.                                const char *hostname,
-7.                                int port,
-6.                                int *waitp)
-5. {
-4.   CURLcode result = CURLE_OK",Useful
"/*name pointer, advance over it and be done*/","-10. }
-9. static DOHcode skipqname(const unsigned char *doh, size_t dohlen,
-8.                          unsigned int *indexp)
-7. {
-6.   unsigned char length;
-5.   do {
-4.     if(dohlen < (*indexp + 1))
-3.       return DOH_DNS_OUT_OF_RANGE;
-2.     ",Useful
"/*make clang and gcc optimize this to bswap by incrementing
      the pointer first.*/","-10.     *indexp += 1 + length;
-9.   } while(length);
-8.   return DOH_OK;
-7. }
-6. static unsigned short get16bit(const unsigned char *doh, int index)
-5. {
-4.   return (unsigned short)((doh[index] << 8) | doh[index + 1]);
-3. }
-2. static unsigned in",Useful
"/** doh2ai()
 *
 * This function returns a pointer to the first element of a newly allocated
 * Curl_addrinfo struct linked list filled with the data from a set of DOH
 * lookups.  Curl_addrinfo is meant to work like the addrinfo struct does for
 * a IPv6 stack, but usable also for IPv4, all hosts and environments.
 *
 * The memory allocated by this function *MUST* be free'd later on calling
 * Curl_freeaddrinfo().  For each successful call to this function there
 * must be an associated call later to Curl_freeaddrinfo().*/","-10.     }
-9.   }
-8.   for(i = 0; i < d->numcname; i++) {
-7.     infof(data, ""CNAME: %s"", Curl_dyn_ptr(&d->cname[i]));
-6.   }
-5. }
-4. #else
-3. #define showdoh(x,y)
-2. #endif
-1. /*
 * doh2ai()
 *
 * This function returns a pointer to the first ele",Useful
/*no input == no output!*/,"-1.   if(!de)

 /*no input == no output!*/

1.     return NULL;
2.   for(i = 0; i < de->numaddr; i++) {
3.     size_t ss_size;
4.     CURL_SA_FAMILY_T addrtype;
5.     if(de->addr[i].type == DNS_TYPE_AAAA) {
6. #ifndef ENABLE_IPV6",Useful
/*we can't handle IPv6 addresses*/,"-6.     return NULL;
-5.   for(i = 0; i < de->numaddr; i++) {
-4.     size_t ss_size;
-3.     CURL_SA_FAMILY_T addrtype;
-2.     if(de->addr[i].type == DNS_TYPE_AAAA) {
-1. #ifndef ENABLE_IPV6

 /*we can't handle IPv6 addresses*/

1.       continue;
2. #e",Useful
/*store the pointer we want to return from this function*/,"-10.     }
-9.     ai = calloc(1, sizeof(struct Curl_addrinfo) + ss_size + hostlen);
-8.     if(!ai) {
-7.       result = CURLE_OUT_OF_MEMORY;
-6.       break;
-5.     }
-4.     ai->ai_addr = (void *)((char *)ai + sizeof(struct Curl_addrinfo));
-3.     ai",Useful
/*leave the rest of the struct filled with zero*/,"-2.     ai->ai_socktype = SOCK_STREAM;
-1.     ai->ai_addrlen = (curl_socklen_t)ss_size;

 /*leave the rest of the struct filled with zero*/

1.     switch(ai->ai_family) {
2.     case AF_INET:",Useful
/*storage area for this info*/,"-2.     switch(ai->ai_family) {
-1.     case AF_INET:

 /*storage area for this info*/

1.       DEBUGASSERT(sizeof(struct in_addr) == sizeof(de->addr[i].ip.v4));
2.       memcpy(&addr->sin_addr, &de->addr[i].ip.v4, sizeof(struct in_addr));
3.       addr-",Useful
/*storage area for this info*/,"-2.     switch(ai->ai_family) {
-1.     case AF_INET:

 /*storage area for this info*/

1.       DEBUGASSERT(sizeof(struct in_addr) == sizeof(de->addr[i].ip.v4));
2.       memcpy(&addr->sin_addr, &de->addr[i].ip.v4, sizeof(struct in_addr));
3.       addr-",Useful
/*defaults to no response*/,"-10.   int i = 0;
-9.   for(i = 0; i < d->numcname; i++) {
-8.     Curl_dyn_free(&d->cname[i]);
-7.   }
-6. }
-5. CURLcode Curl_doh_is_resolved(struct Curl_easy *data,
-4.                               struct Curl_dns_entry **dnsp)
-3. {
-2.   CURLcode re",Useful
"/*parse the responses, create the struct and return it!*/","-4.     for(slot = 0; slot < DOH_PROBE_SLOTS; slot++) {
-3.       curl_multi_remove_handle(data->multi, dohp->probe[slot].easy);
-2.       Curl_close(&dohp->probe[slot].easy);
-1.     }

 /*parse the responses, create the struct and return it!*/

1.     d",Useful
"/*we got a response, store it in the cache*/","-10.       struct Curl_addrinfo *ai;
-9.       infof(data, ""DoH Host name: %s"", dohp->host);
-8.       showdoh(data, &de);
-7.       ai = doh2ai(&de, dohp->host, dohp->port);
-6.       if(!ai) {
-5.         de_cleanup(&de);
-4.         return CURLE_OUT_OF",Useful
"/*returned failure, bail out nicely*/","-4.       dns = Curl_cache_addr(data, ai, dohp->host, dohp->port);
-3.       if(data->share)
-2.         Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
-1.       if(!dns) {

 /*returned failure, bail out nicely*/

1.         Curl_freeaddrinfo(ai);
2.       ",Useful
/*CURL_DISABLE_DOH*/,#NAME?,Useful
/*called before setup properly!*/,"-10.                              void *userp)
-9. {
-8.   struct connectdata *conn = (struct connectdata *)userp;
-7.   struct http_conn *c = &conn->proto.httpc;
-6.   struct Curl_easy *data = get_transfer(c);
-5.   ssize_t written;
-4.   CURLcode result",Useful
"/*We pass a pointer to this struct in the push callback, but the contents of
   the struct are hidden from the user.*/","-10.     return NGHTTP2_ERR_WOULDBLOCK;
-9.   }
-8.   if(written == -1) {
-7.     failf(data, ""Failed sending HTTP2 data"");
-6.     return NGHTTP2_ERR_CALLBACK_FAILURE;
-5.   }
-4.   if(!written)
-3.     return NGHTTP2_ERR_WOULDBLOCK;
-2.   return written",Useful
"/*Verify that we got a good easy handle in the push header struct,
     mostly to detect rubbish input fast(er). Also empty header name
     is just a rubbish too. We have to allow "":"" at the beginning of
     the header, but header == "":"" must be rejected. If we have ':' in
     the middle of header, it could be matched in middle of the value,
     this is because we do prefix match.*/","-2. char *curl_pushheader_byname(struct curl_pushheaders *h, const char *header)
-1. {

 /*Verify that we got a good easy handle in the push header struct,
     mostly to detect rubbish input fast(er). Also empty header name
     is just a rubbish too. We",Useful
"/*sub-match, make sure that it is followed by a colon*/","-10.      this is because we do prefix match.*/
-9.   if(!h || !GOOD_EASY_HANDLE(h->data) || !header || !header[0] ||
-8.      !strcmp(header, "":"") || strchr(header + 1, ':'))
-7.     return NULL;
-6.   else {
-5.     struct HTTP *stream = h->data->req.p.",Useful
/*clone the parent*/,"-9.   H2BUGF(infof(data, ""PUSH_PROMISE received, stream %u"",
-8.                frame->promised_stream_id));
-7.   if(data->multi->push_cb) {
-6.     struct HTTP *stream;
-5.     struct HTTP *newstream;
-4.     struct curl_pushheaders heads;
-3.     CURLM",Useful
/*only signal change if the value actually changed*/,"-10.         nghttp2_session_get_remote_settings(
-9.           session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);
-8.       httpc->settings.enable_push =
-7.         nghttp2_session_get_remote_settings(
-6.           session, NGHTTP2_SETTINGS_ENABLE_PUSH",Useful
/*deny!*/,"-5.     if(get_transfer(httpc) != data_s)
-4.       Curl_expire(data_s, 0, EXPIRE_RUN_NOW);
-3.     break;
-2.   case NGHTTP2_PUSH_PROMISE:
-1.     rv = push_promise(data_s, conn, &frame->push_promise);

 /*deny!*/

1.       int h2;
2.       DEBUGASSERT((",Useful
"/*Receiving a Stream ID not in the hash should not happen, this is an
       internal error more than anything else!*/","-2.   data_s = nghttp2_session_get_stream_user_data(session, stream_id);
-1.   if(!data_s)

 /*Receiving a Stream ID not in the hash should not happen, this is an
       internal error more than anything else!*/

1.     return NGHTTP2_ERR_CALLBACK_FAILURE",Useful
"/*We could get stream ID not in the hash.  For example, if we
         decided to reject stream (e.g., PUSH_PROMISE).*/","-2.     data_s = nghttp2_session_get_stream_user_data(session, stream_id);
-1.     if(!data_s) {

 /*We could get stream ID not in the hash.  For example, if we
         decided to reject stream (e.g., PUSH_PROMISE).*/

1.       return 0;
2.     }
3.     ",Useful
"/*Receiving a Stream ID not in the hash should not happen, this is an
       internal error more than anything else!*/","-2.   data_s = nghttp2_session_get_stream_user_data(session, stream_id);
-1.   if(!data_s)

 /*Receiving a Stream ID not in the hash should not happen, this is an
       internal error more than anything else!*/

1.     return NGHTTP2_ERR_CALLBACK_FAILURE",Useful
/*pseudo headers are lower case*/,"-3.   if(frame->hd.type == NGHTTP2_PUSH_PROMISE) {
-2.     char *h;
-1.     if(!strcmp(H2H3_PSEUDO_AUTHORITY, (const char *)name)) {

 /*pseudo headers are lower case*/

1.       int rc = 0;
2.       char *check = aprintf(""%s:%d"", conn->host.name, conn->r",Useful
/*no memory*/,"-3.       int rc = 0;
-2.       char *check = aprintf(""%s:%d"", conn->host.name, conn->remote_port);
-1.       if(!check)

 /*no memory*/

1.         return NGHTTP2_ERR_CALLBACK_FAILURE;
2.       if(!Curl_strcasecompare(check, (const char *)value) &&
3.   ",Useful
"/*This is push is not for the same authority that was asked for in
         * the URL. RFC 7540 section 8.2 says: ""A client MUST treat a
         * PUSH_PROMISE for which the server is not authoritative as a stream
         * error of type PROTOCOL_ERROR.""*/","-4.         return NGHTTP2_ERR_CALLBACK_FAILURE;
-3.       if(!Curl_strcasecompare(check, (const char *)value) &&
-2.          ((conn->remote_port != conn->given->defport) ||
-1.           !Curl_strcasecompare(conn->host.name, (const char *)value))) {
   ",Useful
/*the space character after the status code is mandatory*/,"-10.               stream->status_code);
-9.     result = Curl_headers_push(data_s, buffer, CURLH_PSEUDO);
-8.     if(result)
-7.       return NGHTTP2_ERR_CALLBACK_FAILURE;
-6.     result = Curl_dyn_addn(&stream->header_recvbuf, STRCONST(""HTTP/2 ""));
-5. ",Useful
/*convert to a HTTP1-style header*/,"-8.     if(get_transfer(httpc) != data_s)
-7.       Curl_expire(data_s, 0, EXPIRE_RUN_NOW);
-6.     H2BUGF(infof(data_s, ""h2 status: HTTP/2 %03d (easy %p)"",
-5.                  stream->status_code, data_s));
-4.     return 0;
-3.   }

 /*convert to a HTT",Useful
/*0 is successful*/,"-4.   if(get_transfer(httpc) != data_s)
-3.     Curl_expire(data_s, 0, EXPIRE_RUN_NOW);
-2.   H2BUGF(infof(data_s, ""h2 header: %.*s: %.*s"", namelen, name, valuelen,
-1.                value));

 /*0 is successful*/

1. }
2. static ssize_t data_source_read",Useful
"/*Receiving a Stream ID not in the hash should not happen, this is an
         internal error more than anything else!*/","-2.     data_s = nghttp2_session_get_stream_user_data(session, stream_id);
-1.     if(!data_s)

 /*Receiving a Stream ID not in the hash should not happen, this is an
         internal error more than anything else!*/

1.       return NGHTTP2_ERR_CALLBACK",Useful
/*most likely at least*/,"-10. {
-9.   if(!conn->proto.httpc.h2) {
-8.     int rc;
-7.     nghttp2_session_callbacks *callbacks;
-6.     conn->proto.httpc.inbuf = malloc(H2_BUFSIZE);
-5.     if(!conn->proto.httpc.inbuf)
-4.       return CURLE_OUT_OF_MEMORY;
-3.     rc = nghttp2_se",Useful
/*most likely at least*/,"-10. {
-9.   if(!conn->proto.httpc.h2) {
-8.     int rc;
-7.     nghttp2_session_callbacks *callbacks;
-6.     conn->proto.httpc.inbuf = malloc(H2_BUFSIZE);
-5.     if(!conn->proto.httpc.inbuf)
-4.       return CURLE_OUT_OF_MEMORY;
-3.     rc = nghttp2_se",Useful
/*this returns number of bytes it wrote*/,"-10. {
-9.   CURLcode result;
-8.   ssize_t binlen;
-7.   char *base64;
-6.   size_t blen;
-5.   struct connectdata *conn = data->conn;
-4.   struct SingleRequest *k = &data->req;
-3.   uint8_t *binsettings = conn->proto.httpc.binsettings;
-2.   struct ht",Useful
"/*not an error per se, but should still close the connection*/","-10.        identifiers has been reached. */
-9.     connclose(data->conn, ""http/2: No new requests allowed"");
-8.   }
-7.   if(should_close_session(httpc)) {
-6.     struct HTTP *stream = data->req.p.http;
-5.     H2BUGF(infof(data,
-4.                  ",Useful
/** Called from transfer.c:done_sending when we stop uploading.*/,"-8.       connclose(data->conn, ""GOAWAY received"");
-7.       *err = CURLE_OK;
-6.     }
-5.     return -1;
-4.   }
-3.   return 0;
-2. }
-1. /*
 * Called from transfer.c:done_sending when we stop uploading.

 /** Called from transfer.c:done_sending when ",Useful
/*make sure this is only attempted for HTTP/2 transfers*/,"-6. CURLcode Curl_http2_done_sending(struct Curl_easy *data,
-5.                                  struct connectdata *conn)
-4. {
-3.   CURLcode result = CURLE_OK;
-2.   if((conn->handler == &Curl_handler_http2_ssl) ||
-1.      (conn->handler == &Curl_han",Useful
/*DONE!*/,"-5.     struct HTTP *stream = data->req.p.http;
-4.     struct http_conn *httpc = &conn->proto.httpc;
-3.     nghttp2_session *h2 = httpc->h2;
-2.     if(stream->upload_left) {

 /*DONE!*/

111",Useful
/*Reset to FALSE to prevent infinite loop in readwrite_data function.*/,"-10.   if(httpc->pause_stream_id == stream->stream_id) {
-9.     httpc->pause_stream_id = 0;
-8.   }
-7.   drained_transfer(data, httpc);
-6.   if(httpc->pause_stream_id == 0) {
-5.     if(h2_process_pending_input(data, httpc, err) != 0) {
-4.       retur",Useful
/*trigger Curl_retry_request() later*/,"-1.     data->state.refused_stream = TRUE;

 /*trigger Curl_retry_request() later*/

1.     return -1;
2.   }
3.   else if(stream->error != NGHTTP2_NO_ERROR) {
4.     failf(data, ""HTTP/2 stream %d was not closed cleanly: %s (err %u)"",
5.           stream-",Useful
/*send new weight and/or dependency*/,"-10.  */
-9. static int h2_session_send(struct Curl_easy *data,
-8.                            nghttp2_session *h2)
-7. {
-6.   struct HTTP *stream = data->req.p.http;
-5.   struct http_conn *httpc = &data->conn->proto.httpc;
-4.   set_transfer(httpc, dat",Useful
"/*already marked for closure, return OK and we're done*/","-4.   if(should_close_session(httpc)) {
-3.     H2BUGF(infof(data,
-2.                  ""http2_recv: nothing to do in this session""));
-1.     if(conn->bits.close) {

 /*already marked for closure, return OK and we're done*/

1.       *err = CURLE_OK;
2. ",Useful
"/*Nullify here because we call nghttp2_session_send() and they
     might refer to the old buffer.*/","-6.       *err = CURLE_OK;
-5.       return 0;
-4.     }
-3.     *err = CURLE_HTTP2;
-2.     return -1;
-1.   }

 /*Nullify here because we call nghttp2_session_send() and they
     might refer to the old buffer.*/

1.   stream->upload_mem = NULL;
2.   st",Useful
"/*if we didn't get the same buffer this time, we must move the data to
         the beginning*/","-10.                data, stream->stream_id,
-9.                nghttp2_session_get_local_window_size(httpc->h2),
-8.                nghttp2_session_get_stream_local_window_size(httpc->h2,
-7.                                                             st",Useful
"/*this stream is closed, trigger a another read ASAP to detect that*/","-7.       H2BUGF(infof(data, ""Data returned for PAUSED stream %u"",
-6.                    stream->stream_id));
-5.     }
-4.     else if(!stream->closed) {
-3.       drained_transfer(data, httpc);
-2.     }
-1.     else

 /*this stream is closed, trigger ",Useful
"/*Nullify here because we call nghttp2_session_send() and they
       might refer to the old buffer.*/","-10.     if(nghttp2_is_fatal(rv)) {
-9.       *err = CURLE_SEND_ERROR;
-8.       return -1;
-7.     }
-6.     rv = h2_session_send(data, h2);
-5.     if(nghttp2_is_fatal(rv)) {
-4.       *err = CURLE_SEND_ERROR;
-3.       return -1;
-2.     }
-1.     len ",Useful
"/*we are sure that we have more data to send here.  Calling the
         following API will make nghttp2_session_want_write() return
         nonzero if remote window allows it, which then libcurl checks
         socket is writable or not.  See http2_perform_getsock().*/","-8.     stream->upload_mem = NULL;
-7.     stream->upload_len = 0;
-6.     if(should_close_session(httpc)) {
-5.       H2BUGF(infof(data, ""http2_send: nothing to do in this session""));
-4.       *err = CURLE_HTTP2;
-3.       return -1;
-2.     }
-1.     i",Useful
/*data sending without specifying the data amount up front*/,"-10.   H2BUGF(infof(data, ""http2_send request allowed %d (easy handle %p)"",
-9.                nghttp2_session_check_request_allowed(h2), (void *)data));
-8.   switch(data->state.httpreq) {
-7.   case HTTPREQ_POST:
-6.   case HTTPREQ_POST_FORM:
-5.   case",Useful
/*already done*/,"-2.   if((conn->handler == &Curl_handler_http2_ssl) ||
-1.      (conn->handler == &Curl_handler_http2))

 /*already done*/

1.   if(conn->handler->flags & PROTOPT_SSL)
2.     conn->handler = &Curl_handler_http2_ssl;
3.   else
4.     conn->handler = &Curl_",Useful
/*at least potentially multiplexed*/,"-10.   if(conn->handler->flags & PROTOPT_SSL)
-9.     conn->handler = &Curl_handler_http2_ssl;
-8.   else
-7.     conn->handler = &Curl_handler_http2;
-6.   result = http2_init(data, conn);
-5.   if(result) {
-4.     Curl_dyn_free(&stream->header_recvbuf)",Useful
"/*Only call this function for a transfer that already got a HTTP/2
   CURLE_HTTP2_STREAM error!*/","-10. {
-9.   while(data->set.stream_dependents) {
-8.     struct Curl_easy *tmp = data->set.stream_dependents->data;
-7.     Curl_http2_remove_child(data, tmp);
-6.     if(data->set.stream_depends_on)
-5.       Curl_http2_add_child(data->set.stream_depend",Useful
/*!USE_NGHTTP2*/,"-5. bool Curl_h2_http_1_1_error(struct Curl_easy *data)
-4. {
-3.   struct HTTP *stream = data->req.p.http;
-2.   return (stream->error == NGHTTP2_HTTP_1_1_REQUIRED);
-1. }

 /*!USE_NGHTTP2*/

111",Useful
/*Satisfy external references even if http2 is not compiled in.*/,"-6. bool Curl_h2_http_1_1_error(struct Curl_easy *data)
-5. {
-4.   struct HTTP *stream = data->req.p.http;
-3.   return (stream->error == NGHTTP2_HTTP_1_1_REQUIRED);
-2. }

 /*Satisfy external references even if http2 is not compiled in.*/

1. #include <",Useful
/*USE_NGHTTP2*/,#NAME?,Useful
/*The last #include files should be:*/,"-10. #if !defined(CURL_DISABLE_IMAP) || !defined(CURL_DISABLE_SMTP) ||       \
-9.   !defined(CURL_DISABLE_POP3)
-8. #include <curl/curl.h>
-7. #include ""urldata.h""
-6. #include ""vauth/vauth.h""
-5. #include ""curl_md5.h""
-4. #include ""warnless.h""
-3. #incl",Useful
/*Compute binary message length. Check for overflows.*/,"-10.                                         struct bufref *out)
-9. {
-8.   char *plainauth;
-7.   size_t plainlen;
-6.   size_t zlen;
-5.   size_t clen;
-4.   size_t plen;
-3.   zlen = (authzid == NULL ? 0 : strlen(authzid));
-2.   clen = strlen(authcid",Useful
/*Calculate the reply*/,"-7.   if((zlen > SIZE_T_MAX/4) || (clen > SIZE_T_MAX/4) ||
-6.      (plen > (SIZE_T_MAX/2 - 2)))
-5.     return CURLE_OUT_OF_MEMORY;
-4.   plainlen = zlen + clen + plen + 2;
-3.   plainauth = malloc(plainlen + 1);
-2.   if(!plainauth)
-1.     return CURLE",Useful
/*Disable /analyze warning that GetTickCount64 is preferred*/,"-7.     LARGE_INTEGER count;
-6.     QueryPerformanceCounter(&count);
-5.     now.tv_sec = (time_t)(count.QuadPart / Curl_freq.QuadPart);
-4.     now.tv_usec = (int)((count.QuadPart % Curl_freq.QuadPart) * 1000000 /
-3.                         Curl_freq.Q",Useful
"/*** clock_gettime() is granted to be increased monotonically when the
  ** monotonic clock is queried. Time starting point is unspecified, it
  ** could be the system start-up time, the Epoch, or something else,
  ** in any case the time starting point does not change once that the
  ** system has started up.*/","-10. #endif
-9.     now.tv_sec = milliseconds / 1000;
-8.     now.tv_usec = (milliseconds % 1000) * 1000;
-7.   }
-6.   return now;
-5. }
-4. #elif defined(HAVE_CLOCK_GETTIME_MONOTONIC)
-3. struct curltime Curl_now(void)
-2. {
-1.   /*
  ** clock_gettime(",Useful
"/*** clock_gettime() may be defined by Apple's SDK as weak symbol thus
  ** code compiles but fails during run-time if clock_gettime() is
  ** called on unsupported OS version.*/","-10.   ** could be the system start-up time, the Epoch, or something else,
-9.   ** in any case the time starting point does not change once that the
-8.   ** system has started up.
-7.   */
-6. #ifdef HAVE_GETTIMEOFDAY
-5.   struct timeval now;
-4. #endi",Useful
"/*** gettimeofday() is not granted to be increased monotonically, due to
  ** clock drifting and external source time synchronization it can jump
  ** forward or backward in time.*/","-10.   usecs /= timebase.denom;
-9.   usecs /= 1000;
-8.   cnow.tv_sec = usecs / 1000000;
-7.   cnow.tv_usec = (int)(usecs % 1000000);
-6.   return cnow;
-5. }
-4. #elif defined(HAVE_GETTIMEOFDAY)
-3. struct curltime Curl_now(void)
-2. {
-1.   /*
  ** get",Useful
/*** time() returns the value of time in seconds since the Epoch.*/,"-10.   struct curltime ret;
-9.   (void)gettimeofday(&now, NULL);
-8.   ret.tv_sec = now.tv_sec;
-7.   ret.tv_usec = (int)now.tv_usec;
-6.   return ret;
-5. }
-4. #else
-3. struct curltime Curl_now(void)
-2. {
-1.   /*
  ** time() returns the value of tim",Useful
"/** Returns: time difference in number of milliseconds. For too large diffs it
 * returns max value.
 *
 * @unittest: 1323*/","-7.   struct curltime now;
-6.   now.tv_sec = time(NULL);
-5.   now.tv_usec = 0;
-4.   return now;
-3. }
-2. #endif
-1. /*
 * Returns: time difference in number of milliseconds. For too large diffs it
 * returns max value.
 *
 * @unittest: 1323

 /** Retu",Useful
"/** Returns: time difference in number of microseconds. For too large diffs it
 * returns max value.*/","-10. timediff_t Curl_timediff(struct curltime newer, struct curltime older)
-9. {
-8.   timediff_t diff = (timediff_t)newer.tv_sec-older.tv_sec;
-7.   if(diff >= (TIMEDIFF_T_MAX/1000))
-6.     return TIMEDIFF_T_MAX;
-5.   else if(diff <= (TIMEDIFF_T_MIN/1",Useful
/*CURL_DISABLE_GOPHER*/,#NAME?,Useful
/** DICT protocol handler.*/,"-2. static CURLcode dict_do(struct Curl_easy *data, bool *done);
-1. /*
 * DICT protocol handler.

 /** DICT protocol handler.*/

1.  */
2. const struct Curl_handler Curl_handler_dict = {",Useful
/*scheme*/,"-1. const struct Curl_handler Curl_handler_dict = {

 /*scheme*/

111",Useful
/*setup_connection*/,"-2. const struct Curl_handler Curl_handler_dict = {

 /*setup_connection*/

111",Useful
/*do_it*/,"-3. const struct Curl_handler Curl_handler_dict = {

 /*do_it*/

111",Useful
/*done*/,"
static CURLcode dict_do(struct Curl_easy *data, bool *done);



 /*done*/

111",Useful
/*do_more*/,"-5. const struct Curl_handler Curl_handler_dict = {

 /*do_more*/

111",Useful
/*connect_it*/,"-6. const struct Curl_handler Curl_handler_dict = {

 /*connect_it*/

111",Useful
/*connecting*/,"-7. const struct Curl_handler Curl_handler_dict = {

 /*connecting*/

111",Useful
/*doing*/,"-10.  * DICT protocol handler.
-9.  */
-8. const struct Curl_handler Curl_handler_dict = {

 /*doing*/

111",Useful
/*proto_getsock*/,"-10.  */
-9. const struct Curl_handler Curl_handler_dict = {

 /*proto_getsock*/

111",Useful
/*doing_getsock*/,"-10. const struct Curl_handler Curl_handler_dict = {

 /*doing_getsock*/

111",Useful
/*domore_getsock*/,"-10.   ""DICT"",                               /* scheme */
-9.   ZERO_NULL,                            /* setup_connection */
-8.   dict_do,                              /* do_it */
-7.   ZERO_NULL,                            /* done */
-6.   ZERO_NULL,   ",Useful
/*perform_getsock*/,"-10.   ZERO_NULL,                            /* setup_connection */
-9.   dict_do,                              /* do_it */
-8.   ZERO_NULL,                            /* done */
-7.   ZERO_NULL,                            /* do_more */
-6.   ZERO_NULL,  ",Useful
/*disconnect*/,"-10.   dict_do,                              /* do_it */
-9.   ZERO_NULL,                            /* done */
-8.   ZERO_NULL,                            /* do_more */
-7.   ZERO_NULL,                            /* connect_it */
-6.   ZERO_NULL,        ",Useful
/*readwrite*/,"-10.   ZERO_NULL,                            /* done */
-9.   ZERO_NULL,                            /* do_more */
-8.   ZERO_NULL,                            /* connect_it */
-7.   ZERO_NULL,                            /* connecting */
-6.   ZERO_NULL,   ",Useful
/*connection_check*/,"-10.   ZERO_NULL,                            /* do_more */
-9.   ZERO_NULL,                            /* connect_it */
-8.   ZERO_NULL,                            /* connecting */
-7.   ZERO_NULL,                            /* doing */
-6.   ZERO_NULL,  ",Useful
/*defport*/,"-10.   ZERO_NULL,                            /* connecting */
-9.   ZERO_NULL,                            /* doing */
-8.   ZERO_NULL,                            /* proto_getsock */
-7.   ZERO_NULL,                            /* doing_getsock */
-6.   ZER",Useful
/*protocol*/,"-2. static CURLcode dict_do(struct Curl_easy *data, bool *done);
-1. /*
 * DICT protocol handler.

 /*protocol*/

1.  */
2. const struct Curl_handler Curl_handler_dict = {",Useful
/*flags*/,"-10.   ZERO_NULL,                            /* doing_getsock */
-9.   ZERO_NULL,                            /* domore_getsock */
-8.   ZERO_NULL,                            /* perform_getsock */
-7.   ZERO_NULL,                            /* disconnect *",Useful
/*add one for terminating zero*/,"-10. };
-9. static char *unescape_word(const char *inputbuff)
-8. {
-7.   char *newp = NULL;
-6.   char *dictp;
-5.   size_t len;
-4.   CURLcode result = Curl_urldecode(inputbuff, 0, &newp, &len,
-3.                                    REJECT_NADA);
-2.   ",Useful
"/*According to RFC2229 section 2.2, these letters need to be escaped with
       \[letter]*/","-4.   if(dictp) {
-3.     char *ptr;
-2.     char ch;
-1.     int olen = 0;

 /*According to RFC2229 section 2.2, these letters need to be escaped with
       \[letter]*/

1.     for(ptr = newp;
2.         (ch = *ptr) != 0;
3.         ptr++) {
4.       if",Useful
"/*This is not part of the protocol, but required
                          by RFC 2229*/","-9.   return result;
-8. }
-7. static CURLcode dict_do(struct Curl_easy *data, bool *done)
-6. {
-5.   char *word;
-4.   char *eword;
-3.   char *ppath;
-2.   char *database = NULL;
-1.   char *strategy = NULL;

 /*This is not part of the protocol, but re",Useful
/*no upload*/,"-9.                    ""QUIT\r\n"",
-8.                    database,
-7.                    strategy,
-6.                    eword);
-5.     free(eword);
-4.     if(result) {
-3.       failf(data, ""Failed sending DICT request"");
-2.       return result;
-1",Useful
/*CURL_DISABLE_DICT*/,#NAME?,Useful
/*The last #include files should be:*/,"-10.  ***************************************************************************/
-9. #include ""curl_setup.h""
-8. #if !defined(CURL_DISABLE_CRYPTO_AUTH)
-7. #include <curl/curl.h>
-6. #include ""urldata.h""
-5. #include ""vauth/vauth.h""
-4. #include ""curl_h",Useful
/*The last #include files should be:*/,"-10. #include <curl/curl.h>
-9. #include ""vauth/vauth.h""
-8. #include ""vauth/digest.h""
-7. #include ""urldata.h""
-6. #include ""warnless.h""
-5. #include ""curl_multibyte.h""
-4. #include ""sendf.h""
-3. #include ""strdup.h""
-2. #include ""strcase.h""
-1. #include ",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10.   CtxtHandle context;
-9.   PSecPkgInfo SecurityPackage;
-8.   SEC_WINNT_AUTH_IDENTITY identity;
-7.   SEC_WINNT_AUTH_IDENTITY *p_identity;
-6.   SecBuffer chlg_buf;
-5.   SecBuffer resp_buf;
-4.   SecBufferDesc chlg_desc;
-3.   SecBufferDesc resp_de",Useful
/*Ensure we have a valid challenge message*/,"-10.   PSecPkgInfo SecurityPackage;
-9.   SEC_WINNT_AUTH_IDENTITY identity;
-8.   SEC_WINNT_AUTH_IDENTITY *p_identity;
-7.   SecBuffer chlg_buf;
-6.   SecBuffer resp_buf;
-5.   SecBufferDesc chlg_desc;
-4.   SecBufferDesc resp_desc;
-3.   SECURITY_STATUS ",Useful
/*Allocate our response buffer*/,"-1.   s_pSecFn->FreeContextBuffer(SecurityPackage);

 /*Allocate our response buffer*/

1.   output_token = malloc(token_max);
2.   if(!output_token)
3.     return CURLE_OUT_OF_MEMORY;",Useful
/*Use the current Windows user*/,"-3.     p_identity = &identity;
-2.   }
-1.   else

 /*Use the current Windows user*/

1.     p_identity = NULL;",Useful
/*Pass all additional spaces here*/,"-4.   if(!identity->Domain || !identity->DomainLength) {
-3.     for(;;) {
-2.       char value[DIGEST_MAX_VALUE_LENGTH];
-1.       char content[DIGEST_MAX_CONTENT_LENGTH];

 /*Pass all additional spaces here*/

1.       while(*chlg && ISSPACE(*chlg))
2. ",Useful
/*Pass all additional spaces here*/,"-4.   if(!identity->Domain || !identity->DomainLength) {
-3.     for(;;) {
-2.       char value[DIGEST_MAX_VALUE_LENGTH];
-1.       char content[DIGEST_MAX_CONTENT_LENGTH];

 /*Pass all additional spaces here*/

1.       while(*chlg && ISSPACE(*chlg))
2. ",Useful
"/*Allocate the output buffer according to the max token size as indicated
     by the security package*/","-1.   s_pSecFn->FreeContextBuffer(SecurityPackage);

 /*Allocate the output buffer according to the max token size as indicated
     by the security package*/

1.   output_token = malloc(token_max);
2.   if(!output_token) {
3.     return CURLE_OUT_OF_MEMO",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10.   CtxtHandle context;
-9.   PSecPkgInfo SecurityPackage;
-8.   SEC_WINNT_AUTH_IDENTITY identity;
-7.   SEC_WINNT_AUTH_IDENTITY *p_identity;
-6.   SecBuffer chlg_buf;
-5.   SecBuffer resp_buf;
-4.   SecBufferDesc chlg_desc;
-3.   SecBufferDesc resp_de",Useful
/*Use the current Windows user*/,"-3.     p_identity = &identity;
-2.   }
-1.   else

 /*Use the current Windows user*/

1.     p_identity = NULL;",Useful
/*Copy the generated response*/,"-10.     }
-9.     output_token_len = resp_buf.cbBuffer;
-8.     s_pSecFn->FreeCredentialsHandle(&credentials);
-7.     Curl_sspi_free_identity(p_identity);
-6.   }
-5.   resp = malloc(output_token_len + 1);
-4.   if(!resp) {
-3.     free(output_token);
-",Useful
/*Return the response*/,"-10.     s_pSecFn->FreeCredentialsHandle(&credentials);
-9.     Curl_sspi_free_identity(p_identity);
-8.     free(spn);
-7.     free(output_token);
-6.     if(status == SEC_E_INSUFFICIENT_MEMORY)
-5.       return CURLE_OUT_OF_MEMORY;
-4.     infof(data, """,Useful
/*Reset any variables*/,"-1.   Curl_safefree(digest->input_token);

 /*Reset any variables*/

1.   digest->input_token_len = 0;",Useful
/*Supported mechanisms*/,"-3. #include ""curl_printf.h""
-2. #include ""curl_memory.h""
-1. #include ""memdebug.h""

 /*Supported mechanisms*/

1. static const struct {",Useful
/*Name length*/,"-2. static const struct {

 /*Name length*/

111",Useful
/*Flag bit*/,"-3. static const struct {

 /*Flag bit*/

1. } mechtable[] = {
2.   { ""LOGIN"",        5,  SASL_MECH_LOGIN },
3.   { ""PLAIN"",        5,  SASL_MECH_PLAIN },
4.   { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
5.   { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
",Useful
/*Not yet running*/,"-5. void Curl_sasl_init(struct SASL *sasl, struct Curl_easy *data,
-4.                     const struct SASLproto *params)
-3. {
-2.   unsigned long auth = data->set.httpauth;

 /*Not yet running*/

111",Useful
/*No known authentication mechanism yet*/,"-10.  *
-9.  * Initializes the SASL structure.
-8.  */
-7. void Curl_sasl_init(struct SASL *sasl, struct Curl_easy *data,
-6.                     const struct SASLproto *params)
-5. {
-4.   unsigned long auth = data->set.httpauth;

 /*No known authenticat",Useful
/*Respect external option*/,"-10. {
-9.   unsigned long auth = data->set.httpauth;

 /*Respect external option*/

1.   if(auth != CURLAUTH_BASIC) {
2.     sasl->resetprefs = FALSE;
3.     sasl->prefmech = SASL_AUTH_NONE;
4.     if(auth & CURLAUTH_BASIC)
5.       sasl->prefmech |= SAS",Useful
/*LAST*/,"-10.     ""NTLM"",
-9.     ""NTLM_TYPE2MSG"",
-8.     ""GSSAPI"",
-7.     ""GSSAPI_TOKEN"",
-6.     ""GSSAPI_NO_DATA"",
-5.     ""OAUTH2"",
-4.     ""OAUTH2_RESP"",
-3.     ""GSASL"",
-2.     ""CANCEL"",
-1.     ""FINAL"",

 /*LAST*/

1.   };
2.   if(sasl->state != newstate)",Useful
/*Have credentials been provided?*/,"-2. bool Curl_sasl_can_authenticate(struct SASL *sasl, struct Curl_easy *data)
-1. {

 /*Have credentials been provided?*/

1.   if(data->state.aptr.user)
2.     return TRUE;",Useful
/*Latch for future use*/,"-10.   const long int port = SSL_HOST_PORT();
-9. #if defined(USE_KERBEROS5) || defined(USE_NTLM)
-8.   const char *service = data->set.str[STRING_SERVICE_NAME] ?
-7.     data->set.str[STRING_SERVICE_NAME] :
-6.     sasl->params->service;
-5. #endif
-4.  ",Useful
/*No mechanism used yet*/,"-10. #if defined(USE_KERBEROS5) || defined(USE_NTLM)
-9.   const char *service = data->set.str[STRING_SERVICE_NAME] ?
-8.     data->set.str[STRING_SERVICE_NAME] :
-7.     sasl->params->service;
-6. #endif
-5.   const char *oauth_bearer = data->set.str[STR",Useful
/*Remove the offending mechanism from the supported list*/,"-9.       Curl_bufref_set(&resp, ""\x01"", 1, NULL);
-8.       break;
-7.     }
-6.     else {
-5.       *progress = SASL_DONE;
-4.       state(sasl, data, SASL_STOP);
-3.       return CURLE_LOGIN_DENIED;
-2.     }
-1.   case SASL_CANCEL:

 /*Remove the off",Useful
/*Stop on error*/,"-9.     result = sasl->params->cancelauth(data, sasl->curmech);
-8.     newstate = SASL_CANCEL;
-7.     break;
-6.   case CURLE_OK:
-5.     result = build_message(sasl, &resp);
-4.     if(!result)
-3.       result = sasl->params->contauth(data, sasl->curm",Useful
/*scheme*/,"-10. static CURLcode file_do(struct Curl_easy *data, bool *done);
-9. static CURLcode file_done(struct Curl_easy *data,
-8.                           CURLcode status, bool premature);
-7. static CURLcode file_connect(struct Curl_easy *data, bool *done);
-",Useful
/*do_more*/,"-5. const struct Curl_handler Curl_handler_file = {

 /*do_more*/

111",Useful
/*connecting*/,"-7. const struct Curl_handler Curl_handler_file = {

 /*connecting*/

111",Useful
/*doing*/,"-10.  * FILE scheme handler.
-9.  */
-8. const struct Curl_handler Curl_handler_file = {

 /*doing*/

111",Useful
/*proto_getsock*/,"-10.  */
-9. const struct Curl_handler Curl_handler_file = {

 /*proto_getsock*/

111",Useful
/*doing_getsock*/,"-10. const struct Curl_handler Curl_handler_file = {

 /*doing_getsock*/

111",Useful
/*domore_getsock*/,"-10.   ""FILE"",                               /* scheme */
-9.   file_setup_connection,                /* setup_connection */
-8.   file_do,                              /* do_it */
-7.   file_done,                            /* done */
-6.   ZERO_NULL,   ",Useful
/*perform_getsock*/,"-10.   file_setup_connection,                /* setup_connection */
-9.   file_do,                              /* do_it */
-8.   file_done,                            /* done */
-7.   ZERO_NULL,                            /* do_more */
-6.   file_connect",Useful
/*readwrite*/,"-10.   file_done,                            /* done */
-9.   ZERO_NULL,                            /* do_more */
-8.   file_connect,                         /* connect_it */
-7.   ZERO_NULL,                            /* connecting */
-6.   ZERO_NULL,   ",Useful
/*connection_check*/,"-10.   ZERO_NULL,                            /* do_more */
-9.   file_connect,                         /* connect_it */
-8.   ZERO_NULL,                            /* connecting */
-7.   ZERO_NULL,                            /* doing */
-6.   ZERO_NULL,  ",Useful
/*defport*/,"-10.   ZERO_NULL,                            /* connecting */
-9.   ZERO_NULL,                            /* doing */
-8.   ZERO_NULL,                            /* proto_getsock */
-7.   ZERO_NULL,                            /* doing_getsock */
-6.   ZER",Useful
/*flags*/,"-10.   ZERO_NULL,                            /* doing_getsock */
-9.   ZERO_NULL,                            /* domore_getsock */
-8.   ZERO_NULL,                            /* perform_getsock */
-7.   file_disconnect,                      /* disconnect *",Useful
/*allocate the FILE specific struct*/,"-5. };
-4. static CURLcode file_setup_connection(struct Curl_easy *data,
-3.                                       struct connectdata *conn)
-2. {
-1.   (void)conn;

 /*allocate the FILE specific struct*/

1.   data->req.p.file = calloc(1, sizeof(struct F",Useful
"/*If the first character is a slash, and there's
     something that looks like a drive at the beginning of
     the path, skip the slash.  If we remove the initial
     slash in all cases, paths without drive letters end up
     relative to the current directory which isn't how
     browsers work.

     Some browsers accept | instead of : as the drive letter
     separator, so we do too.

     On other platforms, we need the slash to indicate an
     absolute pathname.  On Windows, absolute paths start
     with a drive letter.*/","-10. #ifdef DOS_FILESYSTEM
-9.   size_t i;
-8.   char *actual_path;
-7. #endif
-6.   size_t real_path_len;
-5.   CURLcode result = Curl_urldecode(data->state.up.path, 0, &real_path,
-4.                                    &real_path_len, REJECT_ZERO);
-3. ",Useful
"/*change path separators from '/' to '\\' for DOS, Windows and OS/2*/","-10.      with a drive letter.
-9.   */
-8.   actual_path = real_path;
-7.   if((actual_path[0] == '/') &&
-6.       actual_path[1] &&
-5.      (actual_path[2] == ':' || actual_path[2] == '|')) {
-4.     actual_path[2] = ':';
-3.     actual_path++;
-2.   ",Useful
/*binary zero*/,"-3.   for(i = 0; i < real_path_len; ++i)
-2.     if(actual_path[i] == '/')
-1.       actual_path[i] = '\\';

 /*binary zero*/

1.       Curl_safefree(real_path);
2.       return CURLE_URL_MALFORMAT;
3.     }
4.   fd = open_readonly(actual_path, O_RDONLY|O",Useful
/*binary zeroes indicate foul play*/,"-7.       Curl_safefree(real_path);
-6.       return CURLE_URL_MALFORMAT;
-5.     }
-4.   fd = open_readonly(actual_path, O_RDONLY|O_BINARY);
-3.   file->path = actual_path;
-2. #else
-1.   if(memchr(real_path, 0, real_path_len)) {

 /*binary zeroes indic",Useful
/*not used*/,"-10.     file_done(data, CURLE_FILE_COULDNT_READ_FILE, FALSE);
-9.     return CURLE_FILE_COULDNT_READ_FILE;
-8.   }
-7.   *done = TRUE;
-6.   return CURLE_OK;
-5. }
-4. static CURLcode file_done(struct Curl_easy *data,
-3.                           CURLco",Useful
/*not used*/,"-10.     file_done(data, CURLE_FILE_COULDNT_READ_FILE, FALSE);
-9.     return CURLE_FILE_COULDNT_READ_FILE;
-8.   }
-7.   *done = TRUE;
-6.   return CURLE_OK;
-5. }
-4. static CURLcode file_done(struct Curl_easy *data,
-3.                           CURLco",Useful
/*not used*/,"-10.     file_done(data, CURLE_FILE_COULDNT_READ_FILE, FALSE);
-9.     return CURLE_FILE_COULDNT_READ_FILE;
-8.   }
-7.   *done = TRUE;
-6.   return CURLE_OK;
-5. }
-4. static CURLcode file_done(struct Curl_easy *data,
-3.                           CURLco",Useful
/*fix: better error code*/,"-2.   data->req.upload_fromhere = buf;
-1.   if(!dir)

 /*fix: better error code*/

1.   if(!dir[1])",Useful
/*fix: better error code*/,"-2.   data->req.upload_fromhere = buf;
-1.   if(!dir)

 /*fix: better error code*/

1.   if(!dir[1])",Useful
"/*This implementation ignores the host name in conformance with
     RFC 1738. Only local files (reachable via the standard file system)
     are supported. This means that files on remotely mounted directories
     (via NFS, Samba, NT sharing) can be accessed through a file:// URL*/","-2. static CURLcode file_do(struct Curl_easy *data, bool *done)
-1. {
  /* This implementation ignores the host name in conformance with
     RFC 1738. Only local files (reachable via the standard file system)
     are supported. This means that files on ",Useful
"/*struct_stat instead of struct stat just to allow the
                          Windows version to have a different struct without
                          having to redefine the simple word 'stat'*/","-1.   CURLcode result = CURLE_OK;

 /*struct_stat instead of struct stat just to allow the
                          Windows version to have a different struct without
                          having to redefine the simple word 'stat'*/

1.   curl_off_t ",Useful
/*unconditionally*/,"-7.   curl_off_t expected_size = -1;
-6.   bool size_known;
-5.   bool fstated = FALSE;
-4.   char *buf = data->state.buffer;
-3.   curl_off_t bytecount = 0;
-2.   int fd;
-1.   struct FILEPROTO *file;

 /*unconditionally*/

1.   Curl_pgrsStartNow(data);
",Useful
/*VMS: This only works reliable for STREAMLF files*/,"-1.   fd = file->fd;

 /*VMS: This only works reliable for STREAMLF files*/

1.   if(-1 != fstat(fd, &statbuf)) {
2.     if(!S_ISDIR(statbuf.st_mode))
3.       expected_size = statbuf.st_size;",Useful
/*and store the modification time*/,"-3.   if(-1 != fstat(fd, &statbuf)) {
-2.     if(!S_ISDIR(statbuf.st_mode))
-1.       expected_size = statbuf.st_size;

 /*and store the modification time*/

1.     data->info.filetime = statbuf.st_mtime;
2.     fstated = TRUE;
3.   }
4.   if(fstated && !",Useful
"/*format: ""Tue, 15 Nov 1994 12:45:26 GMT""*/","-10.         return result;
-9.       result = Curl_client_write(data, CLIENTWRITE_HEADER,
-8.                                  accept_ranges, strlen(accept_ranges));
-7.       if(result != CURLE_OK)
-6.         return result;
-5.     }
-4.     filetime =",Useful
/*A high water mark has been specified so we obey...*/,"-3.       return CURLE_BAD_DOWNLOAD_RESUME;
-2.     }
-1.   }

 /*A high water mark has been specified so we obey...*/

1.   if(data->req.maxdownload > 0)
2.     expected_size = data->req.maxdownload;
3.   if(!fstated || (expected_size <= 0))
4.     size_",Useful
/*protocol-specific functions set up to be called by the main engine*/,"-6. #include ""curl_printf.h""
-5. #include ""curl_memory.h""
-4. #include ""memdebug.h""
-3. #define RTP_PKT_CHANNEL(p)   ((int)((unsigned char)((p)[1])))
-2. #define RTP_PKT_LENGTH(p)  ((((int)((unsigned char)((p)[2]))) << 8) | \
-1.                          ",Useful
/*timeout*/,"-10.  *
-9.  * Instead, if it is readable, run Curl_connalive() to peek at the socket
-8.  * and distinguish between closed and data.
-7.  */
-6. static bool rtsp_connisdead(struct connectdata *check)
-5. {
-4.   int sval;
-3.   bool ret_val = TRUE;
-2.  ",Useful
/*socket is in an error state*/,"-3.     ret_val = FALSE;
-2.   }
-1.   else if(sval & CURL_CSELECT_ERR) {

 /*socket is in an error state*/

1.     ret_val = TRUE;
2.   }
3.   else if(sval & CURL_CSELECT_IN) {",Useful
/*readable with no error. could still be closed*/,"-3.     ret_val = TRUE;
-2.   }
-1.   else if(sval & CURL_CSELECT_IN) {

 /*readable with no error. could still be closed*/

1.     ret_val = !Curl_connalive(check);
2.   }
3.   return ret_val;
4. }",Useful
"/*The User-Agent string might have been allocated in url.c already, because
     it might have been used in the proxy connect, but if we have got a header
     with the user-agent string specified, we erase the previously made string
     here.*/","-10.     if(!Curl_checkheaders(data, STRCONST(""Accept-Encoding"")) &&
-9.        data->set.str[STRING_ENCODING]) {
-8.       Curl_safefree(data->state.aptr.accept_encoding);
-7.       data->state.aptr.accept_encoding =
-6.         aprintf(""Accept-Encoding:",Useful
/*Request Stream-URI RTSP/1.0*/,"-3.   Curl_dyn_init(&req_buffer, DYN_RTSP_REQ_HEADER);
-2.   result =
-1.     Curl_dyn_addf(&req_buffer,

 /*Request Stream-URI RTSP/1.0*/

111",Useful
/** Shared HTTP-like options*/,"-6.   if(p_session_id) {
-5.     result = Curl_dyn_addf(&req_buffer, ""Session: %s\r\n"", p_session_id);
-4.     if(result)
-3.       return result;
-2.   }
-1.   /*
   * Shared HTTP-like options

 /** Shared HTTP-like options*/

1.    */
2.   result = Curl",Useful
/*Just parse the request buffer directly*/,"-10.       rtspc->rtp_bufsize = 0;
-9.       return CURLE_OUT_OF_MEMORY;
-8.     }
-7.     rtspc->rtp_buf = newptr;
-6.     memcpy(rtspc->rtp_buf + rtspc->rtp_bufsize, k->str, *nread);
-5.     rtspc->rtp_bufsize += *nread;
-4.     rtp = rtspc->rtp_buf;
-3",Useful
/*Parse the header*/,"-7.     rtp = k->str;
-6.     rtp_dataleft = *nread;
-5.   }
-4.   while((rtp_dataleft > 0) &&
-3.         (rtp[0] == '$')) {
-2.     if(rtp_dataleft > 4) {
-1.       int rtp_length;

 /*Parse the header*/

111",Useful
/*The channel identifier immediately follows and is 1 byte*/,"-8.     rtp = k->str;
-7.     rtp_dataleft = *nread;
-6.   }
-5.   while((rtp_dataleft > 0) &&
-4.         (rtp[0] == '$')) {
-3.     if(rtp_dataleft > 4) {
-2.       int rtp_length;

 /*The channel identifier immediately follows and is 1 byte*/

1.      ",Useful
/*Move forward in the buffer*/,"-10.              rtspc->rtp_channel, rtp_length));
-9.       result = rtp_client_write(data, &rtp[0], rtp_length + 4);
-8.       if(result) {
-7.         failf(data, ""Got an error writing an RTP packet"");
-6.         *readmore = FALSE;
-5.         Curl_s",Useful
"/*As far as the transfer is concerned, this data is consumed*/","-10.     if(!scratch) {
-9.       Curl_safefree(rtspc->rtp_buf);
-8.       rtspc->rtp_buf = NULL;
-7.       rtspc->rtp_bufsize = 0;
-6.       return CURLE_OUT_OF_MEMORY;
-5.     }
-4.     memcpy(scratch, rtp, rtp_dataleft);
-3.     Curl_safefree(rtspc->rt",Useful
/*sanity check*/,"-2.   if(rtp_dataleft > 0)
-1.     DEBUGASSERT(k->str[0] == rtp[0]);

 /*sanity check*/

1.   *nread = rtp_dataleft;",Useful
"/*If we get here, we have finished with the leftover/merge buffer*/","-1.   *nread = rtp_dataleft;

 /*If we get here, we have finished with the leftover/merge buffer*/

1.   Curl_safefree(rtspc->rtp_buf);
2.   rtspc->rtp_buf = NULL;
3.   rtspc->rtp_bufsize = 0;
4.   return CURLE_OK;
5. }
6. static
7. CURLcode rtp_client_wr",Useful
/*update the handle*/,"-4.     int nc = sscanf(&header[4], "": %ld"", &CSeq);
-3.     if(nc == 1) {
-2.       struct RTSP *rtsp = data->req.p.rtsp;

 /*update the handle*/

1.     }
2.     else {
3.       failf(data, ""Unable to read the CSeq header: [%s]"", header);
4.       retur",Useful
/*Find the first non-space letter*/,"-10.     }
-9.     else {
-8.       failf(data, ""Unable to read the CSeq header: [%s]"", header);
-7.       return CURLE_RTSP_CSEQ_ERROR;
-6.     }
-5.   }
-4.   else if(checkprefix(""Session:"", header)) {
-3.     char *start;
-2.     char *end;
-1.     siz",Useful
/*CURL_DISABLE_RTSP*/,#NAME?,Useful
/*The last #include file should be:*/,"-10. #include <curl/curl.h>
-9. #include ""urldata.h""
-8. #include ""fileinfo.h""
-7. #include ""llist.h""
-6. #include ""strtoofft.h""
-5. #include ""ftp.h""
-4. #include ""ftplistparser.h""
-3. #include ""curl_fnmatch.h""
-2. #include ""curl_memory.h""
-1. #include ""m",Useful
/*allocs buffer which will contain one line of LIST command response*/,"-1. #include ""memdebug.h""

 /*allocs buffer which will contain one line of LIST command response*/

1. #define FTP_BUFFER_ALLOCSIZE 160
2. typedef enum {
3.   PL_UNIX_TOTALSIZE = 0,
4.   PL_UNIX_FILETYPE,
5.   PL_UNIX_PERMISSION,
6.   PL_UNIX_HLINKS,
7.  ",Useful
/*error in previous call*/,"-10. {
-9.   size_t bufflen = size*nmemb;
-8.   struct Curl_easy *data = (struct Curl_easy *)connptr;
-7.   struct ftp_wc *ftpwc = data->wildcard.protdata;
-6.   struct ftp_parselist_data *parser = ftpwc->parser;
-5.   struct fileinfo *infop;
-4.   struct",Useful
"/*scenario:
     * 1. call => OK..
     * 2. call => OUT_OF_MEMORY (or other error)
     * 3. (last) call => is skipped RIGHT HERE and the error is hadled later
     *    in wc_statemach()*/","/* scenario:
     * 1. call => OK..
     * 2. call => OUT_OF_MEMORY (or other error)
     * 3. (last) call => is skipped RIGHT HERE and the error is hadled later
     *    in wc_statemach()

 /*scenario:
     * 1. call => OK..
     * 2. call => OUT_OF_MEMORY (or other error)
     * 3. (last) call => is skipped RIGHT HERE and the error is hadled later
     *    in wc_statemach()*/

1.      */
2.     goto fail;
3.   }
4.   if(parser->os_type == OS_TYPE_UNKNOWN && bufflen > 0) {",Useful
/*considering info about FILE response format*/,"-3.     goto fail;
-2.   }
-1.   if(parser->os_type == OS_TYPE_UNKNOWN && bufflen > 0) {

 /*considering info about FILE response format*/

1.     parser->os_type = (buffer[0] >= '0' && buffer[0] <= '9') ?
2.                        OS_TYPE_WIN_NT : OS_TYP",Useful
"/*if it is important, extend buffer space for file data*/","-10.         goto fail;
-9.       }
-8.       parser->file_data->info.b_size = FTP_BUFFER_ALLOCSIZE;
-7.       parser->item_offset = 0;
-6.       parser->item_length = 0;
-5.     }
-4.     infop = parser->file_data;
-3.     finfo = &infop->info;
-2.     f",Useful
/*start FSM again not considering size of directory*/,"-10.       switch(parser->state.UNIX.main) {
-9.       case PL_UNIX_TOTALSIZE:
-8.         switch(parser->state.UNIX.sub.total_dirsize) {
-7.         case PL_UNIX_TOTALSIZE_INIT:
-6.           if(c == 't') {
-5.             parser->state.UNIX.sub.total_di",Useful
/*only simple control*/,"-10.           break;
-9.         }
-8.         break;
-7.       }
-6.       break;
-5.     case OS_TYPE_WIN_NT:
-4.       switch(parser->state.NT.main) {
-3.       case PL_WINNT_DATE:
-2.         parser->item_length++;
-1.         if(parser->item_length ",Useful
/*Clean up any allocated memory.*/,"-10.       }
-9.       break;
-8.     default:
-7.       retsize = bufflen + 1;
-6.       goto fail;
-5.     }
-4.     i++;
-3.   }
-2.   return retsize;
-1. fail:

 /*Clean up any allocated memory.*/

1.   if(parser->file_data) {
2.     Curl_fileinfo_cle",Useful
/*CURL_DISABLE_FTP*/,"-10.  * 2) Unix version 2
-9.  * drwxr-xr-x 1 user01 ftp  512 Jan 29 1997  prog
-8.  * 3) Unix version 3
-7.  * drwxr-xr-x 1      1   1  512 Jan 29 23:32 prog
-6.  * 4) Unix symlink
-5.  * lrwxr-xr-x 1 user01 ftp  512 Jan 29 23:32 prog -> prog2000
-4.  * ",Useful
/*The last #include files should be:*/,"-10.  ***************************************************************************/
-9. #include ""curl_setup.h""
-8. #if defined(USE_WINDOWS_SSPI) && defined(USE_NTLM)
-7. #include <curl/curl.h>
-6. #include ""vauth/vauth.h""
-5. #include ""urldata.h""
-4. #inc",Useful
"/** Curl_auth_is_ntlm_supported()
 *
 * This is used to evaluate if NTLM is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if NTLM is supported by Windows SSPI.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_is_ntlm_supported()
 *
 * This is used to evaluate if NTLM is supported.
 *
 * Parameters: None
 *
 * Returns TRUE if NTLM is supported by Windows SSPI.

 /** Curl_auth_is_ntlm_sup",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10.                                              const char *service,
-9.                                              const char *host,
-8.                                              struct ntlmdata *ntlm,
-7.                                          ",Useful
/*Allocate our output buffer*/,"-1.   s_pSecFn->FreeContextBuffer(SecurityPackage);

 /*Allocate our output buffer*/

1.   ntlm->output_token = malloc(ntlm->token_max);
2.   if(!ntlm->output_token)
3.     return CURLE_OUT_OF_MEMORY;
4.   if(userp && *userp) {
5.     CURLcode result;",Useful
/*Use the current Windows user*/,"-3.     ntlm->p_identity = &ntlm->identity;
-2.   }
-1.   else

 /*Use the current Windows user*/

1.     ntlm->p_identity = NULL;",Useful
/*Generate our type-1 message*/,"-6.   type_1_desc.ulVersion = SECBUFFER_VERSION;
-5.   type_1_desc.cBuffers  = 1;
-4.   type_1_desc.pBuffers  = &type_1_buf;
-3.   type_1_buf.BufferType = SECBUFFER_TOKEN;
-2.   type_1_buf.pvBuffer   = ntlm->output_token;
-1.   type_1_buf.cbBuffer   = cur",Useful
/*Ensure we have a valid type-2 message*/,"-10.  *
-9.  * Returns CURLE_OK on success.
-8.  */
-7. CURLcode Curl_auth_decode_ntlm_type2_message(struct Curl_easy *data,
-6.                                              const struct bufref *type2,
-5.                                              stru",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10.                                              const char *service,
-9.                                              const char *host,
-8.                                              struct ntlmdata *ntlm,
-7.                                          ",Useful
"/*ssl context comes from schannel.
  * When extended protection is used in IIS server,
  * we have to pass a second SecBuffer to the SecBufferDesc
  * otherwise IIS will not pass the authentication (401 response).
  * Minimum supported version is Windows 7.
  * https://docs.microsoft.com/en-us/security-updates
  * /SecurityAdvisories/2009/973811*/","* /SecurityAdvisories/2009/973811

 /*ssl context comes from schannel.
  * When extended protection is used in IIS server,
  * we have to pass a second SecBuffer to the SecBufferDesc
  * otherwise IIS will not pass the authentication (401 response).
  * Minimum supported version is Windows 7.
  * https://docs.microsoft.com/en-us/security-updates
  * /SecurityAdvisories/2009/973811*/

1.   */
2.   if(ntlm->sslContext) {
3.     SEC_CHANNEL_BINDINGS channelBindings;
4.     SecPkgContext_Bindings pkgBindings;
5.     pkgBindings.Bindings = &channelBindings;
6.     status = s_pSecFn->QueryContextAttributes(
7.       ntlm->sslContext,
8.       SECPKG_ATTR_ENDPOINT_BINDINGS,
9.       &pkgBindings
10.     );",Useful
/*Reset any variables*/,"-2.   Curl_safefree(ntlm->input_token);
-1.   Curl_safefree(ntlm->output_token);

 /*Reset any variables*/

1.   ntlm->token_max = 0;
2.   Curl_safefree(ntlm->spn);
3. }",Useful
/*The last 3 #include files should be in this order*/,"-10. #include ""sendf.h""
-9. #include ""hostip.h""
-8. #include ""hash.h""
-7. #include ""share.h""
-6. #include ""url.h""
-5. #include ""multiif.h""
-4. #include ""inet_ntop.h""
-3. #include ""curl_threads.h""
-2. #include ""connect.h""
-1. #include ""socketpair.h""

 /*Th",Useful
/*Memory allocation failed*/,"-5.   tsd->hostname = strdup(hostname);
-4.   if(!tsd->hostname)
-3.     goto err_exit;
-2.   return 1;
-1.  err_exit:

 /*Memory allocation failed*/

1.   destroy_thread_sync_data(tsd);
2.   return 0;
3. }
4. static int getaddrinfo_complete(struct Curl_e",Useful
"/*too late, gotta clean up the mess*/","-10.   if(rc) {
-9.     tsd->sock_error = SOCKERRNO?SOCKERRNO:rc;
-8.     if(tsd->sock_error == 0)
-7.       tsd->sock_error = RESOLVER_ENOMEM;
-6.   }
-5.   else {
-4.     Curl_addrinfo_set_port(tsd->res, tsd->port);
-3.   }
-2.   Curl_mutex_acquire(tsd-",Useful
"/*DNS has been resolved, signal client task*/","-7.     Curl_mutex_release(tsd->mtx);
-6.     destroy_thread_sync_data(tsd);
-5.     free(td);
-4.   }
-3.   else {
-2. #ifndef CURL_DISABLE_SOCKETPAIR
-1.     if(tsd->sock_pair[1] != CURL_SOCKET_BAD) {

 /*DNS has been resolved, signal client task*/

1. ",Useful
/*HAVE_GETADDRINFO*/,"-10. #  endif
-9. #elif defined(USE_THREADS_WIN32)
-8. #  ifdef HAVE_PROCESS_H
-7. #    include <process.h>
-6. #  endif
-5. #endif
-4. #if (defined(NETWARE) && defined(__NOVELL_LIBC__))
-3. #undef in_addr_t
-2. #define in_addr_t unsigned long
-1. #endif
",Useful
"/*too late, gotta clean up the mess*/","-10.   if(rc) {
-9.     tsd->sock_error = SOCKERRNO?SOCKERRNO:rc;
-8.     if(tsd->sock_error == 0)
-7.       tsd->sock_error = RESOLVER_ENOMEM;
-6.   }
-5.   else {
-4.     Curl_addrinfo_set_port(tsd->res, tsd->port);
-3.   }
-2.   Curl_mutex_acquire(tsd-",Useful
/*HAVE_GETADDRINFO*/,"-10. #  endif
-9. #elif defined(USE_THREADS_WIN32)
-8. #  ifdef HAVE_PROCESS_H
-7. #    include <process.h>
-6. #  endif
-5. #endif
-4. #if (defined(NETWARE) && defined(__NOVELL_LIBC__))
-3. #undef in_addr_t
-2. #define in_addr_t unsigned long
-1. #endif
",Useful
"/** ensure CURLMOPT_SOCKETFUNCTION fires CURL_POLL_REMOVE
     * before the FD is invalidated to avoid EBADF on EPOLL_CTL_DEL*/","-10.       Curl_thread_destroy(td->thread_hnd);
-9.     }
-8.     else {
-7.       if(td->thread_hnd != curl_thread_t_null)
-6.         Curl_thread_join(&td->thread_hnd);
-5.       destroy_thread_sync_data(&td->tsd);
-4.       free(async->tdata);
-3.     ",Useful
/*The thread will set this to 1 when complete.*/,"-10.   td->thread_hnd = curl_thread_t_null;
-9.   if(!init_thread_sync_data(td, hostname, port, hints)) {
-8.     asp->tdata = NULL;
-7.     free(td);
-6.     goto errno_exit;
-5.   }
-4.   free(asp->hostname);
-3.   asp->hostname = strdup(hostname);
-2. ",Useful
/*return read fd to client for polling the DNS resolution status*/,"-10.   timediff_t milli;
-9.   timediff_t ms;
-8.   struct resdata *reslv = (struct resdata *)data->state.async.resolver;
-7. #ifndef CURL_DISABLE_SOCKETPAIR
-6.   struct thread_data *td = data->state.async.tdata;
-5. #else
-4.   (void)socks;
-3. #endif
-",Useful
/*default to synchronous response*/,"-6. struct Curl_addrinfo *Curl_resolver_getaddrinfo(struct Curl_easy *data,
-5.                                                 const char *hostname,
-4.                                                 int port,
-3.                                        ",Useful
/*expect asynchronous response*/,"-1.   if(init_resolve_thread(data, hostname, port, NULL)) {

 /*expect asynchronous response*/

1.     return NULL;
2.   }
3.   failf(data, ""getaddrinfo() thread failed"");
4.   return NULL;
5. }",Useful
/*!HAVE_GETADDRINFO*/,"-5.     return NULL;
-4.   }
-3.   failf(data, ""getaddrinfo() thread failed"");
-2.   return NULL;
-1. }

 /*!HAVE_GETADDRINFO*/

111",Useful
/*default to synchronous response*/,"-6. struct Curl_addrinfo *Curl_resolver_getaddrinfo(struct Curl_easy *data,
-5.                                                 const char *hostname,
-4.                                                 int port,
-3.                                        ",Useful
/*CURLRES_IPV6*/,"#ifdef CURLRES_IPV6

 /*CURLRES_IPV6*/

1.   if(Curl_ipv6works(data))",Useful
/*expect asynchronous response*/,"-1.   if(init_resolve_thread(data, hostname, port, NULL)) {

 /*expect asynchronous response*/

1.     return NULL;
2.   }
3.   failf(data, ""getaddrinfo() thread failed"");
4.   return NULL;
5. }",Useful
/*!HAVE_GETADDRINFO*/,"-5.     return NULL;
-4.   }
-3.   failf(data, ""getaddrinfo() thread failed"");
-2.   return NULL;
-1. }

 /*!HAVE_GETADDRINFO*/

111",Useful
/*CURLRES_THREADED*/,"
#ifdef CURLRES_THREADED



 /*CURLRES_THREADED*/

1. #ifdef HAVE_NETINET_IN_H
2. #include <netinet/in.h>
3. #endif
4. #ifdef HAVE_NETDB_H
5. #include <netdb.h>
6. #endif
7. #ifdef HAVE_ARPA_INET_H
8. #include <arpa/inet.h>
9. #endif
10. #ifdef __VMS",Useful
/*The last #include file should be:*/,"-10.  * KIND, either express or implied.
-9.  *
-8.  ***************************************************************************/
-7. #include ""curl_setup.h""
-6. #include <curl/curl.h>
-5. #ifdef WIN32
-4. #include <wchar.h>
-3. #endif
-2. #include ""strdu",Useful
/*fail*/,"-10. }
-9. #endif
-8. #ifdef WIN32
-7. /***************************************************************************
-6.  *
-5.  * Curl_wcsdup(source)
-4.  *
-3.  * Copies the 'source' wchar string to a newly allocated buffer (that is
-2.  * returned).
-1.",Useful
"/*If the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

      A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    If the algorithm is ""MD5-sess"" then:

      A1 = H(unq(username-value) "":"" unq(realm-value) "":"" passwd) "":""
           unq(nonce-value) "":"" unq(cnonce-value)*/","-10.   }
-9.   if(digest->userhash) {
-8.     hashthis = aprintf(""%s:%s"", userp, digest->realm);
-7.     if(!hashthis)
-6.       return CURLE_OUT_OF_MEMORY;
-5.     hash(hashbuf, (unsigned char *) hashthis, strlen(hashthis));
-4.     free(hashthis);
-3.  ",Useful
"/*If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2 = Method "":"" digest-uri-value

    If the ""qop"" value is ""auth-int"", then A2 is:

      A2 = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)*/","-8.     tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
-7.     if(!tmp)
-6.       return CURLE_OUT_OF_MEMORY;
-5.     hash(hashbuf, (unsigned char *) tmp, strlen(tmp));
-4.     free(tmp);
-3.     convert_to_ascii(hashbuf, ha1);
-2.   }
-1.",Useful
/*We don't support auth-int for PUT or POST*/,"-10.       A2 = Method "":"" digest-uri-value
-9.     If the ""qop"" value is ""auth-int"", then A2 is:
-8.       A2 = Method "":"" digest-uri-value "":"" H(entity-body)
-7.     (The ""Method"" value is the HTTP request method as specified in section
-6.     5.1.1 of",Useful
"/*For test case 64 (snooped from a Mozilla 1.3a request)

     Authorization: Digest username=""testuser"", realm=""testrealm"", \
     nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

     Digest parameters are all quoted strings.  Username which is provided by
     the user will need double quotes and backslashes within it escaped.  For
     the other fields, this shouldn't be an issue.  realm, nonce, and opaque
     are copied as is from the server, escapes and all.  cnonce is generated
     with web-safe characters.  uri is already percent encoded.  nc is 8 hex
     characters.  algorithm and qop with standard values only contain web-safe
     characters.*/","-10.                        digest->cnonce, digest->qop, ha2);
-9.   }
-8.   else {
-7.     hashthis = aprintf(""%s:%s:%s"", ha1, digest->nonce, ha2);
-6.   }
-5.   if(!hashthis)
-4.     return CURLE_OUT_OF_MEMORY;
-3.   hash(hashbuf, (unsigned char *) hash",Useful
/*Add the optional fields*/,"-10.                        ""response=\""%s\"""",
-9.                        userp_quoted,
-8.                        digest->realm,
-7.                        digest->nonce,
-6.                        uripath,
-5.                        request_digest);
-4.",Useful
/*Return the output*/,"-6.     tmp = aprintf(""%s, userhash=true"", response);
-5.     free(response);
-4.     if(!tmp)
-3.       return CURLE_OUT_OF_MEMORY;
-2.     response = tmp;
-1.   }

 /*Return the output*/

1.   *outptr = response;
2.   *outlen = strlen(response);
3.   re",Useful
/*default algorithm*/,"-10.  */
-9. void Curl_auth_digest_cleanup(struct digestdata *digest)
-8. {
-7.   Curl_safefree(digest->nonce);
-6.   Curl_safefree(digest->cnonce);
-5.   Curl_safefree(digest->realm);
-4.   Curl_safefree(digest->opaque);
-3.   Curl_safefree(digest->qop);",Useful
/*!USE_WINDOWS_SSPI*/,"-2.   digest->userhash = FALSE;
-1. }

 /*!USE_WINDOWS_SSPI*/

111",Useful
/*CURL_DISABLE_CRYPTO_AUTH*/,"-10.  * furnished to do so, under the terms of the COPYING file.
-9.  *
-8.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-7.  * KIND, either express or implied.
-6.  *
-5.  * RFC2831 DIGEST-MD5 authentication
-4.  * RFC7616",Useful
/*when SFTP is used*/,"-1. CURLcode Curl_getworkingpath(struct Curl_easy *data,

 /*when SFTP is used*/

111",Useful
"/*returns the  allocated
                                             real path to work with*/","-2. CURLcode Curl_getworkingpath(struct Curl_easy *data,

 /*returns the  allocated
                                             real path to work with*/

1. {
2.   char *real_path = NULL;
3.   char *working_path;
4.   size_t working_path_len;
5.   CURLco",Useful
"/*It is referenced to the home directory, so strip the leading '/~/'*/","-7.   if(data->conn->handler->protocol & CURLPROTO_SCP) {
-6.     real_path = malloc(working_path_len + 1);
-5.     if(!real_path) {
-4.       free(working_path);
-3.       return CURLE_OUT_OF_MEMORY;
-2.     }
-1.     if((working_path_len > 3) && (!memcm",Useful
/*store the pointer for the caller to receive*/,"-10.     else {
-9.       real_path = malloc(working_path_len + 1);
-8.       if(!real_path) {
-7.         free(working_path);
-6.         return CURLE_OUT_OF_MEMORY;
-5.       }
-4.       memcpy(real_path, working_path, 1 + working_path_len);
-3.     }
-",Useful
"/*The get_pathname() function is being borrowed from OpenSSH sftp.c
   version 4.6p1.*/","-3.   *path = real_path;
-2.   return CURLE_OK;
-1. }

 /*The get_pathname() function is being borrowed from OpenSSH sftp.c
   version 4.6p1.*/

1. /*
2.  * Copyright (c) 2001-2004 Damien Miller <djm@openbsd.org>
3.  *
4.  * Permission to use, copy, modif",Useful
/*Allocate enough space for home directory and filename + separator*/,"-1.   cp += strspn(cp, WHITESPACE);

 /*Allocate enough space for home directory and filename + separator*/

1.   fullPathLength = strlen(cp) + strlen(homedir) + 2;
2.   *path = malloc(fullPathLength);
3.   if(!*path)
4.     return CURLE_OUT_OF_MEMORY;",Useful
/*Check for quoted filenames*/,"-4.   fullPathLength = strlen(cp) + strlen(homedir) + 2;
-3.   *path = malloc(fullPathLength);
-2.   if(!*path)
-1.     return CURLE_OUT_OF_MEMORY;

 /*Check for quoted filenames*/

1.   if(*cp == '\""' || *cp == '\'') {
2.     quot = *cp++;",Useful
"/*error(""Unterminated quote"");*/","-5.         i++;
-4.         (*path)[j] = '\0';
-3.         break;
-2.       }

 /*error(""Unterminated quote"");*/

1.         goto fail;
2.       }",Useful
/*Escaped characters*/,"-2.         goto fail;
-1.       }

 /*Escaped characters*/

1.         i++;
2.         if(cp[i] != '\'' && cp[i] != '\""' &&
3.             cp[i] != '\\') {",Useful
"/*error(""Bad escaped character '\\%c'"",
              cp[i]);*/","-3.         i++;
-2.         if(cp[i] != '\'' && cp[i] != '\""' &&
-1.             cp[i] != '\\') {

 /*error(""Bad escaped character '\\%c'"",
              cp[i]);*/

1.           goto fail;
2.         }
3.       }
4.       (*path)[j++] = cp[i];
5.     }
6",Useful
"/*error(""Empty quotes"");*/","-6.           goto fail;
-5.         }
-4.       }
-3.       (*path)[j++] = cp[i];
-2.     }
-1.     if(j == 0) {

 /*error(""Empty quotes"");*/

1.       goto fail;
2.     }
3.     *cpp = cp + i + strspn(cp + i, WHITESPACE);
4.   }
5.   else {",Useful
/*return pointer to second parameter if it exists*/,"-3.     end = strpbrk(cp, WHITESPACE);
-2.     if(!end)
-1.       end = strchr(cp, '\0');

 /*return pointer to second parameter if it exists*/

1.     *cpp = end + strspn(end, WHITESPACE);
2.     pathLength = 0;
3.     relativePath = (cp[0] == '/' && cp[",Useful
"/***********************************************************************
 * Only for builds using asynchronous name resolves
 **********************************************************************/",#NAME?,Useful
/*The last #include file should be:*/,"-10. #ifdef HAVE_PROCESS_H
-9. #include <process.h>
-8. #endif
-7. #include ""urldata.h""
-6. #include ""sendf.h""
-5. #include ""hostip.h""
-4. #include ""hash.h""
-3. #include ""share.h""
-2. #include ""url.h""
-1. #include ""curl_memory.h""

 /*The last #include fil",Useful
"/*failed to store, cleanup and return error*/","-10.   if(CURL_ASYNC_SUCCESS == status) {
-9.     if(ai) {
-8.       if(data->share)
-7.         Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
-6.       dns = Curl_cache_addr(data, ai,
-5.                             data->state.asyn",Useful
"/*IPv4: The input hostent struct will be freed by ares when we return from
     this function*/","-1.   data->state.async.done = TRUE;

 /*IPv4: The input hostent struct will be freed by ares when we return from
     this function*/

1.   return result;
2. }",Useful
/*CURLRES_ASYNCH*/,"
#ifdef CURLRES_ASYNCH



 /*CURLRES_ASYNCH*/

1. #ifdef HAVE_NETINET_IN_H
2. #include <netinet/in.h>
3. #endif
4. #ifdef HAVE_NETDB_H
5. #include <netdb.h>
6. #endif
7. #ifdef HAVE_ARPA_INET_H
8. #include <arpa/inet.h>
9. #endif
10. #ifdef __VMS",Useful
/*ASN.1 OIDs.*/,"-1. };

 /*ASN.1 OIDs.*/

111",Useful
/*Common name.*/,"-2. };

 /*Common name.*/

111",Useful
/*Subject alternative name.*/,"-3. };

 /*Subject alternative name.*/

1. static const struct Curl_OID OIDtable[] = {
2.   { ""1.2.840.10040.4.1"",        ""dsa"" },
3.   { ""1.2.840.10040.4.3"",        ""dsa-with-sha1"" },
4.   { ""1.2.840.10045.2.1"",        ""ecPublicKey"" },
5.   { ""1.2.840.10",Useful
"/** Lightweight ASN.1 parser.
 * In particular, it does not check for syntactic/lexical errors.
 * It is intended to support certificate information gathering for SSL backends
 * that offer a mean to get certificates as a whole, but do not supply
 * entry points to get particular certificate sub-fields.
 * Please note there is no pretention here to rewrite a full SSL library.*/","-1. /*
 * Lightweight ASN.1 parser.
 * In particular, it does not check for syntactic/lexical errors.
 * It is intended to support certificate information gathering for SSL backends
 * that offer a mean to get certificates as a whole, but do not supply
 *",Useful
"/*Get a single ASN.1 element into `elem', parse ASN.1 string at `beg'
     ending at `end'.
     Returns a pointer in source string after the parsed element, or NULL
     if an error occurs.*/","-10.  */
-9. static const char *getASN1Element(struct Curl_asn1Element *elem,
-8.                                   const char *beg, const char *end)
-7.   WARN_UNUSED_RESULT;
-6. static const char *getASN1Element(struct Curl_asn1Element *elem,
-5.       ",Useful
/*Process header byte.*/,"-3.   if(!beg || !end || beg >= end || !*beg ||
-2.      (size_t)(end - beg) > CURL_ASN1_MAX)
-1.     return NULL;

 /*Process header byte.*/

1.   elem->header = beg;
2.   b = (unsigned char) *beg++;
3.   elem->constructed = (b & 0x20) != 0;
4.   elem->c",Useful
/*Process length.*/,"-1.   elem->tag = b;

 /*Process length.*/

1.   if(beg >= end)
2.     return NULL;
3.   b = (unsigned char) *beg++;
4.   if(!(b & 0x80))
5.     len = b;
6.   else if(!(b &= 0x7F)) {",Useful
/*Does not fit in source.*/,"-10.       beg = getASN1Element(&lelem, beg, end);
-9.       if(!beg)
-8.         return NULL;
-7.     }
-6.     if(beg >= end)
-5.       return NULL;
-4.     elem->end = beg;
-3.     return beg + 1;
-2.   }
-1.   else if((unsigned)b > (size_t)(end - beg)",Useful
/*Get long length.*/,"-1.   else {

 /*Get long length.*/

1.     len = 0;
2.     do {
3.       if(len & 0xFF000000L)",Useful
/*Lengths > 32 bits are not supported.*/,"-3.     len = 0;
-2.     do {
-1.       if(len & 0xFF000000L)

 /*Lengths > 32 bits are not supported.*/

1.       len = (len << 8) | (unsigned char) *beg++;
2.     } while(--b);
3.   }
4.   if(len > (size_t)(end - beg))",Useful
"/** Convert an ASN.1 Boolean value into its string representation.  Return the
 * dynamically allocated string, or NULL if source is not an ASN.1 Boolean
 * value.*/","-10.  */
-9. static const struct Curl_OID *searchOID(const char *oid)
-8. {
-7.   const struct Curl_OID *op;
-6.   for(op = OIDtable; op->numoid; op++)
-5.     if(!strcmp(op->numoid, oid) || strcasecompare(op->textoid, oid))
-4.       return op;
-3.   ret",Useful
"/** Convert an ASN.1 octet string to a printable string.
 * Return the dynamically allocated string, or NULL if an error occurs.*/","-10.  * dynamically allocated string, or NULL if source is not an ASN.1 Boolean
-9.  * value.
-8.  */
-7. static const char *bool2str(const char *beg, const char *end)
-6. {
-5.   if(end - beg != 1)
-4.     return NULL;
-3.   return strdup(*beg? ""TRUE"": """,Useful
"/*Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs.*/","-10.   struct dynbuf buf;
-9.   CURLcode result;
-8.   Curl_dyn_init(&buf, 3 * CURL_ASN1_MAX + 1);
-7.   result = Curl_dyn_addn(&buf, """", 0);
-6.   while(!result && beg < end)
-5.     result = Curl_dyn_addf(&buf, ""%02x:"", (unsigned char) *beg++);
-4.   re",Useful
"/** Convert an ASN.1 integer value into its string representation.
 * Return the dynamically allocated string, or NULL if source is not an
 * ASN.1 integer value.*/","-5.   if(++beg > end)
-4.     return NULL;
-3.   return octet2str(beg, end);
-2. }
-1. /*
 * Convert an ASN.1 integer value into its string representation.
 * Return the dynamically allocated string, or NULL if source is not an
 * ASN.1 integer value.

 /",Useful
/*Represent integers <= 32-bit as a single value.*/,"-10.  * ASN.1 integer value.
-9.  */
-8. static const char *int2str(const char *beg, const char *end)
-7. {
-6.   unsigned long val = 0;
-5.   size_t n = end - beg;
-4.   if(!n)
-3.     return NULL;
-2.   if(n > 4)
-1.     return octet2str(beg, end);

 /*",Useful
"/** Perform a lazy conversion from an ASN.1 typed string to UTF8. Allocate the
 * destination buffer dynamically. The allocation size will normally be too
 * large: this is to avoid buffer overflows.
 * Terminate the string with a nul byte and return the converted
 * string length.*/","-8.   if(*beg & 0x80)
-7.     val = ~val;
-6.   do
-5.     val = (val << 8) | *(const unsigned char *) beg++;
-4.   while(beg < end);
-3.   return curl_maprintf(""%s%lx"", val >= 10? ""0x"": """", val);
-2. }
-1. /*
 * Perform a lazy conversion from an ASN.1 ty",Useful
/*Conversion not supported.*/,"-10.     size = 4;
-9.     break;
-8.   case CURL_ASN1_NUMERIC_STRING:
-7.   case CURL_ASN1_PRINTABLE_STRING:
-6.   case CURL_ASN1_TELETEX_STRING:
-5.   case CURL_ASN1_IA5_STRING:
-4.   case CURL_ASN1_VISIBLE_STRING:
-3.   case CURL_ASN1_UTF8_STRING:
-2. ",Useful
/*Not enough memory.*/,"-2.   buf = malloc(4 * (inlength / size) + 1);
-1.   if(!buf)

 /*Not enough memory.*/

1.   if(type == CURL_ASN1_UTF8_STRING) {",Useful
/*FALLTHROUGH*/,"-10.   }
-9.   else {
-8.     for(outlength = 0; from < end;) {
-7.       int charsize;
-6.       unsigned int wc;
-5.       wc = 0;
-4.       switch(size) {
-3.       case 4:
-2.         wc = (wc << 8) | *(const unsigned char *) from++;
-1.         wc = ",Useful
/*FALLTHROUGH*/,"-10.   }
-9.   else {
-8.     for(outlength = 0; from < end;) {
-7.       int charsize;
-6.       unsigned int wc;
-5.       wc = 0;
-4.       switch(size) {
-3.       case 4:
-2.         wc = (wc << 8) | *(const unsigned char *) from++;
-1.         wc = ",Useful
/*case 1:*/,"-3.       case 2:
-2.         wc = (wc << 8) | *(const unsigned char *) from++;

 /*case 1:*/

1.         wc = (wc << 8) | *(const unsigned char *) from++;
2.       }
3.       charsize = 1;
4.       if(wc >= 0x00000080) {
5.         if(wc >= 0x00000800) {",Useful
"/** Convert an ASN.1 String into its UTF-8 string representation.
 * Return the dynamically allocated string, or NULL if an error occurs.*/","while(beg < end) {
    if(i < buflen)
      buf[i] = '.';
    i++;
    x = 0;
    do {
      if(x & 0xFF000000)
        return 0;
      y = *(const unsigned char *) beg++;
      x = (x << 7) | (y & 0x7F);
    } while(y & 0x80);
    if(i >= buflen)
      i += encodeUint(NULL, 0, x);
    else
      i += encodeUint(buf + i, buflen - i, x);
  }
  if(i < buflen)
    buf[i] = '\0';
  return i;
}

 /** Convert an ASN.1 String into its UTF-8 string representation.
 * Return the dynamically allocated string, or NULL if an error occurs.*/

1.  */
2. static const char *DNtostr(struct Curl_asn1Element *dn)
3. {
4.   char *buf = NULL;
5.   ssize_t buflen = encodeDN(NULL, 0, dn);
6.   if(buflen >= 0) {
7.     buf = malloc(buflen + 1);
8.     if(buf) {
9.       if(encodeDN(buf, buflen + 1, dn) == -1) {
10.         free(buf);",Useful
"/** Convert an ASN.1 OID into its dotted string representation.
 * Store the result in th `n'-byte buffer at `buf'.
 * Return the converted string length, or 0 on errors.*/","-3.   return i;
-2. }
-1. /*
 * Convert an ASN.1 OID into its dotted string representation.
 * Store the result in th `n'-byte buffer at `buf'.
 * Return the converted string length, or 0 on errors.

 /** Convert an ASN.1 OID into its dotted string repres",Useful
/*Process the first two numbers.*/,"-10.  * Convert an ASN.1 OID into its dotted string representation.
-9.  * Store the result in th `n'-byte buffer at `buf'.
-8.  * Return the converted string length, or 0 on errors.
-7.  */
-6. static size_t encodeOID(char *buf, size_t buflen,
-5.       ",Useful
/*Process the trailing numbers.*/,"-10.   x = y / 40;
-9.   y -= x * 40;
-8.   i = encodeUint(buf, buflen, x);
-7.   if(i < buflen)
-6.     buf[i] = '.';
-5.   i++;
-4.   if(i >= buflen)
-3.     i += encodeUint(NULL, 0, y);
-2.   else
-1.     i += encodeUint(buf + i, buflen - i, y);

 /*Pr",Useful
"/** Convert an ASN.1 OID into its dotted or symbolic string representation.
 * Return the dynamically allocated string, or NULL if an error occurs.*/","tzp = fracp;
  fracl = 0;
  if(fracp < end && (*fracp == '.' || *fracp == ',')) {
    fracp++;
    do
      tzp++;
    while(tzp < end && *tzp >= '0' && *tzp <= '9');

 /** Convert an ASN.1 OID into its dotted or symbolic string representation.
 * Return the dynamically allocated string, or NULL if an error occurs.*/

1.  */
2. static const char *DNtostr(struct Curl_asn1Element *dn)
3. {
4.   char *buf = NULL;
5.   ssize_t buflen = encodeDN(NULL, 0, dn);
6.   if(buflen >= 0) {
7.     buf = malloc(buflen + 1);
8.     if(buf) {
9.       if(encodeDN(buf, buflen + 1, dn) == -1) {
10.         free(buf);",Useful
/*one extra for the zero byte*/,"-6. static const char *OID2str(const char *beg, const char *end, bool symbolic)
-5. {
-4.   char *buf = NULL;
-3.   if(beg < end) {
-2.     size_t buflen = encodeOID(NULL, 0, beg, end);
-1.     if(buflen) {

 /*one extra for the zero byte*/

1.       if(b",Useful
"/*Convert an ASN.1 Generalized time to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs.*/","-10.   return buf;
-9. }
-8. static const char *GTime2str(const char *beg, const char *end)
-7. {
-6.   const char *tzp;
-5.   const char *fracp;
-4.   char sec1, sec2;
-3.   size_t fracl;
-2.   size_t tzl;
-1.   const char *sep = """";

 /*Convert an ASN.1",Useful
/*Get seconds digits.*/,"-2.   for(fracp = beg; fracp < end && *fracp >= '0' && *fracp <= '9'; fracp++)
-1.     ;

 /*Get seconds digits.*/

1.   sec1 = '0';
2.   switch(fracp - beg - 12) {
3.   case 0:
4.     sec2 = '0';
5.     break;
6.   case 2:
7.     sec1 = fracp[-2];",Useful
/*FALLTHROUGH*/,"-10.   }
-9.   else {
-8.     for(outlength = 0; from < end;) {
-7.       int charsize;
-6.       unsigned int wc;
-5.       wc = 0;
-4.       switch(size) {
-3.       case 4:
-2.         wc = (wc << 8) | *(const unsigned char *) from++;
-1.         wc = ",Useful
"/**  Convert an ASN.1 UTC time to a printable string.
 * Return the dynamically allocated string, or NULL if an error occurs.*/","switch(type) {
  case CURL_ASN1_BOOLEAN:
    return bool2str(elem->beg, elem->end);
  case CURL_ASN1_INTEGER:
  case CURL_ASN1_ENUMERATED:
    return int2str(elem->beg, elem->end);
  case CURL_ASN1_BIT_STRING:
    return bit2str(elem->beg, elem->end);
  case CURL_ASN1_OCTET_STRING:
    return octet2str(elem->beg, elem->end);
  case CURL_ASN1_NULL:
    return strdup("""");
  case CURL_ASN1_OBJECT_IDENTIFIER:
    return OID2str(elem->beg, elem->end, TRUE);
  case CURL_ASN1_UTC_TIME:
    return UTime2str(elem->beg, elem->end);
  case CURL_ASN1_GENERALIZED_TIME:
    return GTime2str(elem->beg, elem->end);
  case CURL_ASN1_UTF8_STRING:
  case CURL_ASN1_NUMERIC_STRING:
  case CURL_ASN1_PRINTABLE_STRING:
  case CURL_ASN1_TELETEX_STRING:
  case CURL_ASN1_IA5_STRING:
  case CURL_ASN1_VISIBLE_STRING:
  case CURL_ASN1_UNIVERSAL_STRING:
  case CURL_ASN1_BMP_STRING:
    return string2str(type, elem->beg, elem->end);
  }

 /**  Convert an ASN.1 UTC time to a printable string.
 * Return the dynamically allocated string, or NULL if an error occurs.*/

1.  */
2. static const char *DNtostr(struct Curl_asn1Element *dn)
3. {
4.   char *buf = NULL;
5.   ssize_t buflen = encodeDN(NULL, 0, dn);
6.   if(buflen >= 0) {
7.     buf = malloc(buflen + 1);
8.     if(buf) {
9.       if(encodeDN(buf, buflen + 1, dn) == -1) {
10.         free(buf);",Useful
/*Get the seconds.*/,"-10.  *  Convert an ASN.1 UTC time to a printable string.
-9.  * Return the dynamically allocated string, or NULL if an error occurs.
-8.  */
-7. static const char *UTime2str(const char *beg, const char *end)
-6. {
-5.   const char *tzp;
-4.   size_t tzl;",Useful
"/** Convert an ASN.1 element to a printable string.
 * Return the dynamically allocated string, or NULL if an error occurs.*/","if(l) {
        for(p3 = str; isupper(*p3); p3++)
          ;
        for(p3 = (*p3 || p3 - str > 2)? ""/"": "", ""; *p3; p3++) {
          if(l < buflen)
            buf[l] = *p3;
          l++;
        }
      }

 /** Convert an ASN.1 element to a printable string.
 * Return the dynamically allocated string, or NULL if an error occurs.*/

1.  */
2. static const char *DNtostr(struct Curl_asn1Element *dn)
3. {
4.   char *buf = NULL;
5.   ssize_t buflen = encodeDN(NULL, 0, dn);
6.   if(buflen >= 0) {
7.     buf = malloc(buflen + 1);
8.     if(buf) {
9.       if(encodeDN(buf, buflen + 1, dn) == -1) {
10.         free(buf);",Useful
/*Unsupported.*/,"-10.   case CURL_ASN1_UTF8_STRING:
-9.   case CURL_ASN1_NUMERIC_STRING:
-8.   case CURL_ASN1_PRINTABLE_STRING:
-7.   case CURL_ASN1_TELETEX_STRING:
-6.   case CURL_ASN1_IA5_STRING:
-5.   case CURL_ASN1_VISIBLE_STRING:
-4.   case CURL_ASN1_UNIVERSAL_STRING",Useful
"/*Encode delimiter.
         If attribute has a short uppercase name, delimiter is "", "".*/","-10.       if(!p2)
-9.         return -1;
-8.       p3 = getASN1Element(&oid, atv.beg, atv.end);
-7.       if(!p3)
-6.         return -1;
-5.       if(!getASN1Element(&value, p3, atv.end))
-4.         return -1;
-3.       str = ASN1tostr(&oid, 0);
-2.    ",Useful
/*Encode attribute name.*/,"-10.          If attribute has a short uppercase name, delimiter is "", "". */
-9.       if(l) {
-8.         for(p3 = str; isupper(*p3); p3++)
-7.           ;
-6.         for(p3 = (*p3 || p3 - str > 2)? ""/"": "", ""; *p3; p3++) {
-5.           if(l < buflen)
-",Useful
/*Generate equal sign.*/,"-6.       for(p3 = str; *p3; p3++) {
-5.         if(l < buflen)
-4.           buf[l] = *p3;
-3.         l++;
-2.       }
-1.       free((char *) str);

 /*Generate equal sign.*/

1.       if(l < buflen)
2.         buf[l] = '=';
3.       l++;",Useful
"/** Convert an ASN.1 distinguished name into a printable string.
 * Return the dynamically allocated string, or NULL if an error occurs.*/","-10.         if(do_pubkey_field(data, certnum, ""dh(g)"", &elem))
-9.           return 1;
-8.         if(do_pubkey_field(data, certnum, ""dh(pub_key)"", &pk))
-7.           return 1;
-6.       }
-5.     }
-4.   }
-3.   return 0;
-2. }
-1. /*
 * Convert an ASN",Useful
"/** ASN.1 parse an X509 certificate into structure subfields.
 * Syntax is assumed to have already been checked by the SSL backend.
 * See RFC 5280.*/","-2. #ifdef WANT_PARSEX509
-1. /*
 * ASN.1 parse an X509 certificate into structure subfields.
 * Syntax is assumed to have already been checked by the SSL backend.
 * See RFC 5280.

 /** ASN.1 parse an X509 certificate into structure subfields.
 * Syntax ",Useful
/*v1.*/,"-10.  * ASN.1 parse an X509 certificate into structure subfields.
-9.  * Syntax is assumed to have already been checked by the SSL backend.
-8.  * See RFC 5280.
-7.  */
-6. int Curl_parseX509(struct Curl_X509certificate *cert,
-5.                    const",Useful
/*Invalid bounds/size.*/,"-1.   if(!getASN1Element(&elem, beg, end))

 /*Invalid bounds/size.*/

1.   beg = elem.beg;
2.   end = elem.end;",Useful
/*Strip leading zero bytes.*/,"-9.     for(q = elem.beg; !*q && q < elem.end; q++)
-8.       ;
-7.     len = (unsigned long)((elem.end - q) * 8);
-6.     if(len) {
-5.       unsigned int i;
-4.       for(i = *(unsigned char *) q; !(i & 0x80); i <<= 1)
-3.         len--;
-2.     }
-1.  ",Useful
/*Generate coefficients.*/,"-10.     if(data->set.ssl.certinfo) {
-9.       q = curl_maprintf(""%lu"", len);
-8.       if(q) {
-7.         CURLcode result =
-6.           Curl_ssl_push_certinfo(data, certnum, ""RSA Public Key"", q);
-5.         free((char *) q);
-4.         if(result)
-",Useful
/*Extract the certificate ASN.1 elements.*/,"-10.   size_t cl1;
-9.   char *cp2;
-8.   CURLcode result = CURLE_OK;
-7.   unsigned long version;
-6.   size_t i;
-5.   size_t j;
-4.   if(!data->set.ssl.certinfo)
-3.     if(certnum)
-2.       return CURLE_OK;

 /*Extract the certificate ASN.1 elements.",Useful
/*Version (always fits in less than 32 bits).*/,"-10.   if(!ccp)
-9.     return CURLE_OUT_OF_MEMORY;
-8.   if(data->set.ssl.certinfo) {
-7.     result = Curl_ssl_push_certinfo(data, certnum, ""Issuer"", ccp);
-6.   }
-5.   if(!certnum)
-4.     infof(data, ""   Issuer: %s"", ccp);
-3.   free((char *) ccp);
-",Useful
/*USE_GSKIT or USE_NSS or USE_GNUTLS or USE_WOLFSSL or USE_SCHANNEL*/,"
#endif /* USE_GSKIT or USE_NSS or USE_GNUTLS or USE_WOLFSSL or USE_SCHANNEL



 /*USE_GSKIT or USE_NSS or USE_GNUTLS or USE_WOLFSSL or USE_SCHANNEL*/

1.         * or USE_SECTRANSP */
2. #ifdef WANT_VERIFYHOST
3. static const char *checkOID(const char *beg, const char *end,
4.                             const char *oid)
5. {
6.   struct Curl_asn1Element e;
7.   const char *ccp;
8.   const char *p;
9.   bool matched;
10.   /* Check if first ASN.1 element at `beg' is the given OID.",Useful
"/*Check if first ASN.1 element at `beg' is the given OID.
     Return a pointer in the source after the OID if found, else NULL.*/","-8. #ifdef WANT_VERIFYHOST
-7. static const char *checkOID(const char *beg, const char *end,
-6.                             const char *oid)
-5. {
-4.   struct Curl_asn1Element e;
-3.   const char *ccp;
-2.   const char *p;
-1.   bool matched;

 /*Check ",Useful
"/*Verify that connection server matches info in X509 certificate at
     `beg'..`end'.*/","-10.   size_t addrlen = (size_t) -1;
-9.   ssize_t len;
-8.   const char * const hostname = SSL_HOST_NAME();
-7.   const char * const dispname = SSL_HOST_DISPNAME();
-6.   size_t hostlen = strlen(hostname);
-5. #ifdef ENABLE_IPV6
-4.   struct in6_addr add",Useful
/*Get the server IP address.*/,"-4.   if(!SSL_CONN_CONFIG(verifyhost))
-3.     return CURLE_OK;
-2.   if(Curl_parseX509(&cert, beg, end))
-1.     return CURLE_PEER_FAILED_VERIFICATION;

 /*Get the server IP address.*/

1. #ifdef ENABLE_IPV6
2.   if(conn->bits.ipv6_ip && Curl_inet_pton(A",Useful
/*Process extensions.*/,"-7. #ifdef ENABLE_IPV6
-6.   if(conn->bits.ipv6_ip && Curl_inet_pton(AF_INET6, hostname, &addr))
-5.     addrlen = sizeof(struct in6_addr);
-4.   else
-3. #endif
-2.   if(Curl_inet_pton(AF_INET, hostname, &addr))
-1.     addrlen = sizeof(struct in_addr);
",Useful
/*Skip critical if present.*/,"-5.     ext.beg = checkOID(ext.beg, ext.end, sanOID);
-4.     if(ext.beg) {
-3.       ext.beg = getASN1Element(&elem, ext.beg, ext.end);
-2.       if(!ext.beg)
-1.         return CURLE_PEER_FAILED_VERIFICATION;

 /*Skip critical if present.*/

1.       if",Useful
/*Parse the octet string contents: is a single sequence.*/,"-5.       if(elem.tag == CURL_ASN1_BOOLEAN) {
-4.         ext.beg = getASN1Element(&elem, ext.beg, ext.end);
-3.         if(!ext.beg)
-2.           return CURLE_PEER_FAILED_VERIFICATION;
-1.       }

 /*Parse the octet string contents: is a single sequenc",Useful
/*IP address.*/,"-4.   if(!SSL_CONN_CONFIG(verifyhost))
-3.     return CURLE_OK;
-2.   if(Curl_parseX509(&cert, beg, end))
-1.     return CURLE_PEER_FAILED_VERIFICATION;

 /*IP address.*/

1. #ifdef ENABLE_IPV6
2.   if(conn->bits.ipv6_ip && Curl_inet_pton(AF_INET6, hostna",Useful
"/*we have to look to the last occurrence of a commonName in the
     distinguished one to get the most significant one.*/","-3.   name.header = NULL;
-2.   name.beg = name.end = """";
-1.   q = cert.subject.beg;

 /*we have to look to the last occurrence of a commonName in the
     distinguished one to get the most significant one.*/

1.   while(q < cert.subject.end) {
2.     q ",Useful
/*USE_GSKIT*/,#NAME?,Useful
/*Defer error at stack use.*/,"-10.     }
-9.     else if(namelen) {
-8.       const struct content_encoding *encoding = find_encoding(name, namelen);
-7.       struct contenc_writer *writer;
-6.       if(!k->writer_stack) {
-5.         k->writer_stack = new_unencoding_writer(data, &cl",Useful
/*Satisfy caller.*/,"-10.   (void) buf;
-9.   (void) nbytes;
-8.   return CURLE_NOT_BUILT_IN;
-7. }
-6. void Curl_unencode_cleanup(struct Curl_easy *data)
-5. {
-4.   (void) data;
-3. }
-2. char *Curl_all_content_encodings(void)
-1. {

 /*Satisfy caller.*/

1. }",Useful
/*CURL_DISABLE_HTTP*/,"-10. #include <zstd.h>
-9. #endif
-8. #include ""sendf.h""
-7. #include ""http.h""
-6. #include ""content_encoding.h""
-5. #include ""strdup.h""
-4. #include ""strcase.h""
-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. #define CONTENT_ENCODING_DEFAULT  ",Useful
/*Send the LOGOUT command*/,"-2. static CURLcode imap_perform_logout(struct Curl_easy *data)
-1. {

 /*Send the LOGOUT command*/

1.   CURLcode result = imap_sendf(data, ""LOGOUT"");
2.   if(!result)
3.     state(data, IMAP_LOGOUT);
4.   return result;
5. }",Useful
/*Loop through the data line*/,"-2.   if(imapcode == '*') {
-1.     line += 2;

 /*Loop through the data line*/

1.     for(;;) {
2.       size_t wordlen;
3.       while(*line &&
4.             (*line == ' ' || *line == '\t' ||
5.               *line == '\r' || *line == '\n')) {
6.     ",Useful
/*Does the server support the SASL-IR capability?*/,"-2.       else if(wordlen == 13 && !memcmp(line, ""LOGINDISABLED"", 13))
-1.         imapc->login_disabled = TRUE;

 /*Does the server support the SASL-IR capability?*/

1.       else if(wordlen == 7 && !memcmp(line, ""SASL-IR"", 7))
2.         imapc->ir_supp",Useful
/*Test the word for a matching authentication mechanism*/,"-5.       else if(wordlen > 5 && !memcmp(line, ""AUTH="", 5)) {
-4.         size_t llen;
-3.         unsigned short mechbit;
-2.         line += 5;
-1.         wordlen -= 5;

 /*Test the word for a matching authentication mechanism*/

1.         mechbit = C",Useful
/*Authenticated*/,"-4.   result = Curl_sasl_continue(&imapc->sasl, data, imapcode, &progress);
-3.   if(!result)
-2.     switch(progress) {
-1.     case SASL_DONE:

 /*Authenticated*/

1.       break;",Useful
/*No mechanism left after cancellation*/,"-1.       break;

 /*No mechanism left after cancellation*/

1.       if((!imapc->login_disabled) && (imapc->preftype & IMAP_TYPE_CLEARTEXT))",Useful
/*End of connect phase*/,"-5.   if(imapcode != IMAP_RESP_OK) {
-4.     failf(data, ""Access denied. %c"", imapcode);
-3.     result = CURLE_LOGIN_DENIED;
-2.   }
-1.   else

 /*End of connect phase*/

1.     state(data, IMAP_STOP);
2.   return result;
3. }",Useful
/*End of DO phase*/,"-7.     line[len] = '\n';
-6.     result = Curl_client_write(data, CLIENTWRITE_BODY, line, len + 1);
-5.     line[len] = '\0';
-4.   }
-3.   else if(imapcode != IMAP_RESP_OK)
-2.     result = CURLE_QUOTE_ERROR;
-1.   else

 /*End of DO phase*/

1.     sta",Useful
/*See if this is an UIDVALIDITY response*/,"-1.   if(imapcode == '*') {

 /*See if this is an UIDVALIDITY response*/

1.     char tmp[20];
2.     if(sscanf(line + 2, ""OK [UIDVALIDITY %19[0123456789]]"", tmp) == 1) {
3.       Curl_safefree(imapc->mailbox_uidvalidity);
4.       imapc->mailbox_uidvalid",Useful
"/*Something like this is received ""* 1 FETCH (BODY[TEXT] {2021}\r"" so parse
     the continuation data contained within the curly brackets*/","-5.   if(imapcode != '*') {
-4.     Curl_pgrsSetDownloadSize(data, -1);
-3.     state(data, IMAP_STOP);
-2.     return CURLE_REMOTE_FILE_NOT_FOUND;
-1.   }

 /*Something like this is received ""* 1 FETCH (BODY[TEXT] {2021}\r"" so parse
     the continuation",Useful
"/*At this point there is a bunch of data in the header ""cache"" that is
         actually body content, send it as body and then skip it. Do note
         that there may even be additional ""headers"" after the body.*/","-10.       if(endptr - ptr > 1 && endptr[0] == '}' &&
-9.          endptr[1] == '\r' && endptr[2] == '\0')
-8.         parsed = TRUE;
-7.     }
-6.   }
-5.   if(parsed) {
-4.     infof(data, ""Found %"" CURL_FORMAT_CURL_OFF_T "" bytes to download"",
-3.      ",Useful
"/*no size, we're done with the data*/","-2.         chunk = (size_t)size;
-1.       if(!chunk) {

 /*no size, we're done with the data*/

1.         state(data, IMAP_STOP);
2.         return CURLE_OK;
3.       }
4.       result = Curl_client_write(data, CLIENTWRITE_BODY, pp->cache, chunk);
5.  ",Useful
/*Reset the cache size*/,"-1.         Curl_safefree(pp->cache);

 /*Reset the cache size*/

1.         pp->cache_size = 0;
2.       }
3.     }
4.     if(data->req.bytecount == size)",Useful
/*IMAP download*/,"-2.       Curl_setup_transfer(data, -1, -1, FALSE, -1);
-1.     else {

 /*IMAP download*/

1.       data->req.maxdownload = size;",Useful
/*End of DO phase*/,"-7.     line[len] = '\n';
-6.     result = Curl_client_write(data, CLIENTWRITE_BODY, line, len + 1);
-5.     line[len] = '\0';
-4.   }
-3.   else if(imapcode != IMAP_RESP_OK)
-2.     result = CURLE_QUOTE_ERROR;
-1.   else

 /*End of DO phase*/

1.     sta",Useful
/*End of DONE phase*/,"-3.   if(imapcode != IMAP_RESP_OK)
-2.     result = CURLE_WEIRD_SERVER_REPLY;
-1.   else

 /*End of DONE phase*/

1.     state(data, IMAP_STOP);
2.   return result;
3. }",Useful
/*IMAP upload*/,"-1.     Curl_pgrsSetUploadSize(data, data->state.infilesize);

 /*IMAP upload*/

1.     Curl_setup_transfer(data, -1, -1, FALSE, FIRSTSOCKET);",Useful
/*End of DO phase*/,"-7.     line[len] = '\n';
-6.     result = Curl_client_write(data, CLIENTWRITE_BODY, line, len + 1);
-5.     line[len] = '\0';
-4.   }
-3.   else if(imapcode != IMAP_RESP_OK)
-2.     result = CURLE_QUOTE_ERROR;
-1.   else

 /*End of DO phase*/

1.     sta",Useful
/*End of DONE phase*/,"-3.   if(imapcode != IMAP_RESP_OK)
-2.     result = CURLE_WEIRD_SERVER_REPLY;
-1.   else

 /*End of DONE phase*/

1.     state(data, IMAP_STOP);
2.   return result;
3. }",Useful
/*Read the response from the server*/,"-3.   if(pp->sendleft)
-2.     return Curl_pp_flushsend(data, pp);
-1.   do {

 /*Read the response from the server*/

1.     result = Curl_pp_readresp(data, sock, pp, &imapcode, &nread);
2.     if(result)
3.       return result;",Useful
/*Was there an error parsing the response line?*/,"-3.     result = Curl_pp_readresp(data, sock, pp, &imapcode, &nread);
-2.     if(result)
-1.       return result;

 /*Was there an error parsing the response line?*/

1.     if(imapcode == -1)
2.       return CURLE_WEIRD_SERVER_REPLY;
3.     if(!imapcode)",Useful
"/*fallthrough, just stop!*/","-10.     case IMAP_FETCH_FINAL:
-9.       result = imap_state_fetch_final_resp(data, imapcode, imapc->state);
-8.       break;
-7.     case IMAP_APPEND:
-6.       result = imap_state_append_resp(data, imapcode, imapc->state);
-5.       break;
-4.     case",Useful
/*internal error*/,"-1.     default:

 /*internal error*/

1.       state(data, IMAP_STOP);
2.       break;
3.     }
4.   } while(!result && imapc->state != IMAP_STOP && Curl_pp_moredata(pp));
5.   return result;
6. }",Useful
/*Called repeatedly until done from multi.c*/,"-6.       state(data, IMAP_STOP);
-5.       break;
-4.     }
-3.   } while(!result && imapc->state != IMAP_STOP && Curl_pp_moredata(pp));
-2.   return result;
-1. }

 /*Called repeatedly until done from multi.c*/

1. static CURLcode imap_multi_statemach(s",Useful
/*Initialise the pingpong layer*/,"-3.   imapc->preftype = IMAP_TYPE_ANY;
-2.   Curl_sasl_init(&imapc->sasl, data, &saslimap);
-1.   Curl_dyn_init(&imapc->dyn, DYN_IMAP_CMD);

 /*Initialise the pingpong layer*/

1.   Curl_pp_setup(pp);
2.   Curl_pp_init(data, pp);",Useful
/*Start off waiting for the server greeting response*/,"-3.   result = imap_parse_url_options(conn);
-2.   if(result)
-1.     return result;

 /*Start off waiting for the server greeting response*/

1.   state(data, IMAP_SERVERGREET);",Useful
/*Start off with an response id of '*'*/,"-1.   state(data, IMAP_SERVERGREET);

 /*Start off with an response id of '*'*/

1.   strcpy(imapc->resptag, ""*"");
2.   result = imap_multi_statemach(data, done);
3.   return result;
4. }
5. /***************************************************************",Useful
/*marked for closure*/,"-10. static CURLcode imap_done(struct Curl_easy *data, CURLcode status,
-9.                           bool premature)
-8. {
-7.   CURLcode result = CURLE_OK;
-6.   struct connectdata *conn = data->conn;
-5.   struct IMAP *imap = data->req.p.imap;
-4.   (v",Useful
/*use the already set error code*/,"-10.                           bool premature)
-9. {
-8.   CURLcode result = CURLE_OK;
-7.   struct connectdata *conn = data->conn;
-6.   struct IMAP *imap = data->req.p.imap;
-5.   (void)premature;
-4.   if(!imap)
-3.     return CURLE_OK;
-2.   if(status",Useful
/*End the APPEND command first by sending an empty line*/,"-3.     if(!data->set.upload && data->set.mimepost.kind == MIMEKIND_NONE)
-2.       state(data, IMAP_FETCH_FINAL);
-1.     else {

 /*End the APPEND command first by sending an empty line*/

1.       result = Curl_pp_sendf(data, &conn->proto.imapc.pp, ""%s",Useful
/*Cleanup our per-request based variables*/,"-3.     if(!result)
-2.       result = imap_block_statemach(data, conn, FALSE);
-1.   }

 /*Cleanup our per-request based variables*/

1.   Curl_safefree(imap->mailbox);
2.   Curl_safefree(imap->uidvalidity);
3.   Curl_safefree(imap->uid);
4.   Curl_safef",Useful
/*not done yet*/,"-10.  *
-9.  * The variable 'done' points to will be TRUE if the protocol-layer connect
-8.  * phase is done when this function returns, or FALSE if not.
-7.  */
-6. static CURLcode imap_connect(struct Curl_easy *data, bool *done)
-5. {
-4.   CURLcode res",Useful
/*Start the first command in the DO phase*/,"-5.   if(imap->mailbox && imapc->mailbox &&
-4.      strcasecompare(imap->mailbox, imapc->mailbox) &&
-3.      (!imap->uidvalidity || !imapc->mailbox_uidvalidity ||
-2.       strcasecompare(imap->uidvalidity, imapc->mailbox_uidvalidity)))
-1.     selected",Useful
/*Custom command using the same mailbox or no mailbox*/,"-2.     result = imap_perform_append(data);
-1.   else if(imap->custom && (selected || !imap->mailbox))

 /*Custom command using the same mailbox or no mailbox*/

1.     result = imap_perform_list(data);
2.   else if(!imap->custom && selected && (imap->ui",Useful
/*Cleanup the SASL module*/,"-2.   Curl_pp_disconnect(&imapc->pp);
-1.   Curl_dyn_free(&imapc->dyn);

 /*Cleanup the SASL module*/

1.   Curl_sasl_cleanup(conn, imapc->sasl.authused);",Useful
/*Cleanup our connection based variables*/,"-1.   Curl_sasl_cleanup(conn, imapc->sasl.authused);

 /*Cleanup our connection based variables*/

1.   Curl_safefree(imapc->mailbox);
2.   Curl_safefree(imapc->mailbox_uidvalidity);
3.   return CURLE_OK;
4. }",Useful
/*Called from multi.c while DOing*/,"-3.     Curl_setup_transfer(data, -1, -1, FALSE, -1);
-2.   return CURLE_OK;
-1. }

 /*Called from multi.c while DOing*/

1. static CURLcode imap_doing(struct Curl_easy *data, bool *dophase_done)
2. {
3.   CURLcode result = imap_multi_statemach(data, doph",Useful
/*Clear the TLS upgraded flag*/,"-3.   CURLcode result = imap_init(data);
-2.   if(result)
-1.     return result;

 /*Clear the TLS upgraded flag*/

1.   conn->bits.tls_upgraded = FALSE;
2.   return CURLE_OK;
3. }
4. /**********************************************************************",Useful
"/*Does the input contain any ""atom-special"" characters?*/","-10.     else if(!escape_only) {
-9.       const char *p3 = atom_specials;
-8.       while(*p3 && !others_exists) {
-7.         if(*p1 == *p3)
-6.           others_exists = TRUE;
-5.         p3++;
-4.       }
-3.     }
-2.     p1++;
-1.   }

 /*Does the i",Useful
"/***********************************************************************
 *
 * imap_is_bchar()
 *
 * Portable test of whether the specified char is a ""bchar"" as defined in the
 * grammar of RFC-5092.*/","-3.   newstr[newlen] = '\0';
-2.   return newstr;
-1. }
/***********************************************************************
 *
 * imap_is_bchar()
 *
 * Portable test of whether the specified char is a ""bchar"" as defined in the
 * grammar of RFC-5092.",Useful
/*bchar*/,"-5.   newstr[newlen] = '\0';
-4.   return newstr;
-3. }
-2. /***********************************************************************
-1.  *
 * imap_is_bchar()

 /*bchar*/

1.  *
2.  * Portable test of whether the specified char is a ""bchar"" as defined in ",Useful
/*bchar -> achar*/,"-1.     case ':': case '@': case '/':

 /*bchar -> achar*/

1.     case '&': case '=':",Useful
/*bchar -> achar -> uchar -> unreserved*/,"-1.     case '&': case '=':

 /*bchar -> achar -> uchar -> unreserved*/

1.     case '0': case '1': case '2': case '3': case '4': case '5': case '6':
2.     case '7': case '8': case '9':
3.     case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': c",Useful
/*bchar -> achar -> uchar -> sub-delims-sh*/,"-10.     case '7': case '8': case '9':
-9.     case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':
-8.     case 'H': case 'I': case 'J': case 'K': case 'L': case 'M': case 'N':
-7.     case 'O': case 'P': case 'Q': case 'R': case 'S': ca",Useful
/*bchar -> achar -> uchar -> pct-encoded*/,"-2.     case '!': case '$': case '\'': case '(': case ')': case '*':
-1.     case '+': case ',':

 /*bchar -> achar -> uchar -> pct-encoded*/

111",Useful
/*HEXDIG chars are already included above*/,"-3.     case '!': case '$': case '\'': case '(': case ')': case '*':
-2.     case '+': case ',':

 /*HEXDIG chars are already included above*/

1.       return true;
2.     default:
3.       return false;
4.   }
5. }
6. /**********************************",Useful
/*skip leading slash*/,"-2.   CURLcode result = CURLE_OK;
-1.   struct IMAP *imap = data->req.p.imap;

 /*skip leading slash*/

1.   const char *ptr = begin;",Useful
/*See how much of the URL is a valid path and decode it*/,"-1.   const char *ptr = begin;

 /*See how much of the URL is a valid path and decode it*/

1.   while(imap_is_bchar(*ptr))
2.     ptr++;
3.   if(ptr != begin) {",Useful
/*Find the length of the value parameter*/,"-4.     result = Curl_urldecode(begin, ptr - begin, &name, NULL,
-3.                             REJECT_CTRL);
-2.     if(result)
-1.       return result;

 /*Find the length of the value parameter*/

1.     begin = ++ptr;
2.     while(imap_is_bchar(*ptr)",Useful
"/*Does the URL contain a query parameter? Only valid when we have a mailbox
     and no UID as per RFC-5092*/","-10.       value = NULL;
-9.     }
-8.     else {
-7.       free(name);
-6.       free(value);
-5.       return CURLE_URL_MALFORMAT;
-4.     }
-3.     free(name);
-2.     free(value);
-1.   }

 /*Does the URL contain a query parameter? Only valid when we ",Useful
/*Any extra stuff at the end of the URL is an error*/,"-3.     (void)curl_url_get(data->state.uh, CURLUPART_QUERY, &imap->query,
-2.                        CURLU_URLDECODE);
-1.   }

 /*Any extra stuff at the end of the URL is an error*/

1.   if(*ptr)
2.     return CURLE_URL_MALFORMAT;
3.   return CURLE_OK;
",Useful
/*CURL_DISABLE_IMAP*/,"-10.  * RFC4616 PLAIN authentication
-9.  * RFC4752 The Kerberos V5 (""GSSAPI"") SASL Mechanism
-8.  * RFC4959 IMAP Extension for SASL Initial Client Response
-7.  * RFC5092 IMAP URL Scheme
-6.  * RFC6749 OAuth 2.0 Authorization Framework
-5.  * RFC8314 Use",Useful
/*these backends use functions from this file*/,"-10.  * furnished to do so, under the terms of the COPYING file.
-9.  *
-8.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-7.  * KIND, either express or implied.
-6.  *
-5.  **************************************************",Useful
/** Helper GSS-API error functions.*/,"-5. #include ""curl_printf.h""
-4. #include ""curl_memory.h""
-3. #include ""memdebug.h""
-2. static gss_ctx_id_t gss_context = GSS_C_NO_CONTEXT;
-1. /*
 * Helper GSS-API error functions.

 /** Helper GSS-API error functions.*/

1.  */
2. static int check_gss_e",Useful
/*convert major status code (GSS-API error) to text*/,"-10. {
-9.   if(GSS_ERROR(major_status)) {
-8.     OM_uint32 maj_stat, min_stat;
-7.     OM_uint32 msg_ctx = 0;
-6.     gss_buffer_desc status_string;
-5.     char buf[1024];
-4.     size_t len;
-3.     len = 0;
-2.     msg_ctx = 0;
-1.     while(!msg_ctx",Useful
/*convert minor status code (underlying routine error) to text*/,"-10.         break;
-9.       }
-8.       gss_release_buffer(&min_stat, &status_string);
-7.     }
-6.     if(sizeof(buf) > len + 3) {
-5.       strcpy(buf + len, "".\n"");
-4.       len += 2;
-3.     }
-2.     msg_ctx = 0;
-1.     while(!msg_ctx) {

 /*con",Useful
/*clear allocated memory*/,"-10.                            strlen(conn->socks_proxy.host.name) + 2);
-9.     if(!service.value)
-8.       return CURLE_OUT_OF_MEMORY;
-7.     service.length = serviceptr_length +
-6.       strlen(conn->socks_proxy.host.name) + 1;
-5.     msnprintf(se",Useful
"/*errors, keep sending it...*/","-8.   if(check_gss_err(data, gss_major_status,
-7.                    gss_minor_status, ""gss_import_name()"")) {
-6.     failf(data, ""Failed to create service name."");
-5.     gss_release_name(&gss_status, &server);
-4.     return CURLE_COULDNT_CONNECT;
-3",Useful
/*GSS-API subnegotiation version*/,"-10.     if(check_gss_err(data, gss_major_status,
-9.                      gss_minor_status, ""gss_init_sec_context"")) {
-8.       gss_release_name(&gss_status, &server);
-7.       gss_release_buffer(&gss_status, &gss_recv_token);
-6.       gss_release_buf",Useful
/*authentication message type*/,"-10.                      gss_minor_status, ""gss_init_sec_context"")) {
-9.       gss_release_name(&gss_status, &server);
-8.       gss_release_buffer(&gss_status, &gss_recv_token);
-7.       gss_release_buffer(&gss_status, &gss_send_token);
-6.       gss_",Useful
/*ignore the first (VER) byte*/,"-10.      * | 1  |  1   |  2  | up to 2^16 - 1 |
-9.      * +----+------+-----+----------------+
-8.      */
-7.     result = Curl_blockread_all(data, sock, (char *)socksreq, 4, &actualread);
-6.     if(result || (actualread != 4)) {
-5.       failf(data,",Useful
/*Do encryption*/,"-10.     gss_release_buffer(&gss_status, &gss_send_token);
-9.     return CURLE_OUT_OF_MEMORY;
-8.   }
-7.   memcpy(user, gss_send_token.value, gss_send_token.length);
-6.   user[gss_send_token.length] = '\0';
-5.   gss_release_name(&gss_status, &gss_clie",Useful
/*GSS-API subnegotiation version*/,"-10.     if(check_gss_err(data, gss_major_status,
-9.                      gss_minor_status, ""gss_init_sec_context"")) {
-8.       gss_release_name(&gss_status, &server);
-7.       gss_release_buffer(&gss_status, &gss_recv_token);
-6.       gss_release_buf",Useful
/*encryption message type*/,"-10.   }
-9.   memcpy(user, gss_send_token.value, gss_send_token.length);
-8.   user[gss_send_token.length] = '\0';
-7.   gss_release_name(&gss_status, &gss_client_name);
-6.   gss_release_buffer(&gss_status, &gss_send_token);
-5.   infof(data, ""SOCKS5 se",Useful
/*no data protection*/,"-10.   memcpy(user, gss_send_token.value, gss_send_token.length);
-9.   user[gss_send_token.length] = '\0';
-8.   gss_release_name(&gss_status, &gss_client_name);
-7.   gss_release_buffer(&gss_status, &gss_send_token);
-6.   infof(data, ""SOCKS5 server aut",Useful
"/** Sending the encryption type in clear seems wrong. It should be
   * protected with gss_seal()/gss_wrap(). See RFC1961 extract below
   * The NEC reference implementations on which this is based is
   * therefore at fault
   *
   *  +------+------+------+.......................+
   *  + ver  | mtyp | len  |   token               |
   *  +------+------+------+.......................+
   *  + 0x01 | 0x02 | 0x02 | up to 2^16 - 1 octets |
   *  +------+------+------+.......................+
   *
   *   Where:
   *
   *  - ""ver"" is the protocol version number, here 1 to represent the
   *    first version of the SOCKS/GSS-API protocol
   *
   *  - ""mtyp"" is the message type, here 2 to represent a protection
   *    -level negotiation message
   *
   *  - ""len"" is the length of the ""token"" field in octets
   *
   *  - ""token"" is the GSS-API encapsulated protection level
   *
   * The token is produced by encapsulating an octet containing the
   * required protection level using gss_seal()/gss_wrap() with conf_req
   * set to FALSE.  The token is verified using gss_unseal()/
   * gss_unwrap().
   **/","-2.   gss_enc = 0;

 /** Sending the encryption type in clear seems wrong. It should be
   * protected with gss_seal()/gss_wrap(). See RFC1961 extract below
   * The NEC reference implementations on which this is based is
   * therefore at fault
   *
   *",Useful
/*ignore the first (VER) byte*/,"-10.      * | 1  |  1   |  2  | up to 2^16 - 1 |
-9.      * +----+------+-----+----------------+
-8.      */
-7.     result = Curl_blockread_all(data, sock, (char *)socksreq, 4, &actualread);
-6.     if(result || (actualread != 4)) {
-5.       failf(data,",Useful
/*status / message type*/,"-10.      * +----+------+-----+----------------+
-9.      */
-8.     result = Curl_blockread_all(data, sock, (char *)socksreq, 4, &actualread);
-7.     if(result || (actualread != 4)) {
-6.       failf(data, ""Failed to receive GSS-API authentication respo",Useful
/*The last #include files should be:*/,"-10.  *
-9.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-8.  * KIND, either express or implied.
-7.  *
-6.  ***************************************************************************/
-5. #include ""curl_setup.h""
-4. #incl",Useful
"/** Curl_auth_build_spn()
 *
 * This is used to build a SPN string in the following formats:
 *
 * service/host@realm (Not currently used)
 * service/host       (Not used by GSS-API)
 * service@realm      (Not used by Windows SSPI)
 *
 * Parameters:
 *
 * service  [in] - The service type such as http, smtp, pop or imap.
 * host     [in] - The host name.
 * realm    [in] - The realm.
 *
 * Returns a pointer to the newly allocated SPN.*/","-3. #include ""curl_memory.h""
-2. #include ""memdebug.h""
-1. /*
 * Curl_auth_build_spn()
 *
 * This is used to build a SPN string in the following formats:
 *
 * service/host@realm (Not currently used)
 * service/host       (Not used by GSS-API)
 * service@",Useful
/*Return our newly allocated SPN*/,"-6.   if(host && realm)
-5.     spn = aprintf(""%s/%s@%s"", service, host, realm);
-4.   else if(host)
-3.     spn = aprintf(""%s/%s"", service, host);
-2.   else if(realm)
-1.     spn = aprintf(""%s@%s"", service, realm);

 /*Return our newly allocated SPN*/

",Useful
"/*Note: We could use DsMakeSPN() or DsClientMakeSpnForTargetServer() rather
     than doing this ourselves but the first is only available in Windows XP
     and Windows Server 2003 and the latter is only available in Windows 2000
     but not Windows95/98/ME or Windows NT4.0 unless the Active Directory
     Client Extensions are installed. As such it is far simpler for us to
     formulate the SPN instead.*/","-10.   return spn;
-9. }
-8. #else
-7. TCHAR *Curl_auth_build_spn(const char *service, const char *host,
-6.                            const char *realm)
-5. {
-4.   char *utf8_spn = NULL;
-3.   TCHAR *tchar_spn = NULL;
-2.   TCHAR *dupe_tchar_spn = NULL",Useful
/*Return our newly allocated SPN*/,"-6.   if(host && realm)
-5.     spn = aprintf(""%s/%s@%s"", service, host, realm);
-4.   else if(host)
-3.     spn = aprintf(""%s/%s"", service, host);
-2.   else if(realm)
-1.     spn = aprintf(""%s@%s"", service, realm);

 /*Return our newly allocated SPN*/

",Useful
/*USE_WINDOWS_SSPI*/,"-10.  * service@realm      (Not used by Windows SSPI)
-9.  *
-8.  * Parameters:
-7.  *
-6.  * service  [in] - The service type such as http, smtp, pop or imap.
-5.  * host     [in] - The host name.
-4.  * realm    [in] - The realm.
-3.  *
-2.  * Returns a",Useful
"/** Curl_auth_user_contains_domain()
 *
 * This is used to test if the specified user contains a Windows domain name as
 * follows:
 *
 * Domain\User (Down-level Logon Name)
 * Domain/User (curl Down-level format - for compatibility with existing code)
 * User@Domain (User Principal Name)
 *
 * Note: The user name may be empty when using a GSS-API library or Windows
 * SSPI as the user and domain are either obtained from the credentials cache
 * when using GSS-API or via the currently logged in user's credentials when
 * using Windows SSPI.
 *
 * Parameters:
 *
 * user  [in] - The user name.
 *
 * Returns TRUE on success; otherwise FALSE.*/","-1. /*
 * Curl_auth_user_contains_domain()
 *
 * This is used to test if the specified user contains a Windows domain name as
 * follows:
 *
 * Domain\User (Down-level Logon Name)
 * Domain/User (curl Down-level format - for compatibility with existing co",Useful
/*Check we have a domain name or UPN present*/,"-10.  * Parameters:
-9.  *
-8.  * user  [in] - The user name.
-7.  *
-6.  * Returns TRUE on success; otherwise FALSE.
-5.  */
-4. bool Curl_auth_user_contains_domain(const char *user)
-3. {
-2.   bool valid = FALSE;
-1.   if(user && *user) {

 /*Check we ",Useful
"/*User and domain are obtained from the GSS-API credentials cache or the
       currently logged in user from Windows*/","-6.     char *p = strpbrk(user, ""\\/@"");
-5.     valid = (p != NULL && p > user && p < user + strlen(user) - 1 ? TRUE :
-4.                                                                     FALSE);
-3.   }
-2. #if defined(HAVE_GSSAPI) || defined(USE_WIN",Useful
/*The last #include files should be:*/,"-10.  *
-9.  ***************************************************************************/
-8. #include ""curl_setup.h""
-7. #if defined(USE_WINDOWS_SSPI) && defined(USE_KERBEROS5)
-6. #include <curl/curl.h>
-5. #include ""vauth/vauth.h""
-4. #include ""urldata",Useful
/*For Windows 9x compatibility of SSPI calls*/,"-10. {
-9.   CURLcode result = CURLE_OK;
-8.   CtxtHandle context;
-7.   PSecPkgInfo SecurityPackage;
-6.   SecBuffer chlg_buf;
-5.   SecBuffer resp_buf;
-4.   SecBufferDesc chlg_desc;
-3.   SecBufferDesc resp_desc;
-2.   SECURITY_STATUS status;
-1.   uns",Useful
/*Allocate our response buffer*/,"-1.     s_pSecFn->FreeContextBuffer(SecurityPackage);

 /*Allocate our response buffer*/

1.     krb5->output_token = malloc(krb5->token_max);
2.     if(!krb5->output_token)
3.       return CURLE_OUT_OF_MEMORY;
4.   }
5.   if(!krb5->credentials) {",Useful
/*Use the current Windows user*/,"-3.       krb5->p_identity = &krb5->identity;
-2.     }
-1.     else

 /*Use the current Windows user*/

1.       krb5->p_identity = NULL;",Useful
/*Ensure we have a valid challenge message*/,"-10.   SecBufferDesc wrap_desc;
-9.   unsigned char *indata;
-8.   unsigned long qop = 0;
-7.   unsigned long sec_layer = 0;
-6.   unsigned long max_size = 0;
-5.   SecPkgContext_Sizes sizes;
-4.   SECURITY_STATUS status;
-3. #if defined(CURL_DISABLE_VERB",Useful
/*Ensure we have a valid challenge message*/,"-10.   SecBufferDesc wrap_desc;
-9.   unsigned char *indata;
-8.   unsigned long qop = 0;
-7.   unsigned long sec_layer = 0;
-6.   unsigned long max_size = 0;
-5.   SecPkgContext_Sizes sizes;
-4.   SECURITY_STATUS status;
-3. #if defined(CURL_DISABLE_VERB",Useful
/*Get our response size information*/,"-4.   if(!Curl_bufref_len(chlg)) {
-3.     infof(data, ""GSSAPI handshake failure (empty security message)"");
-2.     return CURLE_BAD_CONTENT_ENCODING;
-1.   }

 /*Get our response size information*/

1.   status = s_pSecFn->QueryContextAttributes(krb5->c",Useful
/*Not 4 octets long so fail as per RFC4752 Section 3.1*/,"-5.   status = s_pSecFn->DecryptMessage(krb5->context, &input_desc, 0, &qop);
-4.   if(status != SEC_E_OK) {
-3.     infof(data, ""GSSAPI handshake failure (empty security message)"");
-2.     return CURLE_BAD_CONTENT_ENCODING;
-1.   }

 /*Not 4 octets long",Useful
/*Allocate the encryption (wrap) buffer*/,"-10.   status = s_pSecFn->EncryptMessage(krb5->context, KERB_WRAP_NO_ENCRYPT,
-9.                                     &wrap_desc, 0);
-8.   if(status != SEC_E_OK) {
-7.     free(padding);
-6.     free(message);
-5.     free(trailer);
-4.     if(status == ",Useful
/*Reset any variables*/,"-2.   Curl_safefree(krb5->spn);
-1.   Curl_safefree(krb5->output_token);

 /*Reset any variables*/

1.   krb5->token_max = 0;
2. }",Useful
/*test 529*/,"-10.   int res = 0;
-9.   CURL *curl = NULL;
-8.   FILE *hd_src = NULL;
-7.   int hd;
-6.   struct_stat file_info;
-5.   CURLM *m = NULL;
-4.   int running;
-3.   start_test_timing();
-2.   if(!libtest_arg2) {
-1. #ifdef LIB529

 /*test 529*/

1.     fpri",Useful
/*test 525*/,"-2.     fprintf(stderr, ""Usage: lib529 [url] [uploadfile]\n"");
-1. #else

 /*test 525*/

1.     fprintf(stderr, ""Usage: lib525 [url] [uploadfile]\n"");
2. #endif
3.     return TEST_ERR_USAGE;
4.   }
5.   hd_src = fopen(libtest_arg2, ""rb"");
6.   if(!hd_src)",Useful
"/*can't open file, bail out*/","-2.   hd = fstat(fileno(hd_src), &file_info);
-1.   if(hd == -1) {

 /*can't open file, bail out*/

1.     fprintf(stderr, ""fstat() failed with error: %d (%s)\n"",
2.             errno, strerror(errno));
3.     fprintf(stderr, ""ERROR: cannot open file (%s)",Useful
/*specify target*/,"-1.   easy_setopt(curl, CURLOPT_UPLOAD, 1L);

 /*specify target*/

1.   easy_setopt(curl, CURLOPT_URL, URL);",Useful
/*use active FTP*/,"-1.   easy_setopt(curl, CURLOPT_VERBOSE, 1L);

 /*use active FTP*/

1.   easy_setopt(curl, CURLOPT_FTPPORT, ""-"");",Useful
/*now specify which file to upload*/,"-1.   easy_setopt(curl, CURLOPT_FTPPORT, ""-"");

 /*now specify which file to upload*/

1.   easy_setopt(curl, CURLOPT_READDATA, hd_src);",Useful
"/*NOTE: if you want this code to work on Windows with libcurl as a DLL, you
     MUST also provide a read callback with CURLOPT_READFUNCTION. Failing to
     do so will give you a crash since a DLL may not use the variable's memory
     when passed in to it from an app like this.*/","-1.   easy_setopt(curl, CURLOPT_READDATA, hd_src);

 /*NOTE: if you want this code to work on Windows with libcurl as a DLL, you
     MUST also provide a read callback with CURLOPT_READFUNCTION. Failing to
     do so will give you a crash since a DLL may ",Useful
"/*Set the size of the file to upload (optional).  If you give a *_LARGE
     option you MUST make sure that the type of the passed-in argument is a
     curl_off_t. If you use CURLOPT_INFILESIZE (without _LARGE) you must
     make sure that to pass in a type 'long' argument.*/","-5.   easy_setopt(curl, CURLOPT_READDATA, hd_src);

 /*Set the size of the file to upload (optional).  If you give a *_LARGE
     option you MUST make sure that the type of the passed-in argument is a
     curl_off_t. If you use CURLOPT_INFILESIZE (withou",Useful
"/*At this point, maxfd is guaranteed to be greater or equal than -1.*/","-4.     FD_ZERO(&rd);
-3.     FD_ZERO(&wr);
-2.     FD_ZERO(&exc);
-1.     multi_fdset(m, &rd, &wr, &exc, &maxfd);

 /*At this point, maxfd is guaranteed to be greater or equal than -1.*/

1.     select_test(maxfd + 1, &rd, &wr, &exc, &interval);
2.     a",Useful
/*test 529*/,"-10.   int res = 0;
-9.   CURL *curl = NULL;
-8.   FILE *hd_src = NULL;
-7.   int hd;
-6.   struct_stat file_info;
-5.   CURLM *m = NULL;
-4.   int running;
-3.   start_test_timing();
-2.   if(!libtest_arg2) {
-1. #ifdef LIB529

 /*test 529*/

1.     fpri",Useful
/*test 525*/,"-2.     fprintf(stderr, ""Usage: lib529 [url] [uploadfile]\n"");
-1. #else

 /*test 525*/

1.     fprintf(stderr, ""Usage: lib525 [url] [uploadfile]\n"");
2. #endif
3.     return TEST_ERR_USAGE;
4.   }
5.   hd_src = fopen(libtest_arg2, ""rb"");
6.   if(!hd_src)",Useful
/*close the local file*/,"-5.   curl_multi_remove_handle(m, curl);
-4.   curl_easy_cleanup(curl);
-3.   curl_multi_cleanup(m);
-2.   curl_global_cleanup();
-1. #endif

 /*close the local file*/

1.   fclose(hd_src);
2.   return res;
3. }",Useful
"/*argv1 = URL
 * argv2 = proxy
 * argv3 = non-zero means ASCII transfer*/",#NAME?,Useful
/*enable ascii/text mode*/,"-10.   if(!curl) {
-9.     fprintf(stderr, ""curl_easy_init() failed\n"");
-8.     curl_global_cleanup();
-7.     return TEST_ERR_MAJOR_BAD;
-6.   }
-5.   test_setopt(curl, CURLOPT_PROXY, libtest_arg2);
-4.   test_setopt(curl, CURLOPT_URL, URL);
-3.   test_",Useful
"/*Based on Alex Fishman's bug report on September 30, 2007*/",#NAME?,Useful
"/*At this point, maxfd is guaranteed to be greater or equal than -1.*/","-4.     FD_ZERO(&fdread);
-3.     FD_ZERO(&fdwrite);
-2.     FD_ZERO(&fdexcep);
-1.     multi_fdset(mhandle, &fdread, &fdwrite, &fdexcep, &maxfd);

 /*At this point, maxfd is guaranteed to be greater or equal than -1.*/

1.     select_test(maxfd + 1, &fdr",Useful
/*get initial open file limits*/,"-10.   char strbuff1[81];
-9.   char fmt_u[] = ""%u"";
-8.   char fmt_lu[] = ""%lu"";
-7. #ifdef HAVE_LONGLONG
-6.   char fmt_llu[] = ""%llu"";
-5.   if(sizeof(rl.rlim_max) > sizeof(long))
-4.     fmt = fmt_llu;
-3.   else
-2. #endif
-1.     fmt = (sizeof(rl.rl",Useful
"/** if soft limit and hard limit are different we ask the
   * system to raise soft limit all the way up to the hard
   * limit. Due to some other system limit the soft limit
   * might not be raised up to the hard limit. So from this
   * point the resulting soft limit is our limit. Trying to
   * open more than soft limit file descriptors will fail.*/","-10.     msnprintf(strbuff, sizeof(strbuff), fmt, rl.rlim_cur);
-9.   fprintf(stderr, ""initial soft limit: %s\n"", strbuff);
-8. #ifdef RLIM_INFINITY
-7.   if(rl.rlim_max == RLIM_INFINITY)
-6.     strcpy(strbuff, ""INFINITY"");
-5.   else
-4. #endif
-3.     ",Useful
/*on failure don't abort just issue a warning*/,"-10.    * point the resulting soft limit is our limit. Trying to
-9.    * open more than soft limit file descriptors will fail.
-8.    */
-7.   if(rl.rlim_cur != rl.rlim_max) {
-6. #ifdef OPEN_MAX
-5.     if((rl.rlim_cur > 0) &&
-4.         (rl.rlim_cur <",Useful
/*on failure don't abort just issue a warning*/,"-10.    * point the resulting soft limit is our limit. Trying to
-9.    * open more than soft limit file descriptors will fail.
-8.    */
-7.   if(rl.rlim_cur != rl.rlim_max) {
-6. #ifdef OPEN_MAX
-5.     if((rl.rlim_cur > 0) &&
-4.         (rl.rlim_cur <",Useful
/*get current open file limits*/,"-4.       store_errmsg(""setrlimit() failed"", errno);
-3.       fprintf(stderr, ""%s\n"", msgbuff);
-2.       msgbuff[0] = '\0';
-1.     }

 /*get current open file limits*/

1.     if(getrlimit(RLIMIT_NOFILE, &rl) != 0) {
2.       store_errmsg(""getrlimit() ",Useful
/*show current open file limits*/,"-5.     if(getrlimit(RLIMIT_NOFILE, &rl) != 0) {
-4.       store_errmsg(""getrlimit() failed"", errno);
-3.       fprintf(stderr, ""%s\n"", msgbuff);
-2.       return -3;
-1.     }

 /*show current open file limits*/

1. #ifdef RLIM_INFINITY
2.     if(rl.rlim",Useful
"/** reserve a chunk of memory before opening file descriptors to
   * avoid a low memory condition once the file descriptors are
   * open. System conditions that could make the test fail should
   * be addressed in the precheck phase. This chunk of memory shall
   * be always free()ed before exiting the rlimit() function so
   * that it becomes available to the test.*/","-1.   /*
   * reserve a chunk of memory before opening file descriptors to
   * avoid a low memory condition once the file descriptors are
   * open. System conditions that could make the test fail should
   * be addressed in the precheck phase. This chun",Useful
/*initialize it to fight lazy allocation*/,"-10.     if(!memchunk) {
-9.       fprintf(stderr, ""memchunk, malloc() failed\n"");
-8.       nitems /= 2;
-7.     }
-6.   } while(nitems && !memchunk);
-5.   if(!memchunk) {
-4.     store_errmsg(""memchunk, malloc() failed"", errno);
-3.     fprintf(stderr,",Useful
/*set the number of file descriptors we will try to open*/,"-3.   fprintf(stderr, ""initializing memchunk array\n"");
-2.   for(i = 0; i < nitems; i++)
-1.     memchunk[i] = -1;

 /*set the number of file descriptors we will try to open*/

1. #ifdef RLIM_INFINITY
2.   if((rl.rlim_cur > 0) && (rl.rlim_cur != RLIM_INF",Useful
/*a huge number of file descriptors*/,"-3.     num_open.rlim_max = rl.rlim_cur - SAFETY_MARGIN;
-2.   }
-1.   else {

 /*a huge number of file descriptors*/

1.     for(nitems = i = 1; nitems <= i; i *= 2)
2.       nitems = i;
3.     if(nitems > 0x7fff)
4.       nitems = 0x40000;
5.     num_op",Useful
/*verify that we won't overflow size_t in malloc()*/,"-6.     for(nitems = i = 1; nitems <= i; i *= 2)
-5.       nitems = i;
-4.     if(nitems > 0x7fff)
-3.       nitems = 0x40000;
-2.     num_open.rlim_max = nitems;
-1.   }

 /*verify that we won't overflow size_t in malloc()*/

1.   if((size_t)(num_open.rl",Useful
/*allocate array for file descriptors*/,"-9.   if((size_t)(num_open.rlim_max) > ((size_t)-1) / sizeof(*fd)) {
-8.     msnprintf(strbuff1, sizeof(strbuff1), fmt, num_open.rlim_max);
-7.     msnprintf(strbuff, sizeof(strbuff), ""unable to allocate an array for %s ""
-6.               ""file descripto",Useful
/*initialize it to fight lazy allocation*/,"-10.     if(!memchunk) {
-9.       fprintf(stderr, ""memchunk, malloc() failed\n"");
-8.       nitems /= 2;
-7.     }
-6.   } while(nitems && !memchunk);
-5.   if(!memchunk) {
-4.     store_errmsg(""memchunk, malloc() failed"", errno);
-3.     fprintf(stderr,",Useful
/*we don't care if we can't shrink it*/,"-10.                 strbuff1);
-9.       fprintf(stderr, ""%s\n"", strbuff);
-8.       for(num_open.rlim_cur = num_open.rlim_max;
-7.           fd[num_open.rlim_cur] >= 0;
-6.           num_open.rlim_cur++) {
-5.         close(fd[num_open.rlim_cur]);
-4.  ",Useful
"/** when using select() instead of poll() we cannot test
   * libcurl functionality with a socket number equal or
   * greater than FD_SETSIZE. In any case, macro VERIFY_SOCK
   * in lib/select.c enforces this check and protects libcurl
   * from a possible crash. The effect of this protection
   * is that test 537 will always fail, since the actual
   * call to select() never takes place. We skip test 537
   * with an indication that select limit would be exceeded.*/","-10.         fd = tmpfd;
-9.         tmpfd = NULL;
-8.       }
-7.       break;
-6.     }
-5.   }
-4.   msnprintf(strbuff, sizeof(strbuff), fmt, num_open.rlim_max);
-3.   fprintf(stderr, ""%s file descriptors open\n"", strbuff);
-2. #if !defined(HAVE_POLL_F",Useful
/*using a FD_SETSIZE bound select()*/,"-10.        ((unsigned int)fd[rl.rlim_cur] > num_open.rlim_cur)) {
-9.       msnprintf(strbuff, sizeof(strbuff), ""select limit is FD_SETSIZE %d"",
-8.                 FD_SETSIZE);
-7.       store_errmsg(strbuff, 0);
-6.       fprintf(stderr, ""%s\n"", msgbuf",Useful
"/** Old or 'backwards compatible' implementations of stdio do not allow
   * handling of streams with an underlying file descriptor number greater
   * than 255, even when allowing high numbered file descriptors for sockets.
   * At this point we have a big number of file descriptors which have been
   * opened using dup(), so lets test the stdio implementation and discover
   * if it is capable of fopen()ing some additional files.*/","-1.   /*
   * Old or 'backwards compatible' implementations of stdio do not allow
   * handling of streams with an underlying file descriptor number greater
   * than 255, even when allowing high numbered file descriptors for sockets.
   * At this point w",Useful
"/*free the chunk of memory we were reserving so that it
     becomes becomes available to the test*/","-10.     msnprintf(strbuff1, sizeof(strbuff1), fmt, num_open.rlim_max);
-9.     msnprintf(strbuff, sizeof(strbuff), ""fopen fails with %s fds open"",
-8.               strbuff1);
-7.     fprintf(stderr, ""%s\n"", msgbuff);
-6.     msnprintf(strbuff, sizeof(st",Useful
/*used by the test script to ask if we can run this test or not*/,"-10.   if(!keep_open) {
-9.     close_file_descriptors();
-8.   }
-7.   return 0;
-6. }
-5. int test(char *URL)
-4. {
-3.   CURLcode res;
-2.   CURL *curl;
-1.   if(!strcmp(URL, ""check"")) {

 /*used by the test script to ask if we can run this test or not",Useful
"/*run the test with the bunch of open file descriptors
     and close them all once the test is over*/","-2.     return TEST_ERR_MAJOR_BAD;
-1.   }

 /*run the test with the bunch of open file descriptors
     and close them all once the test is over*/

1.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
2.     fprintf(stderr, ""curl_global_init() failed",Useful
/*skip test*/,"-10.   msnprintf(strbuff, sizeof(strbuff), fmt, num_open.rlim_max);
-9.   fprintf(stderr, ""%s file descriptors open\n"", strbuff);
-8. #if !defined(HAVE_POLL_FINE) && !defined(USE_WINSOCK)
-7.   /*
-6.    * when using select() instead of poll() we cannot t",Useful
/*copy one single byte*/,"-10.   struct WriteThis *pooh = (struct WriteThis *)userp;
-9.   int eof = !*pooh->readptr;
-8.   if(size*nmemb < 1)
-7.     return 0;
-6. #ifndef LIB645
-5.   eof = pooh->sizeleft <= 0;
-4.   if(!eof)
-3.     pooh->sizeleft--;
-2. #endif
-1.   if(!eof) {",Useful
/*advance pointer*/,"-10.   int eof = !*pooh->readptr;
-9.   if(size*nmemb < 1)
-8.     return 0;
-7. #ifndef LIB645
-6.   eof = pooh->sizeleft <= 0;
-5.   if(!eof)
-4.     pooh->sizeleft--;
-3. #endif
-2.   if(!eof) {

 /*advance pointer*/

111",Useful
/*we return 1 byte at a time!*/,"-10.   if(size*nmemb < 1)
-9.     return 0;
-8. #ifndef LIB645
-7.   eof = pooh->sizeleft <= 0;
-6.   if(!eof)
-5.     pooh->sizeleft--;
-4. #endif
-3.   if(!eof) {

 /*we return 1 byte at a time!*/

1.   }",Useful
/*no more data left to deliver*/,"-1.   }

 /*no more data left to deliver*/

1. #endif
2. }
3. static int once(char *URL, bool oldstyle)
4. {
5.   CURL *curl;
6.   CURLcode res = CURLE_OK;
7.   curl_mime *mime = NULL;
8.   curl_mimepart *part = NULL;
9.   struct WriteThis pooh;
10.   str",Useful
/*Fill in the file upload part*/,"-10.     return TEST_ERR_MAJOR_BAD;
-9.   }
-8.   part = curl_mime_addpart(mime);
-7.   if(!part) {
-6.     fprintf(stderr, ""curl_mime_addpart(1) failed\n"");
-5.     curl_mime_free(mime);
-4.     curl_easy_cleanup(curl);
-3.     curl_global_cleanup();
-2.",Useful
"/*Now add the same data with another name and make it not look like
     a file upload but still using the callback*/","-9.     res = curl_mime_name(part, ""sendfile alternative"");
-8.     if(!res)
-7.       res = curl_mime_data_cb(part, datasize, read_callback,
-6.                               NULL, NULL, &pooh);
-5.     if(!res)
-4.       res = curl_mime_filename(part, """,Useful
/*Fill in the file upload part*/,"-10.     return TEST_ERR_MAJOR_BAD;
-9.   }
-8.   part = curl_mime_addpart(mime);
-7.   if(!part) {
-6.     fprintf(stderr, ""curl_mime_addpart(1) failed\n"");
-5.     curl_mime_free(mime);
-4.     curl_easy_cleanup(curl);
-3.     curl_global_cleanup();
-2.",Useful
/*Fill in a submit field too*/,"-6.   res = curl_mime_name(part, ""filename"");
-5.   if(!res)
-4.     res = curl_mime_data(part, ""postit2.c"",
-3.                          CURL_ZERO_TERMINATED);
-2.   if(res)
-1.     printf(""curl_mime_xxx(3) = %s\n"", curl_easy_strerror(res));

 /*Fill in ",Useful
/*First set the URL that is about to receive our POST.*/,"-10.     curl_global_cleanup();
-9.     return TEST_ERR_MAJOR_BAD;
-8.   }
-7.   res = curl_mime_name(part, ""somename"");
-6.   if(!res)
-5.     res = curl_mime_filename(part, ""somefile.txt"");
-4.   if(!res)
-3.     res = curl_mime_data(part, ""blah blah"", ",Useful
/*send a multi-part mimepost*/,"-1.   test_setopt(curl, CURLOPT_URL, URL);

 /*send a multi-part mimepost*/

1.   test_setopt(curl, CURLOPT_MIMEPOST, mime);",Useful
"/*Perform the request, res will get the return code*/","-1.   test_setopt(curl, CURLOPT_HEADER, 1L);

 /*Perform the request, res will get the return code*/

1.   res = curl_easy_perform(curl);
2. test_cleanup:",Useful
/*now cleanup the mimepost structure*/,"-1.   curl_easy_cleanup(curl);

 /*now cleanup the mimepost structure*/

1.   curl_mime_free(mime);
2.   return res;
3. }
4. static int cyclic_add(void)
5. {
6.   CURL *easy = curl_easy_init();
7.   curl_mime *mime = curl_mime_init(easy);
8.   curl_mimepa",Useful
/*new*/,"-9.   if(oldstyle) {
-8.     res = curl_mime_name(part, ""sendfile"");
-7.     if(!res)
-6.       res = curl_mime_data_cb(part, datasize, read_callback,
-5.                               NULL, NULL, &pooh);
-4.     if(!res)
-3.       res = curl_mime_filenam",Useful
"/** we force our own host name, in order to make some tests machine independent*/","-10.  * copies of the Software, and permit persons to whom the Software is
-9.  * furnished to do so, under the terms of the COPYING file.
-8.  *
-7.  * This software is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY
-6.  * KIND, either express ",Useful
"/*LD_PRELOAD used, but no hostname set, we'll just return a failure*/","-10.  * we force our own host name, in order to make some tests machine independent
-9.  */
-8. int gethostname(char *name, GETHOSTNAME_TYPE_ARG2 namelen)
-7. {
-6.   const char *force_hostname = getenv(""CURL_GETHOSTNAME"");
-5.   if(force_hostname) {
-4. ",Useful
"/*not interested in the downloaded bytes, return the size*/","-4. #define RUN_FOR_SECONDS 7
-3. static pthread_mutex_t connlock;
-2. static size_t write_db(void *ptr, size_t size, size_t nmemb, void *data)
-1. {

 /*not interested in the downloaded bytes, return the size*/

111",Useful
/*ignores error*/,"-10. {
-9.   struct initurl *u = (struct initurl *)ptr;
-8.   int i;
-7.   time_t end = time(NULL) + RUN_FOR_SECONDS;
-6.   for(i = 0; time(NULL) < end; i++) {
-5.     CURL *curl = curl_easy_init();
-4.     curl_easy_setopt(curl, CURLOPT_URL, u->url);
-3.",Useful
/*Must initialize libcurl before any threads are started*/,"-10.     fprintf(stderr, ""Thread %d transfer %d\n"", u->threadno, i);
-9.   }
-8.   return NULL;
-7. }
-6. int test(char *URL)
-5. {
-4.   pthread_t tid[NUM_THREADS];
-3.   int i;
-2.   CURLSH *share;
-1.   struct initurl url[NUM_THREADS];

 /*Must initial",Useful
/*now wait for all threads to terminate*/,"-10.     int error;
-9.     url[i].url = URL;
-8.     url[i].share = share;
-7.     url[i].threadno = i;
-6.     error = pthread_create(&tid[i], NULL, run_thread, &url[i]);
-5.     if(0 != error)
-4.       fprintf(stderr, ""Couldn't run thread number %d, e",Useful
"/*without pthread, this test doesn't work*/","-9.   for(i = 0; i< NUM_THREADS; i++) {
-8.     pthread_join(tid[i], NULL);
-7.     fprintf(stderr, ""Thread %d terminated\n"", i);
-6.   }
-5.   kill_locks();
-4.   curl_share_cleanup(share);
-3.   curl_global_cleanup();
-2.   return 0;
-1. }

 /*without p",Useful
/*if this happens things are major weird*/,"-10.   struct_stat file_info;
-9.   if(!libtest_arg2) {
-8.     fprintf(stderr, ""Usage: <url> <file-to-upload>\n"");
-7.     return TEST_ERR_USAGE;
-6.   }
-5.   hd_src = fopen(libtest_arg2, ""rb"");
-4.   if(!hd_src) {
-3.     fprintf(stderr, ""fopen failed ",Useful
"/*can't open file, bail out*/","-2.   hd = fstat(fileno(hd_src), &file_info);
-1.   if(hd == -1) {

 /*can't open file, bail out*/

1.     fprintf(stderr, ""fstat() failed with error: %d %s\n"",
2.             errno, strerror(errno));
3.     fprintf(stderr, ""ERROR: cannot open file %s\n"",",Useful
/*get a curl handle*/,"-10.   if(!file_info.st_size) {
-9.     fprintf(stderr, ""ERROR: file %s has zero size!\n"", libtest_arg2);
-8.     fclose(hd_src);
-7.     return TEST_ERR_MAJOR_BAD;
-6.   }
-5.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-4.     fprintf(stderr, ",Useful
/*enable uploading*/,"-7.   curl = curl_easy_init();
-6.   if(!curl) {
-5.     fprintf(stderr, ""curl_easy_init() failed\n"");
-4.     curl_global_cleanup();
-3.     fclose(hd_src);
-2.     return TEST_ERR_MAJOR_BAD;
-1.   }

 /*enable uploading*/

1.   test_setopt(curl, CURLOPT",Useful
/*enable verbose*/,"-1.   test_setopt(curl, CURLOPT_UPLOAD, 1L);

 /*enable verbose*/

1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);",Useful
/*specify target*/,"-1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);

 /*specify target*/

1.   test_setopt(curl, CURLOPT_URL, URL);",Useful
/*now specify which file to upload*/,"-1.   test_setopt(curl, CURLOPT_URL, URL);

 /*now specify which file to upload*/

1.   test_setopt(curl, CURLOPT_READDATA, hd_src);",Useful
/*Now run off and do what you've been told!*/,"-1.   test_setopt(curl, CURLOPT_READDATA, hd_src);

 /*Now run off and do what you've been told!*/

1.   curl_easy_perform(curl);",Useful
"/*and now upload the exact same again, but without rewinding so it already
     is at end of file*/","-1.   curl_easy_perform(curl);

 /*and now upload the exact same again, but without rewinding so it already
     is at end of file*/

1.   res = curl_easy_perform(curl);
2. test_cleanup:",Useful
/*close the local file*/,"-2.   res = curl_easy_perform(curl);
-1. test_cleanup:

 /*close the local file*/

1.   fclose(hd_src);
2.   curl_easy_cleanup(curl);
3.   curl_global_cleanup();
4.   return res;
5. }",Useful
"/** Change the FTP_FILEMETHOD option to use full paths rather than a CWD
    * command.  Alter the URL's path a bit, appending a ""./"".  Use an innocuous
    * QUOTE command, after which curl will CWD to ftp_conn->entrypath and then
    * (on the next call to ftp_statemach_act) find a non-zero ftpconn->dirdepth
    * even though no directories are stored in the ftpconn->dirs array (after a
    * call to freedirs).*/","-5.    test_setopt(curl, CURLOPT_URL, URL);
-4.    test_setopt(curl, CURLOPT_VERBOSE, 1L);
-3.    test_setopt(curl, CURLOPT_FTP_FILEMETHOD, (long) CURLFTPMETHOD_SINGLECWD);
-2.    res = curl_easy_perform(curl);
-1.    /*
    * Change the FTP_FILEMETHOD op",Useful
/*URL is setup in the code*/,"-10. int test(char *URL)
-9. {
-8.   int res = 0;
-7.   CURL *curl[NUM_HANDLES] = {NULL, NULL};
-6.   char *port = libtest_arg3;
-5.   char *address = libtest_arg2;
-4.   char dnsentry[256];
-3.   struct curl_slist *slist = NULL;
-2.   int i;
-1.   char t",Useful
/*get an easy handle*/,"-1.   for(i = 0; i < NUM_HANDLES; i++) {

 /*get an easy handle*/

1.     easy_init(curl[i]);",Useful
"/*server.example.curl:%s/path/1512%04i"",*/","-1.     msnprintf(target_url, sizeof(target_url),

 /*server.example.curl:%s/path/1512%04i"",*/

1.               port, i + 1);
2.     target_url[sizeof(target_url) - 1] = '\0';
3.     easy_setopt(curl[i], CURLOPT_URL, target_url);",Useful
/*make the first one populate the GLOBAL cache*/,"-3.     easy_setopt(curl[i], CURLOPT_HEADER, 1L);
-2.     easy_setopt(curl[i], CURLOPT_DNS_USE_GLOBAL_CACHE, 1L);
-1.   }

 /*make the first one populate the GLOBAL cache*/

1.   easy_setopt(curl[0], CURLOPT_RESOLVE, slist);",Useful
"/*argv1 = URL
 * argv2 = proxy
 * argv3 = proxyuser:password*/",#NAME?,Useful
/*only do this once and then require a clearing of this*/,"-10. #include ""memdebug.h""
-9. #define UPLOADTHIS ""this is the blurb we want to upload\n""
-8. #ifndef LIB548
-7. static size_t readcallback(char  *ptr,
-6.                            size_t size,
-5.                            size_t nmemb,
-4.           ",Useful
/*clear counter to make the read callback restart*/,"-2.   if(cmd == CURLIOCMD_RESTARTREAD) {
-1.     fprintf(stderr, ""REWIND!\n"");

 /*clear counter to make the read callback restart*/

1.   }
2.   return CURLIOE_OK;
3. }
4. #endif
5. int test(char *URL)
6. {
7.   CURLcode res;
8.   CURL *curl;
9. #ifndef ",Useful
"/*547 style, which means reading the POST data from a callback*/","-2.   test_setopt(curl, CURLOPT_POSTFIELDS, UPLOADTHIS);
-1. #else

 /*547 style, which means reading the POST data from a callback*/

1.   test_setopt(curl, CURLOPT_IOCTLFUNCTION, ioctlcallback);
2.   test_setopt(curl, CURLOPT_IOCTLDATA, &counter);
3.   ",Useful
"/*We CANNOT do the POST fine without setting the size (or choose
     chunked)!*/","-4.   test_setopt(curl, CURLOPT_IOCTLFUNCTION, ioctlcallback);
-3.   test_setopt(curl, CURLOPT_IOCTLDATA, &counter);
-2.   test_setopt(curl, CURLOPT_READFUNCTION, readcallback);
-1.   test_setopt(curl, CURLOPT_READDATA, &counter);

 /*We CANNOT do the POS",Useful
/*First set the URL that is about to receive our POST.*/,"-10.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-9.     fprintf(stderr, ""curl_global_init() failed\n"");
-8.     return TEST_ERR_MAJOR_BAD;
-7.   }
-6.   curl = curl_easy_init();
-5.   if(!curl) {
-4.     fprintf(stderr, ""curl_easy_init() failed",Useful
/*Now specify we want to POST data*/,"-1.   test_setopt(curl, CURLOPT_URL, URL);

 /*Now specify we want to POST data*/

1.   test_setopt(curl, CURLOPT_POST, 1L);",Useful
/*Set the expected POST size*/,"-1.   test_setopt(curl, CURLOPT_POST, 1L);

 /*Set the expected POST size*/

1.   test_setopt(curl, CURLOPT_POSTFIELDSIZE, 1L);",Useful
/*pointer to pass to our read function*/,"-1.   test_setopt(curl, CURLOPT_READFUNCTION, read_callback);

 /*pointer to pass to our read function*/

1.   test_setopt(curl, CURLOPT_READDATA, NULL);",Useful
"/*Perform the request, res will get the return code*/","-1.   test_setopt(curl, CURLOPT_HEADER, 1L);

 /*Perform the request, res will get the return code*/

1.   res = curl_easy_perform(curl);
2. test_cleanup:",Useful
"/*Purpose
 *
 * 1. Accept a TCP connection on a custom port (IPv4 or IPv6), or connect
 *    to a given (localhost) port.
 *
 * 2. Get commands on STDIN. Pass data on to the TCP stream.
 *    Get data from TCP stream and pass on to STDOUT.
 *
 * This program is made to perform all the socket/stream/connection stuff for
 * the test suite's (perl) FTP server. Previously the perl code did all of
 * this by its own, but I decided to let this program do the socket layer
 * because of several things:
 *
 * o We want the perl code to work with rather old perl installations, thus
 *   we cannot use recent perl modules or features.
 *
 * o We want IPv6 support for systems that provide it, and doing optional IPv6
 *   support in perl seems if not impossible so at least awkward.
 *
 * o We want FTP-SSL support, which means that a connection that starts with
 *   plain sockets needs to be able to ""go SSL"" in the midst. This would also
 *   require some nasty perl stuff I'd rather avoid.
 *
 * (Source originally based on sws.c)*/",#NAME?,Useful
"/** Signal handling notes for sockfilt
 * ----------------------------------
 *
 * This program is a single-threaded process.
 *
 * This program is intended to be highly portable and as such it must be kept
 * as simple as possible, due to this the only signal handling mechanisms used
 * will be those of ANSI C, and used only in the most basic form which is good
 * enough for the purpose of this program.
 *
 * For the above reason and the specific needs of this program signals SIGHUP,
 * SIGPIPE and SIGALRM will be simply ignored on systems where this can be
 * done.  If possible, signals SIGINT and SIGTERM will be handled by this
 * program as an indication to cleanup and finish execution as soon as
 * possible.  This will be achieved with a single signal handler
 * 'exit_signal_handler' for both signals.
 *
 * The 'exit_signal_handler' upon the first SIGINT or SIGTERM received signal
 * will just set to one the global var 'got_exit_signal' storing in global var
 * 'exit_signal' the signal that triggered this change.
 *
 * Nothing fancy that could introduce problems is used, the program at certain
 * points in its normal flow checks if var 'got_exit_signal' is set and in
 * case this is true it just makes its way out of loops and functions in
 * structured and well behaved manner to achieve proper program cleanup and
 * termination.
 *
 * Even with the above mechanism implemented it is worthwile to note that
 * other signals might still be received, or that there might be systems on
 * which it is not possible to trap and ignore some of the above signals.
 * This implies that for increased portability and reliability the program
 * must be coded as if no signal was being ignored or handled at all.  Enjoy
 * it!*/",#NAME?,Useful
"/*make the curlx header define all printf() functions to use the curlx_*
   versions instead*/","-10. #ifdef HAVE_NETINET_IN6_H
-9. #include <netinet/in6.h>
-8. #endif
-7. #ifdef HAVE_ARPA_INET_H
-6. #include <arpa/inet.h>
-5. #endif
-4. #ifdef HAVE_NETDB_H
-3. #include <netdb.h>
-2. #endif
-1. #define ENABLE_CURLX_PRINTF

 /*make the curlx header de",Useful
/*include memdebug.h last*/,"-6. #include ""getpart.h""
-5. #include ""inet_pton.h""
-4. #include ""util.h""
-3. #include ""server_sockaddr.h""
-2. #include ""timediff.h""
-1. #include ""warnless.h""

 /*include memdebug.h last*/

1. #include ""memdebug.h""
2. #ifdef USE_WINSOCK
3. #undef  EINTR",Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

 /*errno.h value*/

1. #undef  EAGAIN",Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

 /*errno.h value*/

1. #undef  EAGAIN",Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

 /*errno.h value*/

1. #undef  EAGAIN",Useful
/*errno.h value*/,"-3. #include ""memdebug.h""
-2. #ifdef USE_WINSOCK
-1. #undef  EINTR

 /*errno.h value*/

1. #undef  EAGAIN",Useful
"/*if non-zero, we activate this mode*/","-10. #define DEFAULT_LOGFILE ""log/sockfilt.log""
-9. #endif
-8. const char *serverlogfile = DEFAULT_LOGFILE;
-7. static bool verbose = FALSE;
-6. static bool bind_only = FALSE;
-5. #ifdef ENABLE_IPV6
-4. static bool use_ipv6 = FALSE;
-3. #endif
-2. static ",Useful
/*as a server waiting for connections*/,"-1. enum sockmode {

 /*as a server waiting for connections*/

111",Useful
"/*as a server, connected to a client*/","-2. enum sockmode {

 /*as a server, connected to a client*/

111",Useful
"/*as a client, connected to a server*/","-3. enum sockmode {

 /*as a client, connected to a server*/

111",Useful
"/*as a client, disconnected from server*/","-4. enum sockmode {

 /*as a client, disconnected from server*/

1. };
2. #ifdef WIN32",Useful
"/** fullread is a wrapper around the read() function. This will repeat the call
 * to read() until it actually has read the complete number of bytes indicated
 * in nbytes or it fails with a condition that cannot be handled with a simple
 * retry of the read call.*/","-10.   if(success) {
-9.     return wcount;
-8.   }
-7.   errno = GetLastError();
-6.   return -1;
-5. }
-4. #undef  write
-3. #define write(a,b,c) write_wincon(a,b,c)
-2. #endif
-1. /*
 * fullread is a wrapper around the read() function. This will repeat",Useful
"/** fullwrite is a wrapper around the write() function. This will repeat the
 * call to write() until it actually has written the complete number of bytes
 * indicated in nbytes or it fails with a condition that cannot be handled
 * with a simple retry of the write call.*/","-10.       logmsg(""got 0 reading from stdin"");
-9.       return 0;
-8.     }
-7.     nread += rc;
-6.   } while((size_t)nread < nbytes);
-5.   if(verbose)
-4.     logmsg(""read %zd bytes"", nread);
-3.   return nread;
-2. }
-1. /*
 * fullwrite is a wrapper ",Useful
"/** read_stdin tries to read from stdin nbytes into the given buffer. This is a
 * blocking function that will only return TRUE when nbytes have actually been
 * read or FALSE when an unrecoverable error has been detected. Failure of this
 * function is an indication that the sockfilt process should terminate.*/","-10.       logmsg(""put 0 writing to stdout"");
-9.       return 0;
-8.     }
-7.     nwrite += wc;
-6.   } while((size_t)nwrite < nbytes);
-5.   if(verbose)
-4.     logmsg(""wrote %zd bytes"", nwrite);
-3.   return nwrite;
-2. }
-1. /*
 * read_stdin tries to",Useful
"/** write_stdout tries to write to stdio nbytes from the given buffer. This is a
 * blocking function that will only return TRUE when nbytes have actually been
 * written or FALSE when an unrecoverable error has been detected. Failure of
 * this function is an indication that the sockfilt process should terminate.*/","-10. static bool read_stdin(void *buffer, size_t nbytes)
-9. {
-8.   ssize_t nread = fullread(fileno(stdin), buffer, nbytes);
-7.   if(nread != (ssize_t)nbytes) {
-6.     logmsg(""exiting..."");
-5.     return FALSE;
-4.   }
-3.   return TRUE;
-2. }
-1. /*
",Useful
"/** WinSock select() does not support standard file descriptors,
 * it can only check SOCKETs. The following function is an attempt
 * to re-create a select() function with support for other handle types.
 *
 * select() function with support for WINSOCK2 sockets and all
 * other handle types supported by WaitForMultipleObjectsEx() as
 * well as disk files, anonymous and names pipes, and character input.
 *
 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms687028.aspx
 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms741572.aspx*/","-10.       width = 0;
-9.       optr = data;
-8.       left = sizeof(data);
-7.     }
-6.   }
-5.   if(width)
-4.     logmsg(""'%s'"", data);
-3. }
-2. #ifdef USE_WINSOCK
-1. /*
 * WinSock select() does not support standard file descriptors,
 * it can only ",Useful
"/*The handle represents a file on disk, this means:
        * - WaitForMultipleObjectsEx will always be signalled for it.
        * - comparison of current position in file and total size of
        *   the file can be used to check if we reached the end yet.
        *
        * Approach: Loop till either the internal event is signalled
        *           or if the end of the file has already been reached.*/","-3.   type = GetFileType(handle);
-2.   switch(type) {
-1.     case FILE_TYPE_DISK:
       /* The handle represents a file on disk, this means:
        * - WaitForMultipleObjectsEx will always be signalled for it.
        * - comparison of current positio",Useful
/*get total size of file*/,"-10.         * - comparison of current position in file and total size of
-9.         *   the file can be used to check if we reached the end yet.
-8.         *
-7.         * Approach: Loop till either the internal event is signalled
-6.         *        ",Useful
/*get the current position within the file*/,"-6.           length = 0;
-5.           size.QuadPart = 0;
-4.           size.LowPart = GetFileSize(handle, &length);
-3.           if((size.LowPart != INVALID_FILE_SIZE) ||
-2.              (GetLastError() == NO_ERROR)) {
-1.             size.HighPart = ",Useful
"/*compare position with size, abort if not equal*/","-5.             pos.QuadPart = 0;
-4.             pos.LowPart = SetFilePointer(handle, 0, &pos.HighPart,
-3.                                         FILE_CURRENT);
-2.             if((pos.LowPart != INVALID_SET_FILE_POINTER) ||
-1.                (GetLast",Useful
/*sleep and continue waiting*/,"-1.               if(size.QuadPart == pos.QuadPart) {

 /*sleep and continue waiting*/

1.                 SleepEx(0, FALSE);
2.                 ReleaseMutex(mutex);
3.                 continue;
4.               }
5.             }
6.           }",Useful
"/*there is some data available, stop waiting*/","-6.                 SleepEx(0, FALSE);
-5.                 ReleaseMutex(mutex);
-4.                 continue;
-3.               }
-2.             }
-1.           }

 /*there is some data available, stop waiting*/

1.           logmsg(""[select_ws_wait_thre",Useful
"/*The handle represents a character input, this means:
        * - WaitForMultipleObjectsEx will be signalled on any kind of input,
        *   including mouse and window size events we do not care about.
        *
        * Approach: Loop till either the internal event is signalled
        *           or we get signalled for an actual key-event.*/","-5.           break;
-4.         }
-3.       }
-2.       break;
-1.     case FILE_TYPE_CHAR:
       /* The handle represents a character input, this means:
        * - WaitForMultipleObjectsEx will be signalled on any kind of input,
        *   including ",Useful
/*check if this is an actual console handle*/,"-10.         * - WaitForMultipleObjectsEx will be signalled on any kind of input,
-9.         *   including mouse and window size events we do not care about.
-8.         *
-7.         * Approach: Loop till either the internal event is signalled
-6.      ",Useful
/*retrieve an event from the console buffer*/,"-1.           if(GetConsoleMode(handle, &ret)) {

 /*retrieve an event from the console buffer*/

1.             length = 0;
2.             if(PeekConsoleInput(handle, &inputrecord, 1, &length)) {",Useful
/*purge the non-key-event and continue waiting*/,"-1.               if(length == 1 && inputrecord.EventType != KEY_EVENT) {

 /*purge the non-key-event and continue waiting*/

1.                 ReadConsoleInput(handle, &inputrecord, 1, &length);
2.                 ReleaseMutex(mutex);
3.                ",Useful
"/*there is some data available, stop waiting*/","-6.                 SleepEx(0, FALSE);
-5.                 ReleaseMutex(mutex);
-4.                 continue;
-3.               }
-2.             }
-1.           }

 /*there is some data available, stop waiting*/

1.           logmsg(""[select_ws_wait_thre",Useful
"/*The handle represents an anonymous or named pipe, this means:
        * - WaitForMultipleObjectsEx will always be signalled for it.
        * - peek into the pipe and retrieve the amount of data available.
        *
        * Approach: Loop till either the internal event is signalled
        *           or there is data in the pipe available for reading.*/","-5.           break;
-4.         }
-3.       }
-2.       break;
-1.     case FILE_TYPE_PIPE:
       /* The handle represents an anonymous or named pipe, this means:
        * - WaitForMultipleObjectsEx will always be signalled for it.
        * - peek int",Useful
/*peek into the pipe and retrieve the amount of data available*/,"-7.           break;
-6.         }
-5.       }
-4.       break;
-3.     case FILE_TYPE_PIPE:
-2.        /* The handle represents an anonymous or named pipe, this means:
-1.         * - WaitForMultipleObjectsEx will always be signalled for it.
        * - ",Useful
"/*if there is no data available, sleep and continue waiting*/","-2.           length = 0;
-1.           if(PeekNamedPipe(handle, NULL, 0, NULL, &length, NULL)) {

 /*if there is no data available, sleep and continue waiting*/

1.             if(length == 0) {
2.               SleepEx(0, FALSE);
3.               Releas",Useful
"/*there is some data available, stop waiting*/","-6.                 SleepEx(0, FALSE);
-5.                 ReleaseMutex(mutex);
-4.                 continue;
-3.               }
-2.             }
-1.           }

 /*there is some data available, stop waiting*/

1.           logmsg(""[select_ws_wait_thre",Useful
/*allocate internal waiting data structure*/,"-10.       }
-9.       break;
-8.   }
-7.   return 0;
-6. }
-5. static HANDLE select_ws_wait(HANDLE handle, HANDLE signal,
-4.                              HANDLE abort, HANDLE mutex)
-3. {
-2.   struct select_ws_wait_data *data;
-1.   HANDLE thread = NUL",Useful
/*allocate internal array for the internal data*/,"-6.   mutex = CreateMutex(NULL, FALSE, NULL);
-5.   if(!mutex) {
-4.     CloseHandle(abort);
-3.     errno = ENOMEM;
-2.     return -1;
-1.   }

 /*allocate internal array for the internal data*/

1.   data = calloc(nfds, sizeof(struct select_ws_data));
2",Useful
/*allocate internal array for the internal event handles*/,"-7.   data = calloc(nfds, sizeof(struct select_ws_data));
-6.   if(!data) {
-5.     CloseHandle(abort);
-4.     CloseHandle(mutex);
-3.     errno = ENOMEM;
-2.     return -1;
-1.   }

 /*allocate internal array for the internal event handles*/

1.   handl",Useful
/*convert struct timeval to milliseconds*/,"-4.   if(nfds < 0) {
-3.     errno = EINVAL;
-2.     return -1;
-1.   }

 /*convert struct timeval to milliseconds*/

1.   if(tv) {
2.     timeout_ms = (DWORD)curlx_tvtoms(tv);
3.   }
4.   else {
5.     timeout_ms = INFINITE;
6.   }",Useful
/*wait for one of the internal handles to trigger*/,"-3.     handles[nfd] = exit_event;
-2.     wait += 1;
-1.   }

 /*wait for one of the internal handles to trigger*/

1.   wait = WaitForMultipleObjectsEx(wait, handles, FALSE, timeout_ms, FALSE);",Useful
"/*first handle stdin, stdout and stderr*/","-2.     if(wait != WAIT_FAILED && (wait - WAIT_OBJECT_0) <= i &&
-1.        WaitForSingleObjectEx(handle, 0, FALSE) == WAIT_OBJECT_0) {

 /*first handle stdin, stdout and stderr*/

1.       if(fd == fileno(stdin)) {",Useful
/*stdin is never ready for write or exceptional*/,"-1.       if(fd == fileno(stdin)) {

 /*stdin is never ready for write or exceptional*/

1.         FD_CLR(wsasock, writefds);
2.         FD_CLR(wsasock, exceptfds);
3.       }
4.       else if(fd == fileno(stdout) || fd == fileno(stderr)) {",Useful
/*stdout and stderr are never ready for read or exceptional*/,"-4.         FD_CLR(wsasock, writefds);
-3.         FD_CLR(wsasock, exceptfds);
-2.       }
-1.       else if(fd == fileno(stdout) || fd == fileno(stderr)) {

 /*stdout and stderr are never ready for read or exceptional*/

1.         FD_CLR(wsasock, readfd",Useful
/*try to handle the event with the WINSOCK2 functions*/,"-4.         FD_CLR(wsasock, readfds);
-3.         FD_CLR(wsasock, exceptfds);
-2.       }
-1.       else {

 /*try to handle the event with the WINSOCK2 functions*/

1.         wsaevents.lNetworkEvents = 0;
2.         error = WSAEnumNetworkEvents(wsasock,",Useful
/*remove from descriptor set if not ready for read/accept/close*/,"-1.           wsaevents.lNetworkEvents |= data[i].wsastate;

 /*remove from descriptor set if not ready for read/accept/close*/

1.           if(!(wsaevents.lNetworkEvents & (FD_READ|FD_ACCEPT|FD_CLOSE)))
2.             FD_CLR(wsasock, readfds);",Useful
/*remove from descriptor set if not ready for write/connect*/,"-2.           if(!(wsaevents.lNetworkEvents & (FD_READ|FD_ACCEPT|FD_CLOSE)))
-1.             FD_CLR(wsasock, readfds);

 /*remove from descriptor set if not ready for write/connect*/

1.           if(!(wsaevents.lNetworkEvents & (FD_WRITE|FD_CONNECT|FD_CL",Useful
/*remove from descriptor set if not exceptional*/,"-2.           if(!(wsaevents.lNetworkEvents & (FD_WRITE|FD_CONNECT|FD_CLOSE)))
-1.             FD_CLR(wsasock, writefds);

 /*remove from descriptor set if not exceptional*/

1.           if(!(wsaevents.lNetworkEvents & FD_OOB))
2.             FD_CLR(wsas",Useful
/*remove from all descriptor sets since this handle did not trigger*/,"-6.       if(FD_ISSET(wsasock, readfds) || FD_ISSET(wsasock, writefds) ||
-5.          FD_ISSET(wsasock, exceptfds)) {
-4.         ret++;
-3.       }
-2.     }
-1.     else {

 /*remove from all descriptor sets since this handle did not trigger*/

1.     ",Useful
"/*sockfdp is a pointer to an established stream or CURL_SOCKET_BAD

  if sockfd is CURL_SOCKET_BAD, listendfd is a listening socket we must
  accept()*/","-1. /*
  sockfdp is a pointer to an established stream or CURL_SOCKET_BAD

  if sockfd is CURL_SOCKET_BAD, listendfd is a listening socket we must
  accept()

 /*sockfdp is a pointer to an established stream or CURL_SOCKET_BAD

  if sockfd is CURL_SOCKET_",Useful
"/*As a last resort, quit if sockfilt process becomes orphan. Just in case
     parent ftpserver process has died without killing its sockfilt children*/","-7.   unsigned char buffer[17010];
-6.   char data[16];
-5.   if(got_exit_signal) {
-4.     logmsg(""signalled to die, exiting..."");
-3.     return FALSE;
-2.   }
-1. #ifdef HAVE_GETPPID

 /*As a last resort, quit if sockfilt process becomes orphan. Just i",Useful
/*server mode*/,"-10.   }
-9. #endif
-8.   timeout.tv_sec = 120;
-7.   timeout.tv_usec = 0;
-6.   FD_ZERO(&fds_read);
-5.   FD_ZERO(&fds_write);
-4.   FD_ZERO(&fds_err);
-3.   FD_SET((curl_socket_t)fileno(stdin), &fds_read);
-2.   switch(*mode) {
-1.   case PASSIVE_LISTEN",Useful
/*there's always a socket to wait for*/,"-1.     sockfd = listenfd;

 /*there's always a socket to wait for*/

1.     FD_SET(sockfd, &fds_read);
2.     maxfd = (int)sockfd;
3.     break;
4.   case PASSIVE_CONNECT:
5.     sockfd = *sockfdp;
6.     if(CURL_SOCKET_BAD == sockfd) {",Useful
"/*eeek, we are supposedly connected and then this cannot be -1 !*/","-6.     FD_SET(sockfd, &fds_read);
-5.     maxfd = (int)sockfd;
-4.     break;
-3.   case PASSIVE_CONNECT:
-2.     sockfd = *sockfdp;
-1.     if(CURL_SOCKET_BAD == sockfd) {

 /*eeek, we are supposedly connected and then this cannot be -1 !*/

1.       lo",Useful
/*stdin*/,"-3. };
-2. #ifdef WIN32
-1. /*
 * read-wrapper to support reading from stdin on Windows.

 /*stdin*/

1.  */
2. static ssize_t read_wincon(int fd, void *buf, size_t count)
3. {
4.   HANDLE handle = NULL;
5.   DWORD mode, rcount = 0;
6.   BOOL success;
7. ",Useful
/*there's always a socket to wait for*/,"-1.     sockfd = listenfd;

 /*there's always a socket to wait for*/

1.     FD_SET(sockfd, &fds_read);
2.     maxfd = (int)sockfd;
3.     break;
4.   case PASSIVE_CONNECT:
5.     sockfd = *sockfdp;
6.     if(CURL_SOCKET_BAD == sockfd) {",Useful
/*sockfd turns CURL_SOCKET_BAD when our connection has been closed*/,"-6.       FD_SET(sockfd, &fds_read);
-5.       maxfd = (int)sockfd;
-4.     }
-3.     break;
-2.   case ACTIVE:
-1.     sockfd = *sockfdp;

 /*sockfd turns CURL_SOCKET_BAD when our connection has been closed*/

1.     if(CURL_SOCKET_BAD != sockfd) {
2.   ",Useful
/*select() blocking behavior call on blocking descriptors please*/,"-1.   do {

 /*select() blocking behavior call on blocking descriptors please*/

1.     rc = select(maxfd + 1, &fds_read, &fds_write, &fds_err, &timeout);
2.     if(got_exit_signal) {
3.       logmsg(""signalled to die, exiting..."");
4.       return FALSE;",Useful
/*timeout*/,"-5. };
-4. static int select_ws(int nfds, fd_set *readfds, fd_set *writefds,
-3.                      fd_set *exceptfds, struct timeval *tv)
-2. {
-1.   HANDLE abort, mutex, signal, handle, *handles;
  DWORD timeout_ms, wait, nfd, nth, nws, i;

 /*timeout",Useful
"/*read from stdin, commands/data to be dealt with and possibly passed on
       to the socket

       protocol:

       4 letter command + LF [mandatory]

       4-digit hexadecimal data length + LF [if the command takes data]
       data                       [the data being as long as set above]

       Commands:

       DATA - plain pass-through data*/","-3.     return TRUE;
-2.   if(FD_ISSET(fileno(stdin), &fds_read)) {
-1.     ssize_t buffer_len;
    /* read from stdin, commands/data to be dealt with and possibly passed on
       to the socket

       protocol:

       4 letter command + LF [mandatory]
",Useful
/*send away on the socket*/,"-10.       logmsg(""> %zd bytes data, server => client"", buffer_len);
-9.       if(!read_stdin(buffer, buffer_len))
-8.         return FALSE;
-7.       lograw(buffer, buffer_len);
-6.       if(*mode == PASSIVE_LISTEN) {
-5.         logmsg(""*** We are disco",Useful
"/*there's no stream set up yet, this is an indication that there's a
         client connecting.*/","-10.           *mode = ACTIVE_DISCONNECT;
-9.       }
-8.       else
-7.         logmsg(""attempt to close already dead connection"");
-6.       return TRUE;
-5.     }
-4.   }
-3.   if((sockfd != CURL_SOCKET_BAD) && (FD_ISSET(sockfd, &fds_read)) ) {
-2.    ",Useful
/*store the new socket*/,"-10.       curl_socket_t newfd = accept(sockfd, NULL, NULL);
-9.       if(CURL_SOCKET_BAD == newfd) {
-8.         error = SOCKERRNO;
-7.         logmsg(""accept(%d, NULL, NULL) failed with error: (%d) %s"",
-6.                sockfd, error, strerror(error))",Useful
/*we have connected*/,"-10.       if(CURL_SOCKET_BAD == newfd) {
-9.         error = SOCKERRNO;
-8.         logmsg(""accept(%d, NULL, NULL) failed with error: (%d) %s"",
-7.                sockfd, error, strerror(error));
-6.       }
-5.       else {
-4.         logmsg(""====> Cli",Useful
"/*read from socket, pass on data to stdout*/","-3.       }
-2.       return TRUE;
-1.     }

 /*read from socket, pass on data to stdout*/

1.     nread_socket = sread(sockfd, buffer, sizeof(buffer));
2.     if(nread_socket > 0) {
3.       msnprintf(data, sizeof(data), ""DATA\n%04zx\n"", nread_socket);
",Useful
/*double the sleep for next attempt*/,"-10.                  error, strerror(error));
-9.           sclose(sock);
-8.           return CURL_SOCKET_BAD;
-7.         }
-6.         if(got_exit_signal) {
-5.           logmsg(""signalled to die, exiting..."");
-4.           sclose(sock);
-3.         ",Useful
"/*Real failure, listener port shall not be zero beyond this point.*/","-10.       break;
-9. #ifdef ENABLE_IPV6
-8.     case AF_INET6:
-7.       *listenport = ntohs(localaddr.sa6.sin6_port);
-6.       break;
-5. #endif
-4.     default:
-3.       break;
-2.     }
-1.     if(!*listenport) {

 /*Real failure, listener port shal",Useful
/*bindonly option forces no listening*/,"-8.       logmsg(""Apparently getsockname() succeeded, with listener port zero."");
-7.       logmsg(""A valid reason for this failure is a binary built without"");
-6.       logmsg(""proper network library linkage. This might not be the only"");
-5.       logm",Useful
/*start accepting connections*/,"-4.   if(bind_only) {
-3.     logmsg(""instructed to bind port without listening"");
-2.     return sock;
-1.   }

 /*start accepting connections*/

1.   rc = listen(sock, 5);
2.   if(0 != rc) {
3.     error = SOCKERRNO;
4.     logmsg(""listen(%d, 5) failed ",Useful
/*default*/,"-10.       width += 2;
-9.       optr += 2;
-8.       left -= 2;
-7.       break;
-6.     case '\r':
-5.       msnprintf(optr, left, ""\\r"");
-4.       width += 2;
-3.       optr += 2;
-2.       left -= 2;
-1.       break;
    default:

 /*default*/

1.   ",Useful
"/*for completeness, we support this option as well*/","-10.         serverlogfile = argv[arg++];
-9.     }
-8.     else if(!strcmp(""--ipv6"", argv[arg])) {
-7. #ifdef ENABLE_IPV6
-6.       ipv_inuse = ""IPv6"";
-5.       use_ipv6 = TRUE;
-4. #endif
-3.       arg++;
-2.     }
-1.     else if(!strcmp(""--ipv4"", arg",Useful
"/*Asked to actively connect to the specified local port instead of
         doing a passive server-style listening.*/","-10.     else if(!strcmp(""--port"", argv[arg])) {
-9.       arg++;
-8.       if(argc>arg) {
-7.         char *endptr;
-6.         unsigned long ulnum = strtoul(argv[arg], &endptr, 10);
-5.         port = curlx_ultous(ulnum);
-4.         arg++;
-3.       }
",Useful
/*Set an IP address to use with --connect; otherwise use localhost*/,"-10.            (ulnum < 1025UL) || (ulnum > 65535UL)) {
-9.           fprintf(stderr, ""sockfilt: invalid --connect argument (%s)\n"",
-8.                   argv[arg]);
-7.           return 0;
-6.         }
-5.         connectport = curlx_ultous(ulnum);
-4",Useful
"/*Active mode, we should connect to the given port number*/","-10.     sock = socket(AF_INET6, SOCK_STREAM, 0);
-9. #endif
-8.   if(CURL_SOCKET_BAD == sock) {
-7.     error = SOCKERRNO;
-6.     logmsg(""Error creating socket: (%d) %s"",
-5.            error, strerror(error));
-4.     write_stdout(""FAIL\n"", 5);
-3.    ",Useful
/*use this as stream*/,"-8.     if(rc) {
-7.       error = SOCKERRNO;
-6.       logmsg(""Error connecting to port %hu: (%d) %s"",
-5.              connectport, error, strerror(error));
-4.       write_stdout(""FAIL\n"", 5);
-3.       goto sockfilt_cleanup;
-2.     }
-1.     logmsg(""",Useful
/*no stream socket yet*/,"-5.     sock = sockdaemon(sock, &port);
-4.     if(CURL_SOCKET_BAD == sock) {
-3.       write_stdout(""FAIL\n"", 5);
-2.       goto sockfilt_cleanup;
-1.     }

 /*no stream socket yet*/

1.   }
2.   logmsg(""Running %s version"", ipv_inuse);
3.   if(connectp",Useful
"/** To properly set the return status of the process we
     * must raise the same signal SIGINT or SIGTERM that we
     * caught and let the old handler take care of it.*/","-10.   if(sock != CURL_SOCKET_BAD)
-9.     sclose(sock);
-8.   if(wrotepidfile)
-7.     unlink(pidname);
-6.   if(wroteportfile)
-5.     unlink(portname);
-4.   restore_signal_handlers(false);
-3.   if(got_exit_signal) {
-2.     logmsg(""============> sock",Useful
/*copy one single byte*/,"-10. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-9. {
-8.   struct WriteThis *pooh = (struct WriteThis *)userp;
-7.   int eof = !*pooh->readptr;
-6.   if(size*nmemb < 1)
-5.     return 0;
-4.   eof = pooh->sizeleft <= 0",Useful
/*advance pointer*/,"-10. {
-9.   struct WriteThis *pooh = (struct WriteThis *)userp;
-8.   int eof = !*pooh->readptr;
-7.   if(size*nmemb < 1)
-6.     return 0;
-5.   eof = pooh->sizeleft <= 0;
-4.   if(!eof)
-3.     pooh->sizeleft--;
-2.   if(!eof) {

 /*advance pointer*/

",Useful
/*we return 1 byte at a time!*/,"-10.   struct WriteThis *pooh = (struct WriteThis *)userp;
-9.   int eof = !*pooh->readptr;
-8.   if(size*nmemb < 1)
-7.     return 0;
-6.   eof = pooh->sizeleft <= 0;
-5.   if(!eof)
-4.     pooh->sizeleft--;
-3.   if(!eof) {

 /*we return 1 byte at a tim",Useful
/*no more data left to deliver*/,"-1.   }

 /*no more data left to deliver*/

1. }
2. int test(char *URL)
3. {
4.   CURL *easy = NULL;
5.   CURL *easy2 = NULL;
6.   curl_mime *mime = NULL;
7.   curl_mimepart *part;
8.   struct curl_slist *hdrs = NULL;
9.   CURLcode result;
10.   int res =",Useful
"/** Check proper copy/release of mime post data bound to a duplicated
   * easy handle.*/","-10. {
-9.   CURL *easy = NULL;
-8.   CURL *easy2 = NULL;
-7.   curl_mime *mime = NULL;
-6.   curl_mimepart *part;
-5.   struct curl_slist *hdrs = NULL;
-4.   CURLcode result;
-3.   int res = TEST_ERR_FAILURE;
-2.   struct WriteThis pooh;
-1.   /*
   * Ch",Useful
/*First set the URL that is about to receive our POST.*/,"-5.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-4.     fprintf(stderr, ""curl_global_init() failed\n"");
-3.     return TEST_ERR_MAJOR_BAD;
-2.   }
-1.   easy = curl_easy_init();

 /*First set the URL that is about to receive our POST.*/

1.   te",Useful
/*Prepare the callback structure.*/,"-1.   test_setopt(easy, CURLOPT_HEADER, 1L);

 /*Prepare the callback structure.*/

1.   pooh.readptr = data;
2.   pooh.sizeleft = (curl_off_t) strlen(data);
3.   pooh.freecount = 0;",Useful
/*Build the mime tree.*/,"-3.   pooh.readptr = data;
-2.   pooh.sizeleft = (curl_off_t) strlen(data);
-1.   pooh.freecount = 0;

 /*Build the mime tree.*/

1.   mime = curl_mime_init(easy);
2.   part = curl_mime_addpart(mime);
3.   curl_mime_data(part, ""hello"", CURL_ZERO_TERMINATE",Useful
/*Bind mime data to its easy handle.*/,"-10.   curl_mime_name(part, ""greeting"");
-9.   curl_mime_type(part, ""application/X-Greeting"");
-8.   curl_mime_encoder(part, ""base64"");
-7.   hdrs = curl_slist_append(hdrs, ""X-Test-Number: 654"");
-6.   curl_mime_headers(part, hdrs, TRUE);
-5.   part = cur",Useful
"/*Now free the mime structure: it should unbind it from the first
     easy handle.*/","-6.   easy2 = curl_easy_duphandle(easy);
-5.   if(!easy2) {
-4.     fprintf(stderr, ""curl_easy_duphandle() failed\n"");
-3.     res = TEST_ERR_FAILURE;
-2.     goto test_cleanup;
-1.   }

 /*Now free the mime structure: it should unbind it from the first
 ",Useful
/*Perform on the first handle: should not send any data.*/,"-2.   curl_mime_free(mime);

 /*Perform on the first handle: should not send any data.*/

1.   result = curl_easy_perform(easy);
2.   if(result) {
3.     fprintf(stderr, ""curl_easy_perform(original) failed\n"");
4.     res = (int) result;
5.     goto test_",Useful
"/*Perform on the second handle: if the bound mime structure has not been
     duplicated properly, it should cause a valgrind error.*/","-6.   result = curl_easy_perform(easy);
-5.   if(result) {
-4.     fprintf(stderr, ""curl_easy_perform(original) failed\n"");
-3.     res = (int) result;
-2.     goto test_cleanup;
-1.   }

 /*Perform on the second handle: if the bound mime structure has no",Useful
"/*Free the duplicated handle: it should call free_callback again.
     If the mime copy was bad or not automatically released, valgrind
     will signal it.*/","-6.   result = curl_easy_perform(easy2);
-5.   if(result) {
-4.     fprintf(stderr, ""curl_easy_perform(duplicated) failed\n"");
-3.     res = (int) result;
-2.     goto test_cleanup;
-1.   }

 /*Free the duplicated handle: it should call free_callback agai",Useful
/*Test that scheme is properly initialized on curl_easy_init.*/,"-7. int test(char *URL)
-6. {
-5.   CURL *curl, *dupe = NULL;
-4.   char *scheme;
-3.   int res = CURLE_OK;
-2.   global_init(CURL_GLOBAL_ALL);
-1.   easy_init(curl);
  /* Test that scheme is properly initialized on curl_easy_init.

 /*Test that scheme is",Useful
/*Test that a scheme is properly set after receiving an HTTP resource.*/,"-10.     res = CURLE_FAILED_INIT;
-9.     goto test_cleanup;
-8.   }
-7.   easy_setopt(curl, CURLOPT_URL, URL);
-6.   res = curl_easy_perform(curl);
-5.   if(res) {
-4.     fprintf(stderr, ""%s:%d curl_easy_perform() failed with code %d (%s)\n"",
-3.       ",Useful
/*number of sockets actually stored in array*/,"-10.  ***************************************************************************/
-9. #include ""test.h""
-8. #include <fcntl.h>
-7. #include ""testutil.h""
-6. #include ""warnless.h""
-5. #include ""memdebug.h""
-4. #define TEST_HANG_TIMEOUT 60 * 1000
-3. struc",Useful
/*max number of sockets that fit in allocated array*/,"-10. #include ""test.h""
-9. #include <fcntl.h>
-8. #include ""testutil.h""
-7. #include ""warnless.h""
-6. #include ""memdebug.h""
-5. #define TEST_HANG_TIMEOUT 60 * 1000
-4. struct Sockets
-3. {
-2.   curl_socket_t *sockets;

 /*max number of sockets that fit i",Useful
"/**
   * To ensure we only have each file descriptor once, we remove it then add
   * it again.*/","-4. static void addFd(struct Sockets *sockets, curl_socket_t fd, const char *what)
-3. {
-2.   /**
-1.    * To ensure we only have each file descriptor once, we remove it then add
   * it again.

 /**
   * To ensure we only have each file descriptor once,",Useful
/** Allocate array storage when required.*/,"-3.   fprintf(stderr, ""Add socket fd %d for %s\n"", (int) fd, what);
-2.   removeFd(sockets, fd, 0);
-1.   /*
   * Allocate array storage when required.

 /** Allocate array storage when required.*/

1.    */
2.   if(!sockets->sockets) {
3.     sockets->so",Useful
/*cleanup in test_cleanup*/,"-10.     sockets->sockets = malloc(sizeof(curl_socket_t) * 20U);
-9.     if(!sockets->sockets)
-8.       return;
-7.     sockets->max_count = 20;
-6.   }
-5.   else if(sockets->count + 1 > sockets->max_count) {
-4.     curl_socket_t *oldptr = sockets->soc",Useful
/** Add file descriptor to array.*/,"-6.       sockets->sockets = oldptr;
-5.       return;
-4.     }
-3.     sockets->max_count += 20;
-2.   }
-1.   /*
   * Add file descriptor to array.

 /** Add file descriptor to array.*/

1.    */
2.   sockets->sockets[sockets->count] = fd;
3.   ++socke",Useful
"/*can't open file, bail out*/","-2.   hd = fstat(fileno(hd_src), &file_info);
-1.   if(hd == -1) {

 /*can't open file, bail out*/

1.     fprintf(stderr, ""fstat() failed with error: %d (%s)\n"",
2.             errno, strerror(errno));
3.     fprintf(stderr, ""ERROR: cannot open file (%s)",Useful
/*specify target*/,"-1.   easy_setopt(curl, CURLOPT_UPLOAD, 1L);

 /*specify target*/

1.   easy_setopt(curl, CURLOPT_URL, URL);",Useful
/*now specify which file to upload*/,"-1.   easy_setopt(curl, CURLOPT_VERBOSE, 1L);

 /*now specify which file to upload*/

1.   easy_setopt(curl, CURLOPT_READDATA, hd_src);
2.   easy_setopt(curl, CURLOPT_USERPWD, libtest_arg3);
3.   easy_setopt(curl, CURLOPT_SSH_PUBLIC_KEYFILE, ""curl_client_",Useful
/*Check the sockets for reading / writing*/,"-10.     if(timeout.tv_sec != -1) {
-9.       int usTimeout = getMicroSecondTimeout(&timeout);
-8.       tv.tv_sec = usTimeout / 1000000;
-7.       tv.tv_usec = usTimeout % 1000000;
-6.     }
-5.     else if(maxFd <= 0) {
-4.       tv.tv_sec = 0;
-3.     ",Useful
/*Curl's timer has elapsed.*/,"-3.     checkFdSet(m, &sockets.read, &readSet, CURL_CSELECT_IN, ""read"");
-2.     checkFdSet(m, &sockets.write, &writeSet, CURL_CSELECT_OUT, ""write"");
-1.     if(timeout.tv_sec != -1 && getMicroSecondTimeout(&timeout) == 0) {

 /*Curl's timer has elapsed.*",Useful
/*deprecated API*/,"-8.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-7.     fprintf(stderr, ""curl_global_init() failed\n"");
-6.     return TEST_ERR_MAJOR_BAD;
-5.   }
-4.   asize = (int)sizeof(a);
-3.   ptr = curl_easy_escape(NULL, (char *)a, asize);
-2.   printf(""",Useful
/*deprecated API*/,"-8.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-7.     fprintf(stderr, ""curl_global_init() failed\n"");
-6.     return TEST_ERR_MAJOR_BAD;
-5.   }
-4.   asize = (int)sizeof(a);
-3.   ptr = curl_easy_escape(NULL, (char *)a, asize);
-2.   printf(""",Useful
/*weird input length*/,"-10.   if(!raw) {
-9.     res = TEST_ERR_MAJOR_BAD;
-8.     goto test_cleanup;
-7.   }
-6.   outlen = (int)strlen(raw);
-5.   printf(""[old] outlen == %d\n"", outlen);
-4.   printf(""[old] unescape == original? %s\n"",
-3.          memcmp(raw, a, outlen) ? ""n",Useful
/*weird input length*/,"-10.   if(!raw) {
-9.     res = TEST_ERR_MAJOR_BAD;
-8.     goto test_cleanup;
-7.   }
-6.   outlen = (int)strlen(raw);
-5.   printf(""[old] outlen == %d\n"", outlen);
-4.   printf(""[old] unescape == original? %s\n"",
-3.          memcmp(raw, a, outlen) ? ""n",Useful
/*just a value*/,"-3.   ptr = curl_easy_escape(NULL, (char *)a, -1);
-2.   printf(""escape -1 length: %s\n"", ptr);

 /*just a value*/

1.   ptr = curl_easy_unescape(NULL, (char *)""moahahaha"", -1, &outlen);
2.   printf(""unescape -1 length: %s %d\n"", ptr, outlen);
3. test_cle",Useful
"/*Get socket being used for this easy handle, otherwise CURL_SOCKET_BAD*/","-10. static int res = 0;
-9. static size_t callback(char *ptr, size_t size, size_t nmemb, void *data)
-8. {
-7.   ssize_t idx = ((CURL **) data) - easy;
-6.   curl_socket_t sock;
-5.   long longdata;
-4.   CURLcode code;
-3.   const size_t failure = (size",Useful
/*Track relationship between this easy handle and the socket.*/,"-10.             ""with code %d (%s)\n"",
-9.             __FILE__, __LINE__, (int)code, curl_easy_strerror(code));
-8.     res = TEST_ERR_MAJOR_BAD;
-7.     return failure;
-6.   }
-5.   if(longdata == -1L)
-4.     sock = CURL_SOCKET_BAD;
-3.   else
-2.   ",Useful
"/*An easy handle without previous socket, record the socket.*/","-1.     if(sockets[idx] == CURL_SOCKET_BAD) {

 /*An easy handle without previous socket, record the socket.*/

1.       sockets[idx] = sock;
2.     }
3.     else if(sock != sockets[idx]) {",Useful
"/*An easy handle with a socket different to previously
         tracked one, log and fail right away. Known bug #37.*/","-3.       sockets[idx] = sock;
-2.     }
-1.     else if(sock != sockets[idx]) {

 /*An easy handle with a socket different to previously
         tracked one, log and fail right away. Known bug #37.*/

1.       fprintf(stderr, ""Handle %d started on socke",Useful
/*Start a new handle if we aren't at the max*/,"-10.   multi_setopt(multi, CURLMOPT_MAX_TOTAL_CONNECTIONS, 10L);
-9. #endif
-8.   for(;;) {
-7.     struct timeval interval;
-6.     fd_set fdread;
-5.     fd_set fdwrite;
-4.     fd_set fdexcep;
-3.     long timeout = -99;
-2.     int maxfd = -99;
-1.   ",Useful
"/*At this point, maxfd is guaranteed to be greater or equal than -1.*/","-4.     FD_ZERO(&fdread);
-3.     FD_ZERO(&fdwrite);
-2.     FD_ZERO(&fdexcep);
-1.     multi_fdset(multi, &fdread, &fdwrite, &fdexcep, &maxfd);

 /*At this point, maxfd is guaranteed to be greater or equal than -1.*/

1.     if(state == NeedSocketForNewH",Useful
"/*At this point, timeout is guaranteed to be greater or equal than -1.*/","-10.         fprintf(stderr, ""Warning: socket did not open immediately for new ""
-9.                 ""handle (trying again)\n"");
-8.         continue;
-7.       }
-6.       state = num_handles < MAX_EASY_HANDLES ? ReadyForNewHandle
-5.                    ",Useful
"/*if there's no timeout and we get here on the last handle, we may
         already have read the last part of the stream so waiting makes no
         sense*/","-10.     fprintf(stderr, ""%s:%d num_handles %d timeout %ld running %d\n"",
-9.             __FILE__, __LINE__, num_handles, timeout, running);
-8.     if(timeout != -1L) {
-7.       int itimeout = (timeout > (long)INT_MAX) ? INT_MAX : (int)timeout;
-6.    ",Useful
"/*more addresses can be added here
     rcpt_list = curl_slist_append(rcpt_list, ""<others@example.com>"");*/","-10.     fprintf(stderr, ""curl_global_init() failed\n"");
-9.     return TEST_ERR_MAJOR_BAD;
-8.   }
-7.   curl = curl_easy_init();
-6.   if(!curl) {
-5.     fprintf(stderr, ""curl_easy_init() failed\n"");
-4.     curl_global_cleanup();
-3.     return TEST_E",Useful
/*copy one single byte*/,"-10.   (void)ptr;
-9.   (void)size;
-8.   (void)nmemb;
-7.   (void)userp;
-6.   return CURL_READFUNC_ABORT;
-5. #else
-4.   struct WriteThis *pooh = (struct WriteThis *)userp;
-3.   if(size*nmemb < 1)
-2.     return 0;
-1.   if(pooh->sizeleft) {

 /*copy ",Useful
/*advance pointer*/,"-10.   (void)size;
-9.   (void)nmemb;
-8.   (void)userp;
-7.   return CURL_READFUNC_ABORT;
-6. #else
-5.   struct WriteThis *pooh = (struct WriteThis *)userp;
-4.   if(size*nmemb < 1)
-3.     return 0;
-2.   if(pooh->sizeleft) {

 /*advance pointer*/

111",Useful
/*less data left*/,"-10.   (void)nmemb;
-9.   (void)userp;
-8.   return CURL_READFUNC_ABORT;
-7. #else
-6.   struct WriteThis *pooh = (struct WriteThis *)userp;
-5.   if(size*nmemb < 1)
-4.     return 0;
-3.   if(pooh->sizeleft) {

 /*less data left*/

111",Useful
/*we return 1 byte at a time!*/,"-10.   (void)userp;
-9.   return CURL_READFUNC_ABORT;
-8. #else
-7.   struct WriteThis *pooh = (struct WriteThis *)userp;
-6.   if(size*nmemb < 1)
-5.     return 0;
-4.   if(pooh->sizeleft) {

 /*we return 1 byte at a time!*/

1.   }",Useful
/*no more data left to deliver*/,"-1.   }

 /*no more data left to deliver*/

1. #endif
2. }
3. static int once(char *URL, bool oldstyle)
4. {
5.   CURL *curl;
6.   CURLcode res = CURLE_OK;
7.   CURLFORMcode formrc;
8.   struct curl_httppost *formpost = NULL;
9.   struct curl_httppost *la",Useful
/*Fill in the file upload field*/,"-10. {
-9.   CURL *curl;
-8.   CURLcode res = CURLE_OK;
-7.   CURLFORMcode formrc;
-6.   struct curl_httppost *formpost = NULL;
-5.   struct curl_httppost *lastptr = NULL;
-4.   struct WriteThis pooh;
-3.   struct WriteThis pooh2;
-2.   pooh.readptr = dat",Useful
"/*Now add the same data with another name and make it not look like
     a file upload but still using the callback*/","-10.     formrc = curl_formadd(&formpost,
-9.                           &lastptr,
-8.                           CURLFORM_COPYNAME, ""sendfile alternative"",
-7.                           CURLFORM_STREAM, &pooh,
-6.                           CURLFORM_CONTENT",Useful
/*Fill in the file upload field*/,"-10. {
-9.   CURL *curl;
-8.   CURLcode res = CURLE_OK;
-7.   CURLFORMcode formrc;
-6.   struct curl_httppost *formpost = NULL;
-5.   struct curl_httppost *lastptr = NULL;
-4.   struct WriteThis pooh;
-3.   struct WriteThis pooh2;
-2.   pooh.readptr = dat",Useful
/*Fill in a submit field too*/,"-7.   formrc = curl_formadd(&formpost,
-6.                         &lastptr,
-5.                         CURLFORM_COPYNAME, ""filename"",
-4.                         CURLFORM_COPYCONTENTS, ""postit2.c"",
-3.                         CURLFORM_END);
-2.   if(for",Useful
/*First set the URL that is about to receive our POST.*/,"-10.                         CURLFORM_END);
-9.   if(formrc)
-8.     printf(""curl_formadd(5) = %d\n"", (int)formrc);
-7.   curl = curl_easy_init();
-6.   if(!curl) {
-5.     fprintf(stderr, ""curl_easy_init() failed\n"");
-4.     curl_formfree(formpost);
-3.",Useful
/*Now specify we want to POST data*/,"-1.   test_setopt(curl, CURLOPT_URL, URL);

 /*Now specify we want to POST data*/

1.   test_setopt(curl, CURLOPT_POST, 1L);",Useful
/*Set the expected POST size*/,"-1.   test_setopt(curl, CURLOPT_POST, 1L);

 /*Set the expected POST size*/

1.   test_setopt(curl, CURLOPT_POSTFIELDSIZE, (long)pooh.sizeleft);",Useful
/*send a multi-part formpost*/,"-1.   test_setopt(curl, CURLOPT_READFUNCTION, read_callback);

 /*send a multi-part formpost*/

1.   test_setopt(curl, CURLOPT_HTTPPOST, formpost);",Useful
/*get verbose debug output please*/,"-1.   test_setopt(curl, CURLOPT_HTTPPOST, formpost);

 /*get verbose debug output please*/

1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);",Useful
/*include headers in the output*/,"-1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);

 /*include headers in the output*/

1.   test_setopt(curl, CURLOPT_HEADER, 1L);",Useful
"/*Perform the request, res will get the return code*/","-1.   test_setopt(curl, CURLOPT_HEADER, 1L);

 /*Perform the request, res will get the return code*/

1.   res = curl_easy_perform(curl);
2. test_cleanup:",Useful
/*new*/,"-10.   if(oldstyle) {
-9.     formrc = curl_formadd(&formpost,
-8.                           &lastptr,
-7.                           CURLFORM_COPYNAME, ""sendfile"",
-6.                           CURLFORM_STREAM, &pooh,
-5.                           CURLFOR",Useful
/*for setlocale()*/,#NAME?,Useful
/*for setmode()*/,"-2. #endif
-1. #ifdef HAVE_IO_H

 /*for setmode()*/

1. #endif
2. #ifdef HAVE_FCNTL_H",Useful
/*for setmode()*/,"-2. #endif
-1. #ifdef HAVE_IO_H

 /*for setmode()*/

1. #endif
2. #ifdef HAVE_FCNTL_H",Useful
"/** Winsock select() requires that at least one of the three fd_set
   * pointers is not NULL and points to a non-empty fdset. IOW Winsock
   * select() can not be used to sleep without a single fd_set.*/","-10. #include ""timediff.h""
-9. int select_wrapper(int nfds, fd_set *rd, fd_set *wr, fd_set *exc,
-8.                    struct timeval *tv)
-7. {
-6.   if(nfds < 0) {
-5.     SET_SOCKERRNO(EINVAL);
-4.     return -1;
-3.   }
-2. #ifdef USE_WINSOCK
-1.   /",Useful
/*for test timing*/,"-10. #else
-9.   struct timeval t;
-8.   curlx_mstotv(&t, ms);
-7.   select_wrapper(0, NULL, NULL, NULL, &t);
-6. #endif
-5. }
-4. char *libtest_arg2 = NULL;
-3. char *libtest_arg3 = NULL;
-2. int test_argc;
-1. char **test_argv;

 /*for test timing*/

1.",Useful
/*for unittests*/,"-1. #ifdef UNITTESTS

 /*for unittests*/

1. #endif
2. #ifdef CURLDEBUG
3. static void memory_tracking_init(void)
4. {
5.   char *env;",Useful
"/*if CURL_MEMDEBUG is set, this starts memory tracking message logging*/","-5. #endif
-4. #ifdef CURLDEBUG
-3. static void memory_tracking_init(void)
-2. {
-1.   char *env;

 /*if CURL_MEMDEBUG is set, this starts memory tracking message logging*/

1.   env = curl_getenv(""CURL_MEMDEBUG"");
2.   if(env) {",Useful
/*use the value as file name*/,"-2.   env = curl_getenv(""CURL_MEMDEBUG"");
-1.   if(env) {

 /*use the value as file name*/

1.     char fname[CURL_MT_LOGFNAME_BUFSIZE];
2.     if(strlen(env) >= CURL_MT_LOGFNAME_BUFSIZE)
3.       env[CURL_MT_LOGFNAME_BUFSIZE-1] = '\0';
4.     strcpy(fnam",Useful
"/*this weird stuff here is to make curl_free() get called before
       curl_dbg_memdebug() as otherwise memory tracking will log a free()
       without an alloc!*/","-6.     char fname[CURL_MT_LOGFNAME_BUFSIZE];
-5.     if(strlen(env) >= CURL_MT_LOGFNAME_BUFSIZE)
-4.       env[CURL_MT_LOGFNAME_BUFSIZE-1] = '\0';
-3.     strcpy(fname, env);
-2.     curl_free(env);
-1.     curl_dbg_memdebug(fname);

 /*this weird stuff ",Useful
"/*if CURL_MEMLIMIT is set, this enables fail-on-alloc-number-N feature*/","-1.   }

 /*if CURL_MEMLIMIT is set, this enables fail-on-alloc-number-N feature*/

1.   env = curl_getenv(""CURL_MEMLIMIT"");
2.   if(env) {
3.     char *endptr;
4.     long num = strtol(env, &endptr, 10);
5.     if((endptr != env) && (endptr == env + strl",Useful
/*returns a hexdump in a static memory area*/,"-10.     char *endptr;
-9.     long num = strtol(env, &endptr, 10);
-8.     if((endptr != env) && (endptr == env + strlen(env)) && (num > 0))
-7.       curl_dbg_memlimit(num);
-6.     curl_free(env);
-5.   }
-4. }
-3. #else
-2. #  define memory_tracking_i",Useful
"/** Setup proper locale from environment. This is needed to enable locale-
   * specific behaviour by the C library in order to test for undesired side
   * effects that could cause in libcurl.*/","-10.   int result;
-9. #ifdef O_BINARY
-8. #  ifdef __HIGHC__
-7.   _setmode(stdout, O_BINARY);
-6. #  else
-5.   setmode(fileno(stdout), O_BINARY);
-4. #  endif
-3. #endif
-2.   memory_tracking_init();
-1.   /*
   * Setup proper locale from environment. ",Useful
"/*prevent valgrind from reporting possibly lost memory (fd cache, ...)*/","-4.   fprintf(stderr, ""URL: %s\n"", URL);
-3.   result = test(URL);
-2. #ifdef USE_NSS
-1.   if(PR_Initialized())

 /*prevent valgrind from reporting possibly lost memory (fd cache, ...)*/

1.     PR_Cleanup();
2. #endif
3. #ifdef WIN32",Useful
"/*this tests if removing an easy handle immediately after multi
     perform has been called succeeds or not.*/","-10.   multi_init(multiHandle);
-9.   easy_init(curl);
-8.   easy_setopt(curl, CURLOPT_USERPWD, libtest_arg2);
-7.   easy_setopt(curl, CURLOPT_SSH_PUBLIC_KEYFILE, ""curl_client_key.pub"");
-6.   easy_setopt(curl, CURLOPT_SSH_PRIVATE_KEYFILE, ""curl_client_ke",Useful
/*no wakeup*/,"-10. {
-9.   CURLM *multi = NULL;
-8.   int numfds;
-7.   int i;
-6.   int res = 0;
-5.   struct timeval time_before_wait, time_after_wait;
-4.   (void)URL;
-3.   start_test_timing();
-2.   global_init(CURL_GLOBAL_ALL);
-1.   multi_init(multi);

 /*no wak",Useful
/*try a single wakeup*/,"-10.   time_before_wait = tutil_tvnow();
-9.   multi_poll(multi, NULL, 0, 1000, &numfds);
-8.   time_after_wait = tutil_tvnow();
-7.   if(tutil_tvdiff(time_after_wait, time_before_wait) < 500) {
-6.     fprintf(stderr, ""%s:%d curl_multi_poll returned too ",Useful
/*previous wakeup should not wake up this*/,"-10.   time_before_wait = tutil_tvnow();
-9.   multi_poll(multi, NULL, 0, 1000, &numfds);
-8.   time_after_wait = tutil_tvnow();
-7.   if(tutil_tvdiff(time_after_wait, time_before_wait) > 500) {
-6.     fprintf(stderr, ""%s:%d curl_multi_poll returned too ",Useful
/*Server returns http code 416.*/,"-2. #include ""memdebug.h""

 /*Server returns http code 416.*/

111",Useful
/*Server sends content-range hdr.*/,"-10.   The input parameters are:
-9.   - CURLOPT_RANGE/CURLOPT_RESUME_FROM
-8.   - CURLOPT_FAILONERROR
-7.   - Returned http code (2xx/416)
-6.   - Content-Range header present in reply.
-5. */
-4. #include ""memdebug.h""

 /*Server sends content-range hdr.",Useful
/*Body should be ignored.*/,"-10.   - CURLOPT_RANGE/CURLOPT_RESUME_FROM
-9.   - CURLOPT_FAILONERROR
-8.   - Returned http code (2xx/416)
-7.   - Content-Range header present in reply.
-6. */
-5. #include ""memdebug.h""

 /*Body should be ignored.*/

1. struct testparams {",Useful
/*Code that should be returned by curl_easy_perform().*/,"-2. struct testparams {

 /*Code that should be returned by curl_easy_perform().*/

1. };
2. static const struct testparams params[] = {
3.   { 0,                                                             CURLE_OK },
4.   {                              ",Useful
/*set in first.c*/,"-10. size_t WriteHeader(void *ptr, size_t size, size_t nmemb, void *stream);
-9. static unsigned long realHeaderSize = 0;
-8. int test(char *URL)
-7. {
-6.   long headerSize;
-5.   CURLcode code;
-4.   CURL *curl = NULL;
-3.   int res = 0;
-2.   global_in",Useful
"/*This test case and code is based on the bug recipe Joe Malicki provided for
 * bug report #1871269, fixed on Jan 14 2008 before the 7.18.0 release.*/",#NAME?,Useful
/*build request url*/,"-10.  *
-9.  ***************************************************************************/
-8. #include ""test.h""
-7. #ifdef HAVE_SYS_STAT_H
-6. #include <sys/stat.h>
-5. #endif
-4. #ifdef HAVE_FCNTL_H
-3. #include <fcntl.h>
-2. #endif
-1. #include ""memdebu",Useful
/*Do the ANNOUNCE*/,"-10.   sdpf = fopen(""log/file568.txt"", ""rb"");
-9.   if(!sdpf) {
-8.     fprintf(stderr, ""can't open log/file568.txt\n"");
-7.     res = TEST_ERR_MAJOR_BAD;
-6.     goto test_cleanup;
-5.   }
-4.   test_setopt(curl, CURLOPT_RTSP_REQUEST, CURL_RTSPREQ_ANNOUN",Useful
/*Make sure we can do a normal request now*/,"-6.   res = curl_easy_perform(curl);
-5.   if(res)
-4.     goto test_cleanup;
-3.   test_setopt(curl, CURLOPT_UPLOAD, 0L);
-2.   fclose(sdpf);
-1.   sdpf = NULL;

 /*Make sure we can do a normal request now*/

1.   stream_uri = suburl(URL, request++);
2. ",Useful
/*Make sure we can do a normal request now*/,"-6.   res = curl_easy_perform(curl);
-5.   if(res)
-4.     goto test_cleanup;
-3.   test_setopt(curl, CURLOPT_UPLOAD, 0L);
-2.   fclose(sdpf);
-1.   sdpf = NULL;

 /*Make sure we can do a normal request now*/

1.   stream_uri = suburl(URL, request++);
2. ",Useful
/*wait until the server has sent all response headers*/,"-10. {
-9.   data->easy_handle = curl;
-8.   data->response_received = 0;
-7.   data->paused = 0;
-6.   data->remaining_bytes = 3;
-5. }
-4. static size_t read_callback(char *ptr, size_t size, size_t nitems,
-3.                             void *userdata)",Useful
/*unused parameter*/,"-10.   else {
-9.     data->paused = 1;
-8.     return CURL_READFUNC_PAUSE;
-7.   }
-6. }
-5. static size_t write_callback(char *ptr, size_t size, size_t nmemb,
-4.                              void *userdata)
-3. {
-2.   struct cb_data *data = (struct cb",Useful
/*all response headers have been received*/,"-1.   (void)ptr;

 /*all response headers have been received*/

1.   data->response_received = 1;
2.   if(data->paused) {",Useful
/*continue to send request body data*/,"-2.   data->response_received = 1;
-1.   if(data->paused) {

 /*continue to send request body data*/

1.     data->paused = 0;
2.     curl_easy_pause(data->easy_handle, CURLPAUSE_CONT);
3.   }
4.   return totalsize;
5. }
6. static int perform_and_check_co",Useful
"/*Loop the transfer and cleanup the handle properly every lap. This will
     still reuse connections since the pool is in the shared object!*/","-10.   global_init(CURL_GLOBAL_ALL);
-9.   share = curl_share_init();
-8.   if(!share) {
-7.     fprintf(stderr, ""curl_share_init() failed\n"");
-6.     curl_global_cleanup();
-5.     return TEST_ERR_MAJOR_BAD;
-4.   }
-3.   curl_share_setopt(share, CURLSH",Useful
/*use the share object*/,"-4.   for(i = 0; i < 3; i++) {
-3.     CURL *curl = curl_easy_init();
-2.     if(curl) {
-1.       curl_easy_setopt(curl, CURLOPT_URL, URL);

 /*use the share object*/

1.       curl_easy_setopt(curl, CURLOPT_SHARE, share);",Useful
"/*Perform the request, res will get the return code*/","-1.       curl_easy_setopt(curl, CURLOPT_SHARE, share);

 /*Perform the request, res will get the return code*/

1.       res = curl_easy_perform(curl);",Useful
/*Check for errors*/,"-1.       res = curl_easy_perform(curl);

 /*Check for errors*/

1.       if(res != CURLE_OK)
2.         fprintf(stderr, ""curl_easy_perform() failed: %s\n"",
3.                 curl_easy_strerror(res));",Useful
"/** Make sure libcurl does not send a `Content-Length: -1` header when HTTP POST
 * size is unknown.*/",#NAME?,Useful
/*copy one single byte*/,"-10. struct WriteThis {
-9.   char *readptr;
-8.   size_t sizeleft;
-7. };
-6. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-5. {
-4.   struct WriteThis *pooh = (struct WriteThis *)userp;
-3.   if(size*nmemb < 1)
-2.     ",Useful
/*advance pointer*/,"-10.   char *readptr;
-9.   size_t sizeleft;
-8. };
-7. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-6. {
-5.   struct WriteThis *pooh = (struct WriteThis *)userp;
-4.   if(size*nmemb < 1)
-3.     return 0;
-2.   if(pooh",Useful
/*less data left*/,"-10.   size_t sizeleft;
-9. };
-8. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-7. {
-6.   struct WriteThis *pooh = (struct WriteThis *)userp;
-5.   if(size*nmemb < 1)
-4.     return 0;
-3.   if(pooh->sizeleft) {

 /*les",Useful
/*we return 1 byte at a time!*/,"-10. };
-9. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *userp)
-8. {
-7.   struct WriteThis *pooh = (struct WriteThis *)userp;
-6.   if(size*nmemb < 1)
-5.     return 0;
-4.   if(pooh->sizeleft) {

 /*we return 1 byte at a time",Useful
/*no more data left to deliver*/,"-1.   }

 /*no more data left to deliver*/

1. }
2. int test(char *URL)
3. {
4.   CURL *curl;
5.   CURLcode result = CURLE_OK;
6.   int res = 0;
7.   struct WriteThis pooh = { data, sizeof(data)-1 };
8.   global_init(CURL_GLOBAL_ALL);
9.   easy_init(curl)",Useful
/*Purposely omit to set CURLOPT_POSTFIELDSIZE*/,"-10. int test(char *URL)
-9. {
-8.   CURL *curl;
-7.   CURLcode result = CURLE_OK;
-6.   int res = 0;
-5.   struct WriteThis pooh = { data, sizeof(data)-1 };
-4.   global_init(CURL_GLOBAL_ALL);
-3.   easy_init(curl);
-2.   easy_setopt(curl, CURLOPT_URL, U",Useful
/*this should not happen with test case 599*/,"-10.  ***************************************************************************/
-9. #include ""test.h""
-8. #include ""memdebug.h""
-7. static int progress_callback(void *clientp, double dltotal,
-6.                              double dlnow, double ultota",Useful
/*First set the URL that is about to receive our POST.*/,"-10.   if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
-9.     fprintf(stderr, ""curl_global_init() failed\n"");
-8.     return TEST_ERR_MAJOR_BAD;
-7.   }
-6.   curl = curl_easy_init();
-5.   if(!curl) {
-4.     fprintf(stderr, ""curl_easy_init() failed",Useful
/*get verbose debug output please*/,"-2.   test_setopt(curl, CURLOPT_NOPROGRESS, 0L);
-1.   test_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_callback);

 /*get verbose debug output please*/

1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);",Useful
/*follow redirects*/,"-1.   test_setopt(curl, CURLOPT_VERBOSE, 1L);

 /*follow redirects*/

1.   test_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);",Useful
/*include headers in the output*/,"-1.   test_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

 /*include headers in the output*/

1.   test_setopt(curl, CURLOPT_HEADER, 1L);",Useful
"/*Perform the request, res will get the return code*/","-1.   test_setopt(curl, CURLOPT_HEADER, 1L);

 /*Perform the request, res will get the return code*/

1.   res = curl_easy_perform(curl);
2.   if(!res) {
3.     FILE *moo;
4.     res = curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD,
5.          ",Useful
/*Total bytes curl wants*/,"-5. #include ""test.h""
-4. #include ""memdebug.h""
-3. static char data [] = ""Hello Cloud!\n"";
-2. static size_t read_callback(char *ptr, size_t size, size_t nmemb, void *stream)
-1. {

 /*Total bytes curl wants*/

1.   if(amount < strlen(data)) {
2.     ret",Useful
/*http and proxy header list*/,"-10.     return strlen(data);
-9.   }
-8.   (void)stream;
-7.   memcpy(ptr, data, strlen(data));
-6.   return strlen(data);
-5. }
-4. int test(char *URL)
-3. {
-2.   CURL *curl = NULL;
-1.   CURLcode res = CURLE_FAILED_INIT;

 /*http and proxy header list",Useful
/*Create fake DNS entries for serverX.example.com for all handles*/,"-10.   CURL *curl[NUM_HANDLES] = {0};
-9.   int running;
-8.   CURLM *m = NULL;
-7.   int i;
-6.   char target_url[256];
-5.   char dnsentry[256];
-4.   struct curl_slist *slist = NULL, *slist2;
-3.   char *port = libtest_arg3;
-2.   char *address = libte",Useful
/*get an easy handle*/,"-1.   for(i = 0; i < NUM_HANDLES; i++) {

 /*get an easy handle*/

1.     easy_init(curl[i]);",Useful
"/*server%d.example.com:%s/path/1506%04i"",*/","-1.     msnprintf(target_url, sizeof(target_url),

 /*server%d.example.com:%s/path/1506%04i"",*/

1.               i + 1, port, i + 1);
2.     target_url[sizeof(target_url) - 1] = '\0';
3.     easy_setopt(curl[i], CURLOPT_URL, target_url);",Useful
"/*At this point, maxfd is guaranteed to be greater or equal than -1.*/","-4.       FD_ZERO(&rd);
-3.       FD_ZERO(&wr);
-2.       FD_ZERO(&exc);
-1.       multi_fdset(m, &rd, &wr, &exc, &maxfd);

 /*At this point, maxfd is guaranteed to be greater or equal than -1.*/

1.       select_test(maxfd + 1, &rd, &wr, &exc, &interval)",Useful
/*to ensure different end times*/,"-3.       select_test(maxfd + 1, &rd, &wr, &exc, &interval);
-2.       abort_on_test_timeout();
-1.     }

 /*to ensure different end times*/

1.   }
2. test_cleanup:",Useful
/*non linear*/,"-9. void init_by_array( unsigned long init_key[], int key_length )
-8. {
-7.     int i, j, k;
-6.     init_genrand( 19650218UL );
-5.     i = 1; j = 0;
-4.     k = ( N > key_length ? N : key_length );
-3.     for (; k; k-- )
-2.     {
-1.         mt[i] = ",Useful
/*for WORDSIZE > 32 machines*/,"-10. void init_by_array( unsigned long init_key[], int key_length )
-9. {
-8.     int i, j, k;
-7.     init_genrand( 19650218UL );
-6.     i = 1; j = 0;
-5.     k = ( N > key_length ? N : key_length );
-4.     for (; k; k-- )
-3.     {
-2.         mt[i] =",Useful
/*non linear*/,"-9. void init_by_array( unsigned long init_key[], int key_length )
-8. {
-7.     int i, j, k;
-6.     init_genrand( 19650218UL );
-5.     i = 1; j = 0;
-4.     k = ( N > key_length ? N : key_length );
-3.     for (; k; k-- )
-2.     {
-1.         mt[i] = ",Useful
/*for WORDSIZE > 32 machines*/,"-10. void init_by_array( unsigned long init_key[], int key_length )
-9. {
-8.     int i, j, k;
-7.     init_genrand( 19650218UL );
-6.     i = 1; j = 0;
-5.     k = ( N > key_length ? N : key_length );
-4.     for (; k; k-- )
-3.     {
-2.         mt[i] =",Useful
"/*! generates a random number on [0,0xffffffff]-interval
!
! @returns A random integer with 32-bit resolution.
!*/","-1. }

 /*! generates a random number on [0,0xffffffff]-interval
!
! @returns A random integer with 32-bit resolution.
!*/

1. double genrand_res53( void )
2. {
3.     unsigned long a = genrand_int32() >> 5, b = genrand_int32() >> 6;
4.     return ( (doub",Useful
/*generate N words at one time*/,"-5. unsigned long genrand_int32( void )
-4. {
-3.     unsigned long        y;
-2.     static unsigned long mag01[2] = { 0x0UL, MATRIX_A };

 /*generate N words at one time*/

1.     {
2.         int kk;",Useful
"/*! generates a random number on [0,0x7fffffff]-interval
!
! @returns A random integer with 31-bit resolution.
!*/","long genrand_int31( void )
{
    return (long) ( genrand_int32() >> 1 );
}

 /*! generates a random number on [0,0x7fffffff]-interval
!
! @returns A random integer with 31-bit resolution.
!*/

1. double genrand_res53( void )
2. {
3.     unsigned long a = genrand_int32() >> 5, b = genrand_int32() >> 6;
4.     return ( (double) a * 67108864.0 + (double) b ) * ( 1.0 / 9007199254740992.0 );
5. }",Useful
"/*! generates a random number on [0,1]-real-interval
!
! @returns A random number [0,1].
!*/","-4. long genrand_int31( void )
-3. {
-2.     return (long) ( genrand_int32() >> 1 );
-1. }

 /*! generates a random number on [0,1]-real-interval
!
! @returns A random number [0,1].
!*/

1. double genrand_res53( void )
2. {
3.     unsigned long a = genran",Useful
"/*! generates a random number on [0,1)-real-interval
!
! @returns A random number [0,1).
!*/","-1. }

 /*! generates a random number on [0,1)-real-interval
!
! @returns A random number [0,1).
!*/

1. double genrand_res53( void )
2. {
3.     unsigned long a = genrand_int32() >> 5, b = genrand_int32() >> 6;
4.     return ( (double) a * 67108864.0 + (",Useful
"/*! generates a random number on (0,1)-real-interval
!
! @returns A random number (0,1).
!*/","-1. }

 /*! generates a random number on (0,1)-real-interval
!
! @returns A random number (0,1).
!*/

1. double genrand_res53( void )
2. {
3.     unsigned long a = genrand_int32() >> 5, b = genrand_int32() >> 6;
4.     return ( (double) a * 67108864.0 + (",Useful
"/*! generates a random number on [0,1) with 53-bit resolution
!
! @returns A random numer [0,1) with 53-bit resolution.
!*/","-1. }

 /*! generates a random number on [0,1) with 53-bit resolution
!
! @returns A random numer [0,1) with 53-bit resolution.
!*/

1. double genrand_res53( void )
2. {
3.     unsigned long a = genrand_int32() >> 5, b = genrand_int32() >> 6;
4.     retur",Useful
/*Near-border comparison criterion (NBCC).*/,"-4. #include ""plplotP.h""
-3. #define INSIDE( ix, iy )    ( BETW( ix, xmin, xmax ) && BETW( iy, ymin, ymax ) )
-2. #define DTOR       ( PI / 180. )
-1. #define BINC       50

 /*Near-border comparison criterion (NBCC).*/

1. #define PL_NBCC    2",Useful
/*Variant of BETW that returns true if between or within PL_NBCC of it.*/,"-1. #define PL_NBCC    2

 /*Variant of BETW that returns true if between or within PL_NBCC of it.*/

1. #define BETW_NBCC( ix, ia, ib )    ( ( ( ix ) <= ( ia + PL_NBCC ) && ( ix ) >= ( ib - PL_NBCC ) ) || ( ( ix ) >= ( ia - PL_NBCC ) && ( ix ) <= ( ib + ",Useful
"/*Status codes ORed together in the return from notcrossed.
PL_NOT_CROSSED is set whenever the two line segments definitely
(i.e., intersection not near the ends or completely apart)
do not cross each other.

PL_NEAR_A1 is set if the intersect is near (+/- PL_NBCC) the first
end of line segment A.

PL_NEAR_A2 is set if the intersect is near (+/- PL_NBCC) the second
end of line segment A.

PL_NEAR_B1 is set if the intersect is near (+/- PL_NBCC) the first
end of line segment B.

PL_NEAR_B2 is set if the intersect is near (+/- PL_NBCC) the second
end of line segment B.

PL_NEAR_PARALLEL is set if the two line segments are nearly parallel
with each other, i.e., a change in one of the coordinates of up to
(+/- PL_NBCC) would render them exactly parallel.

PL_PARALLEL is set if the two line segments are exactly parallel
with each other.*/","-1. #define BETW_NBCC( ix, ia, ib )    ( ( ( ix ) <= ( ia + PL_NBCC ) && ( ix ) >= ( ib - PL_NBCC ) ) || ( ( ix ) >= ( ia - PL_NBCC ) && ( ix ) <= ( ib + PL_NBCC ) ) )

 /*Status codes ORed together in the return from notcrossed.
PL_NOT_CROSSED is set whe",Useful
/*Static function prototypes*/,"-10.     PL_NEAR_B1       = 0x8,
-9.     PL_NEAR_B2       = 0x10,
-8.     PL_NEAR_PARALLEL = 0x20,
-7.     PL_PARALLEL      = 0x40
-6. };
-5. struct point
-4. {
-3.     PLINT x, y;
-2. };
-1. static PLINT bufferleng, buffersize, *buffer;

 /*Static functi",Useful
"/*--------------------------------------------------------------------------
void plfill()

Pattern fills the polygon bounded by the input points.
For a number of vertices greater than PL_MAXPOLY-1, memory is managed via
malloc/free. Otherwise statically defined arrays of length PL_MAXPOLY
are used.
The final point is explicitly added if it doesn't match up to the first,
to prevent clipping problems.
--------------------------------------------------------------------------*/","-10. positive_orientation( PLINT n, PLINT_VECTOR x, PLINT_VECTOR y );
-9. static int
-8. number_crossings( PLINT *xcross, PLINT *ycross, PLINT *i2cross, PLINT ncross,
-7.                   PLINT i1, PLINT n1, PLINT_VECTOR x1, PLINT_VECTOR y1,
-6.         ",Useful
"/*--------------------------------------------------------------------------
void plfill3()

Pattern fills the polygon in 3d bounded by the input points.
For a number of vertices greater than PL_MAXPOLY-1, memory is managed via
malloc/free. Otherwise statically defined arrays of length PL_MAXPOLY
are used.
The final point is explicitly added if it doesn't match up to the first,
to prevent clipping problems.
--------------------------------------------------------------------------*/","-10. positive_orientation( PLINT n, PLINT_VECTOR x, PLINT_VECTOR y );
-9. static int
-8. number_crossings( PLINT *xcross, PLINT *ycross, PLINT *i2cross, PLINT ncross,
-7.                   PLINT i1, PLINT n1, PLINT_VECTOR x1, PLINT_VECTOR y1,
-6.         ",Useful
/*copy the vertices so we can clip without corrupting the input*/,"-10.     else
-9.     {
-8.         tx    = _tx;
-7.         ty    = _ty;
-6.         tz    = _tz;
-5.         xpoly = _xpoly;
-4.         ypoly = _ypoly;
-3.     }
-2.     plP_gdom( &xmin, &xmax, &ymin, &ymax );
-1.     plP_grange( &zscale, &zmin, &zmax ",Useful
"/*AWI: in the past we have used
plP_fill(xpoly, ypoly, n);
here, but our educated guess is this fill should be done via the clipping
interface instead as below.
No example tests this code so one of our users will end up inadvertently
testing this for us.

jc: I have checked, and both versions does give the same result, i.e., clipping
to the window boundaries. The reason is that the above plP_clip_poly() does
the clipping. To check this, is enough to diminish the x/y/z min/max arguments in
plw3d() in x08c. But let's keep it, although 10% slower...*/","-10.     n    = plP_clip_poly( n, V, 0, -1, xmax );
-9.     n    = plP_clip_poly( n, V, 1, 1, -ymin );
-8.     n    = plP_clip_poly( n, V, 1, -1, ymax );
-7.     n    = plP_clip_poly( n, V, 2, 1, -zmin );
-6.     n    = plP_clip_poly( n, V, 2, -1, zmax );",Useful
"/*If the original number of points is large, then free the arrays*/","-10. // No example tests this code so one of our users will end up inadvertently
-9. // testing this for us.
-8. //
-7. // jc: I have checked, and both versions does give the same result, i.e., clipping
-6. // to the window boundaries. The reason is that ",Useful
"/*--------------------------------------------------------------------------
void plfill_soft()

Pattern fills in software the polygon bounded by the input points.
--------------------------------------------------------------------------*/","-10. positive_orientation( PLINT n, PLINT_VECTOR x, PLINT_VECTOR y );
-9. static int
-8. number_crossings( PLINT *xcross, PLINT *ycross, PLINT *i2cross, PLINT ncross,
-7.                   PLINT i1, PLINT n1, PLINT_VECTOR x1, PLINT_VECTOR y1,
-6.         ",Useful
"/*do not write the hatching lines to the buffer as we have already
written the fill to the buffer*/","-10.     PLFLT  ci, si;
-9.     PLINT  plbuf_write;
-8.     double temp;
-7.     buffersize = 2 * BINC;
-6.     buffer     = (PLINT *) malloc( (size_t) buffersize * sizeof ( PLINT ) );
-5.     if ( !buffer )
-4.     {
-3.         plabort( ""plfill: Out of ",Useful
/*Loop over sets of lines in pattern*/,"-2.     plbuf_write       = plsc->plbuf_write;
-1.     plsc->plbuf_write = FALSE;

 /*Loop over sets of lines in pattern*/

1.     for ( k = 0; k < plsc->nps; k++ )
2.     {
3.         bufferleng = 0;
4.         temp = DTOR * plsc->inclin[k] * 0.1;
5.    ",Useful
/*Loop over points in polygon*/,"-10.         if ( dinc < 0 )
-9.             dinc = -dinc;
-8.         if ( dinc == 0 )
-7.             dinc = 1;
-6.         xp1 = x[n - 2];
-5.         yp1 = y[n - 2];
-4.         tran( &xp1, &yp1, (PLFLT) ci, (PLFLT) si );
-3.         xp2 = x[n - 1];
-",Useful
/*Sort list by y then x*/,"-10.         {
-9.             xp3 = x[i];
-8.             yp3 = y[i];
-7.             tran( &xp3, &yp3, (PLFLT) ci, (PLFLT) si );
-6.             buildlist( xp1, yp1, xp2, yp2, xp3, yp3, dinc );
-5.             xp1 = xp2;
-4.             yp1 = yp2;
-3.  ",Useful
"/*OK, now do the hatching*/","-2.         qsort( (void *) buffer, (size_t) bufferleng / 2,
-1.             (size_t) sizeof ( struct point ), compar );

 /*OK, now do the hatching*/

1.         i = 0;
2.         while ( i < bufferleng )
3.         {
4.             xp1 = buffer[i];
5.  ",Useful
/*Uh oh we're lost*/,"-10.             yp1 = buffer[i + 1];
-9.             i  += 2;
-8.             if ( yp2 != yp1 )
-7.             {
-6.                 fprintf( stderr, ""plfill: oh oh we are lost\n"" );
-5.                 for ( j = 0; j < bufferleng; j += 2 )
-4.         ",Useful
/*reinstate the buffer writing parameter and free memory*/,"-5.             }
-4.             tran( &xp1, &yp1, (PLFLT) ci, (PLFLT) ( -si ) );
-3.             plP_draphy( xp1, yp1 );
-2.         }
-1.     }

 /*reinstate the buffer writing parameter and free memory*/

1.     plsc->plbuf_write = plbuf_write;
2.    ",Useful
"/*--------------------------------------------------------------------------
Utility functions
--------------------------------------------------------------------------*/","-10. positive_orientation( PLINT n, PLINT_VECTOR x, PLINT_VECTOR y );
-9. static int
-8. number_crossings( PLINT *xcross, PLINT *ycross, PLINT *i2cross, PLINT ncross,
-7.                   PLINT i1, PLINT n1, PLINT_VECTOR x1, PLINT_VECTOR y1,
-6.         ",Useful
/*Build coordinate list*/,"-10.     }
-9.     else
-8.     {
-7.         cstep = -1;
-6.         min_y = yp2;
-5.         max_y = yp1;
-4.     }
-3.     nstep = ( yp3 > yp2 ? 1 : -1 );
-2.     if ( yp3 == yp2 )
-1.         nstep = 0;

 /*Build coordinate list*/

1.     ploty = ( mi",Useful
"/*Only reach here if y coords are equal, so sort by x*/","-10. int
-9. compar( const void *pnum1, const void *pnum2 )
-8. {
-7.     const struct point *pnt1, *pnt2;
-6.     pnt1 = (const struct point *) pnum1;
-5.     pnt2 = (const struct point *) pnum2;
-4.     if ( pnt1->y < pnt2->y )
-3.         return -1;
-2",Useful
"/*--------------------------------------------------------------------------
void plP_plfclp()

Fills a polygon within the clip limits.
--------------------------------------------------------------------------*/","-10. positive_orientation( PLINT n, PLINT_VECTOR x, PLINT_VECTOR y );
-9. static int
-8. number_crossings( PLINT *xcross, PLINT *ycross, PLINT *i2cross, PLINT ncross,
-7.                   PLINT i1, PLINT n1, PLINT_VECTOR x1, PLINT_VECTOR y1,
-6.         ",Useful
"/*Polygon 2 obviously has no dups nor two consective segments that
are parallel, but get rid of those type of segments in polygon 1
if they exist.*/","-10.     if ( npts < 3 || !draw )
-9.         return;
-8.     if ( ( x10 = (PLINT *) malloc( (size_t) npts * sizeof ( PLINT ) ) ) == NULL )
-7.     {
-6.         plexit( ""plP_plfclp: Insufficient memory"" );
-5.     }
-4.     if ( ( y10 = (PLINT *) malloc(",Useful
/*Must have at least three points that satisfy the above criteria.*/,"-10.     n1  = 0;
-9.     for ( i = 0; i < npts; i++ )
-8.     {
-7.         if ( !( x[i] == x[im1] && y[i] == y[im1] ) )
-6.         {
-5.             x10[n1]   = x[i];
-4.             y10[n1++] = y[i];
-3.         }
-2.         im1 = i;
-1.     }

 /*Mu",Useful
"/*Polygon 2 obviously has a positive orientation (i.e., as you
ascend in index along the boundary, the points just adjacent to
the boundary and on the left are interior points for the
polygon), but enforce this condition demanded by
fill_intersection_polygon for polygon 1 as well.*/","-6.     if ( n1 < 3 )
-5.     {
-4.         free( x10 );
-3.         free( y10 );
-2.         return;
-1.     }

 /*Polygon 2 obviously has a positive orientation (i.e., as you
ascend in index along the boundary, the points just adjacent to
the boundary a",Useful
"/*Insure that the first vertex of polygon 1 (starting with n1 -
1) that is not on the border of polygon 2 is definitely outside
polygon 2.*/","-10.         }
-9.         n1m1 = n1 - 1;
-8.         for ( i = 0; i < n1; i++ )
-7.         {
-6.             x1[n1m1 - i] = x10[i];
-5.             y1[n1m1 - i] = y10[i];
-4.         }
-3.         free( x10 );
-2.         free( y10 );
-1.     }

 /*Insu",Useful
/*Must have at least 3 points and draw() specified*/,"-10.             PLINT xmin, PLINT xmax, PLINT ymin, PLINT ymax,
-9.             void ( *draw )( short *, short *, PLINT ) )
-8. {
-7. #ifdef USE_FILL_INTERSECTION_POLYGON
-6.     PLINT *x10, *y10, *x1, *y1, *if1, i1start = 0, i, im1, n1, n1m1,
-5.       ",Useful
/*Now handle cases where fill polygon intersects two sides of the box*/,"-10.             xclp[4] = (short) xmin; yclp[4] = (short) ymin;
-9.             ( *draw )( xclp, yclp, 5 );
-8.             if ( xclp != _xclp )
-7.             {
-6.                 free( xclp );
-5.                 free( yclp );
-4.             }
-3.  ",Useful
"/*The cases where the fill region is divided 2/2
Divided horizontally*/","-10.                 printf( ""dir=%d, clipped points:\n"", dir );
-9.                 for ( i = 0; i < iclp; i++ )
-8.                     printf( "" x[%d]=%hd y[%d]=%hd"", i, xclp[i], i, yclp[i] );
-7.                 printf( ""\n"" );
-6.                 pri",Useful
"/*The cases where the fill region is divided 3/1 --
LL           LR           UR           UL
+-----+      +-----+      +-----+      +-----+
|     |      |     |      |    \|      |/    |
|     |      |     |      |     |      |     |
|\    |      |    /|      |     |      |     |
+-----+      +-----+      +-----+      +-----+

Note when we go the long way around, if the direction is reversed the
three vertices must be visited in the opposite order.

LL, short way around*/","-10.             {
-9.                 xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymin; iclp++;
-8.                 xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymax; iclp++;
-7.             }
-6.             else
-5.             {
-4.            ",Useful
"/*LL, long way around, counterclockwise*/","-5.         else if ( ( xclp[0] == (short) xmin && yclp[iclp - 1] == (short) ymin && dir < 0 ) ||
-4.                   ( yclp[0] == (short) ymin && xclp[iclp - 1] == (short) xmin && dir > 0 ) )
-3.         {
-2.             xclp[iclp] = (short) xmin; ycl",Useful
"/*LL, long way around, clockwise*/","-6.         else if ( ( xclp[0] == (short) xmin && yclp[iclp - 1] == (short) ymin && dir > 0 ) )
-5.         {
-4.             xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymin; iclp++;
-3.             xclp[iclp] = (short) xmax; yclp[iclp] = (short) ym",Useful
"/*LR, short way around*/","-6.         else if ( ( yclp[0] == ymin && xclp[iclp - 1] == xmin && dir < 0 ) )
-5.         {
-4.             xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymax; iclp++;
-3.             xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymax; iclp++;
-2. ",Useful
"/*LR, long way around, counterclockwise*/","-5.         else if ( ( xclp[0] == (short) xmax && yclp[iclp - 1] == (short) ymin && dir > 0 ) ||
-4.                   ( yclp[0] == (short) ymin && xclp[iclp - 1] == (short) xmax && dir < 0 ) )
-3.         {
-2.             xclp[iclp] = (short) xmax; ycl",Useful
"/*LR, long way around, clockwise*/","-6.         else if ( yclp[0] == (short) ymin && xclp[iclp - 1] == (short) xmax && dir > 0 )
-5.         {
-4.             xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymax; iclp++;
-3.             xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymax; ",Useful
"/*UR, short way around*/","-6.         else if ( xclp[0] == (short) xmax && yclp[iclp - 1] == (short) ymin && dir < 0 )
-5.         {
-4.             xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymin; iclp++;
-3.             xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymax; ",Useful
"/*UR, long way around, counterclockwise*/","-5.         else if ( ( xclp[0] == (short) xmax && yclp[iclp - 1] == (short) ymax && dir < 0 ) ||
-4.                   ( yclp[0] == (short) ymax && xclp[iclp - 1] == (short) xmax && dir > 0 ) )
-3.         {
-2.             xclp[iclp] = (short) xmax; ycl",Useful
"/*UR, long way around, clockwise*/","-6.         else if ( xclp[0] == (short) xmax && yclp[iclp - 1] == (short) ymax && dir > 0 )
-5.         {
-4.             xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymax; iclp++;
-3.             xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymin; ",Useful
"/*UL, short way around*/","-6.         else if ( yclp[0] == (short) ymax && xclp[iclp - 1] == (short) xmax && dir < 0 )
-5.         {
-4.             xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymin; iclp++;
-3.             xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymin; ",Useful
"/*UL, long way around, counterclockwise*/","-5.         else if ( ( xclp[0] == (short) xmin && yclp[iclp - 1] == (short) ymax && dir > 0 ) ||
-4.                   ( yclp[0] == (short) ymax && xclp[iclp - 1] == (short) xmin && dir < 0 ) )
-3.         {
-2.             xclp[iclp] = (short) xmin; ycl",Useful
"/*UL, long way around, clockwise*/","-6.         else if ( yclp[0] == (short) ymax && xclp[iclp - 1] == (short) xmin && dir > 0 )
-5.         {
-4.             xclp[iclp] = (short) xmin; yclp[iclp] = (short) ymin; iclp++;
-3.             xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymin; ",Useful
"/*Check for the case that only one side has been crossed
(AM) Just checking a single point turns out not to be
enough, apparently the crossed_*1 and crossed_*2 variables
are not quite what I expected.*/","-7.         else if ( xclp[0] == (short) xmin && yclp[iclp - 1] == (short) ymax && dir < 0 )
-6.         {
-5.             xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymax; iclp++;
-4.             xclp[iclp] = (short) xmax; yclp[iclp] = (short) ymin; ",Useful
"/*--------------------------------------------------------------------------
int circulation()

Returns the circulation direction for a given polyline: positive is
counterclockwise, negative is clockwise (right hand rule).

Used to get the circulation of the fill polygon around the bounding box,
when the fill polygon is larger than the bounding box.  Counts left
(positive) vs right (negative) hand turns using a cross product, instead of
performing all the expensive trig calculations needed to get this 100%
correct.  For the fill cases encountered in plplot, this treatment should
give the correct answer most of the time, by far.  When used with plshades,
the typical return value is 3 or -3, since 3 turns are necessary in order
to complete the fill region.  Only for really oddly shaped fill regions
will it give the wrong answer.

AM:
Changed the computation: use the outer product to compute the surface
area, the sign determines if the polygon is followed clockwise or
counterclockwise. This is more reliable. Floating-point numbers
are used to avoid overflow.
--------------------------------------------------------------------------*/","-10. positive_orientation( PLINT n, PLINT_VECTOR x, PLINT_VECTOR y );
-9. static int
-8. number_crossings( PLINT *xcross, PLINT *ycross, PLINT *i2cross, PLINT ncross,
-7.                   PLINT i1, PLINT n1, PLINT_VECTOR x1, PLINT_VECTOR y1,
-6.         ",Useful
/*PLFLT wrapper for !notpointinpolygon.*/,"-10.         x3 = x[i + 2];
-9.         y3 = y[i + 2];
-8.         xproduct = xproduct + ( x2 - x1 ) * ( y3 - y2 ) - ( y2 - y1 ) * ( x3 - x2 );
-7.     }
-6.     if ( xproduct > 0.0 )
-5.         direction = 1;
-4.     if ( xproduct < 0.0 )
-3.         di",Useful
"/*--------------------------------------------------------------------------
int notpointinpolygon()

Returns 0, 1, or 2 depending on whether the test point is definitely
inside, near the border, or definitely outside the polygon.
Notes:
This ""Ray casting algorithm"" has been described in
http://en.wikipedia.org/wiki/Point_in_polygon.
Logic still needs to be inserted to take care of the ""ray passes
through vertex"" problem in a numerically robust way.
--------------------------------------------------------------------------*/","-10. positive_orientation( PLINT n, PLINT_VECTOR x, PLINT_VECTOR y );
-9. static int
-8. number_crossings( PLINT *xcross, PLINT *ycross, PLINT *i2cross, PLINT ncross,
-7.                   PLINT i1, PLINT n1, PLINT_VECTOR x1, PLINT_VECTOR y1,
-6.         ",Useful
/*Determine a point outside the polygon*/,"-8. #define NEW_NOTPOINTINPOLYGON_CODE
-7. static int
-6. notpointinpolygon( PLINT n, PLINT_VECTOR x, PLINT_VECTOR y, PLINT xp, PLINT yp )
-5. {
-4. #ifdef NEW_NOTPOINTINPOLYGON_CODE
-3.     int i, im1, ifnotcrossed;
-2.     int count_crossings = 0;
-1.  ",Useful
"/*Determine whether the line between (xout, yout) and (xp, yp) intersects
one of the polygon segments.*/","-1.     xout = xout + ( xout - xmin ) + 10;

 /*Determine whether the line between (xout, yout) and (xp, yp) intersects
one of the polygon segments.*/

1.     im1 = n - 1;
2.     for ( i = 0; i < n; i++ )
3.     {
4.         if ( !( x[im1] == x[i] && y[im",Useful
"/*return 0 if the test point is definitely inside
(count_crossings odd), return 1 if the test point is near (see
above logic), and return 2 if the test point is definitely
outside the border (count_crossings even).*/","-10.             ifnotcrossed = notcrossed( &xintersect, &yintersect,
-9.                 x[im1], y[im1], x[i], y[i],
-8.                 xp, yp, xout, yout );
-7.             if ( !ifnotcrossed )
-6.                 count_crossings++;
-5.             els",Useful
/*Determine a point outside the polygon*/,"-8. #define NEW_NOTPOINTINPOLYGON_CODE
-7. static int
-6. notpointinpolygon( PLINT n, PLINT_VECTOR x, PLINT_VECTOR y, PLINT xp, PLINT yp )
-5. {
-4. #ifdef NEW_NOTPOINTINPOLYGON_CODE
-3.     int i, im1, ifnotcrossed;
-2.     int count_crossings = 0;
-1.  ",Useful
"/*Determine for each side whether the line segment between
our two points crosses the vertex*/","-10.         if ( xout > x[i] )
-9.         {
-8.             xout = x[i];
-7.         }
-6.         if ( xmax < x[i] )
-5.         {
-4.             xmax = x[i];
-3.         }
-2.     }
-1.     xout = xout - ( xmax - xout );

 /*Determine for each side w",Useful
"/*Line through the two fixed points:
Are x1 and x2 on either side?*/","-4.         if ( x1 == x2 && y1 == y2 )
-3.         {
-2.             continue;
-1.         }

 /*Line through the two fixed points:
Are x1 and x2 on either side?*/

1.         xv1 = x1 - xout;
2.         yv1 = y1 - yout;
3.         xv2 = x2 - xout;
4.   ",Useful
"/*Well, with the normal vector*/","-4.         xv1 = x1 - xout;
-3.         yv1 = y1 - yout;
-2.         xv2 = x2 - xout;
-1.         yv2 = y2 - yout;

 /*Well, with the normal vector*/

1.         inprod2 = xv2 * yvp - yv2 * xvp;
2.         if ( inprod1 * inprod2 >= 0.0 )
3.         {",Useful
"/*Line through the two vertices:
Are xout and xpp on either side?*/","-2.             continue;
-1.         }

 /*Line through the two vertices:
Are xout and xpp on either side?*/

1.         xvv = x2 - x1;
2.         yvv = y2 - y1;
3.         xv1 = xpp - x1;
4.         yv1 = ypp - y1;
5.         xv2 = xout - x1;
6.        ",Useful
"/*Return the result: an even number of crossings means the
point is outside the polygon*/","-2.         count_crossings++;
-1.     }

 /*Return the result: an even number of crossings means the
point is outside the polygon*/

1.     return !( count_crossings % 2 );
2. }",Useful
"/*Fill intersection of two simple polygons that do no self-intersect,
and which have no duplicate vertices or two consecutive edges that
are parallel.  A further requirement is that both polygons have a
positive orientation (see
http://en.wikipedia.org/wiki/Curve_orientation).  That is, as you
traverse the boundary in index order, the inside area of the
polygon is always on the left.  Finally, the first vertex of
polygon 1 (starting with n1 -1) that is not near the border of
polygon 2 must be outside polygon 2.  N.B. it is the calling
routine's responsibility to insure all those requirements are
satisfied.

Two polygons that do not self intersect must have an even number of
edge crossings between them.  (ignoring vertex intersections which
touch, but do not cross).  fill_intersection_polygon eliminates
those intersection crossings by recursion (calling the same routine
twice again with the second polygon split at a boundary defined by
the first intersection point, all polygon 1 vertices between the
intersections, and the second intersection point).  Once the
recursion has eliminated all crossing edges, fill or not using the
appropriate polygon depending on whether the first and second
polygons are identical or whether one of them is entirely inside
the other of them.  If ifextrapolygon is true, the fill step will
consist of another recursive call to the routine with
ifextrapolygon false, and the second polygon set to an additional
polygon defined by the stream (not yet implemented).*/","-1. #define MAX_RECURSION_DEPTH    10

 /*Fill intersection of two simple polygons that do no self-intersect,
and which have no duplicate vertices or two consecutive edges that
are parallel.  A further requirement is that both polygons have a
positive ori",Useful
"/*arguments to intersection_polygon:
recursion_depth is just what it says.
ifextrapolygon used to decide whether to use extra polygon from the stream.
fill is the fill routine.
x1, *y1, n1 define the polygon 1 vertices.
i1start is the first polygon 1 index to look at (because all the previous
ones have been completely processed).
x2, *y2, *if2, n2 define the polygon 2 vertices plus a status indicator
for each vertex which is 1 for a previous crossing and 2 for a polygon
1 vertex.
fill_status is 1 when polygons 1 and 2 _must_ include some joint
filled area and is -1 when polygons 1 and 2 _must_ include some
unfilled area.  fill_status of +/- 1 is determined from the
orientations of polygon 1 and 2 from the next higher recursion
level and how those two are combined to form the polygon 2
split at this recursion level.  fill_status = 0 occurs (at
recursion level 0) for polygons 1 and 2 that are independent of
each other.*/","-10. // twice again with the second polygon split at a boundary defined by
-9. // the first intersection point, all polygon 1 vertices between the
-8. // intersections, and the second intersection point).  Once the
-7. // recursion has eliminated all cros",Useful
/*Check that there are no duplicate vertices.*/,"-10.     if ( n2 < 3 )
-9.     {
-8.         plwarn( ""fill_intersection_polygon: Internal error; n2 < 3."" );
-7.         return;
-6.     }
-5.     if ( i1start < 0 || i1start >= n1 )
-4.     {
-3.         plwarn( ""fill_intersection_polygon: invalid i1star",Useful
"/*Follow polygon 1 (checking intersections with polygon 2 for each
segment of polygon 1) until you have accumulated two
intersections with polygon 2.  Here is an ascii-art illustration
of the situation.


2???2

2       2

--- 1    1
1            2         1      1 ...
X
1
X
2
1         1
1
2
2
2???2


""1"" marks polygon 1 vertices, ""2"" marks polygon 2 vertices, ""X""
marks the intersections, ""---"" stands for part of polygon 1
that has been previously searched for all possible intersections
from index 0, and ""..."" means polygon 1 continues
with more potential intersections above and/or below this diagram
before it finally hooks back to connect with the index 0 vertex.
""2???2"" stands for parts of polygon 2 that must connect with each other
(since the polygon 1 path between the two intersections is
known to be free of intersections.)

Polygon 2 is split at the boundary defined by the two
intersections and all (in this case three) polygon 1 vertices
between the two intersections for the next recursion level.  We
absolutely know for that boundary that no more intersections can
occur (both polygon 1 and polygon 2 are guaranteed not to
self-intersect) so we mark the status of those vertices with that
information so those polygon 2 split vertices will not be used to
search for further intersections at deeper recursion levels.
Note, we know nothing about whether the remaining ""2???2"" parts of the
split polygon 2 intersect with polygon 1 or not so those will
continued to be searched at deeper recursion levels. At the same
time, we absolutely know that the part of polygon 1 to the left of
rightmost x down to and including index 0 cannot yield more
intersections with any split of polygon 2 so we adjust the lower
limit of polygon 1 to be used for intersection searches at deeper
recursion levels.  The result should be that at sufficiently deep
recursion depth we always end up with the case that there are no
intersections to be found between polygon 1 and some polygon 2
split, and in that case we move on to the end phase below.*/","-10.             break;
-9.         i2m1 = i2;
-8.     }
-7.     if ( i2 < n2 )
-6.     {
-5.         plwarn( ""fill_intersection_polygon: Internal error; i2 < n2."" );
-4.         return;
-3.     }

 /*Follow polygon 1 (checking intersections with polygon ",Useful
"/*Have discovered the first two crossings for
polygon 1 at i1 = i1start or above.*/","-10.         {
-9.             i1intersect[ncrossed] = i1;
-8.             if ( ncrossed_change == 2 )
-7.             {
-6.                 ;
-5.             }
-4.             i1intersect[1] = i1;
-3.             ncrossed += ncrossed_change;
-2.         ",Useful
"/*New i1start is the same as the current i1 (just
in case there are more crossings to find between
i1m1 and i1.)*/","-10.             if ( ncrossed_change == 2 )
-9.             {
-8.                 ;
-7.             }
-6.             i1intersect[1] = i1;
-5.             ncrossed += ncrossed_change;
-4.             if ( ncrossed == 2 )
-3.             {

 /*New i1start",Useful
"/*Split polygon 2 at the boundary consisting of
first intersection, intervening (if any) range1
polygon 1 points and second intersection.
range1 must always be non-negative because i1
range only traversed once.*/","-1.                 i1start_new = i1;

 /*Split polygon 2 at the boundary consisting of
first intersection, intervening (if any) range1
polygon 1 points and second intersection.
range1 must always be non-negative because i1
range only traversed once.*/

1",Useful
"/*Polygon 2 intersects could be anywhere (since
i2 range repeated until get an intersect).
Divide polygon 2 into two polygons with a
common boundary consisting of the first intersect,
range1 points from polygon 1 starting at index
kkstart1 of polygon 1, and the second intersect.*/","-7.                 i1start_new = i1;

 /*Polygon 2 intersects could be anywhere (since
i2 range repeated until get an intersect).
Divide polygon 2 into two polygons with a
common boundary consisting of the first intersect,
range1 points from polygon 1 st",Useful
"/*Calculate polygon 2 index range in split 1 (the
split that proceeds beyond the second intersect with
ascending i2 values).*/","-8.                 range1 = i1intersect[1] - i1intersect[0];

 /*Calculate polygon 2 index range in split 1 (the
split that proceeds beyond the second intersect with
ascending i2 values).*/

1.                 range21 = i2intersect[0] - i2intersect[1];
2",Useful
"/*i2 intersect values range between 0 and n2 - 1 so
the smallest untransformed range21 value is -n2 + 1,
and the largest untransformed range21 value is n2 - 1.
This means the smallest transformed range21 value is 0
(which occurs only ifi2intersect[0] = i2intersect[1],
see more commentary for that special case below) while
the largest transformed range21 value is n2 - 1.*/","-3.                 range21 = i2intersect[0] - i2intersect[1];
-2.                 if ( range21 < 0 )
-1.                     range21 += n2;

 /*i2 intersect values range between 0 and n2 - 1 so
the smallest untransformed range21 value is -n2 + 1,
and the",Useful
"/*For this case, the two crossings occur within the same
polygon 2 boundary segment and if those two crossings
are in ascending/descending order in i2, then split 1
(the split with the positive fill_status) must include
all/none of the points in polygon 2.*/","-10.                 // i2 intersect values range between 0 and n2 - 1 so
-9.                 // the smallest untransformed range21 value is -n2 + 1,
-8.                 // and the largest untransformed range21 value is n2 - 1.
-7.                 // This",Useful
"/*Split 2 of polygon 2 consists of the
boundary + range22 (= n2 - range21) points
between kkstart22 (= i2intersect[1]-1) and i2intersect[0] in
descending order of polygon 2 indices.*/","-10.                     if ( ( ifxsort && ifascend && xintersect[0] < xintersect[1] ) ||
-9.                          ( !ifxsort && ifascend && yintersect[0] < yintersect[1] ) ||
-8.                          ( ifxsort && !ifascend && xintersect[0] >= xin",Useful
/*Starting i2 index of split 2.*/,"-1.                 range22 = n2 - range21;

 /*Starting i2 index of split 2.*/

1.                 kkstart22 = i2intersect[1] - 1;
2.                 if ( kkstart22 < 0 )
3.                     kkstart22 += n2;
4.                 nsplit2 = 2 + range1 + r",Useful
"/*Common boundary between split1 and split2.
N.B. Although basic index arithmetic for
split 2 is done in negative orientation
order because the index is decrementing
relative to the index of split 2, actually
store results in reverse order to preserve
the positive orientation that by assumption
both polygon 1 and 2 have.*/","-10.                     plexit( ""fill_intersection_polygon: Insufficient memory"" );
-9.                 }
-8.                 if ( ( ysplit2 = (PLINT *) malloc( (size_t) nsplit2 * sizeof ( PLINT ) ) ) == NULL )
-7.                 {
-6.                  ",Useful
"/*No wrap checks on kk index below because
it must always be in valid range (since
polygon 1 traversed only once).*/","-10.                 k = 0;
-9.                 xsplit1[k] = xintersect[0];
-8.                 ysplit1[k] = yintersect[0];
-7.                 ifsplit1[k] = 1;
-6.                 nsplit2m1 = nsplit2 - 1;
-5.                 xsplit2[nsplit2m1 - k] = xint",Useful
"/*N.B. the positive orientation of split1 is
preserved since the index order is the same
as that of polygon 2, and by assumption
that polygon and polygon 1 have identical
positive orientations.*/","-10.                 kstart = k + 1;
-9.                 kk = kkstart21;
-8.                 for ( k = kstart; k < nsplit1; k++ )
-7.                 {
-6.                     xsplit1[k] = x2[kk];
-5.                     ysplit1[k] = y2[kk];
-4.          ",Useful
"/*N.B. the positive orientation of split2 is
preserved since the index order is the same
as that of polygon 2, and by assumption
that polygon and polygon 1 have identical
positive orientations.*/","-9.                 kk = kkstart22;
-8.                 for ( k = kstart; k < nsplit2; k++ )
-7.                 {
-6.                     xsplit2[nsplit2m1 - k] = x2[kk];
-5.                     ysplit2[nsplit2m1 - k] = y2[kk];
-4.                     if",Useful
/*This end phase is reached only if no crossings are found.*/,"-10.                 return;
-9.             }
-8.         }
-7.         i1m1 = i1;
-6.     }
-5.     if ( ncrossed != 0 )
-4.     {
-3.         plwarn( ""fill_intersection_polygon: Internal error; ncrossed != 0."" );
-2.         return;
-1.     }

 /*This ",Useful
"/*For this case (recursion level 0) the two polygons are
completely independent with no crossings between them or
edges constructed from one another.

The intersection of polygon 2 and 1, must be either of them (in
which case fill with the inner one), or neither of them (in
which case don't fill at all).*/","-6.     {
-5.         if ( recursion_depth != 0 )
-4.         {
-3.             plwarn( ""fill_intersection_polygon: Internal error; fill_status == 0 for recursion_depth > 0"" );
-2.             return;
-1.         }

 /*For this case (recursion level 0) th",Useful
"/*Classify polygon 1 by looking for first vertex in polygon 1
that is definitely inside or outside polygon 2.*/","-10.             plwarn( ""fill_intersection_polygon: Internal error; fill_status == 0 for recursion_depth > 0"" );
-9.             return;
-8.         }

 /*Classify polygon 1 by looking for first vertex in polygon 1
that is definitely inside or outside po",Useful
"/*Classify polygon 2 by looking for first vertex in polygon 2
that is definitely inside or outside polygon 1.*/","-6.         for ( i1 = 0; i1 < n1; i1++ )
-5.         {
-4.             if ( ( ifnotpolygon1inpolygon2 =
-3.                        notpointinpolygon( n2, x2, y2, x1[i1], y1[i1] ) ) != 1 )
-2.                 break;
-1.         }

 /*Classify polygon 2 by",Useful
"/*Do not bother checking vertices already known to be on the
boundary with polygon 1.*/","-3.         ifnotpolygon2inpolygon1 = 1;
-2.         for ( i2 = 0; i2 < n2; i2++ )
-1.         {

 /*Do not bother checking vertices already known to be on the
boundary with polygon 1.*/

1.             if ( !if2[i2] && ( ifnotpolygon2inpolygon1 =
2.     ",Useful
"/*The polygons do not intersect each other so do not fill in this
case.*/","-7.             if ( !if2[i2] && ( ifnotpolygon2inpolygon1 =
-6.                                    notpointinpolygon( n1, x1, y1, x2[i2], y2[i2] ) ) != 1 )
-5.                 break;
-4.         }
-3.         if ( ifnotpolygon2inpolygon1 == 0 && ifnotpol",Useful
/*Polygon 2 definitely inside polygon 1.*/,"-3.             return;
-2.         else if ( ifnotpolygon2inpolygon1 == 0 )
-1.         {

 /*Polygon 2 definitely inside polygon 1.*/

1.             nfill = n2;
2.             xfiller = x2;
3.             yfiller = y2;
4.         }
5.         else if (",Useful
/*Polygon 1 definitely inside polygon 2.*/,"-6.             nfill = n2;
-5.             xfiller = x2;
-4.             yfiller = y2;
-3.         }
-2.         else if ( ifnotpolygon1inpolygon2 == 0 )
-1.         {

 /*Polygon 1 definitely inside polygon 2.*/

1.             nfill = n1;
2.           ",Useful
"/*Polygon 2 vertices near polygon 1 border and vice versa which
implies the polygons are identical.*/","-6.             nfill = n1;
-5.             xfiller = x1;
-4.             yfiller = y1;
-3.         }
-2.         else if ( ifnotpolygon2inpolygon1 == 1 && ifnotpolygon1inpolygon2 == 1 )
-1.         {

 /*Polygon 2 vertices near polygon 1 border and vice ",Useful
"/*Polygon 1 inscribed in polygon 2 or vice versa.  This is normally
unlikely for two independent polygons so the implementation is
ToDo.*/","-6.             nfill = n2;
-5.             xfiller = x2;
-4.             yfiller = y2;
-3.         }
-2.         else
-1.         {

 /*Polygon 1 inscribed in polygon 2 or vice versa.  This is normally
unlikely for two independent polygons so the impleme",Useful
"/*Returns a 0 status code
if the two line segments A, and B defined
by their end points (xA1, yA1, xA2, yA2, xB1, yB1, xB2, and yB2)
definitely (i.e., intersection point is not near the ends of either
of the line segments) cross each other.  Otherwise, return a status
code specifying the type of non-crossing (i.e., completely
separate, near one of the ends, parallel).
Only if status = 0, return the actual
intersection via the argument list pointers to
xintersect and yintersect.*/","-10.             xfill[ifill] = (short) xfiller[ifill];
-9.             yfill[ifill] = (short) yfiller[ifill];
-8.         }
-7.         ( *fill )( xfill, yfill, nfill );
-6.         free( xfill );
-5.         free( yfill );
-4.     }
-3.     return;
-2. ",Useful
"/*Two linear equations to be solved for x and y.
y = ((x - xA1)*yA2 + (xA2 - x)*yA1)/(xA2 - xA1)
y = ((x - xB1)*yB2 + (xB2 - x)*yB1)/(xB2 - xB1)

Transform those two equations to coordinate system with origin
at (xA1, yA1).
y' = x'*yA2A1/xA2A1
y' = ((x' - xB1A1)*yB2A1 + (xB2A1 - x')*yB1A1)/xB2B1
==>
x' = -(
(-xB1A1*yB2A1 + xB2A1*yB1A1)/xB2B1)/
(yB2B1/xB2B1 - yA2A1/xA2A1)
= (xB1A1*yB2A1 - xB2A1*yB1A1)*xA2A1/
(xA2A1*yB2B1 - yA2A1*xB2B1)*/","-4.     PLFLT xA2A1, yA2A1, xB2B1, yB2B1;
-3.     PLFLT xB1A1, yB1A1, xB2A1, yB2A1;
-2.     PLINT status = 0;

 /*Two linear equations to be solved for x and y.
y = ((x - xA1)*yA2 + (xA2 - x)*yA1)/(xA2 - xA1)
y = ((x - xB1)*yB2 + (xB2 - x)*yB1)/(xB2 - xB1",Useful
"/*The ""redundant"" x and y segment range checks (which include near the
end points) are needed for the vertical and the horizontal cases.*/","-10.     }
-9.     else
-8.     {
-7.         xB1A1 = xB1 - xA1;
-6.         yB1A1 = yB1 - yA1;
-5.         xB2A1 = xB2 - xA1;
-4.         yB2A1 = yB2 - yA1;
-3.         factor = ( xB1A1 * yB2A1 - yB1A1 * xB2A1 ) / factor;
-2.         fxintersect = factor",Useful
"/*The intersect is close (within +/- PL_NBCC) to an end point or
corresponds to a definite crossing of the two line segments.
Find out which.*/","-3.         if ( ( BETW_NBCC( fxintersect, xA1, xA2 ) && BETW_NBCC( fyintersect, yA1, yA2 ) ) &&
-2.              ( BETW_NBCC( fxintersect, xB1, xB2 ) && BETW_NBCC( fyintersect, yB1, yB2 ) ) )
-1.         {

 /*The intersect is close (within +/- PL_NBCC) ",Useful
"/*N.B. if none of the above conditions hold then status remains at
zero to signal we have a definite crossing.*/","-8.             if ( fabs( fxintersect - xA1 ) <= PL_NBCC && fabs( fyintersect - yA1 ) <= PL_NBCC )
-7.                 status = status | PL_NEAR_A1;
-6.             else if ( fabs( fxintersect - xA2 ) <= PL_NBCC && fabs( fyintersect - yA2 ) <= PL_NBCC )
",Useful
"/*Decide if polygon has a positive orientation or not.
Note the simple algorithm given in
http://en.wikipedia.org/wiki/Curve_orientation is incorrect for
non-convex polygons.  Instead, for the general nonintersecting case
use the polygon area method given by
http://local.wasp.uwa.edu.au/~pbourke/geometry/polyarea/ where
you project each edge of the polygon down to the X axis and take the
area of the enclosed trapezoid.  The trapezoid areas outside the
polygon are completely cancelled if you sum over all edges.  Furthermore,
the sum of the trapezoid areas have terms which are zero when calculated
with the telescoping rule so the final formula is quite simple.*/","-10.             status = status | PL_NOT_CROSSED;
-9.     }
-8.     if ( !status )
-7.     {
-6.         *xintersect = (PLINT) fxintersect;
-5.         *yintersect = (PLINT) fyintersect;
-4.     }
-3.     return status;
-2. }
-1. #ifdef USE_FILL_INTERSEC",Useful
"/*For the line with endpoints which are the (i1-1)th, and i1th
vertices of polygon 1 with polygon 2 find all definite crossings
with polygon 1.  (The full polygon 1 information is needed only to
help sort out (NOT IMPLEMENTED YET) ambiguous crossings near a
vertex of polygon 1.)  Sort those definite crossings in ascending
order along the line between the (i1-1)th and i1th vertices of
polygon 1, and return the first ncross (= 1 or = 2) crossings in the
xcross, ycross, and i2cross arrays.  Return a zero or positive
status code of the actual number of crossings retained up to the
maximum allowed value of ncross.  If some error occurred, return a
negative status code.*/","-10.         im1 = i;
-9.     }
-8.     if ( twice_area == 0. )
-7.     {
-6.         plwarn( ""positive_orientation: internal logic error, twice_area == 0."" );
-5.         return 0;
-4.     }
-3.     else
-2.         return twice_area > 0.;
-1. }

 /*For ",Useful
"/*Determine all crossings between the line between the (i1-1)th
and i1th vertices of polygon 1 and all edges of polygon 2.
Retain the lowest and (if ncross ==2) next lowest crossings in
order of x (or y if ifxsort is false) along the line from i1-1
to i1.*/","-10.         i1m1 += n1;
-9.     if ( !( ncross == 1 || ncross == 2 ) ||
-8.          ( x1[i1m1] == x1[i1] && y1[i1m1] == y1[i1] ) || n1 < 2 || n2 < 2 )
-7.     {
-6.         plwarn( ""findcrossings: invalid call"" );
-5.         return -1;
-4.     }
-3.   ",Useful
"/*--------------------------------------------------------------------------
void plwxtik()

Draws a tick parallel to x, using world coordinates
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*Minor tick*/,"-7. void
-6. plwxtik( PLFLT x, PLFLT y, PLBOOL minor, PLBOOL invert )
-5. {
-4.     PLINT length, below, above;
-3.     PLFLT height;
-2.     if ( minor )
-1.     {

 /*Minor tick*/

1.         height = plsc->minht;
2.     }
3.     else
4.     {",Useful
/*Major tick*/,"-4.         height = plsc->minht;
-3.     }
-2.     else
-1.     {

 /*Major tick*/

1.         height = plsc->majht;
2.     }
3.     length = MAX( ROUND( height * plsc->ypmm ), 1 );
4.     if ( invert )
5.     {
6.         below = 0;
7.         above = l",Useful
/*Actually draw the tick*/,"-10.     if ( invert )
-9.     {
-8.         below = 0;
-7.         above = length;
-6.     }
-5.     else
-4.     {
-3.         below = length;
-2.         above = 0;
-1.     }

 /*Actually draw the tick*/

1.     plxtik( plP_wcpcx( x ), plP_wcpcy( y ), ",Useful
"/*--------------------------------------------------------------------------
void plwytik()

Draws a tick parallel to y, using world coordinates
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*Minor tick*/,"-7. void
-6. plwxtik( PLFLT x, PLFLT y, PLBOOL minor, PLBOOL invert )
-5. {
-4.     PLINT length, below, above;
-3.     PLFLT height;
-2.     if ( minor )
-1.     {

 /*Minor tick*/

1.         height = plsc->minht;
2.     }
3.     else
4.     {",Useful
/*Major tick*/,"-4.         height = plsc->minht;
-3.     }
-2.     else
-1.     {

 /*Major tick*/

1.         height = plsc->majht;
2.     }
3.     length = MAX( ROUND( height * plsc->ypmm ), 1 );
4.     if ( invert )
5.     {
6.         below = 0;
7.         above = l",Useful
/*Actually draw the tick*/,"-10.     if ( invert )
-9.     {
-8.         below = 0;
-7.         above = length;
-6.     }
-5.     else
-4.     {
-3.         below = length;
-2.         above = 0;
-1.     }

 /*Actually draw the tick*/

1.     plxtik( plP_wcpcx( x ), plP_wcpcy( y ), ",Useful
"/*--------------------------------------------------------------------------
void plxtik()

Draws a tick parallel to x.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
void plytik()

Draws a tick parallel to y.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
void plstik()

Draws a slanting tick at position (mx,my) (measured in mm) of
vector length (dx,dy).
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
void plerx1()

Plot single horizontal error bar.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
void plery1()

Plot single vertical error bar.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
void plerrx()

Plot horizontal error bars (xmin(i),y(i)) to (xmax(i),y(i)).
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
void plerry()

Plot vertical error bars (x,ymin(i)) to (x(i),ymax(i)).
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
Call syntax for plshade():

void plshade(PLFLT *a, PLINT nx, PLINT ny, char *defined,
PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
PLFLT shade_min, PLFLT shade_max,
PLINT sh_color, PLFLT sh_width, PLINT min_color, PLFLT min_width,
PLINT max_color, PLFLT max_width, void (*fill)(), PLINT
rectangular, ...)

arguments:

PLFLT &(a[0][0])

Contains array to be plotted. The array must have been declared as
PLFLT a[nx][ny].  See following note on fortran-style arrays.

PLINT nx, ny

Dimension of array ""a"".

char &(defined[0][0])

Contains array of flags, 1 = data is valid, 0 = data is not valid.
This array determines which sections of the data is to be plotted.
This argument can be NULL if all the values are valid.  Must have been
declared as char defined[nx][ny].

PLFLT xmin, xmax, ymin, ymax

Defines the ""grid"" coordinates.  The data a[0][0] has a position of
(xmin,ymin).

void (*mapform)()

Transformation from `grid' coordinates to world coordinates.  This
pointer to a function can be NULL in which case the grid coordinates
are the same as the world coordinates.

PLFLT shade_min, shade_max

Defines the interval to be shaded. If shade_max <= shade_min, plshade
does nothing.

PLINT sh_cmap, PLFLT sh_color, PLFLT sh_width

Defines color map, color map index, and width used by the fill pattern.

PLINT min_color, PLFLT min_width, PLINT max_color, PLFLT max_width

Defines pen color, width used by the boundary of shaded region. The min
values are used for the shade_min boundary, and the max values are used
on the shade_max boundary.  Set color and width to zero for no plotted
boundaries.

void (*fill)()

Routine used to fill the region.  Use plfill.  Future version of plplot
may have other fill routines.

PLINT rectangular

Flag. Set to 1 if rectangles map to rectangles after (*mapform)() else
set to zero. If rectangular is set to 1, plshade tries to save time by
filling large rectangles.  This optimization fails if (*mapform)()
distorts the shape of rectangles.  For example a plot in polor
coordinates has to have rectangular set to zero.

Example mapform's:

Grid to world coordinate transformation.
This example goes from a r-theta to x-y for a polar plot.

void mapform(PLINT n, PLFLT *x, PLFLT *y) {
int i;
double r, theta;
for (i = 0; i < n; i++) {
r = x[i];
theta = y[i];
x[i] = r*cos(theta);
y[i] = r*sin(theta);
}
}

Grid was in cm, convert to world coordinates in inches.
Expands in x direction.

void mapform(PLINT n, PLFLT *x, PLFLT *y) {
int i;
for (i = 0; i < n; i++) {
x[i] = (1.0 / 2.5) * x[i];
y[i] = (1.0 / 2.5) * y[i];
}
}

--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*Global variables*/,"-8. #include ""plplotP.h""
-7. #include <float.h>
-6. #define NEG                  1
-5. #define POS                  8
-4. #define OK                   0
-3. #define UNDEF                64
-2. #define NUMBER_BISECTIONS    10
-1. #define linear( val1, val2",Useful
/*Function prototypes*/,"-6. static PLFLT sh_max, sh_min;
-5. static int   min_points, max_points, n_point;
-4. static int   min_pts[4], max_pts[4];
-3. static PLINT pen_col_min, pen_col_max;
-2. static PLFLT pen_wd_min, pen_wd_max;
-1. static PLFLT int_val;

 /*Function prototyp",Useful
"/*N.B. This routine only needed by the Fortran interface to distinguish
the case where pltr and pltr_data are NULL.  So don't put declaration in
header which might encourage others to use this in some other context.*/","-10.              PLF2EVAL_callback c2eval, PLPointer c2eval_data,
-9.              PLDEFINED_callback defined,
-8.              PLINT nx, PLINT ny,
-7.              PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-6.              PLFLT shade_min, PLFLT s",Useful
"/*--------------------------------------------------------------------------
plshades()

Shade regions via a series of calls to plshade.
All arguments are the same as plshade except the following:
clevel is a pointer to an array of values representing
the shade edge values, nlevel-1 is
the number of different shades, (nlevel is the number of shade edges),
fill_width is the pattern fill width, and cont_color and cont_width
are the color and width of the contour drawn at each shade edge.
(if cont_color <= 0 or cont_width <=0, no such contours are drawn).
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
plfshades()

Shade regions via a series of calls to plfshade1.
All arguments are the same as plfshade1 except the following:
clevel is a pointer to an array of values representing
the shade edge values, nlevel-1 is
the number of different shades, (nlevel is the number of shade edges),
fill_width is the pattern fill width, and cont_color and cont_width
are the color and width of the contour drawn at each shade edge.
(if cont_color <= 0 or cont_width <=0, no such contours are drawn).
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*Color range to use*/,"-10.            PLDEFINED_callback defined,
-9.            PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-8.            PLFLT_VECTOR clevel, PLINT nlevel, PLFLT fill_width,
-7.            PLINT cont_color, PLFLT cont_width,
-6.            PLFILL_callbac",Useful
"/*The constants in order mean
(1) color map1,
(0, 0, 0, 0) all edge effects will be done with plcont rather
than the normal plshade drawing which gets partially blocked
when sequential shading is done as in the present case*/","-8.     color_min   = plsc->cmap1_min;
-7.     color_max   = plsc->cmap1_max;
-6.     color_range = color_max - color_min;
-5.     for ( i = 0; i < nlevel - 1; i++ )
-4.     {
-3.         shade_min   = clevel[i];
-2.         shade_max   = clevel[i + 1];
-",Useful
"/*N.B. This routine only needed by the Fortran interface to distinguish
the case where pltr and pltr_data are NULL.  So don't put declaration in
header which might encourage others to use this in some other context.*/","-10.              PLF2EVAL_callback c2eval, PLPointer c2eval_data,
-9.              PLDEFINED_callback defined,
-8.              PLINT nx, PLINT ny,
-7.              PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-6.              PLFLT shade_min, PLFLT s",Useful
"/*plc2eval, (PLPointer) &cgrid,*/","-10. plshade_null( PLFLT_MATRIX a, PLINT nx, PLINT ny, PLDEFINED_callback defined,
-9.               PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-8.               PLFLT shade_min, PLFLT shade_max,
-7.               PLINT sh_cmap, PLFLT sh_color, PLFLT",Useful
"/*plc2eval, (PLPointer) &cgrid,*/","-10. plshade_null( PLFLT_MATRIX a, PLINT nx, PLINT ny, PLDEFINED_callback defined,
-9.               PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-8.               PLFLT shade_min, PLFLT shade_max,
-7.               PLINT sh_cmap, PLFLT sh_color, PLFLT",Useful
/*plshade1 deprecated as of plplot-5.14.0*/,"-7.         defined, nx, ny, xmin,
-6.         xmax, ymin, ymax, shade_min, shade_max,
-5.         sh_cmap, sh_color, sh_width,
-4.         min_color, min_width, max_color, max_width,
-3.         fill, rectangular, pltr, pltr_data );
-2. }
-1. #ifdef PL_D",Useful
"/*--------------------------------------------------------------------------
plfshade()

Shade region.
Array values are determined by the input function and the passed data.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
plfshade1()

Shade region.

This function is a plf2ops variant of c_plfshade and c_plfshade1.  It
differs from plfshade in that it supports a ""defined"" callback (like
c_plshade and c_plfshade1) rather than a ""defined mask"" (like plfshade
even though it is not yet implemented).
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
plshade_int()

Shade region -- this routine does all the work

This routine is internal so the arguments can and will change.
To retain some compatibility between versions, you must go through
some stub routine!

4/95

parameters:

f2eval, f2eval_data:  data to plot
defined: defined mask (old API - implimented)
nx, ny: array dimensions
xmin, xmax, ymin, ymax: grid coordinates
shade_min, shade_max: shade region with values between ...
sh_cmap, sh_color, sh_width: shading parameters, width is only for hatching
min_color, min_width: line parameters for boundary (minimum)
max_color, max_width: line parameters for boundary (maximum)
set min_width == 0 and max_width == 0 for no contours
fill: fill function, set to NULL for no shading (contour plot)
rectangular: flag set to 1 if pltr() maps rectangles to rectangles
this helps optimize the plotting
pltr: function to map from grid to plot coordinates


--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*Entire rectangle can be filled*/,"-6.             if ( count >= UNDEF )
-5.                 continue;
-4.             if ( count == 4 * POS )
-3.                 continue;
-2.             if ( count == 4 * NEG )
-1.                 continue;

 /*Entire rectangle can be filled*/

1.       ",Useful
/*find biggest rectangle that fits*/,"-2.             if ( count == 4 * OK )
-1.             {

 /*find biggest rectangle that fits*/

1.                 if ( rectangular )
2.                 {
3.                     big_recl( c0 + iy, ny, nx - ix, ny - iy, &i, &j );
4.                 }
5.  ",Useful
/*Only part of rectangle can be filled*/,"-10.                     {
-9.                         x[i] = xmin + x[i] * dx;
-8.                         y[i] = ymin + y[i] * dy;
-7.                     }
-6.                 }
-5.                 if ( fill != NULL )
-4.                     exfill( fi",Useful
"/*n = number of end of line segments
min_points = number times shade_min meets edge
max_points = number times shade_max meets edge*/","-10.                 for ( i = 0; i < n; i++ )
-9.                 {
-8.                     x[i] = xmin + x[i] * dx;
-7.                     y[i] = ymin + y[i] * dy;
-6.                 }
-5.             }
-4.             if ( min_points == 4 )
-3.      ",Useful
/*special cases: check number of times a contour is in a box*/,"-10.                     y[i] = ymin + y[i] * dy;
-9.                 }
-8.             }
-7.             if ( min_points == 4 )
-6.                 slope = plctestez( a, nx, ny, ix, iy, shade_min );
-5.             if ( max_points == 4 )
-4.             ",Useful
/*2 contour lines in box*/,"-9.             switch ( ( min_points << 3 ) + max_points )
-8.             {
-7.             case 000:
-6.             case 020:
-5.             case 002:
-4.             case 022:
-3.                 if ( fill != NULL && n > 0 )
-2.                     ",Useful
/*3 contours*/,"-10.                     selected_polygon( fill, defined, x, y, 4, 5, 6, 7 );
-9.                 }
-8.                 else
-7.                 {
-6.                     selected_polygon( fill, defined, x, y, 0, 1, 6, 7 );
-5.                     selecte",Useful
"/*--------------------------------------------------------------------------
set_cond()

Fills out condition code array.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
find_interval()

Two points x(0) = a0, (condition code c0) x(1) = a1, (condition code c1)
return interval on the line that are shaded

returns 0 : no points to be shaded 1 : x[0] <= x < 1 is the interval 2 :
x[0] <= x <= x[1] < 1 interval to be shaded n_point, max_points,
min_points are incremented location of min/max_points are stored
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
selected_polygon()

Draws a polygon from points in x[] and y[].
Point selected by v1..v4
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
bisect()

Find boundary recursively by bisection.
(x1, y1) is in the defined region, while (x2, y2) in the undefined one.
The result is returned in
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
exfill()

Fills a polygon from points in x[] and y[] with all points in
undefined regions dropped and replaced by points at the bisected
edge of the defined region.
Note, undefined regions that are confined to the areas between polygon
points are completely ignored.  Also, a range of undefined polygon points
are simply replaced with a straight line with accurately bisected end
points.  So this routine can produce problematic plotted results
if the polygon is not a lot smaller than the typical resolution of
the defined region.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*Slightly less than 2 n points are required for xx, yy, but
allocate room for 2 n to be safe.*/","-10.         ( *fill )( n, x, y );
-9.     else
-8.     {
-7.         PLFLT *xx;
-6.         PLFLT *yy;
-5.         PLFLT xb, yb;
-4.         PLINT count      = 0;
-3.         PLINT im1        = n - 1;
-2.         PLINT is_defined = defined( x[im1], y[im1",Useful
/*is_defined tells whether im1 point was in defined region.*/,"-6.         if ( ( xx = (PLFLT *) malloc( 2 * (size_t) n * sizeof ( PLFLT ) ) ) == NULL )
-5.             plexit( ""exfill: out of memory for xx"" );
-4.         if ( ( yy = (PLFLT *) malloc( 2 * (size_t) n * sizeof ( PLFLT ) ) ) == NULL )
-3.             p",Useful
"/*Cross from undefined (at im1) to defined region.
Bisect for the first point inside the defined region
and add it to xx, yy.*/","-4.             if ( defined( x[i], y[i] ) )
-3.             {
-2.                 if ( !is_defined )
-1.                 {

 /*Cross from undefined (at im1) to defined region.
Bisect for the first point inside the defined region
and add it to xx, yy.*/

",Useful
"/*--------------------------------------------------------------------------
big_recl()

find a big rectangle for shading

2 goals: minimize calls to (*fill)()
keep ratio 1:3 for biggest rectangle

only called by plshade()

assumed that a 1 x 1 square already fits

c[] = condition codes
ny = c[1][0] == c[ny]  (you know what I mean)

returns ix, iy = length of rectangle in grid units

ix < dx - 1
iy < dy - 1

If iy == 1 -> ix = 1 (so that cond code can be set to skip)
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*ok_x = ok to expand in x direction
x = current number of points in x direction*/","-9. #define RATIO    3
-8. #define COND( x, y )    cond_code[x * ny + y]
-7. static void
-6. big_recl( int *cond_code, register int ny, int dx, int dy,
-5.           int *ix, int *iy )
-4. {
-3.     int          ok_x, ok_y, j;
-2.     register int i, x, y",Useful
/*expand in vertical*/,"-10.     ok_x = ok_y = 1;
-9.     x    = y = 2;
-8.     while ( ok_x || ok_y )
-7.     {
-6. #ifdef RATIO
-5.         if ( RATIO * x <= y || RATIO * y <= x )
-4.             break;
-3. #endif
-2.         if ( ok_y )
-1.         {

 /*expand in vertical*/
",Useful
/*row is ok*/,"-10.                 continue;
-9.             cond = &COND( 0, y );
-8.             for ( i = 0; i < x; i++ )
-7.             {
-6.                 if ( *cond != OK )
-5.                     break;
-4.                 cond += ny;
-3.             }
-2.   ",Useful
/*expand in x direction*/,"-9. #define RATIO    3
-8. #define COND( x, y )    cond_code[x * ny + y]
-7. static void
-6. big_recl( int *cond_code, register int ny, int dx, int dy,
-5.           int *ix, int *iy )
-4. {
-3.     int          ok_x, ok_y, j;
-2.     register int i, x, y",Useful
/*column is OK*/,"-10.             if ( x == dx )
-9.                 continue;
-8.             cond = &COND( x, 0 );
-7.             for ( i = 0; i < y; i++ )
-6.             {
-5.                 if ( *cond++ != OK )
-4.                     break;
-3.             }
-2.  ",Useful
/*found the largest rectangle of 'ix' by 'iy'*/,"-5.                 x++;
-4.                 ok_x = 1;
-3.             }
-2.         }
-1.     }

 /*found the largest rectangle of 'ix' by 'iy'*/

1.     *ix = --x;
2.     *iy = --y;",Useful
/*set condition code to UNDEF in interior of rectangle*/,"-2.     *ix = --x;
-1.     *iy = --y;

 /*set condition code to UNDEF in interior of rectangle*/

1.     for ( i = 1; i < x; i++ )
2.     {
3.         cond = &COND( i, 1 );
4.         for ( j = 1; j < y; j++ )
5.         {
6.             *cond++ = UNDEF;
",Useful
"/*--------------------------------------------------------------------------
draw_boundary()

Draw boundaries of contour regions based on min_pts[], and max_pts[].
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*swap points 1 and 3*/,"-10. static void
-9. draw_boundary( PLINT slope, PLFLT *x, PLFLT *y )
-8. {
-7.     int i;
-6.     if ( pen_col_min != 0 && pen_wd_min != 0 && min_points != 0 )
-5.     {
-4.         plcol0( pen_col_min );
-3.         plwidth( pen_wd_min );
-2.         if",Useful
/*swap points 1 and 3*/,"-10. static void
-9. draw_boundary( PLINT slope, PLFLT *x, PLFLT *y )
-8. {
-7.     int i;
-6.     if ( pen_col_min != 0 && pen_wd_min != 0 && min_points != 0 )
-5.     {
-4.         plcol0( pen_col_min );
-3.         plwidth( pen_wd_min );
-2.         if",Useful
"/*--------------------------------------------------------------------------

plctest( &(x[0][0]), PLFLT level)
where x was defined as PLFLT x[4][4];

determines if the contours associated with level have
positive slope or negative slope in the box:

(2,3)   (3,3)

(2,2)   (3,2)

this is heuristic and can be changed by the user

return 1 if positive slope
0 if negative slope

algorithmn:
1st test:
find length of contours assuming positive and negative slopes
if the length of the negative slope contours is much bigger
than the positive slope, then the slope is positive.
(and vice versa)
(this test tries to minimize the length of contours)

2nd test:
if abs((top-right corner) - (bottom left corner)) >
abs((top-left corner) - (bottom right corner)) ) then
return negatiave slope.
(this test tries to keep the slope for different contour levels
the same)
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*find min contour*/,"-10.         temp = sorted[j];
-9.         i    = j - 1;
-8.         while ( i >= 0 && sorted[i] > temp )
-7.         {
-6.             sorted[i + 1] = sorted[i];
-5.             i--;
-4.         }
-3.         sorted[i + 1] = temp;
-2.     }

 /*find min ",Useful
/*one contour line*/,"-3.     temp = int_val * ceil( sorted[0] / int_val );
-2.     if ( temp < sorted[1] )
-1.     {

 /*one contour line*/

1.         for ( i = 0; i < 4; i++ )
2.         {
3.             if ( t[i] < temp )
4.                 return i / 2;
5.         }
6.   ",Useful
/*find max contour*/,"-6.         for ( i = 0; i < 4; i++ )
-5.         {
-4.             if ( t[i] < temp )
-3.                 return i / 2;
-2.         }
-1.     }

 /*find max contour*/

1.     temp = int_val * floor( sorted[3] / int_val );
2.     if ( temp > sorted[2] )
3",Useful
/*one contour line*/,"-3.     temp = int_val * ceil( sorted[0] / int_val );
-2.     if ( temp < sorted[1] )
-1.     {

 /*one contour line*/

1.         for ( i = 0; i < 4; i++ )
2.         {
3.             if ( t[i] < temp )
4.                 return i / 2;
5.         }
6.   ",Useful
/*nothing better to do - be consistant*/,"-6.         for ( i = 0; i < 4; i++ )
-5.         {
-4.             if ( t[i] > temp )
-3.                 return i / 2;
-2.         }
-1.     }

 /*nothing better to do - be consistant*/

1.     return POSITIVE_SLOPE;
2. }",Useful
"/*--------------------------------------------------------------------------
plctestez

second routine - easier to use
fills in x[4][4] and calls plctest

test location a[ix][iy] (lower left corner)
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*software fallback for gradient.*/,"-10. // GNU Library General Public License for more details.
-9. //
-8. // You should have received a copy of the GNU Library General Public License
-7. // along with PLplot; if not, write to the Free Software
-6. // Foundation, Inc., 51 Franklin Street, ",Useful
"/*define where plshades plots gradient for software fallback for
gradient.*/","-2. static void
-1. plgradient_soft( PLINT n, PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT angle );

 /*define where plshades plots gradient for software fallback for
gradient.*/

111",Useful
"/*--------------------------------------------------------------------------
void plgradient()

Draws a linear gradient at an angle relative to the increasing x
direction for the polygon bounded by the x and y vertices.  x, and
y are expressed in world coordinates, and angle (in the world
coordinate system) is expressed in degrees.  The gradient is
expressed using colour and transparency information from cmap1.  The
geometrical gradient direction is specified by the angle argument.
The 0. to 1. range of the independent variable of cmap1 corresponds
to the range of the polygon in the direction specified by angle.
--------------------------------------------------------------------------*/","-2. static PLINT
-1. gradient_defined( PLFLT x, PLFLT y );

 /*--------------------------------------------------------------------------
void plgradient()

Draws a linear gradient at an angle relative to the increasing x
direction for the polygon bounded",Useful
"/*Plot line corresponding to gradient to give visual
debugging cue.
plline( NGRAD, dxgrad, dygrad );*/","-10.             ypoly[i] = plP_wcpcy( y[i] );
-9.         }
-8.         if ( x[0] != x[n - 1] || y[0] != y[n - 1] )
-7.         {
-6.             n++;
-5.             xpoly[n - 1] = plP_wcpcx( x[0] );
-4.             ypoly[n - 1] = plP_wcpcy( y[0] );
-3.",Useful
/*Check the original number of points*/,"-10.         {
-9.             n++;
-8.             xpoly[n - 1] = plP_wcpcx( x[0] );
-7.             ypoly[n - 1] = plP_wcpcy( y[0] );
-6.         }
-5.         plP_plfclp( xpoly, ypoly, n, plsc->clpxmi, plsc->clpxma,
-4.             plsc->clpymi, plsc->",Useful
"/*--------------------------------------------------------------------------
void plgradient_soft()

Software fallback for gradient.  See c_plgradient for an explanation
of the arguments.
--------------------------------------------------------------------------*/","-2. static PLINT
-1. gradient_defined( PLFLT x, PLFLT y );

 /*--------------------------------------------------------------------------
void plgradient_soft()

Software fallback for gradient.  See c_plgradient for an explanation
of the arguments.
------",Useful
/*Find x and y range of polygon.*/,"-3.     plsc->n_polygon = n;
-2.     plsc->x_polygon = x;
-1.     plsc->y_polygon = y;

 /*Find x and y range of polygon.*/

1.     xmin = x[0];
2.     xmax = xmin;
3.     ymin = y[0];
4.     ymax = ymin;",Useful
"/*Define NEDGE shade edges (or NEDGE-1 shade levels)
from 0. to 1.*/","-1.     #define NEDGE    101

 /*Define NEDGE shade edges (or NEDGE-1 shade levels)
from 0. to 1.*/

1.     if ( ( edge = (PLFLT *) malloc( NEDGE * sizeof ( PLFLT ) ) ) == NULL )
2.         plexit( ""plgradient_soft: Insufficient memory for large polygon""
",Useful
/*Calculate broken-down time from continuous time for current stream.*/,"-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*Configure transformation between continuous and broken-down time (and
vice versa) for current stream.*/","-7. void
-6. c_plbtime( PLINT *year, PLINT *month, PLINT *day, PLINT *hour, PLINT *min, PLFLT *sec, PLFLT ctime )
-5. {
-4.     double qsas_sec;
-3.     btimeqsas( year, month, day, hour, min, &qsas_sec, ctime, plsc->qsasconfig );
-2.     *sec = (PLFLT) q",Useful
"/*Default transformation between continuous and broken-down time
(and vice versa) defined here for PLplot.
Note the PLplot default is not necessarily the same as the
libqsastime default.*/","-5. void
-4. c_plconfigtime( PLFLT scale, PLFLT offset1, PLFLT offset2, PLINT ccontrol, PLBOOL ifbtime_offset, PLINT year, PLINT month, PLINT day, PLINT hour, PLINT min, PLFLT sec )
-3. {
-2.     if ( scale == 0. )
-1.     {

 /*Default transformation bet",Useful
/*Calculate continuous time from broken-down time for current stream.*/,"-7.         configqsas( 1. / 86400., 0., 0., 0x0, 1, 1970, 0, 1, 0, 0, 0., &( plsc->qsasconfig ) );
-6.     }
-5.     else
-4.     {
-3.         configqsas( scale, offset1, offset2, ccontrol, ifbtime_offset, year, month, day, hour, min, sec, &( plsc->qsas",Useful
/*Set format for date / time labels.*/,"-10. void
-9. c_plctime( PLINT year, PLINT month, PLINT day, PLINT hour, PLINT min, PLFLT sec, PLFLT *ctime )
-8. {
-7.     int    ret;
-6.     double qsas_ctime;
-5.     ret    = ctimeqsas( year, month, day, hour, min, sec, &qsas_ctime, plsc->qsasconfig ",Useful
"/*--------------------------------------------------------------------------
Transformations returning physical coordinates.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*device coords to physical coords (x)*/,"-4. #include ""plplotP.h""

 /*device coords to physical coords (x)*/

1. PLINT
2. plP_dcpcx( PLFLT x )
3. {
4.     return ( ROUND( plsc->phyxmi + plsc->phyxlen * x ) );
5. }",Useful
/*device coords to physical coords (y)*/,"-5. PLINT
-4. plP_dcpcx( PLFLT x )
-3. {
-2.     return ( ROUND( plsc->phyxmi + plsc->phyxlen * x ) );
-1. }

 /*device coords to physical coords (y)*/

1. PLINT
2. plP_dcpcy( PLFLT y )
3. {
4.     return ( ROUND( plsc->phyymi + plsc->phyylen * y ) );
5. ",Useful
/*millimeters from bottom left-hand corner to physical coords (x)*/,"-5. PLINT
-4. plP_dcpcy( PLFLT y )
-3. {
-2.     return ( ROUND( plsc->phyymi + plsc->phyylen * y ) );
-1. }

 /*millimeters from bottom left-hand corner to physical coords (x)*/

1. PLINT
2. plP_mmpcx( PLFLT x )
3. {
4.     return ( ROUND( plsc->phyxmi +",Useful
/*millimeters from bottom left-hand corner to physical coords (y)*/,"-5. PLINT
-4. plP_mmpcx( PLFLT x )
-3. {
-2.     return ( ROUND( plsc->phyxmi + plsc->xpmm * x ) );
-1. }

 /*millimeters from bottom left-hand corner to physical coords (y)*/

1. PLINT
2. plP_mmpcy( PLFLT y )
3. {
4.     return ( ROUND( plsc->phyymi + pl",Useful
/*world coords to physical coords (x)*/,"-5. PLINT
-4. plP_mmpcy( PLFLT y )
-3. {
-2.     return ( ROUND( plsc->phyymi + plsc->ypmm * y ) );
-1. }

 /*world coords to physical coords (x)*/

1. PLINT
2. plP_wcpcx( PLFLT x )
3. {
4.     if ( !isfinite( x ) )
5.         return PLINT_MIN;
6.     ret",Useful
/*world coords to physical coords (y)*/,"-7. PLINT
-6. plP_wcpcx( PLFLT x )
-5. {
-4.     if ( !isfinite( x ) )
-3.         return PLINT_MIN;
-2.     return ( ROUND( plsc->wpxoff + plsc->wpxscl * x ) );
-1. }

 /*world coords to physical coords (y)*/

1. PLINT
2. plP_wcpcy( PLFLT y )
3. {
4.    ",Useful
"/*--------------------------------------------------------------------------
Transformations returning device coordinates.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*physical coords to device coords (x)*/,"-10. PLINT
-9. plP_wcpcy( PLFLT y )
-8. {
-7.     if ( !isfinite( y ) )
-6.         return PLINT_MIN;
-5.     return ( ROUND( plsc->wpyoff + plsc->wpyscl * y ) );
-4. }

 /*physical coords to device coords (x)*/

1. PLFLT
2. plP_pcdcx( PLINT x )
3. {
4.  ",Useful
/*physical coords to device coords (y)*/,"-5. PLFLT
-4. plP_pcdcx( PLINT x )
-3. {
-2.     return (PLFLT) ( ( x - plsc->phyxmi ) / (double) plsc->phyxlen );
-1. }

 /*physical coords to device coords (y)*/

1. PLFLT
2. plP_pcdcy( PLINT y )
3. {
4.     return (PLFLT) ( ( y - plsc->phyymi ) / (doub",Useful
/*millimeters from bottom left corner to device coords (x)*/,"-5. PLFLT
-4. plP_pcdcy( PLINT y )
-3. {
-2.     return (PLFLT) ( ( y - plsc->phyymi ) / (double) plsc->phyylen );
-1. }

 /*millimeters from bottom left corner to device coords (x)*/

1. PLFLT
2. plP_mmdcx( PLFLT x )
3. {
4.     return ( (PLFLT) ( x * pl",Useful
/*millimeters from bottom left corner to device coords (y)*/,"-5. PLFLT
-4. plP_mmdcx( PLFLT x )
-3. {
-2.     return ( (PLFLT) ( x * plsc->xpmm / ABS( plsc->phyxma - plsc->phyxmi ) ) );
-1. }

 /*millimeters from bottom left corner to device coords (y)*/

1. PLFLT
2. plP_mmdcy( PLFLT y )
3. {
4.     return ( (PLFLT",Useful
/*world coords into device coords (x)*/,"-5. PLFLT
-4. plP_mmdcy( PLFLT y )
-3. {
-2.     return ( (PLFLT) ( y * plsc->ypmm / ABS( plsc->phyyma - plsc->phyymi ) ) );
-1. }

 /*world coords into device coords (x)*/

1. PLFLT
2. plP_wcdcx( PLFLT x )
3. {
4.     return ( (PLFLT) ( plsc->wdxoff + pl",Useful
/*world coords into device coords (y)*/,"-5. PLFLT
-4. plP_wcdcx( PLFLT x )
-3. {
-2.     return ( (PLFLT) ( plsc->wdxoff + plsc->wdxscl * x ) );
-1. }

 /*world coords into device coords (y)*/

1. PLFLT
2. plP_wcdcy( PLFLT y )
3. {
4.     return ( (PLFLT) ( plsc->wdyoff + plsc->wdyscl * y ) );
",Useful
/*subpage coords to device coords (x)*/,"-5. PLFLT
-4. plP_wcdcy( PLFLT y )
-3. {
-2.     return ( (PLFLT) ( plsc->wdyoff + plsc->wdyscl * y ) );
-1. }

 /*subpage coords to device coords (x)*/

1. PLFLT
2. plP_scdcx( PLFLT x )
3. {
4.     return ( (PLFLT) ( plsc->spdxmi + ( plsc->spdxma - plsc-",Useful
/*subpage coords to device coords (y)*/,"-5. PLFLT
-4. plP_scdcx( PLFLT x )
-3. {
-2.     return ( (PLFLT) ( plsc->spdxmi + ( plsc->spdxma - plsc->spdxmi ) * x ) );
-1. }

 /*subpage coords to device coords (y)*/

1. PLFLT
2. plP_scdcy( PLFLT y )
3. {
4.     return ( (PLFLT) ( plsc->spdymi + ( p",Useful
"/*--------------------------------------------------------------------------
Transformations returning millimeters.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*device coords to millimeters from bottom left-hand corner (x)*/,"-8. PLFLT
-7. plP_scdcy( PLFLT y )
-6. {
-5.     return ( (PLFLT) ( plsc->spdymi + ( plsc->spdyma - plsc->spdymi ) * y ) );
-4. }

 /*device coords to millimeters from bottom left-hand corner (x)*/

1. PLFLT
2. plP_dcmmx( PLFLT x )
3. {
4.     return ( (P",Useful
/*device coords to millimeters from bottom left-hand corner (y)*/,"-5. PLFLT
-4. plP_dcmmx( PLFLT x )
-3. {
-2.     return ( (PLFLT) ( x * ABS( plsc->phyxma - plsc->phyxmi ) / plsc->xpmm ) );
-1. }

 /*device coords to millimeters from bottom left-hand corner (y)*/

1. PLFLT
2. plP_dcmmy( PLFLT y )
3. {
4.     return ( (",Useful
/*world coords into millimeters (x)*/,"-5. PLFLT
-4. plP_dcmmy( PLFLT y )
-3. {
-2.     return ( (PLFLT) ( y * ABS( plsc->phyyma - plsc->phyymi ) / plsc->ypmm ) );
-1. }

 /*world coords into millimeters (x)*/

1. PLFLT
2. plP_wcmmx( PLFLT x )
3. {
4.     return ( (PLFLT) ( plsc->wmxoff + plsc",Useful
/*world coords into millimeters (y)*/,"-5. PLFLT
-4. plP_wcmmx( PLFLT x )
-3. {
-2.     return ( (PLFLT) ( plsc->wmxoff + plsc->wmxscl * x ) );
-1. }

 /*world coords into millimeters (y)*/

1. PLFLT
2. plP_wcmmy( PLFLT y )
3. {
4.     return ( (PLFLT) ( plsc->wmyoff + plsc->wmyscl * y ) );
5.",Useful
"/*--------------------------------------------------------------------------
Transformations returning subpage coordinates.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*device coords to subpage coords (x)*/,"-8. PLFLT
-7. plP_wcmmy( PLFLT y )
-6. {
-5.     return ( (PLFLT) ( plsc->wmyoff + plsc->wmyscl * y ) );
-4. }

 /*device coords to subpage coords (x)*/

1. PLFLT
2. plP_dcscx( PLFLT x )
3. {
4.     return ( (PLFLT) ( ( x - plsc->spdxmi ) / ( plsc->spdxma",Useful
/*device coords to subpage coords (y)*/,"-5. PLFLT
-4. plP_dcscx( PLFLT x )
-3. {
-2.     return ( (PLFLT) ( ( x - plsc->spdxmi ) / ( plsc->spdxma - plsc->spdxmi ) ) );
-1. }

 /*device coords to subpage coords (y)*/

1. PLFLT
2. plP_dcscy( PLFLT y )
3. {
4.     return ( (PLFLT) ( ( y - plsc->sp",Useful
"/*--------------------------------------------------------------------------
3-d plot transformations.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*3-d coords to 2-d projection (x)
See c_plw3d for a mathematical explanation of the transformation.*/","-8. PLFLT
-7. plP_dcscy( PLFLT y )
-6. {
-5.     return ( (PLFLT) ( ( y - plsc->spdymi ) / ( plsc->spdyma - plsc->spdymi ) ) );
-4. }

 /*3-d coords to 2-d projection (x)
See c_plw3d for a mathematical explanation of the transformation.*/

1. PLFLT
2. plP",Useful
"/*3-d coords to 2-d projection (y)
See c_plw3d for a mathematical explanation of the transformation.*/","PLFLT
plP_w3wcy( PLFLT x, PLFLT y, PLFLT z )
{
    return ( (PLFLT) ( ( x - plsc->basecx ) * plsc->cyx +
                       ( y - plsc->basecy ) * plsc->cyy +
                       ( z - plsc->ranmi ) * plsc->cyz ) );
}

 /*3-d coords to 2-d projection (y)
See c_plw3d for a mathematical explanation of the transformation.*/

1. PLFLT
2. plP_w3wcz( PLFLT x, PLFLT y, PLFLT z )
3. {
4.     return ( (PLFLT) ( ( x - plsc->basecx ) * plsc->czx +
5.                        ( y - plsc->basecy ) * plsc->czy +
6.                        ( z - plsc->ranmi ) * plsc->czz ) );
7. }",Useful
"/*3-d coords to 2-d projection (z), if that makes any sense...
See c_plw3d for a mathematical explanation of the transformation.*/","-7. PLFLT
-6. plP_w3wcy( PLFLT x, PLFLT y, PLFLT z )
-5. {
-4.     return ( (PLFLT) ( ( x - plsc->basecx ) * plsc->cyx +
-3.                        ( y - plsc->basecy ) * plsc->cyy +
-2.                        ( z - plsc->ranmi ) * plsc->cyz ) );
-1. }

 ",Useful
/*Block size for memory allocation*/,"-10. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-9. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-8. // GNU Library General Public License for more details.
-7. //
-6. // You should have received a copy of the GN",Useful
/*0 3d solid; 1 mesh plot*/,"-10. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-9. // GNU Library General Public License for more details.
-8. //
-7. // You should have received a copy of the GNU Library General Public License
-6. // along with PLplot; if not, wri",Useful
/*1 update view; 0 no update*/,"-4. #include ""plplotP.h""

 /*1 update view; 0 no update*/

1. static PLINT zbflg = 0, zbcol;
2. static PLFLT zbtck, zbwidth;
3. static PLINT *oldhiview = NULL;
4. static PLINT *oldloview = NULL;
5. static PLINT *newhiview = NULL;
6. static PLINT *newlovie",Useful
/*Light source for shading*/,"-10. static PLFLT zbtck, zbwidth;
-9. static PLINT *oldhiview = NULL;
-8. static PLINT *oldloview = NULL;
-7. static PLINT *newhiview = NULL;
-6. static PLINT *newloview = NULL;
-5. static PLINT *utmp      = NULL;
-4. static PLINT *vtmp      = NULL;
-3. s",Useful
"/*--------------------------------------------------------------------------
void plsetlightsource(x, y, z)

Sets the position of the light source.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
void plmesh(x, y, z, nx, ny, opt)

Plots a mesh representation of the function z[x][y]. The x values
are stored as x[0..nx-1], the y values as y[0..ny-1], and the
z values are in the 2-d array z[][]. The integer ""opt"" specifies:
see plmeshc() below.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
void plmeshc(x, y, z, nx, ny, opt, clevel, nlevel)

Plots a mesh representation of the function z[x][y]. The x values
are stored as x[0..nx-1], the y values as y[0..ny-1], and the
z values are in the 2-d array z[][]. The integer ""opt"" specifies:

DRAW_LINEX   draw lines parallel to the X axis
DRAW_LINEY   draw lines parallel to the Y axis
DRAW_LINEXY  draw lines parallel to both the X and Y axis
MAG_COLOR    draw the mesh with a color dependent of the magnitude
BASE_CONT    draw contour plot at bottom xy plane
TOP_CONT     draw contour plot at top xy plane (not yet)
DRAW_SIDES   draw sides

or any bitwise combination, e.g. ""MAG_COLOR | DRAW_LINEX""

--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
/*clipping helper for 3d polygons*/,"-10.            PLFLT_VECTOR clevel, PLINT nlevel )
-9. {
-8.     plfplot3dc( x, y, plf2ops_c(), (PLPointer) z, nx, ny, opt | MESH, clevel, nlevel );
-7. }
-6. void
-5. plfmeshc( PLFLT_VECTOR x, PLFLT_VECTOR y, PLF2OPS zops, PLPointer zp,
-4.           PL",Useful
/*arrays for interface to core functions*/,"-6. static void
-5. shade_triangle( PLFLT x0, PLFLT y0, PLFLT z0,
-4.                 PLFLT x1, PLFLT y1, PLFLT z1,
-3.                 PLFLT x2, PLFLT y2, PLFLT z2 )
-2. {
-1.     int   i;

 /*arrays for interface to core functions*/

1.     short u[6], ",Useful
/*show triangles*/,"-10.             plcol1( ( ( z[0] + z[1] + z[2] ) / 3. - fc_minz ) / ( fc_maxz - fc_minz ) );
-9.         else
-8.             plcol1( plGetAngleToLight( x, y, z ) );
-7.         for ( i = 0; i < n; i++ )
-6.         {
-5.             u[i] = (short) plP_w",Useful
/*fill triangles*/,"-3.         plcol0( 1 );
-2.         x[3] = x[0]; y[3] = y[0]; z[3] = z[0];
-1.         plline3( 4, x, y, z );

 /*fill triangles*/

1.         plP_fill( u, v, n + 1 );
2. #endif
3.     }
4. }",Useful
"/*--------------------------------------------------------------------------
void plsurf3d(x, y, z, nx, ny, opt, clevel, nlevel)

Plots the 3-d surface representation of the function z[x][y].
The x values are stored as x[0..nx-1], the y values as y[0..ny-1],
and the z values are in the 2-d array z[][].  The integer ""opt"" specifies:
see plsurf3dl() below.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
void plsurf3dl(x, y, z, nx, ny, opt, clevel, nlevel,
indexxmin, indexxmax, indexymin, indexymax)

Plots the 3-d surface representation of the function z[x][y].
The x values are stored as x[0..nx-1], the y values as y[0..ny-1],
and the z values are in the 2-d array z[][].


BASE_CONT    draw contour plot at bottom xy plane
TOP_CONT     draw contour plot at top xy plane (not implemented)
SURF_CONT    draw contour at surface
FACETED      each square that makes up the surface is faceted
DRAW_SIDES   draw sides
MAG_COLOR    the surface is colored according to the value of z;
if not defined, the surface is colored according to the
intensity of the reflected light in the surface from a light
source whose position is set using c_pllightsource()

or any bitwise combination, e.g. ""MAG_COLOR | SURF_CONT | BASE_CONT""

indexymin and indexymax are arrays which specify the y index range
(following the convention that the upper range limit is one more than
actual index limit) for an x index range of indexxmin, indexxmax.
This code is a complete departure from the approach taken in the old version
of this routine. Formerly to code attempted to use the logic for the hidden
line algorithm to draw the hidden surface. This was really hard. This code
below uses a simple back to front (painters) algorithm. All the
triangles are drawn.

There are multitude of ways this code could be optimized. Given the
problems with the old code, I tried to focus on clarity here.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*Don't use the data z value to scale the color, use the z axis
values set by plw3d()

plMinMax2dGrid(z, nx, ny, &fc_maxz, &fc_minz);*/","-10.     {
-9.         myabort( ""plsurf3dl: Please set up window first"" );
-8.         return;
-7.     }
-6.     if ( nx <= 0 || ny <= 0 )
-5.     {
-4.         myabort( ""plsurf3dl: Bad array dimensions."" );
-3.         return;
-2.     }

 /*Don't use the",Useful
/*get the viewing parameters*/,"-10.         if ( y[i] >= y[i + 1] )
-9.         {
-8.             myabort( ""plsurf3dl: Y array must be strictly increasing"" );
-7.             return;
-6.         }
-5.         if ( y[i] < ymin && y[i + 1] >= ymin )
-4.             iymin = i;
-3.        ",Useful
/*we're going to draw from back to front*/,"-1.     plP_gw3wc( &cxx, &cxy, &cyx, &cyy, &cyz );

 /*we're going to draw from back to front*/

111",Useful
/*get direction for X*/,"-7.     plP_gw3wc( &cxx, &cxy, &cyx, &cyy, &cyz );

 /*get direction for X*/

1.     if ( cxy >= 0 )
2.     {",Useful
/*direction in X*/,"-10.     plP_gw3wc( &cxx, &cxy, &cyx, &cyy, &cyz );

 /*direction in X*/

111",Useful
/*get direction for Y*/,"-6.     }
-5.     else
-4.     {
-3.         ixDir    = -1;
-2.         ixOrigin = ixmax - 1;
-1.     }

 /*get direction for Y*/

1.     if ( cxx >= 0 )
2.     {
3.         iyDir    = -1;
4.         iyOrigin = iymax - 1;
5.     }
6.     else
7.     {
8. ",Useful
/*samples in the Fast direction*/,"-3.     if ( fabs( cxx ) > fabs( cxy ) )
-2.     {

 /*samples in the Fast direction*/

111",Useful
/*samples in the Slow direction*/,"-4.     if ( fabs( cxx ) > fabs( cxy ) )
-3.     {

 /*samples in the Slow direction*/

1.         ixFast = ixDir; ixSlow = 0;
2.         iyFast = 0;     iySlow = iyDir;
3.     }
4.     else
5.     {
6.         nFast = iymax - iymin;
7.         nSlow = ix",Useful
/*get the tick spacing*/,"-5.     if ( zbflg )
-4.     {
-3.         PLFLT bx[3], by[3], bz[3];
-2.         PLFLT tick = zbtck, tp;
-1.         PLINT nsub = 0;

 /*get the tick spacing*/

1.         pldtik( zmin, zmax, &tick, &nsub, FALSE );",Useful
/*determine the vertices for the background grid line*/,"-1.         pldtik( zmin, zmax, &tick, &nsub, FALSE );

 /*determine the vertices for the background grid line*/

1.         bx[0] = ( ixOrigin != ixmin && ixFast == 0 ) || ixFast > 0 ? xmax : xmin;
2.         by[0] = ( iyOrigin != iymin && iyFast == 0 ) ",Useful
/*draw the vertical line at the back corner*/,"-10.         by[1] = iyOrigin != iymin ? ymax : ymin;
-9.         bx[2] = ( ixOrigin != ixmin && ixSlow == 0 ) || ixSlow > 0 ? xmax : xmin;
-8.         by[2] = ( iyOrigin != iymin && iySlow == 0 ) || iySlow > 0 ? ymax : ymin;
-7.         plwidth( zbwidth ",Useful
"/*If enabled, draw the contour at the base*/","-7.         bx[0] = bx[1];
-6.         by[0] = by[1];
-5.         bz[0] = zmin;
-4.         plline3( 2, bx, by, bz );
-3.         plwidth( width );
-2.         plcol0( color );
-1.     }

 /*If enabled, draw the contour at the base*/

111",Useful
/*get the contour lines*/,"-9.     if ( clevel != NULL && opt & BASE_CONT )
-8.     {
-7. #define NPTS    100
-6.         int      np = NPTS;
-5.         PLFLT    **zstore;
-4.         PLcGrid2 cgrid2;
-3.         PLFLT    *zzloc = (PLFLT *) malloc( (size_t) NPTS * sizeof ( PLFLT )",Useful
/*prepare cont_store input*/,"-10.     if ( clevel != NULL && opt & BASE_CONT )
-9.     {
-8. #define NPTS    100
-7.         int      np = NPTS;
-6.         PLFLT    **zstore;
-5.         PLcGrid2 cgrid2;
-4.         PLFLT    *zzloc = (PLFLT *) malloc( (size_t) NPTS * sizeof ( PLFLT ",Useful
/*Fill cont structure with contours.*/,"-10.                 cgrid2.yg[i][j] = y[j];
-9.                 zstore[i][j]    = getz( zp, i, j );
-8.             }
-7.             for ( j = indexymax[i]; j < ny; j++ )
-6.             {
-5.                 cgrid2.xg[i][j] = x[i];
-4.                 ",Useful
/*Free the 2D input arrays to cont_store since not needed any more.*/,"-2.         cont_store( (PLFLT_MATRIX) zstore, nx, ny, indexxmin + 1, indexxmax, 1, ny,
-1.             clevel, nlevel, pltr2, (void *) &cgrid2, &cont );

 /*Free the 2D input arrays to cont_store since not needed any more.*/

1.         plFree2dGrid( zst",Useful
/*for each contour level*/,"-1.         clev = cont;

 /*for each contour level*/

1.         {
2.             cline = clev->line;",Useful
/*there are several lines that make up the contour*/,"-2.         {
-1.             cline = clev->line;

 /*there are several lines that make up the contour*/

1.             {
2.                 if ( cline->npts > np )
3.                 {
4.                     np = cline->npts;
5.                     if (",Useful
"/*get the 4 corners of the Quad, which are

0--2
|  |
1--3*/","-4.     for ( iSlow = 0; iSlow < nSlow - 1; iSlow++ )
-3.     {
-2.         for ( iFast = 0; iFast < nFast - 1; iFast++ )
-1.         {

 /*get the 4 corners of the Quad, which are

0--2
|  |
1--3*/

111",Useful
"/*we're transforming from Fast/Slow coordinates to x/y coordinates
note, these are the indices, not the values*/","-6.             xm = ym = zm = 0.;
-5.             iftriangle = 1;
-4.             for ( i = 0; i < 2; i++ )
-3.             {
-2.                 for ( j = 0; j < 2; j++ )
-1.                 {

 /*we're transforming from Fast/Slow coordinates to x/y coo",Useful
"/*the ""mean point"" of the quad, common to all four triangles
-- perhaps not a good thing to do for the light shading*/","-10.                     {
-9.                         iftriangle = 0;
-8.                         break;
-7.                     }
-6.                 }
-5.                 if ( iftriangle == 0 )
-4.                     break;
-3.             }
-2.      ",Useful
/*now draw the quad as four triangles*/,"-1.             xm /= 4.; ym /= 4.; zm /= 4.;

 /*now draw the quad as four triangles*/

1.             for ( i = 1; i < 3; i++ )
2.             {
3.                 for ( j = 0; j < 4; j += 3 )
4.                 {
5.                     shade_triangle( ",Useful
"/*yes, xx and yy are the intersection points of the triangle with
the contour line -- draw a straight line betweeen the points
-- at the end this will make up the contour line*/","-7.                                 {
-6.                                     xx[ct] = ( ( clevel[k] - pz[j] ) * ( xm - px[j] ) ) / ( zm - pz[j] ) + px[j];
-5.                                     yy[ct] = ( ( clevel[k] - pz[j] ) * ( ym - py[j] ) ) / ( zm ",Useful
/*surface contour with color set by user*/,"-10.                                 {
-9.                                     xx[ct] = ( ( clevel[k] - pz[j] ) * ( xm - px[j] ) ) / ( zm - pz[j] ) + px[j];
-8.                                     yy[ct] = ( ( clevel[k] - pz[j] ) * ( ym - py[j] ) ) / ( zm",Useful
/*don't break; one triangle can span various contour levels*/,"-3.                                     plcol0( color );
-2.                                     zz[0] = zz[1] = clevel[k];
-1.                                     plline3( 2, xx, yy, zz );

 /*don't break; one triangle can span various contour levels*/

",Useful
/*the sides look ugly !!!*/,"-10.                 }
-9.             }
-8.         }
-7.     }
-6.     if ( opt & FACETED )
-5.     {
-4.         plcol0( 0 );
-3.         plfplot3dcl( x, y, zops, zp, nx, ny, MESH | DRAW_LINEXY, NULL, 0,
-2.             indexxmin, indexxmax, indexymin,",Useful
/*draw one more row with all the Z's set to zmin*/,"-10.             }
-9.         }
-8.     }
-7.     if ( opt & FACETED )
-6.     {
-5.         plcol0( 0 );
-4.         plfplot3dcl( x, y, zops, zp, nx, ny, MESH | DRAW_LINEXY, NULL, 0,
-3.             indexxmin, indexxmax, indexymin, indexymax );
-2.     ",Useful
/*now draw the quad as two triangles (4 might be better)*/,"-10.                     pz[2 * i] = getz( zp, ix, iy );
-9.                 }
-8.                 else
-7.                 {
-6.                     iftriangle = 0;
-5.                     break;
-4.                 }
-3.             }
-2.             if",Useful
/*now draw the quad as two triangles (4 might be better)*/,"-10.                     pz[2 * i] = getz( zp, ix, iy );
-9.                 }
-8.                 else
-7.                 {
-6.                     iftriangle = 0;
-5.                     break;
-4.                 }
-3.             }
-2.             if",Useful
"/*--------------------------------------------------------------------------
void plot3d(x, y, z, nx, ny, opt, side)

Plots a 3-d representation of the function z[x][y]. The x values
are stored as x[0..nx-1], the y values as y[0..ny-1], and the z
values are in the 2-d array z[][]. The integer ""opt"" specifies:
see plot3dcl() below
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
void plot3dc(x, y, z, nx, ny, opt, clevel, nlevel)

Plots a 3-d representation of the function z[x][y]. The x values
are stored as x[0..nx-1], the y values as y[0..ny-1], and the z
values are in the 2-d array z[][]. The integer ""opt"" specifies:
see plot3dcl() below
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
void plot3dcl(x, y, z, nx, ny, opt, clevel, nlevel,
indexxmin, indexxmax, indexymin, indexymax)

Plots a 3-d representation of the function z[x][y]. The x values
are stored as x[0..nx-1], the y values as y[0..ny-1], and the z
values are in the 2-d array z[][]. The integer ""opt"" specifies:

DRAW_LINEX :  Draw lines parallel to x-axis
DRAW_LINEY :  Draw lines parallel to y-axis
DRAW_LINEXY:  Draw lines parallel to both axes
MAG_COLOR:    Magnitude coloring of wire frame
BASE_CONT:    Draw contour at bottom xy plane
TOP_CONT:     Draw contour at top xy plane (not yet)
DRAW_SIDES:   Draw sides around the plot
MESH:       Draw the ""under"" side of the plot

or any bitwise combination, e.g. ""MAG_COLOR | DRAW_LINEX""
indexymin and indexymax are arrays which specify the y index limits
(following the convention that the upper range limit is one more than
actual index limit) for an x index range of indexxmin, indexxmax.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
! Plots a 3-d representation of the virtual function z, which is represented
! by zops and zp.
!
! @param x The x values are stored as x[0..nx-1]
! @param y The y values are stored as y[0..ny-1]
! @param zops Pointer to a plf2ops_t structure of function pointers (see
! plf2opts_t in plplot.h) which define how to perform various manipulations
! (including retrieval) on the elements of the the 2D data field pointed to
! by zp.  Pointers suitable for passing as zops can be obtained for some
! predefined types of 2-d data storage by calling one of the plf2ops_*()
! functions (see plf2ops.c) or you can create your own set for arbitrary 2-d
! storage formats.
! @param zp Pointer to 2D data field.  This pointer is passed to the
! functions of zops whenever the 2D field needs to be manipulated.  The
! combination of zops and zp provides total flexibility in how the underlying
! data values are managed.
! @param nx The number of values in x.
! @param ny The number of values in y.
! @param opt Specifies options for the plot.  It can be a bitwise OR-ing of
! these:
!   - DRAW_LINEX :  Draw lines parallel to x-axis
!   - DRAW_LINEY :  Draw lines parallel to y-axis
!   - DRAW_LINEXY:  Draw lines parallel to both axes
!   - MAG_COLOR:    Magnitude coloring of wire frame
!   - BASE_CONT:    Draw contour at bottom xy plane
!   - TOP_CONT:     Draw contour at top xy plane (not yet)
!   - DRAW_SIDES:   Draw sides around the plot
!   - MESH:         Draw the ""under"" side of the plot
! or any bitwise OR'd combination, e.g. ""MAG_COLOR | DRAW_LINEX""
! @param clevel z values at which to draw contours
! @param nlevel Number of values in clevels
! @param PL_UNUSED( indexxmin ) Not used.
! @param PL_UNUSED( indexxmax ) Not used.
! @param PL_UNUSED( indexymin ) Not used.
! @param PL_UNUSED( indexymax ) Not used.
!
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
/*Check that points in x and in y are strictly increasing*/,"-10.     else
-9.         falsecolor = 0;
-8.     plP_gdom( &xmin, &xmax, &ymin, &ymax );
-7.     plP_grange( &zscale, &zmin, &zmax );
-6.     if ( zmin > zmax )
-5.     {
-4.         PLFLT t = zmin;
-3.         zmin = zmax;
-2.         zmax = t;
-1.     ",Useful
/*copy the data array so we can interpolate around the edges*/,"-8.         _x[0]       = xmin;
-7.         _x[_nx - 1] = xmax;
-6.         for ( i = 1; i < _nx - 1; i++ )
-5.             _x[i] = x[ixmin + i];
-4.         _y[0]       = ymin;
-3.         _y[_ny - 1] = ymax;
-2.         for ( i = 1; i < _ny - 1; i++ )
-",Useful
/*interpolation factors for the 4 edges*/,"-7.         for ( i = 0; i < _nx; i++ )
-6.         {
-5.             if ( ( _z[i] = (PLFLT *) malloc( (size_t) _ny * sizeof ( PLFLT ) ) ) == NULL )
-4.             {
-3.                 plexit( ""c_plot3dcl: Insufficient memory"" );
-2.             }
-1.  ",Useful
/*replace the input with our clipped versions*/,"-10.                 _z[i][_ny - 1] = getz( zp, ixmin + i, iymax - 1 ) * ( 1 - ty1 ) + getz( zp, ixmin + i, iymax ) * ty1;
-9.             }
-8.             for ( j = 0; j < _ny; j++ )
-7.             {
-6.                 if ( _z[i][j] < zmin )
-5.      ",Useful
"/*Don't use the data z value to scale the color, use the z axis
values set by plw3d()

plMinMax2dGrid(z, nx, ny, &fc_maxz, &fc_minz);*/","-10.     {
-9.         myabort( ""plsurf3dl: Please set up window first"" );
-8.         return;
-7.     }
-6.     if ( nx <= 0 || ny <= 0 )
-5.     {
-4.         myabort( ""plsurf3dl: Bad array dimensions."" );
-3.         return;
-2.     }

 /*Don't use the",Useful
"/*If enabled, draw the contour at the base.*/","-8.         fc_minz = plsc->ranmi;
-7.         fc_maxz = plsc->ranma;
-6.         if ( fc_maxz == fc_minz )
-5.         {
-4.             plwarn( ""plot3dcl: Maximum and minimum Z values are equal! \""fixing\""..."" );
-3.             fc_maxz = fc_minz + 1e-6",Useful
"/*even if MESH is not set, ""set it"",
as the base contour can only be done in this case*/","-4.     {
-3.         if ( clevel != NULL && nlevel != 0 )
-2.         {
-1.             base_cont = 1;

 /*even if MESH is not set, ""set it"",
as the base contour can only be done in this case*/

1.             pl3mode = 1;
2.         }
3.     }",Useful
"/*If enabled, use magnitude colored wireframe*/","-3.             pl3mode = 1;
-2.         }
-1.     }

 /*If enabled, use magnitude colored wireframe*/

1.     {
2.         if ( ( ctmp = (PLFLT *) malloc( (size_t) ( 2 * MAX( nx, ny ) ) * sizeof ( PLFLT ) ) ) == NULL )
3.         {
4.             plexit(",Useful
"/*Call 3d line plotter.  Each viewing quadrant
(perpendicular to x-y plane) must be handled separately.*/","-6.     utmp = (PLINT *) malloc( (size_t) ( 2 * MAX( nx, ny ) ) * sizeof ( PLINT ) );
-5.     vtmp = (PLINT *) malloc( (size_t) ( 2 * MAX( nx, ny ) ) * sizeof ( PLINT ) );
-4.     if ( !utmp || !vtmp )
-3.         myexit( ""plot3dcl: Out of memory."" );
-2.",Useful
/*Fill cont structure with contours.*/,"-10.                 cgrid2.yg[i][j] = y[j];
-9.                 zstore[i][j]    = getz( zp, i, j );
-8.             }
-7.             for ( j = indexymax[i]; j < ny; j++ )
-6.             {
-5.                 cgrid2.xg[i][j] = x[i];
-4.                 ",Useful
/*for each contour level*/,"-1.         clev = cont;

 /*for each contour level*/

1.         {
2.             cline = clev->line;",Useful
"/*the hidden line plotter plnxtv() only works OK if the x points are in increasing order.
As this does not always happens, the situation must be detected and the line segment
must be reversed before being plotted*/","-10.                 PLFLT tx, ty;
-9.                 if ( cline->npts > np )
-8.                 {
-7.                     np = cline->npts;
-6.                     if ( ( ( uu = (PLINT *) realloc( uu, (size_t) np * sizeof ( PLINT ) ) ) == NULL ) ||
-5.",Useful
/*convert to 2D coordinates*/,"-7.                 i = 0;
-6.                 if ( cline->npts > 0 )
-5.                 {
-4.                     do
-3.                     {
-2.                         plcol1( ( clev->level - fc_minz ) / ( fc_maxz - fc_minz ) );
-1.                  ",Useful
/*find turn back point*/,"-3.                         {
-2.                             uu[j] = plP_wcpcx( plP_w3wcx( cline->x[j], cline->y[j], plsc->ranmi ) );
-1.                             vv[j] = plP_wcpcy( plP_w3wcy( cline->x[j], cline->y[j], plsc->ranmi ) );

 /*find turn b",Useful
/*plot line with increasing x*/,"-4.                                 break;
-3.                             else
-2.                                 cx = uu[j];
-1.                         }

 /*plot line with increasing x*/

111",Useful
"/*line not yet finished,*/","-5.                                 break;
-4.                             else
-3.                                 cx = uu[j];
-2.                         }

 /*line not yet finished,*/

1.                         {
2.                             start =",Useful
/*search turn forward point*/,"-2.                         {
-1.                             start = j - 1;

 /*search turn forward point*/

1.                             {
2.                                 uu[i] = plP_wcpcx( plP_w3wcx( cline->x[i], cline->y[i], plsc->ranmi ) );
3.  ",Useful
/*reverse line segment*/,"-8.                             {
-7.                                 uu[i] = plP_wcpcx( plP_w3wcx( cline->x[i], cline->y[i], plsc->ranmi ) );
-6.                                 if ( uu[i] > cx )
-5.                                     break;
-4.        ",Useful
/*convert to 2D coordinates*/,"-7.                 i = 0;
-6.                 if ( cline->npts > 0 )
-5.                 {
-4.                     do
-3.                     {
-2.                         plcol1( ( clev->level - fc_minz ) / ( fc_maxz - fc_minz ) );
-1.                  ",Useful
/*and plot it*/,"-5.                             for ( j = start; j <= end; j++ )
-4.                             {
-3.                                 uu[j] = plP_wcpcx( plP_w3wcx( cline->x[j], cline->y[j], plsc->ranmi ) );
-2.                                 vv[j] = plP",Useful
/*now release the contour memory*/,"-9.                         }
-8.                     } while ( j < cline->npts && i < cline->npts );
-7.                 }
-6.                 cline = cline->next;
-5.             }
-4.             while ( cline != NULL );
-3.             clev = clev->ne",Useful
"/*Finish up by drawing sides, background grid (both are optional)*/","-4.         pl3upv = 1;
-3.         free( uu );
-2.         free( vv );
-1.     }

 /*Finish up by drawing sides, background grid (both are optional)*/

1.     if ( side )
2.         plside3( x_modified, y_modified, zops, zp, nx, ny, opt );
3.     if ( zb",Useful
"/*--------------------------------------------------------------------------
void plxyindexlimits()

Transform from y array limits to corresponding x array limits (or vice
versa).

N.B. we follow the convention here that all upper range limits are one
more than the actual last index.
instart (>= 0) through inn is the index range where
the input inarray_min and inarray_max arrays are defined.

outstart (>= 0), through outn (with outn <= outnmax) is the index range
where the output outarray_min and outarray_max arrays are defined.

In order to assure the transformation from y array limits to x array limits
(or vice versa) is single-valued, this programme plaborts if the
inarray_min array has a maximum or inarray_max array has a minimum.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*static void
plxyindexlimits( PLINT instart, PLINT inn,
PLINT *inarray_min, PLINT *inarray_max,
PLINT *outstart, PLINT *outn, PLINT outnmax,
PLINT *outarray_min, PLINT *outarray_max )
{
PLINT i, j;
if ( inn < 0 )
{
myabort( ""plxyindexlimits: Must have instart >= 0"" );
return;
}
if ( inn - instart <= 0 )
{
myabort( ""plxyindexlimits: Must have at least 1 defined point"" );
return;
}
*outstart = inarray_min[instart];
*outn     = inarray_max[instart];
for ( i = instart; i < inn; i++ )
{
*outstart = MIN( *outstart, inarray_min[i] );
*outn     = MAX( *outn, inarray_max[i] );
if ( i + 2 < inn )
{
if ( inarray_min[i] < inarray_min[i + 1] &&
inarray_min[i + 1] > inarray_min[i + 2] )
{
myabort( ""plxyindexlimits: inarray_min must not have a maximum"" );
return;
}
if ( inarray_max[i] > inarray_max[i + 1] &&
inarray_max[i + 1] < inarray_max[i + 2] )
{
myabort( ""plxyindexlimits: inarray_max must not have a minimum"" );
return;
}
}
}
if ( *outstart < 0 )
{
myabort( ""plxyindexlimits: Must have all elements of inarray_min >= 0"" );
return;
}
if ( *outn > outnmax )
{
myabort( ""plxyindexlimits: Must have all elements of inarray_max <= outnmax"" );
return;
}
for ( j = *outstart; j < *outn; j++ )
{
i = instart;
// Find first valid i for this j.
while ( i < inn && !( inarray_min[i] <= j && j < inarray_max[i] ) )
i++;
if ( i < inn )
outarray_min[j] = i;
else
{
myabort( ""plxyindexlimits: bad logic; invalid i should never happen"" );
return;
}
// Find next invalid i for this j.
while ( i < inn && ( inarray_min[i] <= j && j < inarray_max[i] ) )
i++;
outarray_max[j] = i;
}
}*/","-3. #if MJL_HACK
-2. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-1.                        PLINT x2, PLINT y2, PLINT j );
static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
                       PLINT x2, PLINT y2, PLINT x",Useful
"/*--------------------------------------------------------------------------
void plP_gzback()

Get background parameters for 3d plot.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
PLFLT plGetAngleToLight()

Gets cos of angle between normal to a polygon and a light source.
Requires at least 3 elements, forming non-parallel lines
in the arrays.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
/*Find vector perpendicular to the face*/,"-10.     PLFLT px, py, pz;
-9.     PLFLT vlx, vly, vlz;
-8.     PLFLT mag1, mag2;
-7.     PLFLT cosangle;
-6.     vx1 = x[1] - x[0];
-5.     vx2 = x[2] - x[1];
-4.     vy1 = y[1] - y[0];
-3.     vy2 = y[2] - y[1];
-2.     vz1 = z[1] - z[0];
-1.     vz2 = ",Useful
/*Vectors were parallel!*/,"-4.     px   = vy1 * vz2 - vz1 * vy2;
-3.     py   = vz1 * vx2 - vx1 * vz2;
-2.     pz   = vx1 * vy2 - vy1 * vx2;
-1.     mag1 = px * px + py * py + pz * pz;

 /*Vectors were parallel!*/

1.     if ( mag1 == 0 )
2.         return 1;
3.     vlx  = xlight -",Useful
/*Now have 3 vectors going through the first point on the given surface*/,"-8.     if ( mag1 == 0 )
-7.         return 1;
-6.     vlx  = xlight - x[0];
-5.     vly  = ylight - y[0];
-4.     vlz  = zlight - z[0];
-3.     mag2 = vlx * vlx + vly * vly + vlz * vlz;
-2.     if ( mag2 == 0 )
-1.         return 1;

 /*Now have 3 vector",Useful
"/*--------------------------------------------------------------------------
void plt3zz()

Draws the next zig-zag line for a 3-d plot.  The data is stored in array
z[][] as a function of x[] and y[], and is plotted out starting at index
(x0,y0).

Depending on the state of ""flag"", the sequence of data points sent to
plnxtv is altered so as to allow cross-hatch plotting, or plotting
parallel to either the x-axis or the y-axis.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
void plside3()

This routine draws sides around the front of the 3d plot so that
it does not appear to float.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*Get x, y coordinates of legs and plot*/","-10. plside3( PLFLT_VECTOR x, PLFLT_VECTOR y, PLF2OPS zops, PLPointer zp, PLINT nx, PLINT ny, PLINT opt )
-9. {
-8.     PLINT i;
-7.     PLFLT cxx, cxy, cyx, cyy, cyz;
-6.     PLFLT xmin, ymin, zmin, xmax, ymax, zmax, zscale;
-5.     PLFLT tx, ty, ux, uy;",Useful
"/*--------------------------------------------------------------------------
void plgrid3()

This routine draws a grid around the back side of the 3d plot with
hidden line removal.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
void plnxtv()

Draw the next view of a 3-d plot. The physical coordinates of the
points for the next view are placed in the n points of arrays u and
v. The silhouette found so far is stored in the heap as a set of m peak
points.

These routines dynamically allocate memory for hidden line removal.
Memory is allocated in blocks of 2*BINC*sizeof(PLINT) bytes.  Large
values of BINC give better performance but also allocate more memory
than is needed. If your 3D plots are very ""spiky"" or you are working
with very large matrices then you will probably want to increase BINC.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
void plnxtvhi()

Draw the top side of the 3-d plot.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*
For the initial set of points, just display them and store them as the
peak points.
*/","
//! @file


 /*
For the initial set of points, just display them and store them as the
peak points.
*/

111",Useful
"/*Otherwise, we need to consider hidden-line removal problem. We scan
over the points in both the old (i.e. oldhiview[]) and new (i.e. u[]
and v[]) arrays in order of increasing x coordinate.  At each stage, we
find the line segment in the other array (if one exists) that straddles
the x coordinate of the point. We have to determine if the point lies
above or below the line segment, and to check if the below/above status
has changed since the last point.

If pl3upv = 0 we do not update the view, this is useful for drawing
lines on the graph after we are done plotting points.  Hidden line
removal is still done, but the view is not updated.*/","-10.         for ( i = 1; i < n; i++ )
-9.         {
-8.             oldhiview[2 * i]     = u[i];
-7.             oldhiview[2 * i + 1] = v[i];
-6.             plP_draw3d( u[i], v[i], c, i, 0 );
-5.         }
-4.         mhi = n;
-3.         return;
-2.   ",Useful
/*Do the draw or shading with hidden line removal*/,"-10.                     (size_t) newhisize * sizeof ( PLINT ) );
-9.         }
-8.         else
-7.         {
-6.             newhiview =
-5.                 (PLINT *) malloc( (size_t) newhisize * sizeof ( PLINT ) );
-4.         }
-3.         if ( !newhi",Useful
/*Set oldhiview*/,"-1.     plnxtvhi_draw( u, v, c, n );

 /*Set oldhiview*/

1.     swaphiview();
2. }",Useful
"/*--------------------------------------------------------------------------
void plnxtvhi_draw()

Draw the top side of the 3-d plot.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*(oldhiview[2*i], oldhiview[2*i]) is the i'th point in the old array
(u[j], v[j]) is the j'th point in the new array*/","-9. static void
-8. plnxtvhi_draw( PLINT *u, PLINT *v, PLFLT* c, PLINT n )
-7. {
-6.     PLINT i = 0, j = 0, first = 1;
-5.     PLINT sx1 = 0, sx2 = 0, sy1 = 0, sy2 = 0;
-4.     PLINT su1, su2, sv1, sv2;
-3.     PLINT cx, cy, px, py;
-2.     PLINT seg, pt",Useful
"/*First attempt at 3d shading.  It works ok for simple plots, but
will just not draw faces, or draw them overlapping for very
jagged plots*/","-10.     PLINT i = 0, j = 0, first = 1;
-9.     PLINT sx1 = 0, sx2 = 0, sy1 = 0, sy2 = 0;
-8.     PLINT su1, su2, sv1, sv2;
-7.     PLINT cx, cy, px, py;
-6.     PLINT seg, ptold, lstold = 0, pthi, pnewhi = 0, newhi, change, ochange = 0;

 /*First attempt",Useful
"/*The coordinates of the point under consideration are (px,py).  The
line segment joins (sx1,sy1) to (sx2,sy2).  ""ptold"" is true if the
point lies in the old array. We set it by comparing the x coordinates
of the i'th old point and the j'th new point, being careful if we
have fallen past the edges. Having found the point, load up the point
and segment coordinates appropriately.*/","-10. // (u[j], v[j]) is the j'th point in the new array
-9. //
-8. //
-7. // First attempt at 3d shading.  It works ok for simple plots, but
-6. // will just not draw faces, or draw them overlapping for very
-5. // jagged plots
-4. //
-3.     while ( i < ",Useful
"/*
Now determine if the point is higher than the segment, using the
logical function ""above"". We also need to know if it is the old view
or the new view that is higher. ""newhi"" is set true if the new view
is higher than the old.
*/","
//! @file


 /*
Now determine if the point is higher than the segment, using the
logical function ""above"". We also need to know if it is the old view
or the new view that is higher. ""newhi"" is set true if the new view
is higher than the old.
*/

111",Useful
"/*
The last point and this point lie on different sides of
the current silouette
*/","
//! @file


 /*
The last point and this point lie on different sides of
the current silouette
*/

111",Useful
"/*
There is a new intersection point to put in the peak array if the
state of ""newhi"" changes.
*/","
//! @file


 /*
There is a new intersection point to put in the peak array if the
state of ""newhi"" changes.
*/

111",Useful
"/*Take care of special cases at end of arrays.  If pl3upv is 0 the
endpoints are not connected to the old view.*/","-10.             plP_draw3d( px, py, c, j, 1 );
-9.             first  = 0;
-8.             lstold = ptold;
-7.             savehipoint( px, py );
-6.             pthi    = 0;
-5.             ochange = 0;
-4.         }
-3.         else if ( change )
-2.  ",Useful
"/*If pl3upv is not 0 then we do want to connect the current line
with the previous view at the endpoints.  Also find intersection
point with old view.*/","-10.                       ( ( !ptold && i >= mhi ) || ( ptold && j >= n ) ) )
-9.             {
-8.                 plP_draw3d( px, py, c, j, 1 );
-7.                 lstold  = ptold;
-6.                 pthi    = 0;
-5.                 ochange = 0;
-4. ",Useful
/*Determine the intersection*/,"-10.                     su2 = u[n - 1];
-9.                     sv2 = -1;
-8.                 }
-7.                 else
-6.                 {
-5.                     su1 = u[j - 1];
-4.                     sv1 = v[j - 1];
-3.                     su2 = u",Useful
/*If point is high then draw plot to point and update view.*/,"-10.                     if ( lstold && !ochange )
-9.                         plP_draw3d( cx, cy, c, j, 1 );
-8.                     else
-7.                         plP_draw3d( cx, cy, c, j, 0 );
-6.                     lstold = 1;
-5.                  ",Useful
"/*--------------------------------------------------------------------------
void  plP_draw3d()

Does a simple move or line draw.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
void plnxtvlo()

Draw the bottom side of the 3-d plot.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*
For the initial set of points, just display them and store them as the
peak points.
*/","
//! @file


 /*
For the initial set of points, just display them and store them as the
peak points.
*/

111",Useful
"/*Otherwise, we need to consider hidden-line removal problem. We scan
over the points in both the old (i.e. oldloview[]) and new (i.e. u[]
and v[]) arrays in order of increasing x coordinate.  At each stage, we
find the line segment in the other array (if one exists) that straddles
the x coordinate of the point. We have to determine if the point lies
above or below the line segment, and to check if the below/above status
has changed since the last point.

If pl3upv = 0 we do not update the view, this is useful for drawing
lines on the graph after we are done plotting points.  Hidden line
removal is still done, but the view is not updated.*/","-10.         for ( i = 1; i < n; i++ )
-9.         {
-8.             oldhiview[2 * i]     = u[i];
-7.             oldhiview[2 * i + 1] = v[i];
-6.             plP_draw3d( u[i], v[i], c, i, 0 );
-5.         }
-4.         mhi = n;
-3.         return;
-2.   ",Useful
"/*(oldloview[2*i], oldloview[2*i]) is the i'th point in the old array
(u[j], v[j]) is the j'th point in the new array.*/","-10.         }
-9.         else
-8.         {
-7.             newloview =
-6.                 (PLINT *) malloc( (size_t) newlosize * sizeof ( PLINT ) );
-5.         }
-4.         if ( !newloview )
-3.             myexit( ""plnxtvlo: Out of memory."" );
-2. ",Useful
"/*The coordinates of the point under consideration are (px,py).  The
line segment joins (sx1,sy1) to (sx2,sy2).  ""ptold"" is true if the
point lies in the old array. We set it by comparing the x coordinates
of the i'th old point and the j'th new point, being careful if we
have fallen past the edges. Having found the point, load up the point
and segment coordinates appropriately.*/","-10. // (u[j], v[j]) is the j'th point in the new array
-9. //
-8. //
-7. // First attempt at 3d shading.  It works ok for simple plots, but
-6. // will just not draw faces, or draw them overlapping for very
-5. // jagged plots
-4. //
-3.     while ( i < ",Useful
"/*
Now determine if the point is lower than the segment, using the
logical function ""above"". We also need to know if it is the old view
or the new view that is lower. ""newlo"" is set true if the new view is
lower than the old.
*/","
//! @file


 /*
Now determine if the point is lower than the segment, using the
logical function ""above"". We also need to know if it is the old view
or the new view that is lower. ""newlo"" is set true if the new view is
lower than the old.
*/

111",Useful
"/*
There is a new intersection point to put in the peak array if the
state of ""newlo"" changes.
*/","
//! @file


 /*
There is a new intersection point to put in the peak array if the
state of ""newlo"" changes.
*/

111",Useful
"/*Take care of special cases at end of arrays.  If pl3upv is 0 the
endpoints are not connected to the old view.*/","-10.             plP_draw3d( px, py, c, j, 1 );
-9.             first  = 0;
-8.             lstold = ptold;
-7.             savehipoint( px, py );
-6.             pthi    = 0;
-5.             ochange = 0;
-4.         }
-3.         else if ( change )
-2.  ",Useful
"/*If pl3upv is not 0 then we do want to connect the current line
with the previous view at the endpoints.  Also find intersection
point with old view.*/","-10.                       ( ( !ptold && i >= mhi ) || ( ptold && j >= n ) ) )
-9.             {
-8.                 plP_draw3d( px, py, c, j, 1 );
-7.                 lstold  = ptold;
-6.                 pthi    = 0;
-5.                 ochange = 0;
-4. ",Useful
/*Determine the intersection*/,"-10.                     su2 = u[n - 1];
-9.                     sv2 = -1;
-8.                 }
-7.                 else
-6.                 {
-5.                     su1 = u[j - 1];
-4.                     sv1 = v[j - 1];
-3.                     su2 = u",Useful
/*If point is low then draw plot to point and update view.*/,"-10.                     if ( lstold && !ochange )
-9.                         plP_draw3d( cx, cy, c, j, 1 );
-8.                     else
-7.                         plP_draw3d( cx, cy, c, j, 0 );
-6.                     lstold = 1;
-5.                  ",Useful
/*Set oldloview*/,"-10.             savelopoint( px, py );
-9.             lstold  = ptold;
-8.             ochange = 0;
-7.         }
-6.         pnewlo = newlo;
-5.         if ( ptold )
-4.             i = i + 1;
-3.         else
-2.             j = j + 1;
-1.     }

 /*S",Useful
"/*--------------------------------------------------------------------------
savehipoint
savelopoint

Add a point to the list of currently visible peaks/valleys, when
drawing the top/bottom surface, respectively.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
swaphiview
swaploview

Swaps the top/bottom views.  Need to do a real swap so that the
memory cleanup routine really frees everything (and only once).
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
freework

Frees memory associated with work arrays
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
myexit

Calls plexit, cleaning up first.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
myabort

Calls plabort, cleaning up first.
Caller should return to the user program.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
int plabv()

Determines if point (px,py) lies above the line joining (sx1,sy1) to
(sx2,sy2). It only works correctly if sx1 <= px <= sx2.
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
void pl3cut()

Determines the point of intersection (cx,cy) between the line joining
(sx1,sy1) to (sx2,sy2) and the line joining (su1,sv1) to (su2,sv2).
--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
"/*--------------------------------------------------------------------------
void plRotationShear

Calculates the rotation and shear angles from a plplot transformation matrix

N.B. the plot transformation matrix

[xFormMatrix[0] xFormMatrix[2]]
[xFormMatrix[1] xFormMatrix[3]]

is calculated as

[stride cos(t)    stride sin(t)]
[sin(p-t)              cos(p-t)]

where t is the rotation angle and p is the shear angle.
The purpose of this routine is to determine stride, rotation angle,
and shear angle from xFormMatrix.

For information only, xFormMatrix is the product of the following
rotation, skew(shear), and scale matrices:

[stride    0] [1      0] [cos(t)  sin(t)]
[0    cos(p)] [tan(p) 1] [-sin(t) cos(t)]

--------------------------------------------------------------------------*/","-6. #if MJL_HACK
-5. static void plP_fill3( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-4.                        PLINT x2, PLINT y2, PLINT j );
-3. static void plP_fill4( PLINT x0, PLINT y0, PLINT x1, PLINT y1,
-2.                        PLINT x2, PLINT y2,",Useful
/*Calculate rotation in range from -pi to pi.*/,"-5. void
-4. plRotationShear( PLFLT *xFormMatrix, PLFLT *rotation, PLFLT *shear, PLFLT *stride )
-3. {
-2.     PLFLT smr;
-1.     *stride = sqrt( xFormMatrix[0] * xFormMatrix[0] + xFormMatrix[2] * xFormMatrix[2] );

 /*Calculate rotation in range from -pi",Useful
/*Calculate shear - rotation in range from -pi to pi.*/,"-1.     *rotation = atan2( xFormMatrix[2], xFormMatrix[0] );

 /*Calculate shear - rotation in range from -pi to pi.*/

1.     smr = atan2( xFormMatrix[1], xFormMatrix[3] );",Useful
/*Calculate shear in range from -2 pi to 2 pi.*/,"-1.     smr = atan2( xFormMatrix[1], xFormMatrix[3] );

 /*Calculate shear in range from -2 pi to 2 pi.*/

1.     *shear = smr + *rotation;",Useful
/*Calculate shear in range from -pi to pi.*/,"-1.     *shear = smr + *rotation;

 /*Calculate shear in range from -pi to pi.*/

1.     if ( *shear < -PI )
2.         *shear += 2. * PI;
3.     else if ( *shear > PI )
4.         *shear -= 2. * PI;",Useful
"/*Actually must honour some convention to calculate the negative
of the shear angle instead of the shear angle. Why??*/","-4.     if ( *shear < -PI )
-3.         *shear += 2. * PI;
-2.     else if ( *shear > PI )
-1.         *shear -= 2. * PI;

 /*Actually must honour some convention to calculate the negative
of the shear angle instead of the shear angle. Why??*/

1.     *sh",Useful
"/*Comment out the modified old logic which determines the negative
of the shear angle in a more complicated way.  Note, the modification
to divide the asin argument by *stride which solved a long-standing
bug (as does the above logic in a simpler way).

shear = -asin( (xFormMatrix[0] * xFormMatrix[1] +
xFormMatrix[2] * xFormMatrix[3] )/ *stride);*/","-1.     *shear = -*shear;

 /*Comment out the modified old logic which determines the negative
of the shear angle in a more complicated way.  Note, the modification
to divide the asin argument by *stride which solved a long-standing
bug (as does the above",Useful
"/*Compute the cross product of the vectors [1,0] and [0,1] to
determine if we need to make a ""quadrant 3,4"" adjustment
to the shear angle.*/","-9.     *shear = -*shear;

 /*Compute the cross product of the vectors [1,0] and [0,1] to
determine if we need to make a ""quadrant 3,4"" adjustment
to the shear angle.*/

111",Useful
"/*--------------------------------------------------------------------------
void plwind()

Set up world coordinates of the viewport boundaries (2d plots).
--------------------------------------------------------------------------*/","-10. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-9. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-8. // GNU Library General Public License for more details.
-7. //
-6. // You should have received a copy of the GN",Useful
/*Best to just warn and recover on bounds errors*/,"-10. c_plwind( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax )
-9. {
-8.     PLFLT    dx, dy, mmxmi, mmxma, mmymi, mmyma;
-7.     PLFLT    xvpwxmin, xvpwxmax, xvpwymin, xvpwymax;
-6.     PLWindow w;
-5.     if ( plsc->level < 2 )
-4.     {
-3.         pl",Useful
"/*The true plot window is made slightly larger than requested so that
the end limits will be on the graph
Get the (slightly extended) window limits.*/","-10.     }
-9.     if ( ymin == ymax )
-8.     {
-7.         plwarn( ""plwind: Invalid window limits in y."" );
-6.         ymin--; ymax++;
-5.     }
-4.     plsc->vpwxmi = xmin;
-3.     plsc->vpwxma = xmax;
-2.     plsc->vpwymi = ymin;
-1.     plsc->vpwyma",Useful
/*Compute the scaling between coordinate systems*/,"-1.     plP_xgvpw( &xvpwxmin, &xvpwxmax, &xvpwymin, &xvpwymax );

 /*Compute the scaling between coordinate systems*/

1.     dx = xvpwxmax - xvpwxmin;
2.     dy = xvpwymax - xvpwymin;
3.     plsc->wpxscl = ( plsc->vppxma - plsc->vppxmi ) / dx;
4.     pls",Useful
/*Set transformation variables for world coordinates to mm*/,"-10.     dx = xvpwxmax - xvpwxmin;
-9.     dy = xvpwymax - xvpwymin;
-8.     plsc->wpxscl = ( plsc->vppxma - plsc->vppxmi ) / dx;
-7.     plsc->wpxoff = ( xmax * plsc->vppxmi - xmin * plsc->vppxma ) / dx;
-6.     plsc->wpyscl = ( plsc->vppyma - plsc->vppy",Useful
/*Set transformation variables for world coordinates to device coords*/,"-4.     plsc->wmxscl = ( mmxma - mmxmi ) / dx;
-3.     plsc->wmxoff = ( xmax * mmxmi - xmin * mmxma ) / dx;
-2.     plsc->wmyscl = ( mmyma - mmymi ) / dy;
-1.     plsc->wmyoff = ( ymax * mmymi - ymin * mmyma ) / dy;

 /*Set transformation variables for wo",Useful
/*Register plot window attributes*/,"-4.     plsc->wdxscl = plsc->wmxscl * plsc->xpmm / ( plsc->phyxma - plsc->phyxmi );
-3.     plsc->wdxoff = plsc->wmxoff * plsc->xpmm / ( plsc->phyxma - plsc->phyxmi );
-2.     plsc->wdyscl = plsc->wmyscl * plsc->ypmm / ( plsc->phyyma - plsc->phyymi );
-1.",Useful
/*Go to level 3*/,"-9.     w.dxmi = plsc->vpdxmi;
-8.     w.dxma = plsc->vpdxma;
-7.     w.dymi = plsc->vpdymi;
-6.     w.dyma = plsc->vpdyma;
-5.     w.wxmi = xvpwxmin;
-4.     w.wxma = xvpwxmax;
-3.     w.wymi = xvpwymin;
-2.     w.wyma = xvpwymax;
-1.     plP_swin( &w );",Useful
"/*--------------------------------------------------------------------------
void plw3d()

Set up a window for three-dimensional plotting. The data are mapped
into a box with world coordinate size ""basex"" by ""basey"" by ""height"",
with the base being symmetrically positioned about zero. Thus
the mapping between data 3-d and world 3-d coordinates is given by:

x = xmin   =>   wx = -0.5*basex
x = xmax   =>   wx =  0.5*basex
y = ymin   =>   wy = -0.5*basey
y = ymax   =>   wy =  0.5*basey
z = zmin   =>   wz =  0.0
z = zmax   =>   wz =  height

The world coordinate box is then viewed from position ""alt""-""az"",
measured in degrees. For proper operation, 0 <= alt <= 90 degrees,
but az can be any value.
--------------------------------------------------------------------------*/","-10. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-9. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-8. // GNU Library General Public License for more details.
-7. //
-6. // You should have received a copy of the GN",Useful
"/*Mathematical explanation of the 3 transformations of coordinates:
(I) Scaling:
x' = cx*(x-x_mid) = cx*(x-plsc->basecx)
y' = cy*(y-y_mid) = cy*(y-plsc->basecy)
z' = zscale*(z-zmin_adjusted) = zscale*(z-plsc->ranmi)
(II) Rotation about z' axis clockwise by the angle of the azimut when
looking from the top in a right-handed coordinate system.
x''          x'
y'' =  M_1 * y'
z''          z'
where the rotation matrix M_1 (see any mathematical physics book such
as Mathematical Methods in the Physical Sciences by Boas) is
caz          -saz       0
saz           caz       0
0             0        1
(III) Rotation about x'' axis by 90 deg - alt to bring z''' axis
coincident with line of sight and x''' and y''' corresponding to
x and y coordinates in the 2D plane of the plot.
x'''          x''
y''' =  M_2 * y''
z'''          z''
where the rotation matrix M_2 is
1            0         0
0           salt      calt
0          -calt      salt
Note
x'''          x'
y''' =  M *   y'
z'''          z'
where M = M_2*M_1 is given by
caz      -saz     0
salt*saz  salt*caz    calt
-calt*saz -calt*caz    salt
plP_w3wcx and plP_w3wcy take the combination of the plsc->basecx,
plsc->basecy, plsc->ranmi, plsc->cxx, plsc->cxy, plsc->cyx, plsc->cyy, and
plsc->cyz data stored here to implement the combination of the 3
transformations to determine x''' and y''' from x, y, and z.*/","-10.     plsc->domxma = xmax_adjusted;
-9.     plsc->domymi = ymin_adjusted;
-8.     plsc->domyma = ymax_adjusted;
-7.     plsc->zzscl  = zscale;
-6.     plsc->ranmi  = zmin_adjusted;
-5.     plsc->ranma  = zmax_adjusted;
-4.     plsc->base3x = basex;
-3.",Useful
/*Static function prototypes*/,"-10. #include ""plplotP.h""
-9. #define STRING_LEN         40
-8. #define FORMAT_LEN         10
-7. #define TEMP_LEN           30
-6. #define N_EDGE_SEGMENTS    50
-5. static PLFLT xlog[8] =
-4. {
-3.     0.301030, 0.477121, 0.602060, 0.698970,
-2.     0.77",Useful
"/*--------------------------------------------------------------------------
void plbox()

This draws a box around the current viewport, complete with axes, ticks,
numeric labels, and grids, according to input specification.  Just a
front-end to plaxes(), which allows arbitrary placement of coordinate
axes when plotted (here the origin is at 0,0).  See the documentation for
plaxes() for more info.
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
"/*--------------------------------------------------------------------------
void plaxes()

This draws a box around the current viewport, complete with axes,
ticks, numeric labels, and grids, according to input specification.

x0 and y0 specify the origin of the axes.

xopt and yopt are character strings which define the box as follows:

a: Draw axis (X is horizontal line Y=0, Y is vertical line X=0)
b: Draw bottom (X) or left (Y) frame of box
c: Draw top (X) or right (Y) frame of box
d: Interpret axis as a date/time when writing labels
f: Always use fixed point numeric labels
g: Draws a grid at the major tick interval
h: Draws a grid at the minor tick interval
i: Inverts tick marks
l: Logarithmic axes, major ticks at decades, minor ticks at units
n: Write numeric label at conventional location
m: Write numeric label at unconventional location
o: Label text is generated by a user-defined function
t: Draw major tick marks
s: Draw minor tick marks
u: like b (including all side effects such as tick marks and numerical
labels for those) except exclude drawing the edge.
w: like c (including all side effects such as tick marks and numerical
labels for those) except exclude drawing the edge.
v: (for Y only) Label vertically
x: like t (including the side effect of the numerical labels for the major
ticks) except exclude drawing the major and minor tick marks.

xtick, ytick are the major tick intervals required, zero for
automatic selection

nxsub, nysub are the number of subtick intervals in a major tick
interval
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
/*Open the clip limits to the subpage limits*/,"-10.     PLINT  vppxmi, vppxma, vppymi, vppyma;
-9.     PLFLT  xtick1, ytick1, vpwxmi, vpwxma, vpwymi, vpwyma;
-8.     PLFLT  vpwxmin, vpwxmax, vpwymin, vpwymax;
-7.     PLFLT  xp0, yp0, tn, tp, temp;
-6.     PLFLT  factor, tstart;
-5.     if ( plsc->leve",Useful
"/*Bounding-box limits for the box in mm before corrections
for decorations are applied.*/","-9.     plP_gclp( &lxmin, &lxmax, &lymin, &lymax );
-8.     plP_gphy( &pxmin, &pxmax, &pymin, &pymax );
-7.     plP_sclp( pxmin, pxmax, pymin, pymax );
-6.     vppxmi = plsc->vppxmi;
-5.     vppxma = plsc->vppxma;
-4.     vppymi = plsc->vppymi;
-3.     vp",Useful
/*Set plot options from input*/,"-5.         plsc->boxbb_xmin = plsc->vppxmi / plsc->xpmm;
-4.         plsc->boxbb_xmax = plsc->vppxma / plsc->xpmm;
-3.         plsc->boxbb_ymin = plsc->vppymi / plsc->ypmm;
-2.         plsc->boxbb_ymax = plsc->vppyma / plsc->ypmm;
-1.     }

 /*Set plot ",Useful
/*Tick and subtick sizes in device coords*/,"-10.     lcy = plP_stsearch( yopt, 'c' );
-9.     ldy = plP_stsearch( yopt, 'd' );
-8.     lgy = plP_stsearch( yopt, 'g' );
-7.     liy = plP_stsearch( yopt, 'i' );
-6.     lly = plP_stsearch( yopt, 'l' );
-5.     lsy = plP_stsearch( yopt, 's' );
-4.     ",Useful
"/*vpwxmi always numerically less than vpwxma, and
similarly for vpwymi*/","-9.     xmajor = MAX( ROUND( plsc->majht * plsc->ypmm ), 1 );
-8.     ymajor = MAX( ROUND( plsc->majht * plsc->xpmm ), 1 );
-7.     xminor = MAX( ROUND( plsc->minht * plsc->ypmm ), 1 );
-6.     yminor = MAX( ROUND( plsc->minht * plsc->xpmm ), 1 );
-5.    ",Useful
/*Plot axes only if they are inside viewport.*/,"-4.     vpwxmi = ( vpwxmax > vpwxmin ) ? vpwxmin : vpwxmax;
-3.     vpwxma = ( vpwxmax > vpwxmin ) ? vpwxmax : vpwxmin;
-2.     vpwymi = ( vpwymax > vpwymin ) ? vpwymin : vpwymax;
-1.     vpwyma = ( vpwymax > vpwymin ) ? vpwymax : vpwymin;

 /*Plot axes o",Useful
/*Calculate tick spacing*/,"-2.     lax = lax && vpwymi < y0 && y0 < vpwyma;
-1.     lay = lay && vpwxmi < x0 && x0 < vpwxma;

 /*Calculate tick spacing*/

1.     if ( ltx || lgx || lxx )
2.         pldtik( vpwxmi, vpwxma, &xtick1, &nxsub1, ldx );
3.     if ( lty || lgy || lxy )
4. ",Useful
"/*n.b. large change; xtick1, nxsub1, ytick1, nysub1 always positive.*/","-4.     if ( ltx || lgx || lxx )
-3.         pldtik( vpwxmi, vpwxma, &xtick1, &nxsub1, ldx );
-2.     if ( lty || lgy || lxy )
-1.         pldtik( vpwymi, vpwyma, &ytick1, &nysub1, ldy );

 /*n.b. large change; xtick1, nxsub1, ytick1, nysub1 always positi",Useful
/*Set up tick variables*/,"-5.     if ( ltx || lgx || lxx )
-4.         pldtik( vpwxmi, vpwxma, &xtick1, &nxsub1, ldx );
-3.     if ( lty || lgy || lxy )
-2.         pldtik( vpwymi, vpwyma, &ytick1, &nysub1, ldy );

 /*Set up tick variables*/

1.     if ( lix )
2.     {
3.         ",Useful
"/*Carefully follow logic below (and above) for the case where
an inverted major tick mark is written (in the X direction
for a Y axis and vice versa).  Ignore minor tick marks
which are assumed to be smaller.  Ignore axes and grids
which are all contained within the viewport.*/","-10.     }
-9.     else
-8.     {
-7.         i1y = 0;
-6.         i2y = yminor;
-5.         i3y = 0;
-4.         i4y = ymajor;
-3.     }
-2.     if ( plsc->if_boxbb )
-1.     {

 /*Carefully follow logic below (and above) for the case where
an inverted m",Useful
/*Draw the bottom frame of the box*/,"-10.             plsc->boxbb_ymin -= xmajor / plsc->ypmm;
-9.         if ( liy && ( lcy || lwy ) && ( lty && !lxy ) )
-8.             plsc->boxbb_xmax += ymajor / plsc->xpmm;
-7.         if ( lix && ( lcx || lwx ) && ( ltx && !lxx ) )
-6.             plsc",Useful
/*Draw the right-hand frame of box*/,"-10.                             }
-9.                         }
-8.                     }
-7.                     if ( !BETW( tn, vpwxmi, vpwxma ) )
-6.                         break;
-5.                     plxtik( plP_wcpcx( tn ), vppymi, i3x, i4x );
-",Useful
/*Draw the top frame of the box*/,"-10.                             }
-9.                         }
-8.                     }
-7.                     if ( !BETW( tn, vpwymi, vpwyma ) )
-6.                         break;
-5.                     plytik( vppxma, plP_wcpcy( tn ), i4y, i3y );
-",Useful
/*Draw the left-hand frame of box*/,"-10.                             }
-9.                         }
-8.                     }
-7.                     if ( !BETW( tn, vpwxmi, vpwxma ) )
-6.                         break;
-5.                     plxtik( plP_wcpcx( tn ), vppyma, i4x, i3x );
-",Useful
/*Draw the horizontal axis.*/,"-10.                             }
-9.                         }
-8.                     }
-7.                     if ( !BETW( tn, vpwymi, vpwyma ) )
-6.                         break;
-5.                     plytik( vppxmi, plP_wcpcy( tn ), i3y, i4y );
-",Useful
/*Convert world coordinates to physical*/,"-2.         if ( lax )
-1.         {

 /*Convert world coordinates to physical*/

1.             yp0 = plP_wcpcy( y0 );
2.             plP_movphy( vppxmi, (PLINT) yp0 );
3.             plP_draphy( vppxma, (PLINT) yp0 );
4.             if ( ltx && !lxx )
5",Useful
/*Draw the vertical axis.*/,"-10.                             }
-9.                         }
-8.                     }
-7.                     if ( !BETW( tn, vpwxmi, vpwxma ) )
-6.                         break;
-5.                     plxtik( plP_wcpcx( tn ), (PLINT) yp0, xmajor, ",Useful
/*Convert world coordinates to physical*/,"-2.         if ( lax )
-1.         {

 /*Convert world coordinates to physical*/

1.             yp0 = plP_wcpcy( y0 );
2.             plP_movphy( vppxmi, (PLINT) yp0 );
3.             plP_draphy( vppxma, (PLINT) yp0 );
4.             if ( ltx && !lxx )
5",Useful
/*Draw grids.*/,"-10.                             }
-9.                         }
-8.                     }
-7.                     if ( !BETW( tn, vpwymi, vpwyma ) )
-6.                         break;
-5.                     plytik( (PLINT) xp0, plP_wcpcy( tn ), ymajor, ",Useful
/*Write labels.*/,"-2.         grid_box( xopt, xtick1, nxsub1, yopt, ytick1, nysub1 );
-1.     }

 /*Write labels.*/

1.     label_box( xopt, xtick1, yopt, ytick1 );",Useful
/*Restore the clip limits to viewport edge*/,"-1.     label_box( xopt, xtick1, yopt, ytick1 );

 /*Restore the clip limits to viewport edge*/

1.     plP_sclp( lxmin, lxmax, lymin, lymax );
2. }",Useful
"/*--------------------------------------------------------------------------
void plbox3()

This is the 3-d analogue of plbox().
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
"/*We have to wait until after the plot is drawn to draw back
grid so store this stuff.*/","-10.     }
-9.     plP_gw3wc( &cxx, &cxy, &cyx, &cyy, &cyz );
-8.     plP_gdom( &xmin, &xmax, &ymin, &ymax );
-7.     plP_grange( &zscale, &zmin, &zmax );
-6.     plgxax( &xdigmax, &xdigits );
-5.     plgyax( &ydigmax, &ydigits );
-4.     plgzax( &zdigmax",Useful
/*save tick spacing*/,"-4.     plP_gzback( &zbflg, &zbcol, &zbtck, &zbwidth );
-3.     *zbflg = plP_stsearch( zopt, 'd' );
-2.     if ( *zbflg )
-1.     {

 /*save tick spacing*/

111",Useful
/*and color*/,"-5.     plP_gzback( &zbflg, &zbcol, &zbtck, &zbwidth );
-4.     *zbflg = plP_stsearch( zopt, 'd' );
-3.     if ( *zbflg )
-2.     {

 /*and color*/

111",Useful
/*and line width*/,"-6.     plP_gzback( &zbflg, &zbcol, &zbtck, &zbwidth );
-5.     *zbflg = plP_stsearch( zopt, 'd' );
-4.     if ( *zbflg )
-3.     {

 /*and line width*/

1.     }
2.     if ( cxx >= 0.0 && cxy <= 0.0 )
3.     {
4.         ln = plP_stsearch( xopt, 'n' );
5",Useful
/*restore zdigits to initial value for second call*/,"-10.         plzbx( zopt, zlabel, 1, dx, dy, ux, uy,
-9.             plP_w3wcy( xmax, ymin, zmax ), zmin, zmax, ztick, nzsub, &zdigits );
-8.         tx = plP_w3wcx( xmin, ymax, zmin );
-7.         ty = plP_w3wcy( xmin, ymax, zmin );
-6.         ux = plP_",Useful
/*restore zdigits to initial value for second call*/,"-10.         plzbx( zopt, zlabel, 1, dx, dy, ux, uy,
-9.             plP_w3wcy( xmax, ymin, zmax ), zmin, zmax, ztick, nzsub, &zdigits );
-8.         tx = plP_w3wcx( xmin, ymax, zmin );
-7.         ty = plP_w3wcy( xmin, ymax, zmin );
-6.         ux = plP_",Useful
/*restore zdigits to initial value for second call*/,"-10.         plzbx( zopt, zlabel, 1, dx, dy, ux, uy,
-9.             plP_w3wcy( xmax, ymin, zmax ), zmin, zmax, ztick, nzsub, &zdigits );
-8.         tx = plP_w3wcx( xmin, ymax, zmin );
-7.         ty = plP_w3wcy( xmin, ymax, zmin );
-6.         ux = plP_",Useful
/*restore zdigits to initial value for second call*/,"-10.         plzbx( zopt, zlabel, 1, dx, dy, ux, uy,
-9.             plP_w3wcy( xmax, ymin, zmax ), zmin, zmax, ztick, nzsub, &zdigits );
-8.         tx = plP_w3wcx( xmin, ymax, zmin );
-7.         ty = plP_w3wcy( xmin, ymax, zmin );
-6.         ux = plP_",Useful
"/*--------------------------------------------------------------------------
Support routines for 3d box draw.
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
"/*--------------------------------------------------------------------------
void plxybx()

This draws a sloping line from (wx1,wy1) to (wx2,wy2) which represents an
axis of a 3-d graph with data values from ""vmin"" to ""vmax"". Depending on
""opt"", vertical ticks and/or subticks are placed on the line at major tick
interval ""tick"" with ""nsub"" subticks between major ticks. If ""tick"" and/or
""nsub"" is zero, automatic tick positions are computed

b: Draw box boundary
d: Interpret axis as a date/time when writing labels
f: Always use fixed point numeric labels
i: Inverts tick marks (i.e. drawn downwards)
l: Logarithmic axes, major ticks at decades, minor ticks at units
n: Write numeric label
o: Use custom label function
s: Draw minor tick marks
t: Draw major tick marks
u: Write label on line
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
/*Tick and subtick sizes in device coords*/,"-10.     lcy = plP_stsearch( yopt, 'c' );
-9.     ldy = plP_stsearch( yopt, 'd' );
-8.     lgy = plP_stsearch( yopt, 'g' );
-7.     liy = plP_stsearch( yopt, 'i' );
-6.     lly = plP_stsearch( yopt, 'l' );
-5.     lsy = plP_stsearch( yopt, 's' );
-4.     ",Useful
/*Draw the line*/,"-10.         i3 = major;
-9.         i4 = 0;
-8.     }
-7.     else
-6.     {
-5.         i1 = 0;
-4.         i2 = minor;
-3.         i3 = 0;
-2.         i4 = major;
-1.     }

 /*Draw the line*/

1.     plP_movwor( wx1, wy1 );
2.     plP_drawor( wx2, wy2",Useful
/*Label the line*/,"-10.             if ( !BETW( temp, vmin, vmax ) )
-9.                 break;
-8.             lambda = ( vmax_in > vmin_in ) ?
-7.                      ( temp - vmin ) / ( vmax - vmin ) :
-6.                      ( vmax - temp ) / ( vmax - vmin );
-5.     ",Useful
"/*--------------------------------------------------------------------------
void plxytx()

Prints out text along a sloping axis joining world coordinates
(wx1,wy1) to (wx2,wy2). Parameters are as for plmtext.
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
"/*--------------------------------------------------------------------------
void plzbx()

This draws a vertical line from (wx,wy1) to (wx,wy2) which represents the
vertical axis of a 3-d graph with data values from ""vmin"" to ""vmax"".
Depending on ""opt"", ticks and/or subticks are placed on the line at major
tick interval ""tick"" with ""nsub"" subticks between major ticks. If ""tick""
and/or ""nsub"" is zero, automatic tick positions are computed

b: Draws left-hand axis
c: Draws right-hand axis
N.B. d is already used for another purpose (back grid) in zopt
before this routine is called so chose e here to be as close to d
as possible without interfering with the historical use of d.
e: Interpret axis as a date/time when writing labels
f: Always use fixed point numeric labels
i: Inverts tick marks (i.e. drawn to the left)
l: Logarithmic axes, major ticks at decades, minor ticks at units
m: Write numeric label on right axis
n: Write numeric label on left axis
o: Use custom label function
s: Draw minor tick marks
t: Draw major tick marks
u: Writes left-hand label
v: Writes right-hand label
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
/*Tick and subtick sizes in device coords*/,"-10.     lcy = plP_stsearch( yopt, 'c' );
-9.     ldy = plP_stsearch( yopt, 'd' );
-8.     lgy = plP_stsearch( yopt, 'g' );
-7.     liy = plP_stsearch( yopt, 'i' );
-6.     lly = plP_stsearch( yopt, 'l' );
-5.     lsy = plP_stsearch( yopt, 's' );
-4.     ",Useful
/*Draw the line*/,"-10.         i3 = major;
-9.         i4 = 0;
-8.     }
-7.     else
-6.     {
-5.         i1 = 0;
-4.         i2 = minor;
-3.         i3 = 0;
-2.         i4 = major;
-1.     }

 /*Draw the line*/

1.     plP_movwor( wx1, wy1 );
2.     plP_drawor( wx2, wy2",Useful
/*Label the line*/,"-10.             if ( !BETW( temp, vmin, vmax ) )
-9.                 break;
-8.             lambda = ( vmax_in > vmin_in ) ?
-7.                      ( temp - vmin ) / ( vmax - vmin ) :
-6.                      ( vmax - temp ) / ( vmax - vmin );
-5.     ",Useful
"/*--------------------------------------------------------------------------
void plztx()

Prints out text along a vertical axis for a 3d plot joining
world coordinates (wx,wy1) to (wx,wy2).
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
"/*--------------------------------------------------------------------------
void grid_box()

Draws grids at tick locations (major and/or minor).

Note that 'tspace' is the minimim distance away (in fractional number
of ticks or subticks) from the boundary a grid line can be drawn.  If
you are too close, it looks bad.
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
/*Set plot options from input*/,"-5.         plsc->boxbb_xmin = plsc->vppxmi / plsc->xpmm;
-4.         plsc->boxbb_xmax = plsc->vppxma / plsc->xpmm;
-3.         plsc->boxbb_ymin = plsc->vppymi / plsc->ypmm;
-2.         plsc->boxbb_ymax = plsc->vppyma / plsc->ypmm;
-1.     }

 /*Set plot ",Useful
"/*n.b. large change; vpwxmi always numerically less than vpwxma, and
similarly for vpwymi*/","-10.     lfy = plP_stsearch( yopt, 'f' );
-9.     liy = plP_stsearch( yopt, 'i' );
-8.     lly = plP_stsearch( yopt, 'l' );
-7.     lmy = plP_stsearch( yopt, 'm' );
-6.     lny = plP_stsearch( yopt, 'n' );
-5.     lty = plP_stsearch( yopt, 't' );
-4.     ",Useful
/*Draw grid in x direction.*/,"-4.     vpwxmi = ( vpwxmax > vpwxmin ) ? vpwxmin : vpwxmax;
-3.     vpwxma = ( vpwxmax > vpwxmin ) ? vpwxmax : vpwxmin;
-2.     vpwymi = ( vpwymax > vpwymin ) ? vpwymin : vpwymax;
-1.     vpwyma = ( vpwymax > vpwymin ) ? vpwymax : vpwymin;

 /*Draw grid i",Useful
/*Draw grid in y direction*/,"-10.                         if ( BETW( temp, vpwxmi + tcrit, vpwxma - tcrit ) )
-9.                             pljoin( temp, vpwymi, temp, vpwyma );
-8.                     }
-7.                 }
-6.             }
-5.             tcrit = xtick1 * tspac",Useful
"/*--------------------------------------------------------------------------
void label_box()

Writes numeric labels on side(s) of box.
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
"/*pos, height, and just are unnecessarily set to quiet
-O3 -Wuninitialized warnings that are obvious false alarms from
the clarity of the code associated with the true or false
result for custom_exponent_placement.*/","-1.     PLBOOL custom_exponent_placement = !plsc->label_func && plsc->label_data;

 /*pos, height, and just are unnecessarily set to quiet
-O3 -Wuninitialized warnings that are obvious false alarms from
the clarity of the code associated with the true or ",Useful
/*Set plot options from input*/,"-5.         plsc->boxbb_xmin = plsc->vppxmi / plsc->xpmm;
-4.         plsc->boxbb_xmax = plsc->vppxma / plsc->xpmm;
-3.         plsc->boxbb_ymin = plsc->vppymi / plsc->ypmm;
-2.         plsc->boxbb_ymax = plsc->vppyma / plsc->ypmm;
-1.     }

 /*Set plot ",Useful
"/*vpwxmi always numerically less than vpwxma, and
similarly for vpwymi*/","-9.     xmajor = MAX( ROUND( plsc->majht * plsc->ypmm ), 1 );
-8.     ymajor = MAX( ROUND( plsc->majht * plsc->xpmm ), 1 );
-7.     xminor = MAX( ROUND( plsc->minht * plsc->ypmm ), 1 );
-6.     yminor = MAX( ROUND( plsc->minht * plsc->xpmm ), 1 );
-5.    ",Useful
/*Write label(s) for horizontal axes.*/,"-4.     vpwxmi = ( vpwxmax > vpwxmin ) ? vpwxmin : vpwxmax;
-3.     vpwxma = ( vpwxmax > vpwxmin ) ? vpwxmax : vpwxmin;
-2.     vpwymi = ( vpwymax > vpwymin ) ? vpwymin : vpwymax;
-1.     vpwyma = ( vpwymax > vpwymin ) ? vpwymax : vpwymin;

 /*Write label",Useful
/*Bottom axis.*/,"-10.                   ( vpwxma - tn ) / ( vpwxma - vpwxmi );
-9.             if ( plsc->if_boxbb )
-8.             {
-7.                 string_length_mm = plstrl( string );
-6.                 pos_mm           = ( plsc->vppxmi + pos *
-5.               ",Useful
/*Top axis.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""b"", height, pos, 0.5, s",Useful
/*Write separate exponential label if mode = 1.*/,"-10.                         pos_mm + 0.5 * string_length_mm );
-9.                 }
-8.                 else
-7.                 {
-6.                     plmtex( ""t"", height, pos, 0.5, string );
-5.                 }
-4.             }
-3.         }
-2.",Useful
/*Bottom axis exponent.*/,"-10.             }
-9.             else
-8.             {
-7.                 height = 3.2;
-6.                 pos    = 1.0;
-5.                 just   = 0.5;
-4.             }
-3.             snprintf( string, STRING_LEN, ""(x10%su%d%sd)"", esc_string, (i",Useful
/*Top axis exponent.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""b"", height, pos, just, ",Useful
/*Write label(s) for vertical axes.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""t"", height, pos, just, ",Useful
/*Left axis with text written perpendicular to edge.*/,"-10.             {
-9.                 plform( PL_Y_AXIS, tn, yscale, yprec, string, STRING_LEN, lly, lfy, loy );
-8.             }
-7.             pos = ( vpwymax > vpwymin ) ?
-6.                   ( tn - vpwymi ) / ( vpwyma - vpwymi ) :
-5.            ",Useful
"/*Expected offset is 0.5, but adjust to improve
look of result.*/","-7.                         height_mm        = ( height + 0.0 ) * char_height_mm;
-6.                         string_length_mm = plstrl( string );
-5.                         plsc->boxbb_xmin = MIN( plsc->boxbb_xmin, plsc->vppxmi /
-4.                    ",Useful
/*Left axis with text written parallel to edge.*/,"-10.                         plsc->boxbb_ymax = MAX( plsc->boxbb_ymax,
-9.                             pos_mm + 0.7 * char_height_mm );
-8.                     }
-7.                     else
-6.                     {
-5.                         plmtex( ""l",Useful
/*Right axis with text written perpendicular to edge.*/,"-10.                     else
-9.                     {
-8.                         plmtex( ""l"", height, pos, 0.5, string );
-7.                     }
-6.                 }
-5.             }
-4.             if ( lmy )
-3.             {
-2.                ",Useful
"/*Expected offset is 0.5, but adjust to improve
look of result.*/","-7.                         height_mm        = ( height + 0.0 ) * char_height_mm;
-6.                         string_length_mm = plstrl( string );
-5.                         plsc->boxbb_xmin = MIN( plsc->boxbb_xmin, plsc->vppxmi /
-4.                    ",Useful
/*Right axis with text written parallel to edge.*/,"-10.                         plsc->boxbb_ymax = MAX( plsc->boxbb_ymax,
-9.                             pos_mm + 0.7 * char_height_mm );
-8.                     }
-7.                     else
-6.                     {
-5.                         plmtex( ""r",Useful
/*Write separate exponential label if mode = 1.*/,"-10.                         pos_mm + 0.5 * string_length_mm );
-9.                 }
-8.                 else
-7.                 {
-6.                     plmtex( ""t"", height, pos, 0.5, string );
-5.                 }
-4.             }
-3.         }
-2.",Useful
"/*more space to clear labels in ""v"" mode*/","-10.         {
-9.             snprintf( string, STRING_LEN, ""(x10%su%d%sd)"", esc_string, (int) yscale, esc_string );
-8.             if ( custom_exponent_placement )
-7.             {
-6.                 height = ( (PLLabelDefaults *) plsc->label_data )-",Useful
/*Left axis exponent*/,"-5.             }
-4.             else
-3.             {
-2.                 offset = 0.02;
-1.             }

 /*Left axis exponent*/

1.             if ( lny )
2.             {
3.                 if ( !custom_exponent_placement )
4.                 {
5.",Useful
/*Right axis exponent.*/,"-10.                     if ( lvy )
-9.                     {
-8.                         plmtex( ""lv"", height, pos, just, string );
-7.                     }
-6.                     else
-5.                     {
-4.                         plmtex( ""l"", ",Useful
/*Extra space for superscript*/,"-4.             if ( lmy )
-3.             {
-2.                 if ( !custom_exponent_placement )
-1.                 {

 /*Extra space for superscript*/

1.                     pos    = 1.0 + offset;
2.                     just   = 0.5;
3.              ",Useful
"/*For horizontal axes, height of zero corresponds
to character centred on edge so should add 0.5
to height to obtain bounding box edge in
direction away from edge if no exponent.  Add
an additional offset to make exponent fit.*/","-2.                 if ( plsc->if_boxbb )
-1.                 {

 /*For horizontal axes, height of zero corresponds
to character centred on edge so should add 0.5
to height to obtain bounding box edge in
direction away from edge if no exponent.  Add
an ad",Useful
"/*--------------------------------------------------------------------------
void label_box_custom()

Writes numeric labels on side(s) of box in custom locations
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
"/*pos, height, and just are unnecessarily set to quiet
-O3 -Wuninitialized warnings that are obvious false alarms from
the clarity of the code associated with the true or false
result for custom_exponent_placement.*/","-1.     PLBOOL custom_exponent_placement = !plsc->label_func && plsc->label_data;

 /*pos, height, and just are unnecessarily set to quiet
-O3 -Wuninitialized warnings that are obvious false alarms from
the clarity of the code associated with the true or ",Useful
/*Save some parameters*/,"-3.     PLFLT         pos = 0.0, height = 0.0, just = 0.0;
-2.     PLCHAR_VECTOR esc_string = plgesc_string();
-1.     plgchr( &default_mm, &char_height_mm );

 /*Save some parameters*/

1.     plgxax( &xdigmax, &xdigits );
2.     plgyax( &ydigmax, &ydigi",Useful
/*Open the clip limits to the subpage limits*/,"-10.     PLINT  vppxmi, vppxma, vppymi, vppyma;
-9.     PLFLT  xtick1, ytick1, vpwxmi, vpwxma, vpwymi, vpwyma;
-8.     PLFLT  vpwxmin, vpwxmax, vpwymin, vpwymax;
-7.     PLFLT  xp0, yp0, tn, tp, temp;
-6.     PLFLT  factor, tstart;
-5.     if ( plsc->leve",Useful
/*Set plot options from input*/,"-5.         plsc->boxbb_xmin = plsc->vppxmi / plsc->xpmm;
-4.         plsc->boxbb_xmax = plsc->vppxma / plsc->xpmm;
-3.         plsc->boxbb_ymin = plsc->vppymi / plsc->ypmm;
-2.         plsc->boxbb_ymax = plsc->vppyma / plsc->ypmm;
-1.     }

 /*Set plot ",Useful
"/*n.b. large change; vpwxmi always numerically less than vpwxma, and
similarly for vpwymi*/","-10.     lfy = plP_stsearch( yopt, 'f' );
-9.     liy = plP_stsearch( yopt, 'i' );
-8.     lly = plP_stsearch( yopt, 'l' );
-7.     lmy = plP_stsearch( yopt, 'm' );
-6.     lny = plP_stsearch( yopt, 'n' );
-5.     lty = plP_stsearch( yopt, 't' );
-4.     ",Useful
"/*Bounding-box limits for the box in mm before corrections
for decorations are applied.*/","-9.     plP_gclp( &lxmin, &lxmax, &lymin, &lymax );
-8.     plP_gphy( &pxmin, &pxmax, &pymin, &pymax );
-7.     plP_sclp( pxmin, pxmax, pymin, pymax );
-6.     vppxmi = plsc->vppxmi;
-5.     vppxma = plsc->vppxma;
-4.     vppymi = plsc->vppymi;
-3.     vp",Useful
/*Write label(s) for horizontal axes.*/,"-4.     vpwxmi = ( vpwxmax > vpwxmin ) ? vpwxmin : vpwxmax;
-3.     vpwxma = ( vpwxmax > vpwxmin ) ? vpwxmax : vpwxmin;
-2.     vpwymi = ( vpwymax > vpwymin ) ? vpwymin : vpwymax;
-1.     vpwyma = ( vpwymax > vpwymin ) ? vpwymax : vpwymin;

 /*Write label",Useful
"/*Determine spacing between ticks
Use the x-size of the window*/","-4.     if ( ( lmx || lnx ) && ( ltx || lxx ) )
-3.     {
-2.         PLINT xmode, xprec, xscale;
-1.         PLFLT x_spacing, x_spacing_tmp;

 /*Determine spacing between ticks
Use the x-size of the window*/

1.         x_spacing = vpwxma - vpwxmi;
2.   ",Useful
/*Use the smallest space between ticks*/,"-3.         x_spacing = vpwxma - vpwxmi;
-2.         if ( n_xticks > 1 )
-1.         {

 /*Use the smallest space between ticks*/

1.             for ( i = 1; i < n_xticks; i++ )
2.             {
3.                 x_spacing_tmp = fabs( xticks[i] - xticks",Useful
/*Loop through all of the tick marks*/,"-8.             height_mm = ( height + 0.7 ) * char_height_mm;
-7.             if ( lnx )
-6.                 plsc->boxbb_ymin = MIN( plsc->boxbb_ymin, plsc->vppymi /
-5.                     plsc->ypmm - height_mm );
-4.             if ( lmx )
-3.        ",Useful
/*Top axis.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""b"", height, pos, 0.5, s",Useful
/*Write separate exponential label if mode = 1.*/,"-10.                         pos_mm + 0.5 * string_length_mm );
-9.                 }
-8.                 else
-7.                 {
-6.                     plmtex( ""t"", height, pos, 0.5, string );
-5.                 }
-4.             }
-3.         }
-2.",Useful
/*Bottom axis exponent.*/,"-10.             }
-9.             else
-8.             {
-7.                 height = 3.2;
-6.                 pos    = 1.0;
-5.                 just   = 0.5;
-4.             }
-3.             snprintf( string, STRING_LEN, ""(x10%su%d%sd)"", esc_string, (i",Useful
/*Top axis exponent.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""b"", height, pos, just, ",Useful
/*Write label(s) for vertical axes.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""t"", height, pos, just, ",Useful
"/*Determine spacing between ticks
Use the y-size of the window*/","-4.     if ( ( lmy || lny ) && ( lty || lxy ) )
-3.     {
-2.         PLINT ymode, yprec, yscale;
-1.         PLFLT y_spacing, y_spacing_tmp;

 /*Determine spacing between ticks
Use the y-size of the window*/

1.         y_spacing = vpwyma - vpwymi;
2.   ",Useful
/*Use the smallest space between ticks*/,"-3.         x_spacing = vpwxma - vpwxmi;
-2.         if ( n_xticks > 1 )
-1.         {

 /*Use the smallest space between ticks*/

1.             for ( i = 1; i < n_xticks; i++ )
2.             {
3.                 x_spacing_tmp = fabs( xticks[i] - xticks",Useful
/*Left axis with text written perpendicular to edge.*/,"-10.             {
-9.                 plform( PL_Y_AXIS, tn, yscale, yprec, string, STRING_LEN, lly, lfy, loy );
-8.             }
-7.             pos = ( vpwymax > vpwymin ) ?
-6.                   ( tn - vpwymi ) / ( vpwyma - vpwymi ) :
-5.            ",Useful
"/*Expected offset is 0.5, but adjust to improve
look of result.*/","-7.                         height_mm        = ( height + 0.0 ) * char_height_mm;
-6.                         string_length_mm = plstrl( string );
-5.                         plsc->boxbb_xmin = MIN( plsc->boxbb_xmin, plsc->vppxmi /
-4.                    ",Useful
"/*For vertical axes with text written
parallel to edge, height of zero
corresponds to character centred on edge so
should add 0.5 to height to obtain bounding
box edge in direction away from edge,
However, experimentally found 0.8 gave a
better looking result.*/","-3.                     height = liy ? 1.75 : 1.5;
-2.                     if ( plsc->if_boxbb )
-1.                     {

 /*For vertical axes with text written
parallel to edge, height of zero
corresponds to character centred on edge so
should add 0.5 ",Useful
/*Right axis with text written perpendicular to edge.*/,"-10.                     else
-9.                     {
-8.                         plmtex( ""l"", height, pos, 0.5, string );
-7.                     }
-6.                 }
-5.             }
-4.             if ( lmy )
-3.             {
-2.                ",Useful
"/*Expected offset is 0.5, but adjust to improve
look of result.*/","-7.                         height_mm        = ( height + 0.0 ) * char_height_mm;
-6.                         string_length_mm = plstrl( string );
-5.                         plsc->boxbb_xmin = MIN( plsc->boxbb_xmin, plsc->vppxmi /
-4.                    ",Useful
/*Right axis with text written parallel to edge.*/,"-10.                         plsc->boxbb_ymax = MAX( plsc->boxbb_ymax,
-9.                             pos_mm + 0.7 * char_height_mm );
-8.                     }
-7.                     else
-6.                     {
-5.                         plmtex( ""r",Useful
/*Write separate exponential label if mode = 1.*/,"-10.                         pos_mm + 0.5 * string_length_mm );
-9.                 }
-8.                 else
-7.                 {
-6.                     plmtex( ""t"", height, pos, 0.5, string );
-5.                 }
-4.             }
-3.         }
-2.",Useful
"/*more space to clear labels in ""v"" mode*/","-10.         {
-9.             snprintf( string, STRING_LEN, ""(x10%su%d%sd)"", esc_string, (int) yscale, esc_string );
-8.             if ( custom_exponent_placement )
-7.             {
-6.                 height = ( (PLLabelDefaults *) plsc->label_data )-",Useful
/*Left axis exponent.*/,"-5.             }
-4.             else
-3.             {
-2.                 offset = 0.02;
-1.             }

 /*Left axis exponent.*/

1.             if ( lny )
2.             {
3.                 if ( !custom_exponent_placement )
4.                 {
5",Useful
/*Right axis exponent.*/,"-10.                     if ( lvy )
-9.                     {
-8.                         plmtex( ""lv"", height, pos, just, string );
-7.                     }
-6.                     else
-5.                     {
-4.                         plmtex( ""l"", ",Useful
/*Extra space for superscript*/,"-4.             if ( lmy )
-3.             {
-2.                 if ( !custom_exponent_placement )
-1.                 {

 /*Extra space for superscript*/

1.                     pos    = 1.0 + offset;
2.                     just   = 0.5;
3.              ",Useful
/*Restore saved parameters*/,"-10.                         plmtex( ""rv"", height, pos, just, string );
-9.                     }
-8.                     else
-7.                     {
-6.                         plmtex( ""r"", height, pos, just, string );
-5.                     }
-4.   ",Useful
/*Restore the clip limits to viewport edge*/,"-1.     label_box( xopt, xtick1, yopt, ytick1 );

 /*Restore the clip limits to viewport edge*/

1.     plP_sclp( lxmin, lxmax, lymin, lymax );
2. }",Useful
"/*--------------------------------------------------------------------------

Default labeling functions for PLplot

These are the functions which are used internally by PLplot under various
conditions.

They have been separated out for use in other PLplot functions and
potential exposure in the PLplot API.

--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
"/*Exponential, i.e. 10^-1, 10^0, 10^1, etc*/","-10. // These are the functions which are used internally by PLplot under various
-9. // conditions.
-8. //
-7. // They have been separated out for use in other PLplot functions and
-6. // potential exposure in the PLplot API.
-5. //
-4. //---------------",Useful
"/*Fixed point, i.e. .1, 1, 10, etc*/","-4.     snprintf( string, (size_t) len, ""10%su%d"", esc_string, (int) ROUND( value ) );
-3. }
-2. void plP_default_label_log_fixed( PLINT PL_UNUSED( axis ), PLFLT value, char *string, PLINT len, void * PL_UNUSED( data ) )
-1. {

 /*Fixed point, i.e. .1, 1,",Useful
"/*This is necessary to prevent labels like ""-0.0"" on some systems*/","-10.     PLINT  setpre, precis;
-9.     char   form[FORMAT_LEN], temp[TEMP_LEN];
-8.     double scale2;
-7.     scale = ( (PLINT *) data )[0];
-6.     prec  = ( (PLINT *) data )[1];
-5.     plP_gprec( &setpre, &precis );
-4.     if ( setpre )
-3.         ",Useful
"/*--------------------------------------------------------------------------
void plform()

Formats a PLFLT value in one of the following formats.

If ll (logarithmic), then:

-	If lf (fixed), then used fixed point notation, i.e. .1, 1, 10, etc,
with unnecessary trailing .'s or 0's removed.

-	If !lf (default), then use exponential notation, i.e. 10^-1, etc.

If !ll (linear), then:

- If scale == 0, use fixed point format with ""prec"" places after the
decimal point.

-	If scale == 1, use scientific notation with one place before the
decimal point and ""prec"" places after.  In this case, the value
must be divided by 10^scale.

The axis argument is included to support PLplot's custom axis labeling.  It
is passed on to the custom labeling function if it exists.  Otherwise, it
is ignored.
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
"/*Check to see if a custom labeling function is defined.  If not,
use default.*/","-10. //	decimal point and ""prec"" places after.  In this case, the value
-9. //	must be divided by 10^scale.
-8. //
-7. // The axis argument is included to support PLplot's custom axis labeling.  It
-6. // is passed on to the custom labeling function if it",Useful
/*Logarithmic*/,"-10. // xopt and yopt are character strings which define the box as follows:
-9. //
-8. // a: Draw axis (X is horizontal line Y=0, Y is vertical line X=0)
-7. // b: Draw bottom (X) or left (Y) frame of box
-6. // c: Draw top (X) or right (Y) frame of box
",Useful
"/*Fixed point, i.e. .1, 1, 10, etc*/","-4.     snprintf( string, (size_t) len, ""10%su%d"", esc_string, (int) ROUND( value ) );
-3. }
-2. void plP_default_label_log_fixed( PLINT PL_UNUSED( axis ), PLFLT value, char *string, PLINT len, void * PL_UNUSED( data ) )
-1. {

 /*Fixed point, i.e. .1, 1,",Useful
"/*Exponential, i.e. 10^-1, 10^0, 10^1, etc*/","-10. // These are the functions which are used internally by PLplot under various
-9. // conditions.
-8. //
-7. // They have been separated out for use in other PLplot functions and
-6. // potential exposure in the PLplot API.
-5. //
-4. //---------------",Useful
/*Linear*/,"-5.                 plP_default_label_log( axis, value, string, len, NULL );
-4.             }
-3.         }
-2.         else
-1.         {

 /*Linear*/

1.             PLINT scale_prec[2] = { scale, prec };
2.             plP_default_label( axis, value, ",Useful
"/*--------------------------------------------------------------------------
plslabelfunc

Formats a PLFLT value in one of the following formats.

label_func - A pointer to a function which will provide a string to use
as the label for the given floating point value.
Pass this as NULL to clear the custom function and reset it to
the default PLplot labeling function.

label_data - Extra data to pass to the label function.

The label_func function arguments are, in order:

axis: PL_X_AXIS, PL_Y_AXIS or PL_Z_AXIS to indicate which axis is being
labeled
value: The value at this position on the axis
string: The resulting label string should be stored here
data: A pointer to whatever extra information the custom plotting function
requires

--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
"/*Follow plgesc logic here which is to set the default escape
if plsc->esc is in its initial state.*/","-10. c_plslabelfunc( PLLABEL_FUNC_callback label_func, PLPointer label_data )
-9. {
-8.     plsc->label_func = label_func;
-7.     plsc->label_data = label_data;
-6. }
-5. static PLCHAR_VECTOR
-4. plgesc_string( void )
-3. {
-2.     static PLCHAR_VECTOR e",Useful
/*Continuous line*/,"-7. static struct line
-6. {
-5.     PLINT nels;
-4.     PLINT mark[4];
-3.     PLINT space[4];
-2. } line[] = {
-1.     {

 /*Continuous line*/

1.         {
2.             0, 0, 0, 0
3.         },
4.         {
5.             0, 0, 0, 0
6.         }
7.  ",Useful
/*Fill pattern defaults*/,"-10.     {
-9.         3,
-8.         {
-7.             1000, 1500, 2000, 0
-6.         },
-5.         {
-4.             1000, 1000, 1000, 0
-3.         }
-2.     }
-1. };

 /*Fill pattern defaults*/

1. #define NPATTERNS    8
2. static struct pattern
3. ",Useful
/*Number of lines in pattern (1 or 2)*/,"-3. #define NPATTERNS    8
-2. static struct pattern
-1. {

 /*Number of lines in pattern (1 or 2)*/

111",Useful
/*Inclination 10 ths of degrees*/,"-4. #define NPATTERNS    8
-3. static struct pattern
-2. {

 /*Inclination 10 ths of degrees*/

111",Useful
/*Spacing for each line*/,"-5. #define NPATTERNS    8
-4. static struct pattern
-3. {

 /*Spacing for each line*/

1. } pattern[] = {
2.     {
3.         1,
4.         {
5.             0, 0
6.         },
7.         {
8.             2000, 0
9.         }
10.     },",Useful
/*Set defining parameters for pattern fill*/,"-10.     {
-9.         2,
-8.         {
-7.             450, -450
-6.         },
-5.         {
-4.             2000, 2000
-3.         }
-2.     }
-1. };

 /*Set defining parameters for pattern fill*/

1. static void
2. spat( const PLINT inc[], const PLINT",Useful
"/*--------------------------------------------------------------------------
void plschr()

Set character height.
--------------------------------------------------------------------------*/","-2. static void
-1. spat( const PLINT inc[], const PLINT del[], PLINT nlin );

 /*--------------------------------------------------------------------------
void plschr()

Set character height.
-------------------------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plsmin()

Set up lengths of minor tick marks.
--------------------------------------------------------------------------*/","-2. static void
-1. spat( const PLINT inc[], const PLINT del[], PLINT nlin );

 /*--------------------------------------------------------------------------
void plsmin()

Set up lengths of minor tick marks.
-----------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plsmaj()

Set up lengths of major tick marks.
--------------------------------------------------------------------------*/","-2. static void
-1. spat( const PLINT inc[], const PLINT del[], PLINT nlin );

 /*--------------------------------------------------------------------------
void plsmaj()

Set up lengths of major tick marks.
-----------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plssym()

Set symbol height.
--------------------------------------------------------------------------*/","-2. static void
-1. spat( const PLINT inc[], const PLINT del[], PLINT nlin );

 /*--------------------------------------------------------------------------
void plssym()

Set symbol height.
----------------------------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void pllsty()

Set line style.
--------------------------------------------------------------------------*/","-2. static void
-1. spat( const PLINT inc[], const PLINT del[], PLINT nlin );

 /*--------------------------------------------------------------------------
void pllsty()

Set line style.
-------------------------------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plpat()

Set fill pattern directly.
--------------------------------------------------------------------------*/","-2. static void
-1. spat( const PLINT inc[], const PLINT del[], PLINT nlin );

 /*--------------------------------------------------------------------------
void plpat()

Set fill pattern directly.
---------------------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plpsty()

Set fill pattern, using one of the predefined patterns.
A fill pattern <= 0 indicates hardware fill.
--------------------------------------------------------------------------*/","-2. static void
-1. spat( const PLINT inc[], const PLINT del[], PLINT nlin );

 /*--------------------------------------------------------------------------
void plpsty()

Set fill pattern, using one of the predefined patterns.
A fill pattern <= 0 indicat",Useful
"/*--------------------------------------------------------------------------
void spat()

Set defining parameters for pattern fill
--------------------------------------------------------------------------*/","-2. static void
-1. spat( const PLINT inc[], const PLINT del[], PLINT nlin );

 /*--------------------------------------------------------------------------
void spat()

Set defining parameters for pattern fill
--------------------------------------------",Useful
/*plgridd.c: Plot grids data from irregularly sampled data.*/,"
// plgridd.c: Plot grids data from irregularly sampled data.


 /*plgridd.c: Plot grids data from irregularly sampled data.*/

111",Useful
/*forward declarations*/,"-3. #include <libqhull_r/qhull_ra.h>

 /*forward declarations*/

1. static void
2. grid_nnaidw( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
3.              PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy,
4.              PLF2OPS zops,",Useful
/*Check that points in xg and in yg are strictly increasing*/,"-10. plfgriddata( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, PLINT npts,
-9.              PLFLT_VECTOR xg, PLINT nptsx, PLFLT_VECTOR yg, PLINT nptsy,
-8.              PLF2OPS zops, PLPointer zgp, PLINT type, PLFLT data )
-7. {
-6.     int i, j;
-5.  ",Useful
/*clear array to return*/,"-10.         }
-9.     }
-8.     for ( i = 0; i < nptsy - 1; i++ )
-7.     {
-6.         if ( yg[i] >= yg[i + 1] )
-5.         {
-4.             plabort( ""plgriddata: yg array must be strictly increasing"" );
-3.             return;
-2.         }
-1.     }",Useful
/*NaN signals a not processed grid point*/,"-3.     for ( i = 0; i < nptsx; i++ )
-2.         for ( j = 0; j < nptsy; j++ )
-1.             zops->set( zgp, i, j, 0.0 );

 /*NaN signals a not processed grid point*/

1.     switch ( type )
2.     {",Useful
/*Bivariate Cubic Spline Approximation*/,"-2.     switch ( type )
-1.     {

 /*Bivariate Cubic Spline Approximation*/

1. #ifdef WITH_CSA
2.         grid_csa( x, y, z, npts, xg, nptsx, yg, nptsy, zops, zgp );
3. #else
4.         plwarn( ""plgriddata(): PLplot was configured to not use GRID_CSA.\n",Useful
/*Nearest Neighbors Inverse Distance Weighted*/,"-10. //    Real world data is frequently irregularly sampled, but most 3D plots
-9. //    require regularly gridded data. This function does exactly this
-8. //    using several methods:
-7. //    Irregularly sampled data x[npts], y[npts], z[npts] is grid",Useful
/*Nearest Neighbors Linear Interpolation*/,"-10. //    require regularly gridded data. This function does exactly this
-9. //    using several methods:
-8. //    Irregularly sampled data x[npts], y[npts], z[npts] is gridded into
-7. //    zg[nptsx, nptsy] according to methode 'type' and grid inform",Useful
"/*Nearest Neighbors ""Around"" Inverse Distance Weighted*/","-2.         grid_nnli( x, y, z, npts, xg, nptsx, yg, nptsy, zops, zgp, data );
-1.         break;

 /*Nearest Neighbors ""Around"" Inverse Distance Weighted*/

1.         grid_nnaidw( x, y, z, npts, xg, nptsx, yg, nptsy, zops, zgp );
2.         break;",Useful
/*Delaunay Triangulation Linear Interpolation*/,"-10. //    Irregularly sampled data x[npts], y[npts], z[npts] is gridded into
-9. //    zg[nptsx, nptsy] according to methode 'type' and grid information
-8. //    xg[nptsx], yg[nptsy].
-7. //
-6. //    'type' can be:
-5. //
-4. //       GRID_CSA:    Biva",Useful
/*Natural Neighbors*/,"-10. //    zg[nptsx, nptsy] according to methode 'type' and grid information
-9. //    xg[nptsx], yg[nptsy].
-8. //
-7. //    'type' can be:
-6. //
-5. //       GRID_CSA:    Bivariate Cubic Spline approximation (1)
-4. //       GRID_NNIDW:  Nearest Neighb",Useful
"/*
Bivariate Cubic Spline Approximation using Pavel Sakov's csa package

NaNs are returned where no interpolation can be done.
*/","
// plgridd.c: Plot grids data from irregularly sampled data.


 /*
Bivariate Cubic Spline Approximation using Pavel Sakov's csa package

NaNs are returned where no interpolation can be done.
*/

111",Useful
"/*alternative weight coeficients. I Don't like the results
find the maximum distance*/","-10.     if ( knn_order == 0 )
-9.     {
-8.         plwarn( ""plgriddata(): GRID_NNIDW: knn_order must be specified with 'data' arg. Using 15"" );
-7.         knn_order = 15;;
-6.     }
-5.     for ( i = 0; i < nptsx; i++ )
-4.     {
-3.         for ( j = ",Useful
/*not enough neighbors found ?!*/,"-9.             md = items[0].dist;
-8.             for ( k = 1; k < knn_order; k++ )
-7.                 if ( items[k].dist > md )
-6.                     md = items[k].dist;
-5. #endif
-4.             zops->set( zgp, i, j, 0.0 );
-3.             nt = 0.",Useful
"/*Nearest Neighbors Linear Interpolation

The z value at the grid position will be interpolated from the
plane passing through the 3 nearest neighbors.*/","-10.                 zops->add( zgp, i, j, wi * z[items[k].item] );
-9.                 nt += wi;
-8.             }
-7.             if ( nt != 0. )
-6.                 zops->div( zgp, i, j, nt );
-5.             else
-4.                 zops->set( zgp, i,",Useful
/*see if the triangle is a thin one*/,"-10.     else if ( threshold > 2. || threshold < 1. )
-9.     {
-8.         plabort( ""plgriddata(): GRID_NNLI: 1. < threshold < 2."" );
-7.         return;
-6.     }
-5.     for ( i = 0; i < nptsx; i++ )
-4.     {
-3.         for ( j = 0; j < nptsy; j++ )
",Useful
/*coincident points*/,"-9.             for ( ii = 0; ii < 3; ii++ )
-8.             {
-7.                 xx[ii] = x[items[ii].item];
-6.                 yy[ii] = y[items[ii].item];
-5.                 zz[ii] = z[items[ii].item];
-4.             }
-3.             d1 = sqrt( ( x",Useful
/*make d1 < d2*/,"-4.             {
-3.                 zops->set( zgp, i, j, NAN );
-2.                 continue;
-1.             }

 /*make d1 < d2*/

1.             if ( d1 > d2 )
2.             {
3.                 t = d1; d1 = d2; d2 = t;
4.             }",Useful
/*and d2 < d3*/,"-4.             if ( d1 > d2 )
-3.             {
-2.                 t = d1; d1 = d2; d2 = t;
-1.             }

 /*and d2 < d3*/

1.             if ( d2 > d3 )
2.             {
3.                 t = d2; d2 = d3; d3 = t;
4.             }",Useful
/*thin triangle!*/,"-4.             if ( d2 > d3 )
-3.             {
-2.                 t = d2; d2 = d3; d3 = t;
-1.             }

 /*thin triangle!*/

1.             {",Useful
/*deal with it later*/,"-1.             {

 /*deal with it later*/

1.             }",Useful
/*calculate the plane passing through the three points*/,"-1.             }

 /*calculate the plane passing through the three points*/

1.             {
2.                 A = yy[0] * ( zz[1] - zz[2] ) + yy[1] * ( zz[2] - zz[0] ) + yy[2] * ( zz[0] - zz[1] );
3.                 B = zz[0] * ( xx[1] - xx[2] ) + zz[",Useful
/*and interpolate (or extrapolate...)*/,"-5.             {
-4.                 A = yy[0] * ( zz[1] - zz[2] ) + yy[1] * ( zz[2] - zz[0] ) + yy[2] * ( zz[0] - zz[1] );
-3.                 B = zz[0] * ( xx[1] - xx[2] ) + zz[1] * ( xx[2] - xx[0] ) + zz[2] * ( xx[0] - xx[1] );
-2.                 C =",Useful
"/*now deal with NaNs resulting from thin triangles. The idea is
to use the 4 KNN points and exclude one at a time, creating
four triangles, evaluating their thickness and choosing the
most thick as the final one from where the interpolating
plane will be build.  Now that I'm talking of interpolating,
one should really check that the target point is interior to
the candidate triangle... otherwise one is extrapolating*/","-4.                 zops->set( zgp, i, j, -xg[i] * A / C - yg[j] * B / C - D / C );
-3.             }
-2.         }
-1.     }

 /*now deal with NaNs resulting from thin triangles. The idea is
to use the 4 KNN points and exclude one at a time, creating
fou",Useful
/*the excluded point*/,"-10.                     // for (jj=0; jj<ii; jj++) {
-9.                     // if (items[jj].dist > items[jj+1].dist) {
-8.                     // t = items[jj].dist;
-7.                     // items[jj].dist = items[jj+1].dist;
-6.                     ",Useful
/*coincident points*/,"-9.             for ( ii = 0; ii < 3; ii++ )
-8.             {
-7.                 xx[ii] = x[items[ii].item];
-6.                 yy[ii] = y[items[ii].item];
-5.                 zz[ii] = z[items[ii].item];
-4.             }
-3.             d1 = sqrt( ( x",Useful
/*all points are coincident?*/,"-10.                         {
-9.                             t = d2; d2 = d3; d3 = t;
-8.                         }
-7.                         t = ( d1 + d2 ) / d3;
-6.                         if ( t > max_thick )
-5.                         {
-4.     ",Useful
/*one has the thicker triangle constructed from the 4 KNN*/,"-1.                         continue;

 /*one has the thicker triangle constructed from the 4 KNN*/

1.                     cnt = 0;
2.                     for ( ii = 0; ii < 4; ii++ )
3.                     {
4.                         if ( ii != excl_it",Useful
/*and interpolate (or extrapolate...)*/,"-5.             {
-4.                 A = yy[0] * ( zz[1] - zz[2] ) + yy[1] * ( zz[2] - zz[0] ) + yy[2] * ( zz[0] - zz[1] );
-3.                 B = zz[0] * ( xx[1] - xx[2] ) + zz[1] * ( xx[2] - xx[0] ) + zz[2] * ( xx[0] - xx[1] );
-2.                 C =",Useful
"/*Nearest Neighbors ""Around"" Inverse Distance Weighted, brute force approach.

This uses the 1-KNN in each quadrant around the grid point, then
Inverse Distance Weighted is used as in GRID_NNIDW.*/","-7.                     zops->set( zgp, i, j, -xg[i] * A / C - yg[j] * B / C - D / C );
-6.                 }
-5.             }
-4.         }
-3.     }
-2. }

 /*Nearest Neighbors ""Around"" Inverse Distance Weighted, brute force approach.

This uses the 1-",Useful
/*no points found?!*/,"-4.                     zops->add( zgp, i, j, d * z[items[k].item] );
-3.                     nt += d;
-2.                 }
-1.             }

 /*no points found?!*/

1.                 zops->set( zgp, i, j, NAN );
2.             else
3.                 ",Useful
"/*
Delaunay Triangulation Linear Interpolation using Pavel Sakov's nn package

The Delaunay Triangulation on the data points is build and for
each grid point the triangle where it is enclosed found and a
linear interpolation performed.

Points exterior to the convex hull of the data points cannot
be interpolated and are set to NaN.
*/","
// plgridd.c: Plot grids data from irregularly sampled data.


 /*
Delaunay Triangulation Linear Interpolation using Pavel Sakov's nn package

The Delaunay Triangulation on the data points is build and for
each grid point the triangle where it is enclosed found and a
linear interpolation performed.

Points exterior to the convex hull of the data points cannot
be interpolated and are set to NaN.
*/

111",Useful
/*Build system has already checked that sizeof ( realT ) == sizeof ( double )*/,"-7. static void
-6. grid_dtli( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
-5.            PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy, PLF2OPS zops, PLPointer zgp )
-4. {
-3.     point        *pin, *pgrid, *pt;
-2.     PLFLT_VECTO",Useful
"/*
Natural Neighbors using Pavel Sakov's nn package

Points exterior to the convex hull of the data points cannot
be interpolated and are set to NaN.
*/","
// plgridd.c: Plot grids data from irregularly sampled data.


 /*
Natural Neighbors using Pavel Sakov's nn package

Points exterior to the convex hull of the data points cannot
be interpolated and are set to NaN.
*/

111",Useful
/*Build system has already checked that sizeof ( realT ) == sizeof ( double )*/,"-7. static void
-6. grid_dtli( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
-5.            PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy, PLF2OPS zops, PLPointer zgp )
-4. {
-3.     point        *pin, *pgrid, *pt;
-2.     PLFLT_VECTO",Useful
/*only accept weights greater than wtmin*/,"-10. static void
-9. grid_nni( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
-8.           PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy, PLF2OPS zops, PLPointer zgp,
-7.           PLFLT wtmin )
-6. {
-5.     PLFLT_VECTOR xt, yt, zt;
",Useful
"/*
this function just calculates the K Nearest Neighbors of grid point
[gx, gy].
*/","
// plgridd.c: Plot grids data from irregularly sampled data.


 /*
this function just calculates the K Nearest Neighbors of grid point
[gx, gy].
*/

111",Useful
/*save sqrt() time*/,"-10.     int   max_slot, i, j;
-9.     max_dist = PLFLT_MAX;
-8.     max_slot = 0;
-7.     for ( i = 0; i < knn_order; i++ )
-6.     {
-5.         items[i].dist = PLFLT_MAX;
-4.         items[i].item = -1;
-3.     }
-2.     for ( i = 0; i < npts; i++ )
-1",Useful
/*find new maximum distance*/,"-2.             items[max_slot].dist = d;
-1.             items[max_slot].item = i;

 /*find new maximum distance*/

1.             max_dist = items[0].dist;
2.             max_slot = 0;
3.             for ( j = 1; j < knn_order; j++ )
4.             {
5.",Useful
/*now calculate the distance*/,"-10.             {
-9.                 if ( items[j].dist > max_dist )
-8.                 {
-7.                     max_dist = items[j].dist;
-6.                     max_slot = j;
-5.                 }
-4.             }
-3.         }
-2.     }
-1.     fo",Useful
"/*This function searchs the 1-nearest neighbor in each quadrant around
the grid point.*/","-2. }

 /*This function searchs the 1-nearest neighbor in each quadrant around
the grid point.*/

111",Useful
/*save sqrt() time*/,"-10.     int   max_slot, i, j;
-9.     max_dist = PLFLT_MAX;
-8.     max_slot = 0;
-7.     for ( i = 0; i < knn_order; i++ )
-6.     {
-5.         items[i].dist = PLFLT_MAX;
-4.         items[i].item = -1;
-3.     }
-2.     for ( i = 0; i < npts; i++ )
-1",Useful
/*now calculate the distance*/,"-10.             {
-9.                 if ( items[j].dist > max_dist )
-8.                 {
-7.                     max_dist = items[j].dist;
-6.                     max_slot = j;
-5.                 }
-4.             }
-3.         }
-2.     }
-1.     fo",Useful
"/*another DTLI, based only on QHULL, not nn*/","-7. #include ""plplotP.h""
-6. #ifdef WITH_CSA
-5. #include ""../lib/csa/csa.h""
-4. #endif
-3. #ifdef PL_HAVE_QHULL
-2. #include ""../lib/nn/nn.h""

 /*another DTLI, based only on QHULL, not nn*/

1. #include <libqhull_r/qhull_ra.h>",Useful
/*array of coordinates for each point*/,"-4. static void
-3. grid_adtli( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
-2.             PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy, PLF2OPS zops, PLPointer zgp )
-1. {

 /*array of coordinates for each point*/

111",Useful
/*True if qhull should free points*/,"-5. static void
-4. grid_adtli( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
-3.             PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy, PLF2OPS zops, PLPointer zgp )
-2. {

 /*True if qhull should free points*/

111",Useful
/*option flags for qhull*/,"-6. static void
-5. grid_adtli( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
-4.             PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy, PLF2OPS zops, PLPointer zgp )
-3. {

 /*option flags for qhull*/

111",Useful
/*set by FORALLfacets*/,"-7. static void
-6. grid_adtli( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
-5.             PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy, PLF2OPS zops, PLPointer zgp )
-4. {

 /*set by FORALLfacets*/

1.     vertexT *vertex, **vert",Useful
/*memory remaining after qh_memfreeshort*/,"-2.     vertexT *vertex, **vertexp;
-1.     facetT  *neighbor, **neighborp;

 /*memory remaining after qh_memfreeshort*/

1.     FILE    *outfile = NULL;",Useful
/*error messages from qhull code*/,"-1.     FILE    *outfile = NULL;

 /*error messages from qhull code*/

1.     int     exitcode;
2.     int     i, j, k, l;
3.     int     dim = 2;
4.     PLFLT   xt[3], yt[3], zt[3];
5.     PLFLT   A, B, C, D;
6.     coordT  point[3];
7.     boolT   isout",Useful
"/*Could pass extra args to qhull through the 'data' argument of
plgriddata()*/","-10.     int     dim = 2;
-9.     PLFLT   xt[3], yt[3], zt[3];
-8.     PLFLT   A, B, C, D;
-7.     coordT  point[3];
-6.     boolT   isoutside;
-5.     realT   bestdist;
-4.     int     totpart = 0;
-3.     int     numfacets, numsimplicial, numridges;
-2.",Useful
/*print the triangles vertices*/,"-1.     {

 /*print the triangles vertices*/

1.         printf( ""Triangles\n"" );
2.         FORALLfacets {
3.             if ( !facet->upperdelaunay )
4.             {
5.                 FOREACHvertex_( facet->vertices )",Useful
/*vertices index*/,"-5.         printf( ""Triangles\n"" );
-4.         FORALLfacets {
-3.             if ( !facet->upperdelaunay )
-2.             {
-1.                 FOREACHvertex_( facet->vertices )

 /*vertices index*/

1.                 printf( ""\n"" );
2.             }
",Useful
/*print each triangle neighbors*/,"-4.                 printf( ""\n"" );
-3.             }
-2.         }
-1. #endif

 /*print each triangle neighbors*/

1.         printf( ""Neigbors\n"" );
2.         qh_findgood_all( qh facet_list );
3.         qh_countfacets( qh facet_list, NULL, !qh_ALL, &n",Useful
"/*Without the setjmp(), Qhull will exit() after reporting an error*/","-10.             &totneighbors, &numridges, &numcoplanars, &numtricoplanars );
-9.         FORALLfacets {
-8.             if ( !facet->upperdelaunay )
-7.             {
-6.                 FOREACHneighbor_( facet )
-5.                 printf( "" %d"", neigh",Useful
"/*several ways to find the triangle given a point follow.
None but brute force works*/","-10.         if ( !exitcode )
-9.         {
-8.             qh->NOerrexit = False;
-7.             for ( i = 0; i < nptsx; i++ )
-6.                 for ( j = 0; j < nptsy; j++ )
-5.                 {
-4.                     l        = 0;
-3.             ",Useful
"/*Until someone implements a working qh_findbestfacet(),
do an exautive search!

As far as I understand it, qh_findbestfacet() and
qh_findbest() fails when 'point' does not belongs to
the convex hull, i.e., when the search becomes blocked
when a facet is upperdelaunay (although the error
message says that the facet may be upperdelaynay or
flipped, I never found a flipped one).

Another possibility is to implement the 'walking
triangle algorithm*/","-6.                         qh_NOupper,
-5.                         &bestdist, &isoutside, &totpart );
-4. #endif
-3. #if 0
-2.                     vertex = qh_nearvertex( facet, point, &bestdist );
-1. #endif

 /*Until someone implements a working qh_fin",Useful
/*calculate the plane passing through the three points*/,"-1.             }

 /*calculate the plane passing through the three points*/

1.             {
2.                 A = yy[0] * ( zz[1] - zz[2] ) + yy[1] * ( zz[2] - zz[0] ) + yy[2] * ( zz[0] - zz[1] );
3.                 B = zz[0] * ( xx[1] - xx[2] ) + zz[",Useful
/*free long memory*/,"-7.                         zops->set( zgp, i, j, -xg[i] * A / C - yg[j] * B / C - D / C );
-6.                     }
-5.                 }
-4.         }
-3.         qh->NOerrexit = True;
-2.     }
-1.     free( points );

 /*free long memory*/

111",Useful
/*free short memory and memory allocator*/,"-8.                         zops->set( zgp, i, j, -xg[i] * A / C - yg[j] * B / C - D / C );
-7.                     }
-6.                 }
-5.         }
-4.         qh->NOerrexit = True;
-3.     }
-2.     free( points );

 /*free short memory and memory ",Useful
/*for plMacLibOpen prototype; used in plLibOpen*/,"-5. #define DEBUG
-4. #define NEED_PLDEBUG
-3. #include ""plplotP.h""
-2. #ifdef macintosh
-1. #include ""mac.h""

 /*for plMacLibOpen prototype; used in plLibOpen*/

1. #endif",Useful
/*Random number generator (Mersenne Twister)*/,"-10. #endif
-9. #endif
-8. #ifdef __unix
-7. #include <sys/types.h>
-6. #include <sys/stat.h>
-5. #ifdef PL_HAVE_UNISTD_H
-4. #include <unistd.h>
-3. #endif
-2. #include <errno.h>
-1. #endif

 /*Random number generator (Mersenne Twister)*/

1. #include ""m",Useful
"/*An additional hardwired location for lib files.
I have no plans to change these again, ever.*/","-10. static void
-9. plcmap1_def( void );
-8. static PLFLT
-7. value( double n1, double n2, double hue );
-6. static char *
-5. read_line( char *buffer, int length, FILE *fp );
-4. static void
-3. cmap0_palette_read( PLCHAR_VECTOR filename,
-2.           ",Useful
"/*--------------------------------------------------------------------------
Routines that deal with colors & color maps.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
Routines that deal with colors & color maps.
----------------------------------------",Useful
"/*--------------------------------------------------------------------------
plcol0()

! Set color, map 0.  Argument is a integer between 0 and plsc->ncol0.
!
! @param icol0 The index of the color map 0 color to use as the current
! color. (0 - plsc->ncol0).*/","-7. #ifndef PLLIBDEV
-6. #define PLLIBDEV    ""/usr/local/plplot/lib""
-5. #endif
-4. #endif

 /*--------------------------------------------------------------------------
plcol0()

! Set color, map 0.  Argument is a integer between 0 and plsc->ncol0.
!
! @",Useful
"/*--------------------------------------------------------------------------
plscolbg()

! Set the background color (cmap0[0]) by 8 bit RGB value
!
! @param r Red value of the background color (MIN_PLINT_RGB - MAX_PLINT_RGB).
! @param g Green value of the background color (MIN_PLINT_RGB - MAX_PLINT_RGB).
! @param b Blue value of the background color (MIN_PLINT_RGB - MAX_PLINT_RGB).*/","-10.     icol1 = (PLINT) ( col1 * plsc->ncol1 );
-9.     icol1 = MIN( icol1, plsc->ncol1 - 1 );
-8.     plsc->icol1      = icol1;
-7.     plsc->curcolor.r = plsc->cmap1[plsc->icol1].r;
-6.     plsc->curcolor.g = plsc->cmap1[plsc->icol1].g;
-5.     plsc->c",Useful
"/*--------------------------------------------------------------------------
plscolbga()

! Set the background color (cmap0[0]) by 8 bit RGB value and alpha value
!
! @param r Red value of the background color (MIN_PLINT_RGB - MAX_PLINT_RGB).
! @param g Green value of the background color (MIN_PLINT_RGB - MAX_PLINT_RGB).
! @param b Blue value of the background color (MIN_PLINT_RGB - MAX_PLINT_RGB).
! @param alpha Alpha (transparency) value of the background color
! (MIN_PLFLT_ALPHA - MAX_PLFLT_ALPHA).*/","-5. void
-4. c_plscolbg( PLINT r, PLINT g, PLINT b )
-3. {
-2.     plscol0( 0, r, g, b );
-1. }

 /*--------------------------------------------------------------------------
plscolbga()

! Set the background color (cmap0[0]) by 8 bit RGB value and alpha ",Useful
"/*--------------------------------------------------------------------------
plgcolbg()

! Returns the background color (cmap0[0]) by 8 bit RGB value
!
! @param r Current red value of the background color.
! @param g Current green value of the background color.
! @param b Current blue value of the background color.*/","-5. void
-4. c_plscolbga( PLINT r, PLINT g, PLINT b, PLFLT alpha )
-3. {
-2.     plscol0a( 0, r, g, b, alpha );
-1. }

 /*--------------------------------------------------------------------------
plgcolbg()

! Returns the background color (cmap0[0]) by 8",Useful
"/*--------------------------------------------------------------------------
plgcolbga()

! Returns the background color (cmap0[0]) by 8 bit RGB value and alpha value
!
! @param r Current red value of the background color.
! @param g Current green value of the background color.
! @param b Current blue value of the background color.
! @param alpha Current alpha value of the background color.*/","-5. void
-4. c_plgcolbg( PLINT *r, PLINT *g, PLINT *b )
-3. {
-2.     plgcol0( 0, r, g, b );
-1. }

 /*--------------------------------------------------------------------------
plgcolbga()

! Returns the background color (cmap0[0]) by 8 bit RGB value and",Useful
"/*--------------------------------------------------------------------------
plscol0()

! Set a given color from color map 0 by 8 bit RGB value
! Does not result in any additional cells to be allocated.
!
! @param icol0 index of the color to set (0 - plsc->ncol0)
! @param r Red value of the color (MIN_PLINT_RGB - MAX_PLINT_RGB).
! @param g Green value of the color (MIN_PLINT_RGB - MAX_PLINT_RGB).
! @param b Blue value of the color (MIN_PLINT_RGB - MAX_PLINT_RGB).*/","-5. void
-4. c_plgcolbga( PLINT *r, PLINT *g, PLINT *b, PLFLT *alpha )
-3. {
-2.     plgcol0a( 0, r, g, b, alpha );
-1. }

 /*--------------------------------------------------------------------------
plscol0()

! Set a given color from color map 0 by 8 b",Useful
"/*--------------------------------------------------------------------------
plscol0a()

! Set a given color from color map 0 by 8 bit RGB value and alpha value.
! Does not result in any additional cells to be allocated.
!
! @param icol0 index of the color to set (0 - plsc->ncol0)
! @param r Red value of the color (MIN_PLINT_RGB - MAX_PLINT_RGB).
! @param g Green value of the color (MIN_PLINT_RGB - MAX_PLINT_RGB).
! @param b Blue value of the color (MIN_PLINT_RGB - MAX_PLINT_RGB).
! @param alpha Alpha value of the color (MIN_PLFLT_ALPHA - MAX_PLFLT_ALPHA).*/","-10.     if ( icol0 < 0 || icol0 >= plsc->ncol0 )
-9.     {
-8.         char buffer[BUFFER_SIZE];
-7.         snprintf( buffer, BUFFER_SIZE, ""plscol0: Illegal color table value: %d"", (int) icol0 );
-6.         plabort( buffer );
-5.         return;
-4.   ",Useful
"/*--------------------------------------------------------------------------
plgcol0()

! Returns 8 bit RGB values for given color from color map 0
! Values are negative if an invalid color id is given
!
! @param icol0 Index of the color to be return (0 - plsc->ncol0).
! @param r Current red value of the color.
! @param g Current green value of the color.
! @param b Current blue value of the color.*/","-10.         return;
-9.     }
-8.     limit_rgba_range( ""plscol0a: invalid cmap0 RGBA color has been corrected"", &r, &g, &b, &alpha );
-7.     plsc->cmap0[icol0].r = (unsigned char) r;
-6.     plsc->cmap0[icol0].g = (unsigned char) g;
-5.     plsc->cmap0",Useful
"/*--------------------------------------------------------------------------
plgcol0a()

! Returns 8 bit RGB values for given color from color map 0 and alpha value
! Values are negative if an invalid color id is given
!
! @param icol0 Index of the color to be return (0 - plsc->ncol0).
! @param r Current red value of the color.
! @param g Current green value of the color.
! @param b Current blue value of the color.
! @param alpha Current alpha value of the color.*/","-10.         char buffer[BUFFER_SIZE];
-9.         snprintf( buffer, BUFFER_SIZE, ""plgcol0: Invalid color index: %d"", (int) icol0 );
-8.         plabort( buffer );
-7.         return;
-6.     }
-5.     *r = plsc->cmap0[icol0].r;
-4.     *g = plsc->cmap0[i",Useful
"/*--------------------------------------------------------------------------
plscmap0()

! Set color map 0 colors by 8 bit RGB values.  This sets the entire color
! map -- only as many colors as specified will be allocated.
!
! @param r Array of red values.
! @param g Array of green values.
! @param b Array of blue values.
! @param ncol0 Total number of RGB values.*/","-10.         *alpha = MAX_PLFLT_ALPHA;
-9.         plabort( buffer );
-8.         return;
-7.     }
-6.     *r     = plsc->cmap0[icol0].r;
-5.     *g     = plsc->cmap0[icol0].g;
-4.     *b     = plsc->cmap0[icol0].b;
-3.     *alpha = plsc->cmap0[icol0].a;",Useful
"/*--------------------------------------------------------------------------
plscmap0a()

! Set color map 0 colors by 8 bit RGB and alpha value.  This sets the
! entire color map -- only as many colors as specified will be allocated.
!
! @param r Array of red values.
! @param g Array of green values.
! @param b Array of blue values.
! @param alpha Array of alpha values.
! @param ncol0 Total number of RGBA values.*/","-10.         nc_b = b[i];
-9.         limit_rgba_range( ""plscmap0: invalid cmap0 RGB color has been corrected"", &nc_r, &nc_g, &nc_b, NULL );
-8.         plsc->cmap0[i].r = (unsigned char) nc_r;
-7.         plsc->cmap0[i].g = (unsigned char) nc_g;
-6.     ",Useful
"/*--------------------------------------------------------------------------
plscmap1()

! Set color map 1 colors by 8 bit RGB values
! This also sets the number of colors.
!
! @param r Array of red values.
! @param g Array of green values.
! @param b Array of blue values.
! @param ncol1 Total number of RGB values.*/","-10.         nc_alpha = alpha[i];
-9.         limit_rgba_range( ""plscmap0a: invalid cmap0 RGBA color has been corrected"", &nc_r, &nc_g, &nc_b, &nc_alpha );
-8.         plsc->cmap0[i].r = (unsigned char) nc_r;
-7.         plsc->cmap0[i].g = (unsigned char)",Useful
"/*--------------------------------------------------------------------------
plscmap1a()

! Set color map 1 colors by 8 bit RGB and alpha values
! This also sets the number of colors.
!
! @param r Array of red values.
! @param g Array of green values.
! @param b Array of blue values.
! @param alpha Array of alpha values.
! @param ncol1 Total number of RGBA values.*/","-10.         nc_b = b[i];
-9.         limit_rgba_range( ""plscmap1: invalid cmap1 RGB color has been corrected"", &nc_r, &nc_g, &nc_b, NULL );
-8.         plsc->cmap1[i].r = (unsigned char) nc_r;
-7.         plsc->cmap1[i].g = (unsigned char) nc_g;
-6.     ",Useful
"/*--------------------------------------------------------------------------
plscmap1l()

! Set color map 1 colors using a piece-wise linear relationship between
! position in the color map (from 0 to 1) and position in HLS or RGB color
! space.  May be called at any time.
!
! The idea here is to specify a number of control points that specify the
! mapping between HLS (or RGB or CMY) and palette 1 value.  Between these
! points, linear interpolation is used.  By mapping position in the color
! map to function value, this gives a smooth variation of color with
! intensity.  Any number of control points may be specified, located at
! arbitrary positions (intensities), although typically 2 - 4 are enough.
! Another way of stating this is that we are traversing a given number of
! lines through HLS (or RGB) space as we move through cmap 1 entries.  The
! control points at the minimum and maximum intensity (0 and 1) must
! always be specified.  By adding more control points you can get more
! variation.  One good technique for plotting functions that vary about
! some expected average is to use an additional 2 control points in the
! center (intensity ~= 0.5) that are the same color as the background
! (typically white for paper output, black for crt), and same hue as the
! boundary control points.  This allows the highs and lows to be very
! easily distinguished.
!
! Each control point must specify the position in cmap 1 as well as three
! coordinates in HLS or RGB space.  The first and last points MUST correspond to
! cmap1 coordinates MIN_PLFLT_CMAP1 and MAX_PLFLT_CMAP1.
!
! Every change in hue from one control point to the next can be linearly
! interpolated in two ways.  The usual (alt_hue_path[i] false) method for the ith interval
! uses the dh = h[i+1] - h[i] interval for interpolation.  The alternate (alt_hue_path true) method for the ith interval uses the dh = (h[i+1] - h[i]) - 360 if (h[i+1] - h[i]) is positive or dh = 360 - (h[i+1] - h[i]) if (h[i+1] - h[i]) is negative interval for the interpolation.  Thus, alt_hue_path true interpolation intervals always include hue = 0.
! Specifying
! alt_hue_path=NULL is equivalent to setting alt_hue_path[]=false for every control point.
!
! Bounds on RGB coordinates:
!	R,G,B		[0, 1]		magnitude
!
! Bounds on HLS coordinates:
!	hue		[0, 360]	degrees
!	lightness	[0, 1]		magnitude
!	saturation	[0, 1]		magnitude
!
! The inputs are:
! @param itype 0: HLS, 1: RGB
! @param npts	number of control points
! @param intensity[] intensity index for each control point
! @param coord1[] first coordinate for each control point
! @param coord2[] second coordinate for each control point
! @param coord3[] third coordinate for each control point
! @param alt_hue_path[] if true, use alternative hue interpolation path
! for the associated interval.*/","-10.         nc_alpha = alpha[i];
-9.         limit_rgba_range( ""plscmap1a: invalid cmap1 RGBA color has been corrected"", &nc_r, &nc_g, &nc_b, &nc_alpha );
-8.         plsc->cmap1[i].r = (unsigned char) nc_r;
-7.         plsc->cmap1[i].g = (unsigned char)",Useful
/*Save control points*/,"-2.     if ( plsc->cmap1 == NULL )
-1.         plscmap1n( 0 );

 /*Save control points*/

1.     plsc->cmap1cp_is_rgb = itype == 0 ? 0 : 1;
2.     plsc->ncp1           = npts;
3.     for ( n = 0; n < npts; n++ )
4.     {
5.         plsc->cmap1cp[n].c1 = c",Useful
/*Calculate and set color map*/,"-2.             plsc->cmap1cp[n].alt_hue_path = 0;
-1.     }

 /*Calculate and set color map*/

1.     plcmap1_calc();
2. }",Useful
"/*--------------------------------------------------------------------------
plscmap1la()

! This is the same as plscmap1l, but also allows alpha value interpolation.
!
! @param itype 0: HLS, 1: RGB
! @param npts	number of control points
! @param intensity[] intensity index for each control point
! @param coord1[] first coordinate for each control point
! @param coord2[] second coordinate for each control point
! @param coord3[] third coordinate for each control point
! @param alpha[] alpha value for each control point
! @param alt_hue_path[] if true, use alternative hue interpolation path
! for the associated interval.*/","-10.         nc_alpha = alpha[i];
-9.         limit_rgba_range( ""plscmap1a: invalid cmap1 RGBA color has been corrected"", &nc_r, &nc_g, &nc_b, &nc_alpha );
-8.         plsc->cmap1[i].r = (unsigned char) nc_r;
-7.         plsc->cmap1[i].g = (unsigned char)",Useful
/*Save control points*/,"-2.     if ( plsc->cmap1 == NULL )
-1.         plscmap1n( 0 );

 /*Save control points*/

1.     plsc->cmap1cp_is_rgb = itype == 0 ? 0 : 1;
2.     plsc->ncp1           = npts;
3.     for ( n = 0; n < npts; n++ )
4.     {
5.         plsc->cmap1cp[n].c1 = c",Useful
/*Calculate and set color map*/,"-2.             plsc->cmap1cp[n].alt_hue_path = 0;
-1.     }

 /*Calculate and set color map*/

1.     plcmap1_calc();
2. }",Useful
"/*--------------------------------------------------------------------------
plcmap1_calc()

! Bin up cmap 1 space and assign colors to make inverse mapping easy.*/","-2.     plcmap1_calc();
-1. }

 /*--------------------------------------------------------------------------
plcmap1_calc()

! Bin up cmap 1 space and assign colors to make inverse mapping easy.*/

1. void
2. plcmap1_calc( void )
3. {
4.     int   i, n;
5",Useful
/*Loop over all control point pairs*/,"-6. void
-5. plcmap1_calc( void )
-4. {
-3.     int   i, n;
-2.     PLFLT delta, dp, dh, dl, ds, da, dr, dg, db;
-1.     PLFLT h, l, s, p, r, g, b, a;

 /*Loop over all control point pairs*/

1.     if ( !plsc->cmap1cp_is_rgb )
2.     {
3.         for ( n",Useful
"/*Differences in p, h, l, s between ctrl pts*/","-6.     if ( !plsc->cmap1cp_is_rgb )
-5.     {
-4.         for ( n = 0; n < plsc->ncp1 - 1; n++ )
-3.         {
-2.             if ( plsc->cmap1cp[n].p == plsc->cmap1cp[n + 1].p )
-1.                 continue;

 /*Differences in p, h, l, s between ctrl pt",Useful
"/*Loop over all color cells.  Only interested in cells located (in
cmap1 space)  between n_th and n+1_th control points*/","-2.             if ( plsc->cmap1cp[n].alt_hue_path )
-1.                 dh = ( dh > 0 ) ? dh - 360 : dh + 360;

 /*Loop over all color cells.  Only interested in cells located (in
cmap1 space)  between n_th and n+1_th control points*/

1.             for",Useful
/*Interpolate based on position of color cell in cmap1 space*/,"-6.             for ( i = 0; i < plsc->ncol1; i++ )
-5.             {
-4.                 p = (double) i / ( plsc->ncol1 - 1.0 );
-3.                 if ( ( p < plsc->cmap1cp[n].p ) ||
-2.                      ( p > plsc->cmap1cp[n + 1].p ) )
-1.         ",Useful
"/*Linearly interpolate to get color cell h, l, s values*/","-1.                 delta = ( p - plsc->cmap1cp[n].p ) / dp;

 /*Linearly interpolate to get color cell h, l, s values*/

1.                 h = plsc->cmap1cp[n].c1 + dh * delta;
2.                 l = plsc->cmap1cp[n].c2 + dl * delta;
3.                 ",Useful
"/*Differences in p, h, l, s between ctrl pts*/","-6.     if ( !plsc->cmap1cp_is_rgb )
-5.     {
-4.         for ( n = 0; n < plsc->ncp1 - 1; n++ )
-3.         {
-2.             if ( plsc->cmap1cp[n].p == plsc->cmap1cp[n + 1].p )
-1.                 continue;

 /*Differences in p, h, l, s between ctrl pt",Useful
"/*Loop over all color cells.  Only interested in cells located (in
cmap1 space)  between n_th and n+1_th control points*/","-2.             if ( plsc->cmap1cp[n].alt_hue_path )
-1.                 dh = ( dh > 0 ) ? dh - 360 : dh + 360;

 /*Loop over all color cells.  Only interested in cells located (in
cmap1 space)  between n_th and n+1_th control points*/

1.             for",Useful
/*Interpolate based on position of color cell in cmap1 space*/,"-6.             for ( i = 0; i < plsc->ncol1; i++ )
-5.             {
-4.                 p = (double) i / ( plsc->ncol1 - 1.0 );
-3.                 if ( ( p < plsc->cmap1cp[n].p ) ||
-2.                      ( p > plsc->cmap1cp[n + 1].p ) )
-1.         ",Useful
"/*Linearly interpolate to get color cell h, l, s values*/","-1.                 delta = ( p - plsc->cmap1cp[n].p ) / dp;

 /*Linearly interpolate to get color cell h, l, s values*/

1.                 h = plsc->cmap1cp[n].c1 + dh * delta;
2.                 l = plsc->cmap1cp[n].c2 + dl * delta;
3.                 ",Useful
"/*--------------------------------------------------------------------------
! Set the color map 1 value range to use in continuous color plots.
!
! @param min_color Specifies the minimum cmap1 index to use.  A
! value of MIN_PLFLT_CMAP1 or less indicates that the range should
! start at MIN_PLFLT_CMAP1, the lowest valid cmap1 index available.
! @param max_color Specifies the maximum cmap1 index to use.  A
! value of MAX_PLFLT_CMAP1 or greater indicates that the range
! should finish at MAX_PLFLT_CMAP1, the highest valid cmap1 index
! available.
!
! If the specified range is completely invalid (i.e., min_color >= max_color or max_color
! < MIN_PLFLT_CMAP1, or min_color > MAX_PLFLT_CMAP1), then min_color = MIN_PLFLT_CMAP1
! and max_color = MAX_PLFLT_CMAP1 is used.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
! Set the color map 1 value range to use in continuous color plots.
!
! @param min_co",Useful
"/*At this stage, the following conditions have been met:
min_color < max_color, max_color > MIN_PLFLT_CMAP1, and min_color < MAX_PLFLT_CMAP1.*/","-9. void
-8. c_plscmap1_range( PLFLT min_color, PLFLT max_color )
-7. {
-6.     if ( min_color >= max_color || max_color <= MIN_PLFLT_CMAP1 || min_color >= MAX_PLFLT_CMAP1 )
-5.     {
-4.         plwarn( ""plscmap1_range called with completely invalid colo",Useful
"/*--------------------------------------------------------------------------
! Get the color map 1 value range used in continuous color plots.
!
! @param min_color Specifies the minimum color used.
! @param max_color Specifies the maximum color used.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
! Get the color map 1 value range used in continuous color plots.
!
! @param min_colo",Useful
"/*--------------------------------------------------------------------------
plscmap0n()

! Set number of colors in cmap 0, (re-)allocate cmap 0, and fill with
! default values for those colors not previously allocated (and less
! than index 15, after that you just get grey).
!
! The driver is not guaranteed to support all of these.
!
! @param ncol0 Total number of colors.*/","-6. void
-5. c_plgcmap1_range( PLFLT *min_color, PLFLT *max_color )
-4. {
-3.     *min_color = plsc->cmap1_min;
-2.     *max_color = plsc->cmap1_max;
-1. }

 /*--------------------------------------------------------------------------
plscmap0n()

! Set n",Useful
/*Handle all possible startup conditions*/,"-2.     if ( ncol0 > 0 && plsc->ncol0 == ncol0 )
-1.         return;

 /*Handle all possible startup conditions*/

1.     if ( plsc->ncol0 <= 0 && ncol0 <= 0 )
2.         ncol = PL_DEFAULT_NCOL0;
3.     else if ( ncol0 <= 0 )
4.         ncol = plsc->ncol0",Useful
"/*--------------------------------------------------------------------------
color_set()

! Initializes color table 0 entry by RGB values.
!
! @param i Index of the color.
! @param r Red value of the color.
! @param g Green value of the color.
! @param b Blue value of the color.
! @param a Alpha value of the color.
! @param name The name of the color.*/","-5.     plsc->ncol0 = ncol;
-4.     plcmap0_def( imin, imax );
-3.     if ( plsc->level > 0 )
-2.         plP_state( PLSTATE_CMAP0 );
-1. }

 /*--------------------------------------------------------------------------
color_set()

! Initializes color tab",Useful
"/*--------------------------------------------------------------------------
plcmap0_def()

! Initializes specified color map 0 color entry to its default for
! index range from imin to imax.
!
! @param imin Index of the first color to set to its default.
! @param imax Index of the last color to set to its default.*/","-10. color_set( PLINT i, U_CHAR r, U_CHAR g, U_CHAR b, PLFLT a, PLCHAR_VECTOR name )
-9. {
-8.     plsc->cmap0[i].r    = r;
-7.     plsc->cmap0[i].g    = g;
-6.     plsc->cmap0[i].b    = b;
-5.     plsc->cmap0[i].a    = a;
-4.     plsc->cmap0[i].name = na",Useful
"/*Initialize all colours undefined by the default colour palette file
to opaque red as a warning.*/","-10.                 ""colors defined by default cmap0 palette file"" );
-9.         free( r );
-8.         free( g );
-7.         free( b );
-6.         free( a );
-5.     }
-4.     else
-3.     {
-2.         number_colors = 0;
-1.     }

 /*Initialize all",Useful
"/*--------------------------------------------------------------------------
plscmap1n()

! Set number of colors in cmap 1, (re-)allocate cmap 1, and set default
! values if this is the first allocation.
!
! Note that the driver is allowed to disregard this number.
! In particular, most use fewer than we use internally.
!
! @param ncol1 The number of colors in cmap1.*/","-4.     for ( i = MAX( number_colors, imin ); i <= imax; i++ )
-3.         color_def( i, MAX_PLINT_RGB, MIN_PLINT_RGB, MIN_PLINT_RGB, MAX_PLFLT_ALPHA,
-2.             ""opaque red colour to mark not defined by palette file"" );
-1. }

 /*-------------------",Useful
/*Positions of control points*/,"-4. static void
-3. plcmap1_def( void )
-2. {
-1.     PLFLT i[6], h[6], l[6], s[6], midpt = 0., vertex = 0.;

 /*Positions of control points*/

111",Useful
/*left boundary*/,"-5. static void
-4. plcmap1_def( void )
-3. {
-2.     PLFLT i[6], h[6], l[6], s[6], midpt = 0., vertex = 0.;

 /*left boundary*/

111",Useful
/*a little left of center*/,"-6. static void
-5. plcmap1_def( void )
-4. {
-3.     PLFLT i[6], h[6], l[6], s[6], midpt = 0., vertex = 0.;

 /*a little left of center*/

111",Useful
/*at center*/,"-7. static void
-6. plcmap1_def( void )
-5. {
-4.     PLFLT i[6], h[6], l[6], s[6], midpt = 0., vertex = 0.;

 /*at center*/

111",Useful
/*at center*/,"-7. static void
-6. plcmap1_def( void )
-5. {
-4.     PLFLT i[6], h[6], l[6], s[6], midpt = 0., vertex = 0.;

 /*at center*/

111",Useful
/*a little right of center*/,"-9. static void
-8. plcmap1_def( void )
-7. {
-6.     PLFLT i[6], h[6], l[6], s[6], midpt = 0., vertex = 0.;

 /*a little right of center*/

111",Useful
/*right boundary*/,"-10. static void
-9. plcmap1_def( void )
-8. {
-7.     PLFLT i[6], h[6], l[6], s[6], midpt = 0., vertex = 0.;

 /*right boundary*/

111",Useful
"/*For center control points, pick black or white, whichever is closer to bg
Be careful to pick just short of top or bottom else hue info is lost*/","-10. plcmap1_def( void )
-9. {
-8.     PLFLT i[6], h[6], l[6], s[6], midpt = 0., vertex = 0.;

 /*For center control points, pick black or white, whichever is closer to bg
Be careful to pick just short of top or bottom else hue info is lost*/

1.     if (",Useful
/*Set hue*/,"-10.     if ( vertex < 0.5 )
-9.     {
-8.         vertex = 0.01;
-7.         midpt  = 0.10;
-6.     }
-5.     else
-4.     {
-3.         vertex = 0.99;
-2.         midpt  = 0.90;
-1.     }

 /*Set hue*/

111",Useful
/*low: blue-violet*/,"-10.     {
-9.         vertex = 0.01;
-8.         midpt  = 0.10;
-7.     }
-6.     else
-5.     {
-4.         vertex = 0.99;
-3.         midpt  = 0.90;
-2.     }

 /*low: blue-violet*/

111",Useful
/*only change as we go over vertex*/,"-10.         vertex = 0.01;
-9.         midpt  = 0.10;
-8.     }
-7.     else
-6.     {
-5.         vertex = 0.99;
-4.         midpt  = 0.90;
-3.     }

 /*only change as we go over vertex*/

111",Useful
/*only change as we go over vertex*/,"-10.         vertex = 0.01;
-9.         midpt  = 0.10;
-8.     }
-7.     else
-6.     {
-5.         vertex = 0.99;
-4.         midpt  = 0.90;
-3.     }

 /*only change as we go over vertex*/

111",Useful
/*high: red*/,"-10.     }
-9.     else
-8.     {
-7.         vertex = 0.99;
-6.         midpt  = 0.90;
-5.     }

 /*high: red*/

111",Useful
/*high: red*/,"-10.     }
-9.     else
-8.     {
-7.         vertex = 0.99;
-6.         midpt  = 0.90;
-5.     }

 /*high: red*/

111",Useful
/*keep fixed*/,"-10.     {
-9.         vertex = 0.99;
-8.         midpt  = 0.90;
-7.     }

 /*keep fixed*/

111",Useful
/*Set lightness*/,"-10.         vertex = 0.99;
-9.         midpt  = 0.90;
-8.     }

 /*Set lightness*/

111",Useful
/*low*/,"-10. //! intensity.  Any number of control points may be specified, located at
-9. //! arbitrary positions (intensities), although typically 2 - 4 are enough.
-8. //! Another way of stating this is that we are traversing a given number of
-7. //! lines th",Useful
/*midpoint value*/,"-10.     }

 /*midpoint value*/

111",Useful
/*bg*/,"-10.     icol1 = MIN( icol1, plsc->ncol1 - 1 );
-9.     plsc->icol1      = icol1;
-8.     plsc->curcolor.r = plsc->cmap1[plsc->icol1].r;
-7.     plsc->curcolor.g = plsc->cmap1[plsc->icol1].g;
-6.     plsc->curcolor.b = plsc->cmap1[plsc->icol1].b;
-5.     ",Useful
/*bg*/,"-10.     icol1 = MIN( icol1, plsc->ncol1 - 1 );
-9.     plsc->icol1      = icol1;
-8.     plsc->curcolor.r = plsc->cmap1[plsc->icol1].r;
-7.     plsc->curcolor.g = plsc->cmap1[plsc->icol1].g;
-6.     plsc->curcolor.b = plsc->cmap1[plsc->icol1].b;
-5.     ",Useful
/*midpoint value*/,"-10.     }

 /*midpoint value*/

111",Useful
/*Set saturation -- keep at maximum*/,"-10.     h[3] = 0;           // high: red
-9.     h[4] = 0;           // high: red
-8.     h[5] = 0;           // keep fixed
-7. // Set lightness
-6.     l[0] = 0.5;         // low
-5.     l[1] = midpt;       // midpoint value
-4.     l[2] = vertex;      ",Useful
"/*--------------------------------------------------------------------------
plscolor()

! Used to globally turn color output on/off
!
! @param color 0 = no color, Not zero = color.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plscolor()

! Used to globally turn color output on/off
!
! @param color 0 = no color",Useful
"/*--------------------------------------------------------------------------
void value()

! Auxiliary function used by c_plhlsrgb().
!
! @param n1 Lightness/saturation value 1.
! @param n2 Lightness/saturation value 2.
! @param hue hue (0.0 - 360.0).
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
void value()

! Auxiliary function used by c_plhlsrgb().
!
! @param n1 Lightness/satu",Useful
"/*--------------------------------------------------------------------------
void c_plhlsrgb()

! Convert HLS color to RGB color.
! Bounds on HLS (input):
!	hue		[0., 360.]	degrees
!	lightness	[0., 1.]	magnitude
!	saturation	[0., 1.]	magnitude
!
! Hue is always mapped onto the interval [0., 360.] regardless of input.
! Bounds on RGB (output) is always [0., 1.].  Convert to RGB color values
! by multiplying by 2**nbits (nbits typically 8).
!
! @param h hue in HLS color scheme (0.0 - 360.0)
! @param l lightness in HLS color scheme (0.0 - 1.0)
! @param s saturation in HLS color scheme (0.0 - 1.0)
! @param p_r red value of the HLS color
! @param p_g green value of the HLS color
! @param p_b blue value of the HLS color*/","-10.     if ( hue < 60. )
-9.         val = n1 + ( n2 - n1 ) * hue / 60.;
-8.     else if ( hue < 180. )
-7.         val = n2;
-6.     else if ( hue < 240. )
-5.         val = n1 + ( n2 - n1 ) * ( 240. - hue ) / 60.;
-4.     else
-3.         val = n1;
-2.",Useful
"/*--------------------------------------------------------------------------
void c_plrgbhls()

! Convert RGB color to HLS color.
! Bounds on RGB (input) is always [0., 1.].
! Bounds on HLS (output):
!	hue		[0., 360.]	degrees
!	lightness	[0., 1.]	magnitude
!	saturation	[0., 1.]	magnitude
! @param r red in RGB color scheme (0.0 - 1.0)
! @param g green in RGB color scheme (0.0 - 1.0)
! @param b blue in RGB color scheme (0.0 - 1.0)
! @param p_h hue value of the RGB color.
! @param p_l lightness value of the RGB color.
! @param p_s saturation value of the RGB color.*/","-10.     PLFLT m1, m2;
-9.     if ( l <= .5 )
-8.         m2 = l * ( s + 1. );
-7.     else
-6.         m2 = l + s - l * s;
-5.     m1 = 2 * l - m2;
-4.     *p_r = value( m1, m2, h + 120. );
-3.     *p_g = value( m1, m2, h );
-2.     *p_b = value( m1, m2,",Useful
"/*--------------------------------------------------------------------------
read_line()

! Read a complete line and fill the buffer with its contents up to
! capacity. Then sanitize the string - no control characters, no
! trailing blanks
!
! @param buffer storage for the line of text.
! @param length size of the buffer.
! @param fp open file pointer from which the line of text should be read.
!
! @returns The sanitized line from the file.*/","-10.         h = h * 60;
-9.         if ( h < 0 )
-8.             h = h + 360;
-7.         else if ( h >= 360 )
-6.             h = h - 360;
-5.     }
-4.     *p_h = h;
-3.     *p_l = l;
-2.     *p_s = s;
-1. }

 /*----------------------------------------",Useful
"/*--------------------------------------------------------------------------
cmap0_palette_read()

! Read and check r, g, b, a data from a cmap0*.pal format file.
! The caller must free the returned malloc'ed space for r, g, b, and a.
!
! @param filename name of the cmap0 palette file.
! @param number_colors number of color found in the palette file.
! @param r red value of each color in the palette file.
! @param g green value of each color in the palette file.
! @param b blue value of each color in the palette file.
! @param a alpha value of each color in the palette file.*/","-8.     pchr = buffer + strlen( buffer ) - 1;
-7.     while ( pchr != buffer && *pchr == ' ' )
-6.     {
-5.         *pchr = '\0';
-4.         pchr--;
-3.     }
-2.     return buffer;
-1. }

 /*-------------------------------------------------------------",Useful
/*Get the color data*/,"-10.             fclose( fp );
-9.             plexit( ""cmap0_palette_read: insufficient memory"" );
-8.         }
-7.         for ( i = 0; i < *number_colors; i++ )
-6.         {
-5.             if ( read_line( color_info, COLLEN, fp ) == NULL )
-4.      ",Useful
/*fuzzy range check.*/,"-10.             }
-9.             else if ( strlen( color_info ) > 9 )
-8.             {
-7.                 if ( sscanf( color_info, ""#%2x%2x%2x %lf"",
-6.                     (unsigned int *) ( *r + i ), (unsigned int *) ( *g + i ),
-5.                 ",Useful
"/*Fall back to opaque red on opaque white as visual warning of any
error above.*/","-10.         {
-9.             snprintf( msgbuf, MSGLEN, ""Unrecognized cmap0 format data line.  Line is %s\n"",
-8.                 color_info );
-7.             plwarn( msgbuf );
-6.             free( *r );
-5.             free( *g );
-4.             free",Useful
"/*--------------------------------------------------------------------------
void c_plspal0(filename)

! Set the palette for color map 0 using a cmap0*.pal format file.
! filename: the name of the cmap0*.pal file to use.
!
! @param filename name of the cmap0 palette file.*/","-8.     pchr = buffer + strlen( buffer ) - 1;
-7.     while ( pchr != buffer && *pchr == ' ' )
-6.     {
-5.         *pchr = '\0';
-4.         pchr--;
-3.     }
-2.     return buffer;
-1. }

 /*-------------------------------------------------------------",Useful
"/*Allocate default number of cmap0 colours if cmap0 allocation not
done already.*/","-8. void
-7. c_plspal0( PLCHAR_VECTOR filename )
-6. {
-5.     int          i;
-4.     unsigned int *r, *g, *b;
-3.     double       *a;
-2.     int          number_colors;
-1.     cmap0_palette_read( filename, &number_colors, &r, &g, &b, &a );

 /*Alloca",Useful
/*Allocate sufficient cmap0 colours to contain present data.*/,"-1.     plscmap0n( 0 );

 /*Allocate sufficient cmap0 colours to contain present data.*/

1.     if ( number_colors > plsc->ncol0 )
2.     {
3.         plscmap0n( number_colors );
4.     }
5.     for ( i = 0; i < number_colors; i++ )
6.     {
7.         c",Useful
"/*! This code fragment used a lot in plspal1 to deal with
! floating-point range checking of a value and the adjustment of that
! value when close to the range when there is floating-point errors.
!
! @param value The value to range check.
! @param min The minimum allowable value.
! @param max The maximum allowable value.
! @param fuzz Amount of slop to allow beyond the range defined by min & max.
! @param err_number The error number.*/","-10.     }
-9.     for ( i = 0; i < number_colors; i++ )
-8.     {
-7.         c_plscol0a( i, (PLINT) r[i], (PLINT) g[i], (PLINT) b[i], a[i] );
-6.     }
-5.     free( r );
-4.     free( g );
-3.     free( b );
-2.     free( a );
-1. }

 /*! This code fra",Useful
"/*--------------------------------------------------------------------------
void c_plspal1(filename)

! Set the palette for color map 1 using a cmap1*.pal format file.
! filename: the name of the cmap1*.pal file to use.
!
! @param filename name of the cmap1 palette file.
! @param interpolate interpolate between control points.*/","-10.     if ( value < ( min - fuzz ) || value > ( max + fuzz ) ) {                                                                         \
-9.         snprintf( msgbuf, MSGLEN, ""Unrecognized cmap1 format data line.  Error number is %d. Line is %s\n"", er",Useful
"/*For old format, input colours range from 0 to 255 and
need to be renormalized to the range from 0. to 1..*/","-10.             color_info[PALLEN - 1] = '\0';
-9.             return_sscanf          = sscanf( color_info, ""#%2x%2x%2x %d %d"", &r_i, &g_i, &b_i, &pos_i, &alt_hue_path_i );
-8.             if ( return_sscanf < 4 || ( return_sscanf_old != 0 && return_ssca",Useful
/*Next to oldest tk format with alt_hue_path specified.*/,"-10.             g[i]   = (PLFLT) g_i / 255.;
-9.             b[i]   = (PLFLT) b_i / 255.;
-8.             a[i]   = 1.0;
-7.             pos[i] = 0.01 * (PLFLT) pos_i;
-6.             fuzzy_range_check( r[i], 0., 1., FUZZ_EPSILON, 1 );
-5.             fuz",Useful
/*Oldest tk format.  No alt_hue_path specified.*/,"-5.                 alt_hue_path[i] = (PLBOOL) alt_hue_path_i;
-4.             }
-3.         }
-2.         if ( return_sscanf == 4 )
-1.         {

 /*Oldest tk format.  No alt_hue_path specified.*/

1.             free( alt_hue_path );
2.             alt",Useful
/*New floating point file version with support for alpha and alt_hue_path values*/,"-6.             free( alt_hue_path );
-5.             alt_hue_path = NULL;
-4.         }
-3.     }
-2.     else
-1.     {

 /*New floating point file version with support for alpha and alt_hue_path values*/

1.         for ( i = 0; i < number_colors; i++ ",Useful
"/*Check that all rgba and pos data within range from 0. to
1. except for the hls colour space case where the first
coordinate is checked within range from 0. to 360.*/","-10.                 snprintf( msgbuf, MSGLEN, ""Unrecognized cmap1 format (wrong number of items for version 2 of format) %s\n"", color_info );
-9.                 plwarn( msgbuf );
-8.                 err = 1;
-7.                 break;
-6.             }
",Useful
"/*Fall back to red scale as visual warning if some problem occurred
above.*/","-10.             {
-9.                 ri[i] = (PLINT) ( r[i] * MAX_PLINT_RGB );
-8.                 gi[i] = (PLINT) ( g[i] * MAX_PLINT_RGB );
-7.                 bi[i] = (PLINT) ( b[i] * MAX_PLINT_RGB );
-6.             }
-5.             c_plscmap1a( ri,",Useful
"/*--------------------------------------------------------------------------
A grab-bag of various control routines.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
A grab-bag of various control routines.
---------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plwarn()

! A handy way to issue warnings, if need be.
!
! @param errormsg The error message.*/","-10.     free( gi );
-9.     free( bi );
-8.     free( a );
-7.     free( pos );
-6.     free( alt_hue_path );
-5. finish: plrestore_locale( save_locale );
-4. }

 /*--------------------------------------------------------------------------
void plwarn()
",Useful
"/*--------------------------------------------------------------------------
void plabort()

! Much the same as plwarn(), but appends "", aborting operation"" to the
! error message.  Helps to keep source code uncluttered and provides a
! convention for error aborts.
!
! If cleanup needs to be done in the main program, the user should write
! his/her own exit handler and pass it in via plsabort().
!
! @param errormsg The error message.*/","-10.     free( gi );
-9.     free( bi );
-8.     free( a );
-7.     free( pos );
-6.     free( alt_hue_path );
-5. finish: plrestore_locale( save_locale );
-4. }

 /*--------------------------------------------------------------------------
void plabort()",Useful
"/*--------------------------------------------------------------------------
void plsabort()

! Sets an optional user abort handler.
!
! @param handler A function that takes a PLCHAR_VECTOR argument that will
! be called in the event of a abort.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
void plsabort()

! Sets an optional user abort handler.
!
! @param handler A function",Useful
"/*--------------------------------------------------------------------------
void plexit()

! In case of an abort this routine is called.  It just prints out an error
! message and tries to clean up as much as possible.  It's best to turn
! off pause and then restore previous setting before returning.
!
! If cleanup needs to be done in the main program, the user should write
! his/her own exit handler and pass it in via plsexit().  This function
! should should either call plend() before exiting, or simply return.
!
! @param errormsg The error message.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
void plexit()

! In case of an abort this routine is called.  It just prints out an e",Useful
"/*--------------------------------------------------------------------------
void plsexit()

! Sets an optional user exit handler.
!
! @param handler A function that takes a PLCHAR_VECTOR argument that will
! will be called in the event of a exit.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
void plsexit()

! Sets an optional user exit handler.
!
! @param handler A function t",Useful
"/*--------------------------------------------------------------------------
void plgra()

! Switches to graphics screen.
!
! Here and in pltext() it's a good idea to return silently if plinit()
! hasn't yet been called, since plwarn() calls pltext() and plgra(), and
! plwarn() may be called at any time.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
void plgra()

! Switches to graphics screen.
!
! Here and in pltext() it's a good ide",Useful
"/*--------------------------------------------------------------------------
void plxormod()

! Set xor mode? FIXME: Not really sure what this function does.
!
! @param mode Boolean.
! @param status 1 if successful, 0 otherwise.*/","-6. void
-5. c_plgra( void )
-4. {
-3.     if ( plsc->level > 0 )
-2.         plP_esc( PLESC_GRAPH, NULL );
-1. }

 /*--------------------------------------------------------------------------
void plxormod()

! Set xor mode? FIXME: Not really sure what t",Useful
/*xor mode*/,"-9. void
-8. c_plgra( void )
-7. {
-6.     if ( plsc->level > 0 )
-5.         plP_esc( PLESC_GRAPH, NULL );
-4. }

 /*xor mode*/

111",Useful
"/*--------------------------------------------------------------------------
void pltext()

! Switches to text screen.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
void pltext()

! Switches to text screen.
-------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void pl_cmd()

! Front-end to driver escape function.
! In principle this can be used to pass just about anything directly
! to the driver.
!
! @param op A PLESC command to pass to the driver.
! @param ptr Data associated with the op command.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
void pl_cmd()

! Front-end to driver escape function.
! In principle this can be used",Useful
"/*--------------------------------------------------------------------------
char *plFindCommand

! Looks for the specified executable file.  Search path:
!      if command invoked in the build tree:
!         build_tree/tk (plserver lies there - needed for the tk driver)
!         source_tree/scripts (plpr lies there - needed for the tk driver)
!      else
!	PLPLOT_BIN_ENV = $(PLPLOT_BIN)
!	current directory
!	PLPLOT_HOME_ENV/bin = $(PLPLOT_HOME)/bin
!	BIN_DIR
!
! The caller must free the returned pointer (points to malloc'ed memory)
! when finished with it.
!
! @param fn Name of the executable(?).
!
! @returns The location of the executable file.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
char *plFindCommand

! Looks for the specified executable file.  Search path:
!      ",Useful
/**** see if in build tree ***/,"-4. char *
-3. plFindCommand( PLCHAR_VECTOR fn )
-2. {
-1.     char *fs = NULL, *dn;

 /**** see if in build tree ***/

1.     if ( plInBuildTree() == 1 )
2.     {
3.         plGetName( BUILD_DIR, ""bindings/tk"", fn, &fs );
4.         if ( !plFindName( fs ",Useful
"/*--------------------------------------------------------------------------
FILE *plLibOpen(fn)

! Return file pointer to library file (such as a colormap palette).
! Locations checked:
!	PLPLOT_LIB_ENV = $(PLPLOT_LIB)
!	current directory
!	PLPLOT_HOME_ENV/lib = $(PLPLOT_HOME)/lib
!	DATA_DIR
!	PLLIBDEV
!
! @param fn Name of the file.
!
! @returns A open file pointer (if successful).
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
FILE *plLibOpen(fn)

! Return file pointer to library file (such as a colormap palett",Useful
"/*--------------------------------------------------------------------------
FILE *plLibOpenPdfstrm(fn)

! Return file PDFstrm * to a file (originally used for loading fonts?).
! Locations checked:
!	PLPLOT_LIB_ENV = $(PLPLOT_LIB)
!	current directory
!	PLPLOT_HOME_ENV/lib = $(PLPLOT_HOME)/lib
!	DATA_DIR
!	PLLIBDEV
!
! @param fn Name of the file.
!
! @returns A open PDFstrm file pointer (if successful)
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
FILE *plLibOpenPdfstrm(fn)

! Return file PDFstrm * to a file (originally used for lo",Useful
/****   search build tree               ****/,"-5. PDFstrm *
-4. plLibOpenPdfstrm( PLCHAR_VECTOR fn )
-3. {
-2.     PDFstrm *file;
-1.     char    *fs = NULL, *dn = NULL;

 /****   search build tree               ****/

1.     if ( plInBuildTree() == 1 )
2.     {
3.         plGetName( SOURCE_DIR, ""dat",Useful
"/*--------------------------------------------------------------------------
PLINR plFindName

! Authors: Paul Dubois (LLNL), others?
! This function is in the public domain.
!
! Given a pathname, determine if it is a symbolic link.  If so, continue
! searching to the ultimate terminus - there may be more than one link.
! Use the error value to determine when the terminus is reached, and to
! determine if the pathname really exists.  Then stat it to determine
! whether it's executable.  Return 0 for an executable, errno otherwise.
! Note that 'p' _must_ have at least one '/' character - it does by
! construction in this program.  The contents of the array pointed to by
! 'p' are changed to the actual pathname if findname is successful.
!
! This function is only defined under Unix for now.
!
! @param p Name of the executable to find.
!
! @returns 0 if p is found & is an executable.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
PLINR plFindName

! Authors: Paul Dubois (LLNL), others?
! This function is in the pu",Useful
"/*--------------------------------------------------------------------------
void plGetName()

! Gets search name for file by concatenating the dir, subdir, and file
! name, allocating memory as needed.  The appropriate delimiter is added
! after the dir specification as necessary.  The caller is responsible
! for freeing the malloc'ed memory.
!
! @param dir The directory name.
! @param subdir The sub-directory name.
! @param filename The file name.
! @param filespec The result of concatenating dir, subdir and filename.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
void plGetName()

! Gets search name for file by concatenating the dir, subdir, and f",Useful
"/*--------------------------------------------------------------------------
void strcat_delim()

! Append path name deliminator if necessary (does not add one if one's
! there already, or if dealing with a colon-terminated device name).
!
! @param dirspec String to add the appropriate delimiter too.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
void strcat_delim()

! Append path name deliminator if necessary (does not add one if",Useful
"/*--------------------------------------------------------------------------
plcol_interp()

! Initializes device cmap 1 entry by interpolation from pls->cmap1
! entries.  Returned PLColor is supposed to represent the i_th color
! out of a total of ncol colors in the current color scheme.
!
! @param pls A plot stream structure.
! @param newcolor A color structure to store the color in.
! @param i Index of the desired color.
! @param ncol Total number of colors (supported by the device?).
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plcol_interp()

! Initializes device cmap 1 entry by interpolation from pls->cmap1
! ",Useful
"/*--------------------------------------------------------------------------
plOpenFile()

! Opens file for output, prompting if not set.
! Prints extra newline at end to make output look better in batch runs.
! A file name of ""-"" indicates output to stdout.
!
! @param pls A plot stream structure.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plOpenFile()

! Opens file for output, prompting if not set.
! Prints extra newline a",Useful
"/*Setting pls->FileName = NULL forces creation of a new family member
You should also free the memory associated with it if you do this*/","-9. #define MAX_NUM_TRIES    10
-8. void
-7. plOpenFile( PLStream *pls )
-6. {
-5.     int    i = 0, count = 0;
-4.     size_t len;
-3.     char   line[BUFFER_SIZE];
-2.     while ( pls->OutFile == NULL )
-1.     {

 /*Setting pls->FileName = NULL forces ",Useful
"/*Need this here again, for prompted family initialization*/","-6.         if ( !strcmp( pls->FileName, ""-"" ) )
-5.         {
-4.             pls->OutFile     = stdout;
-3.             pls->output_type = 1;
-2.             break;
-1.         }

 /*Need this here again, for prompted family initialization*/

1.        ",Useful
"/*--------------------------------------------------------------------------
plCloseFile()

! Closes output file unless it is associated with stdout.
!
! @param pls A plot stream structure.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plCloseFile()

! Closes output file unless it is associated with stdout.
!
! @param p",Useful
"/*--------------------------------------------------------------------------
plP_getmember()

! Sets up next file member name (in pls->FileName), but does not open it.
!
! @param pls A plot stream structure.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plP_getmember()

! Sets up next file member name (in pls->FileName), but does not ope",Useful
"/*--------------------------------------------------------------------------
plP_sfnam()

! Sets up file name (with ""%n"" removed if present) & family stem name.
! Reserve some extra space (10 chars) to hold an optional member number.
!
! @param pls A plot stream.
! @param fnam The base file name of the plot files.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plP_sfnam()

! Sets up file name (with ""%n"" removed if present) & family stem name.
!",Useful
"/*--------------------------------------------------------------------------
plFamInit()

! Initializes family file parameters.
!
! @param pls A plot stream structure.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plFamInit()

! Initializes family file parameters.
!
! @param pls A plot stream struc",Useful
"/*--------------------------------------------------------------------------
plGetFam()

! Starts new member file of family file set if necessary.
!
! Note each member file is a complete graphics file (can be printed
! individually), although 'plrender' will treat a family as a single
! logical file if given the family name instead of the member name.
!
! @param pls A plot stream structure.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plGetFam()

! Starts new member file of family file set if necessary.
!
! Note each m",Useful
"/*Apply compensating factor to original xpmm and ypmm so that
character aspect ratio is preserved when overall aspect ratio
is changed.*/","-1.             pls->page_status = local_page_status;

 /*Apply compensating factor to original xpmm and ypmm so that
character aspect ratio is preserved when overall aspect ratio
is changed.*/

1.             plP_gpixmm( &xpmm_loc, &ypmm_loc );
2.       ",Useful
"/*--------------------------------------------------------------------------
plRotPhy()

! Rotates physical coordinates if necessary for given orientation.
! Each time orient is incremented, the plot is rotated 90 deg clockwise.
! Note: this is now used only to rotate by 90 degrees for devices that
! expect portrait mode.
!
! @param orient New plot orientation (0-3)
! @param xmin Current plot x minimum?
! @param ymin Current plot y minimum?
! @param xmax Current plot x maximum?
! @param ymax Current plot y maximum?
! @param px Old x coordinate mapped to new x coordinate.
! @param py Old y coordinate mapped to new y coordinate.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plRotPhy()

! Rotates physical coordinates if necessary for given orientation.
! Each",Useful
"/*--------------------------------------------------------------------------
plAllocDev()

! Allocates a standard PLDev structure for device-specific data, stores
! the address in pls->dev, and returns the address as well.
!
! @param pls A plot stream structure.
!
! @returns A PLDev *
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plAllocDev()

! Allocates a standard PLDev structure for device-specific data, stores",Useful
"/*--------------------------------------------------------------------------
plGinInit()

! Just fills in the PLGraphicsIn with appropriate initial values.
!
! @param gin A plot graphics input (i.e. keypress or mouseclick) structure.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plGinInit()

! Just fills in the PLGraphicsIn with appropriate initial values.
!
! @p",Useful
"/*--------------------------------------------------------------------------
plGetInt()

! Prompts human to input an integer in response to given message.
!
! @param s The prompt message.
!
! @returns The PLINT the human entered.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plGetInt()

! Prompts human to input an integer in response to given message.
!
! @pa",Useful
"/*--------------------------------------------------------------------------
plGetFlt()

! Prompts human to input a float in response to given message.
!
! @param s The prompt message.
!
! @returns The PLFLT the human entered.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plGetFlt()

! Prompts human to input a float in response to given message.
!
! @param",Useful
"/*--------------------------------------------------------------------------
plstrdup()

! A replacement for strdup(), which isn't portable.
! Caller responsible for freeing the allocated memory.
!
! @param src The string to duplicate.
!
! @returns A copy of the string src.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plstrdup()

! A replacement for strdup(), which isn't portable.
! Caller responsible ",Useful
"/*--------------------------------------------------------------------------
plsnprintf()

! Dummy function for snprintf(). This function just calls
! the unsafe function ignoring the string size. This function will
! rarely be needed if ever.
!
! @param buffer String output buffer.
! @param n Size of buffer.
! @param format The format string.
! @param ... The values that go in the format string (...)
!
! @returns The length of buffer that is actually used.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plsnprintf()

! Dummy function for snprintf(). This function just calls
! the unsafe ",Useful
"/*--------------------------------------------------------------------------
plsnscanf()

! Dummy function for snscanf(). This function just calls
! the unsafe function ignoring the string size. This function will
! rarely be needed if ever.
!
! @param buffer String output buffer.
! @param n Size of buffer.
! @param format The format string.
! @param ... The values that go in the format string (...)
!
! @returns The length of buffer that is actually used.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plsnscanf()

! Dummy function for snscanf(). This function just calls
! the unsafe fu",Useful
"/*--------------------------------------------------------------------------
plseed()

! Set the seed for the random number generator included.
!
! @param seed The random number generator seed value.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plseed()

! Set the seed for the random number generator included.
!
! @param seed Th",Useful
"/*--------------------------------------------------------------------------
plrandd()

! @returns A random number on [0,1]-interval.
!
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plrandd()

! @returns A random number on [0,1]-interval.
!
--------------------------",Useful
"/*--------------------------------------------------------------------------
plsave_set_locale()

! Save LC_NUMERIC locale in a string.  The pointer to that string is
! returned. Then set LC_NUMERIC to ""C"" locale.
! n.b. plsave_set_locale and plrestore_locale should always be used as
! a pair to surround PLplot code that absolutely requires the
! LC_NUMERIC ""C"" locale to be in effect.  It is one of plrestore_locale's
! responsibilities to free the memory allocated here for the locale
! string.
!
! @returns The LC_NUMERIC locale.
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plsave_set_locale()

! Save LC_NUMERIC locale in a string.  The pointer to that strin",Useful
/*save original LC_NUMERIC locale for restore below.*/,"-9. char *
-8. plsave_set_locale( void )
-7. {
-6.     char * setlocale_ptr;
-5.     char * saved_lc_numeric_locale;
-4.     if ( !( saved_lc_numeric_locale = (char *) malloc( 100 * sizeof ( char ) ) ) )
-3.     {
-2.         plexit( ""plsave_set_locale: o",Useful
"/*--------------------------------------------------------------------------
plrestore_locale()

! Restore LC_NUMERIC locale string that was determined by
! plsave_set_locale with the pointer to that string as the argument.
! Also, free the memory for that string.
!
! @param saved_lc_numeric_locale The saved numeric locale..
--------------------------------------------------------------------------*/","-4. #ifndef PLLIBDEV
-3. #define PLLIBDEV    ""/usr/local/plplot/lib""
-2. #endif
-1. #endif

 /*--------------------------------------------------------------------------
plrestore_locale()

! Restore LC_NUMERIC locale string that was determined by
! plsav",Useful
"/*! @file
!  These function perform variuos affine transformations.
!
! For background on these affine functions see SVG specification, e.g.,
! http://www.w3.org/TR/SVGTiny12/coords.html#EstablishingANewUserSpace.
! Affine 3x3 matrices with elements A_i,j always have a last row of
! 0, 0, 1 so the elements are conveniently stored in a vector in the order
! A_1_1, A_2_1, A_1_2, A_2_2, A_1_3, A_2_3, with the last row implied.
!
! N.B.  The PLplot affine interpretation of translate, scale, etc., is
! as actions on coordinate systems, rather than actions on objects.  This
! is identical to the SVG specficiation interpretation.  However, the
! SVG specification interprets the affine matrix as follows:
! old_coord_vector = affine_matrix * new_coordinate vector.  In PLplot
! we use the alternative interpretation
! new_coord_vector = affine_matrix * old_coordinate vector.
! The result is all affine matrices below are the inverses of the SVG
! equivalents.
!
! N.B. All PLplot affine functions below return the affine matrix result (in
! vector form) as the first argument).  It is the calling routine's
! responsibility to provide the space for all affine matrix arguments,
! i.e., a PLFLT array with a dimension of 6.
!*/","-10. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-9. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-8. // GNU Library General Public License for more details.
-7. //
-6. // You should have received a copy of the GN",Useful
"/*! Translate new coordinate system axes relative to the old.
!
! @param affine_vector Pre-allocated storage for a translation matrix.
! @param xtranslate Amount to translate in x.
! @param ytranslate Amount to translate in y.
!*/","void
plP_affine_translate( PLFLT *affine_vector, PLFLT xtranslate, PLFLT ytranslate )
{
    affine_vector[0] = 1.;
    affine_vector[1] = 0.;
    affine_vector[2] = 0.;
    affine_vector[3] = 1.;

 /*! Translate new coordinate system axes relative to the old.
!
! @param affine_vector Pre-allocated storage for a translation matrix.
! @param xtranslate Amount to translate in x.
! @param ytranslate Amount to translate in y.
!*/

1. void
2. plP_affine_multiply(
3.     PLFLT *affine_vectorA,
4.     PLFLT_VECTOR affine_vectorB,
5.     PLFLT_VECTOR affine_vectorC )
6. {
7.     int   i;
8.     PLFLT result[NAFFINE];",Useful
"/*If the new coordinate system axis is shifted by xtranslate and ytranslate
relative to the old, then the actual new coordinates are shifted in
the opposite direction.*/","-7. void
-6. plP_affine_translate( PLFLT *affine_vector, PLFLT xtranslate, PLFLT ytranslate )
-5. {
-4.     affine_vector[0] = 1.;
-3.     affine_vector[1] = 0.;
-2.     affine_vector[2] = 0.;
-1.     affine_vector[3] = 1.;

 /*If the new coordinate syste",Useful
"/*! Scale new coordinate system axes relative to the old.
!
! @param affine_vector Pre-allocate storage for a scale matrix.
! @param xscale Amount to scale in x.
! @param yscale Amount to scale in y.
!*/","-3.     affine_vector[4] = -xtranslate;
-2.     affine_vector[5] = -ytranslate;
-1. }

 /*! Scale new coordinate system axes relative to the old.
!
! @param affine_vector Pre-allocate storage for a scale matrix.
! @param xscale Amount to scale in x.
! @pa",Useful
/*Multiply two affine matrices stored in affine vector form.*/,"-8. void
-7. plP_affine_multiply(
-6.     PLFLT *affine_vectorA,
-5.     PLFLT_VECTOR affine_vectorB,
-4.     PLFLT_VECTOR affine_vectorC )
-3. {
-2.     int   i;
-1.     PLFLT result[NAFFINE];

 /*Multiply two affine matrices stored in affine vector form",Useful
"/*Get better names, those are too cryptic!

ZEROW2B: zero writing to buffer ?
ZEROW2D: zero writing to display ?
ONEW2B: set writing to buffer ?
ONEW2D: set writing to display ?*/","-4. #include ""plplotP.h""
-3. #define COLOR_MIN        0.0
-2. #define COLOR_MAX        1.0
-1. #define COLOR_NO_PLOT    ( -1.0 )

 /*Get better names, those are too cryptic!

ZEROW2B: zero writing to buffer ?
ZEROW2D: zero writing to display ?
ONEW2B: set",Useful
/*TODO: store previous state*/,"-4. void
-3. NoBufferNoPixmap()
-2. {
-1.     PLINT op = ZEROW2B;

 /*TODO: store previous state*/

1.     plP_esc( PLESC_EXPOSE, NULL );
2.     plP_esc( PLESC_IMAGEOPS, &op );
3. }
4. void
5. RestoreWrite2BufferPixmap()
6. {
7.     PLINT op = ONEW2B;",Useful
/*TODO: revert from previous state*/,"-7.     plP_esc( PLESC_EXPOSE, NULL );
-6.     plP_esc( PLESC_IMAGEOPS, &op );
-5. }
-4. void
-3. RestoreWrite2BufferPixmap()
-2. {
-1.     PLINT op = ONEW2B;

 /*TODO: revert from previous state*/

1.     plP_esc( PLESC_IMAGEOPS, &op );
2. }",Useful
"/*
NOTE: The plshade* functions require that both pltr and pltr_data are set
in order for pltr to be used.  plimageslow does NOT require this, so it is
up to the user to make sure pltr_data is something non-NULL if pltr
requires it.
Plottable values in idata must be scaled between COLOR_MIN and COLOR_MAX.
This is an internal function, and should not be used directly.  Its
interface may change.
*/","
// plimage()


 /*
NOTE: The plshade* functions require that both pltr and pltr_data are set
in order for pltr to be used.  plimageslow does NOT require this, so it is
up to the user to make sure pltr_data is something non-NULL if pltr
requires it.
Plottable values in idata must be scaled between COLOR_MIN and COLOR_MAX.
This is an internal function, and should not be used directly.  Its
interface may change.
*/

111",Useful
/*Indices*/,"-5. void
-4. plimageslow( PLFLT *idata, PLINT nx, PLINT ny,
-3.              PLFLT xmin, PLFLT ymin, PLFLT dx, PLFLT dy,
-2.              PLTRANSFORM_callback pltr, PLPointer pltr_data )
-1. {

 /*Indices*/

1.     PLINT ix, iy, i;",Useful
/*Float coordinates*/,"-1.     PLINT ix, iy, i;

 /*Float coordinates*/

1.     PLFLT xf[4], yf[4];",Useful
/*Translated (by pltr) coordinates*/,"-1.     PLFLT xf[4], yf[4];

 /*Translated (by pltr) coordinates*/

1.     PLFLT tx, ty;",Useful
"/*The corners of a single filled region
int corners[4]; - unreferenced
The color to use in the fill*/","-1.     PLFLT tx, ty;

 /*The corners of a single filled region
int corners[4]; - unreferenced
The color to use in the fill*/

1.     PLFLT color;
2.     plP_esc( PLESC_START_RASTERIZE, NULL );
3.     for ( ix = 0; ix < nx; ix++ )
4.     {
5.         for ",Useful
/*Only plot values within in appropriate range*/,"-6.     PLFLT color;
-5.     plP_esc( PLESC_START_RASTERIZE, NULL );
-4.     for ( ix = 0; ix < nx; ix++ )
-3.     {
-2.         for ( iy = 0; iy < ny; iy++ )
-1.         {

 /*Only plot values within in appropriate range*/

1.             color = idata[i",Useful
/*The color value has to be scaled to 0.0 -> 1.0 plcol1 color values*/,"-3.             color = idata[ix * ny + iy];
-2.             if ( color == COLOR_NO_PLOT )
-1.                 continue;

 /*The color value has to be scaled to 0.0 -> 1.0 plcol1 color values*/

1.             plcol1( color / COLOR_MAX );
2.             x",Useful
/*Translate the points*/,"-9.             plcol1( color / COLOR_MAX );
-8.             xf[0] = xf[1] = ix;
-7.             xf[2] = xf[3] = ix + 1;
-6.             yf[0] = yf[3] = iy;
-5.             yf[1] = yf[2] = iy + 1;
-4.             if ( pltr )
-3.             {
-2.         ",Useful
/*Automatic translation to the specified plot area*/,"-9.                     ( *pltr )( xf[i], yf[i], &tx, &ty, pltr_data );
-8.                     xf[i] = tx;
-7.                     yf[i] = ty;
-6.                 }
-5.             }
-4.             else
-3.             {
-2.                 for ( i = 0;",Useful
"/*--------------------------------------------------------------------------
plimagefr_null

arguments are
idata: array containing image data
nx: dimension of the array in the X axis.
ny: dimension of the  array in the Y axis
The array data is indexed like data[ix][iy]

xmin, xmax, ymin, ymax:
data[0][0] corresponds to (xmin,ymin)
data[nx-1][ny-1] to (xmax,ymax)

zmin, zmax:
only data within bounds zmin <= data <= zmax will be
plotted. If zmin == zmax, all data will be ploted.

valuemin, valuemax:
The minimum and maximum values to use for value -> color
mappings.  A value in idata of valuemin or less will have
color 0.0 and a value in idata of valuemax or greater will
have color 1.0.  Values between valuemin and valuemax will
map linearly to to the colors between 0.0 and 1.0.
If you do not want to display values outside of the
(valuemin -> valuemax) range, then set zmin = valuemin and
zmax = valuemax.
This allows for multiple plots to use the same color scale
with a consistent value -> color mapping, regardless of the
image content.

--------------------------------------------------------------------------*/","-10. void
-9. grimage( short *x, short *y, unsigned short *z, PLINT nx, PLINT ny )
-8. {
-7.     plsc->dev_ix    = x;
-6.     plsc->dev_iy    = y;
-5.     plsc->dev_z     = z;
-4.     plsc->dev_nptsX = nx;
-3.     plsc->dev_nptsY = ny;
-2.     plP_esc( PL",Useful
"/*N.B. This routine only needed by the Fortran interface to distinguish
the case where pltr and pltr_data are NULL.  So don't put declaration in
header which might encourage others to use this in some other context.*/","-10. //       have color 1.0.  Values between valuemin and valuemax will
-9. //       map linearly to to the colors between 0.0 and 1.0.
-8. //       If you do not want to display values outside of the
-7. //       (valuemin -> valuemax) range, then set z",Useful
"/*--------------------------------------------------------------------------
plimagefr

arguments are
idata: array containing image data
nx: dimension of the array in the X axis.
ny: dimension of the  array in the Y axis
The array data is indexed like data[ix][iy]

xmin, xmax, ymin, ymax:
data[0][0] corresponds to (xmin,ymin)
data[nx-1][ny-1] to (xmax,ymax)

zmin, zmax:
only data within bounds zmin <= data <= zmax will be
plotted. If zmin == zmax, all data will be ploted.

valuemin, valuemax:
The minimum and maximum values to use for value -> color
mappings.  A value in idata of valuemin or less will have
color 0.0 and a value in idata of valuemax or greater will
have color 1.0.  Values between valuemin and valuemax will
map linearly to to the colors between 0.0 and 1.0.
If you do not want to display values outside of the
(valuemin -> valuemax) range, then set zmin = valuemin and
zmax = valuemax.
This allows for multiple plots to use the same color scale
with a consistent value -> color mapping, regardless of the
image content.

--------------------------------------------------------------------------*/","-10. void
-9. grimage( short *x, short *y, unsigned short *z, PLINT nx, PLINT ny )
-8. {
-7.     plsc->dev_ix    = x;
-6.     plsc->dev_iy    = y;
-5.     plsc->dev_z     = z;
-4.     plsc->dev_nptsX = nx;
-3.     plsc->dev_nptsY = ny;
-2.     plP_esc( PL",Useful
/*z holds scaled image pixel values*/,"-10.         valuemin, valuemax, pltr, pltr_data );
-9. }
-8. void
-7. plfimagefr( PLF2OPS idataops, PLPointer idatap, PLINT nx, PLINT ny,
-6.             PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax, PLFLT zmin, PLFLT zmax,
-5.             PLFLT valuem",Useful
/*Color palette 0 color in use before the plimage* call*/,"-1.     PLFLT datum;

 /*Color palette 0 color in use before the plimage* call*/

1.     PLINT init_color;",Useful
/*Color range*/,"-1.     PLINT init_color;

 /*Color range*/

1.     PLFLT color_min, color_max, color_range;
2.     if ( plsc->level < 3 )
3.     {
4.         plabort( ""plimagefr: window must be set up first"" );
5.         return;
6.     }
7.     if ( nx <= 0 || ny <= 0 ",Useful
/*Save the currently-in-use color.*/,"-10.     }
-9.     if ( nx <= 0 || ny <= 0 )
-8.     {
-7.         plabort( ""plimagefr: nx and ny must be positive"" );
-6.         return;
-5.     }
-4.     if ( ( z = (PLFLT *) malloc( (size_t) ( ny * nx ) * sizeof ( PLFLT ) ) ) == NULL )
-3.     {
-2.  ",Useful
"/*If no acceptable data range is given, then set the min/max data range
to include all of the given data.*/","-1.     init_color = plsc->icol0;

 /*If no acceptable data range is given, then set the min/max data range
to include all of the given data.*/

1.     if ( zmin == zmax )
2.     {",Useful
/*Find the minimum and maximum values in the image*/,"-2.     if ( zmin == zmax )
-1.     {

 /*Find the minimum and maximum values in the image*/

1.         idataops->minmax( idatap, nx, ny, &zmin, &zmax );
2.     }",Useful
/*Calculate the size of the color range to use*/,"-2.         idataops->minmax( idatap, nx, ny, &zmin, &zmax );
-1.     }

 /*Calculate the size of the color range to use*/

1.     color_min   = plsc->cmap1_min;
2.     color_max   = plsc->cmap1_max;
3.     color_range = color_max - color_min;",Useful
/*Set to a value scaled between color_min and color_max.*/,"-10.                 else
-9.                 {
-8.                     if ( datum < valuemin )
-7.                     {
-6.                         datum = valuemin;
-5.                     }
-4.                     else if ( datum > valuemax )
-3.     ",Useful
"/*dx and dy are the plot-coordinates pixel sizes for an untransformed
image*/","nnx = (PLINT) ceil( ( Dxmax - Dxmin ) / dx ) + 1;
        nny = (PLINT) ceil( ( Dymax - Dymin ) / dy ) + 1;

 /*dx and dy are the plot-coordinates pixel sizes for an untransformed
image*/

1.         data_min, data_max, NULL, NULL );",Useful
"/*--------------------------------------------------------------------------
plimage

arguments are
idata: array containing image data
nx: dimension of the array in the X axis.
ny: dimension of the  array in the Y axis
The array data is indexed like data[ix][iy]

xmin, xmax, ymin, ymax:
data[0][0] corresponds to (xmin,ymin)
data[nx-1][ny-1] to (xmax,ymax)

zmin, zmax:
only data within bounds zmin <= data <= zmax will be
plotted. If zmin == zmax, all data will be ploted.

Dxmin, Dxmax, Dymin, Dymax:
plots only the window of points whose(x,y)'s fall
inside the [Dxmin->Dxmax]X[Dymin->Dymax] window

--------------------------------------------------------------------------*/","-10. void
-9. grimage( short *x, short *y, unsigned short *z, PLINT nx, PLINT ny )
-8. {
-7.     plsc->dev_ix    = x;
-6.     plsc->dev_iy    = y;
-5.     plsc->dev_z     = z;
-4.     plsc->dev_nptsX = nx;
-3.     plsc->dev_nptsY = ny;
-2.     plP_esc( PL",Useful
"/*z holds the subimage (Dxmin, Dymin) - (Dxmax, Dymax)*/","-10.         xmin, xmax, ymin, ymax, zmin, zmax,
-9.         Dxmin, Dxmax, Dymin, Dymax );
-8. }
-7. void
-6. plfimage( PLF2OPS idataops, PLPointer idatap, PLINT nx, PLINT ny,
-5.           PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax, PLFLT zmin, PLFLT",Useful
/*Was any space allocated for z?*/,"-2.     PLFLT   **z;
-1.     PLF2OPS zops;

 /*Was any space allocated for z?*/

1.     PLBOOL  copied;
2.     copied = FALSE;
3.     if ( nx <= 0 || ny <= 0 )
4.     {
5.         plabort( ""plimage: nx and ny must be positive"" );
6.         return;
7.    ",Useful
"/*Find the minimum and maximum values in the image.  Use these values to
for the color scale range.*/","-10.     if ( Dxmin < xmin || Dxmax > xmax || Dymin < ymin || Dymax > ymax )
-9.     {
-8.         plabort( ""plimage: Dxmin or Dxmax or Dymin or Dymax not compatible with xmin or xmax or ymin or ymax."" );
-7.         return;
-6.     }
-5.     if ( Dxmax <",Useful
"/*If the whole image should be shown, then no copying is needed.*/","-3.     idataops->minmax( idatap, nx, ny, &data_min, &data_max );
-2.     if ( xmin == Dxmin && xmax == Dxmax && ymin == Dymin && ymax == Dymax )
-1.     {

 /*If the whole image should be shown, then no copying is needed.*/

1.         z    = (PLFLT **) ",Useful
"/*dx and dy are the plot-coordinates pixel sizes for an untransformed
image*/","nnx = (PLINT) ceil( ( Dxmax - Dxmin ) / dx ) + 1;
        nny = (PLINT) ceil( ( Dymax - Dymin ) / dy ) + 1;

 /*dx and dy are the plot-coordinates pixel sizes for an untransformed
image*/

1.         data_min, data_max, NULL, NULL );",Useful
"/*Pixel dimensions of the (Dxmin, Dymin) to (Dxmax, Dymax) box*/","-2.         dx = ( xmax - xmin ) / (PLFLT) ( nx - 1 );
-1.         dy = ( ymax - ymin ) / (PLFLT) ( ny - 1 );

 /*Pixel dimensions of the (Dxmin, Dymin) to (Dxmax, Dymax) box*/

1.         nnx = (PLINT) ceil( ( Dxmax - Dxmin ) / dx ) + 1;
2.         nny =",Useful
"/*Call plimagefr with the value -> color range mapped to the minimum
Offsets for the idata indices to select
(Dxmin, Dymin) to (Dxmax, Dymax)*/","-2.         nnx = (PLINT) ceil( ( Dxmax - Dxmin ) / dx ) + 1;
-1.         nny = (PLINT) ceil( ( Dymax - Dymin ) / dy ) + 1;

 /*Call plimagefr with the value -> color range mapped to the minimum
Offsets for the idata indices to select
(Dxmin, Dymin) to (D",Useful
/*Allocate space for the sub-image*/,"-2.         xm = (PLINT) floor( ( Dxmin - xmin ) / dx );
-1.         ym = (PLINT) floor( ( Dymin - ymin ) / dy );

 /*Allocate space for the sub-image*/

1.         plAlloc2dGrid( &z, nnx, nny );
2.         zops = plf2ops_c();",Useful
"/*Go through the image and select the pixels within the given
(Dxmin, Dymin) - (Dxmax, Dymax) window.*/","-2.         plAlloc2dGrid( &z, nnx, nny );
-1.         zops = plf2ops_c();

 /*Go through the image and select the pixels within the given
(Dxmin, Dymin) - (Dxmax, Dymax) window.*/

1.         ixx = -1;
2.         for ( ix = xm; ix < xm + nnx; ix++ )
3.  ",Useful
/*Set the appropriate values to pass in to plimagefr*/,"-9.         ixx = -1;
-8.         for ( ix = xm; ix < xm + nnx; ix++ )
-7.         {
-6.             ixx++; iyy = 0;
-5.             for ( iy = ym; iy < ym + nny; iy++ )
-4.             {
-3.                 z[ixx][iyy++] = idataops->get( idatap, ix, iy )",Useful
/*Only free the memory if it was allocated by us...*/,"-4.         copied = TRUE;
-3.     }
-2.     plfimagefr( zops, (PLPointer) z, nnx, nny, Dxmin, Dxmax, Dymin, Dymax, zmin, zmax,
-1.         data_min, data_max, NULL, NULL );

 /*Only free the memory if it was allocated by us...*/

1.     if ( copied == TR",Useful
/*Static function prototypes*/,"-4. #define NEED_PLDEBUG
-3. #include ""plplotP.h""
-2. #include <float.h>
-1. #include <ctype.h>

 /*Static function prototypes*/

1. static void plP_plotvect( PLFLT x, PLFLT y, PLFLT u, PLFLT v, PLFLT scale );",Useful
"/*--------------------------------------------------------------------------
N.B. This routine only needed by the Fortran interface to distinguish
the case where both arrowx and arrowy are NULL.  So don't put declaration in
header which might encourage others to use this in some other context.
--------------------------------------------------------------------------*/","-1. static void plP_plotvect( PLFLT x, PLFLT y, PLFLT u, PLFLT v, PLFLT scale );

 /*--------------------------------------------------------------------------
N.B. This routine only needed by the Fortran interface to distinguish
the case where both arrow",Useful
"/*--------------------------------------------------------------------------
void c_plsvect()

Set the style of the arrow used by plvect
--------------------------------------------------------------------------*/","-1. static void plP_plotvect( PLFLT x, PLFLT y, PLFLT u, PLFLT v, PLFLT scale );

 /*--------------------------------------------------------------------------
void c_plsvect()

Set the style of the arrow used by plvect
-----------------------------------",Useful
/*Reset default arrow if null pointers are passed.*/,"-10. void
-9. c_plsvect( PLFLT_VECTOR arrowx, PLFLT_VECTOR arrowy, PLINT npts, PLBOOL fill )
-8. {
-7.     int   i;
-6.     PLFLT def_arrow_x[6] = { -0.5, 0.5, 0.3, 0.5, 0.3, 0.5 };
-5.     PLFLT def_arrow_y[6] = { 0.0, 0.0, 0.2, 0.0, -0.2, 0.0 };
-4.    ",Useful
"/*
Plot an individual vector
*/","
//      Vector plotting routines.


 /*
Plot an individual vector
*/

111",Useful
"/*Unnecessarily initialize a_y to quiet a -O1 -Wuninitialized warning
which is a false alarm.  (If something goes wrong with the
a_x malloc below any further use of a_y does not occur.)*/","-5. static void
-4. plP_plotvect( PLFLT x, PLFLT y, PLFLT u, PLFLT v, PLFLT scale )
-3. {
-2.     PLFLT uu, vv, px0, py0, dpx, dpy;
-1.     PLFLT xt, yt;

 /*Unnecessarily initialize a_y to quiet a -O1 -Wuninitialized warning
which is a false alarm.  (If ",Useful
/*transform arrow -> a*/,"-2.     dpx = plP_wcpcx( xt ) - px0;
-1.     dpy = plP_wcpcy( yt ) - py0;

 /*transform arrow -> a*/

1.     for ( j = 0; j < plsc->arrow_npts; j++ )
2.     {
3.         a_x[j] = (PLINT) ( plsc->arrow_x[j] * dpx - plsc->arrow_y[j] * dpy + px0 );
4.       ",Useful
/*draw the arrow*/,"-5.     for ( j = 0; j < plsc->arrow_npts; j++ )
-4.     {
-3.         a_x[j] = (PLINT) ( plsc->arrow_x[j] * dpx - plsc->arrow_y[j] * dpy + px0 );
-2.         a_y[j] = (PLINT) ( plsc->arrow_x[j] * dpy + plsc->arrow_y[j] * dpx + py0 );
-1.     }

 /*draw t",Useful
"/*
void plfvect()

Routine to plot a vector array with arbitrary coordinate
and vector transformations
*/","
//      Vector plotting routines.


 /*
void plfvect()

Routine to plot a vector array with arbitrary coordinate
and vector transformations
*/

111",Useful
/*Calculate apropriate scaling if necessary*/,"-10.     plAlloc2dGrid( &y, nx, ny );
-9.     for ( j = 0; j < ny; j++ )
-8.     {
-7.         for ( i = 0; i < nx; i++ )
-6.         {
-5.             u[i][j] = getuv( i, j, up );
-4.             v[i][j] = getuv( i, j, vp );
-3.             pltr( (PLFLT)",Useful
/*Function prototypes*/,"-4. #include ""plplotP.h""
-3. #define INSIDE( ix, iy )    ( BETW( ix, xmin, xmax ) && BETW( iy, ymin, ymax ) )
-2. static PLINT xline[PL_MAXPOLY], yline[PL_MAXPOLY];
-1. static PLINT lastx = PL_UNDEFINED, lasty = PL_UNDEFINED;

 /*Function prototypes*/

11",Useful
/*Draws a polyline within the clip limits.*/,"-5. #include ""plplotP.h""
-4. #define INSIDE( ix, iy )    ( BETW( ix, xmin, xmax ) && BETW( iy, ymin, ymax ) )
-3. static PLINT xline[PL_MAXPOLY], yline[PL_MAXPOLY];
-2. static PLINT lastx = PL_UNDEFINED, lasty = PL_UNDEFINED;

 /*Draws a polyline within t",Useful
/*General line-drawing routine.  Takes line styles into account.*/,"-2. static void
-1. pllclp( PLINT *x, PLINT *y, PLINT npts );

 /*General line-drawing routine.  Takes line styles into account.*/

1. static void
2. genlin( short *x, short *y, PLINT npts );",Useful
/*Draws a dashed line to the specified point from the previous one.*/,"-2. static void
-1. genlin( short *x, short *y, PLINT npts );

 /*Draws a dashed line to the specified point from the previous one.*/

1. static void
2. grdashline( short *x, short *y );",Useful
/*Determines if a point is inside a polygon or not*/,"-2. static void
-1. grdashline( short *x, short *y );

 /*Determines if a point is inside a polygon or not*/

111",Useful
/*Interpolate between two points in n steps*/,"-3. static void
-2. grdashline( short *x, short *y );

 /*Interpolate between two points in n steps*/

1. static PLFLT *
2. interpolate_between( int n, PLFLT a, PLFLT b );",Useful
"/*--------------------------------------------------------------------------
void pljoin()

Draws a line segment from (x1, y1) to (x2, y2).
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void pljoin()

Draws a line segment from (x1, y1) to (x2, y2).
------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plline()

Draws line segments connecting a series of points.
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plline()

Draws line segments connecting a series of points.
---------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plpath()

Draws a line segment from (x1, y1) to (x2, y2).  If a coordinate
transform is defined then break the line up in to n pieces to approximate
the path.  Otherwise it simply calls pljoin().
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plpath()

Draws a line segment from (x1, y1) to (x2, y2).  If a coordinate
transform is defined then",Useful
"/*No transform, so fall back on pljoin for a normal straight line*/","-6. void
-5. c_plpath( PLINT n, PLFLT x1, PLFLT y1, PLFLT x2, PLFLT y2 )
-4. {
-3.     PLFLT *xs, *ys;
-2.     if ( plsc->coordinate_transform == NULL )
-1.     {

 /*No transform, so fall back on pljoin for a normal straight line*/

1.         pljoin( x1",Useful
"/*Approximate the path in transformed space with a sequence of line
segments.*/","-4.         pljoin( x1, y1, x2, y2 );
-3.     }
-2.     else
-1.     {

 /*Approximate the path in transformed space with a sequence of line
segments.*/

1.         xs = interpolate_between( n, x1, x2 );
2.         ys = interpolate_between( n, y1, y2 );
3",Useful
"/*plP_interpolate allocates memory, so we have to free it here.*/","-8.         xs = interpolate_between( n, x1, x2 );
-7.         ys = interpolate_between( n, y1, y2 );
-6.         if ( xs == NULL || ys == NULL )
-5.         {
-4.             plexit( ""c_plpath: Insufficient memory"" );
-3.             return;
-2.         ",Useful
"/*--------------------------------------------------------------------------
void plline3(n, x, y, z)

Draws a line in 3 space.  You must first set up the viewport, the
2d viewing window (in world coordinates), and the 3d normalized
coordinate box.  See x18c.c for more info.

This version adds clipping against the 3d bounding box specified in plw3d
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plline3(n, x, y, z)

Draws a line in 3 space.  You must first set up the viewport, the
2d viewing wi",Useful
/*get the bounding box in 3d*/,"-10. void
-9. c_plline3( PLINT n, PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z )
-8. {
-7.     int   i;
-6.     PLFLT vmin[3], vmax[3], zscale;
-5.     if ( plsc->level < 3 )
-4.     {
-3.         plabort( ""plline3: Please set up window first"" );
-2.   ",Useful
/*interate over the vertices*/,"-2.     plP_gdom( &vmin[0], &vmax[0], &vmin[1], &vmax[1] );
-1.     plP_grange( &zscale, &vmin[2], &vmax[2] );

 /*interate over the vertices*/

1.     for ( i = 0; i < n - 1; i++ )
2.     {
3.         PLFLT p0[3], p1[3];
4.         int   axis;",Useful
/*copy the end points of the segment to allow clipping*/,"-4.     for ( i = 0; i < n - 1; i++ )
-3.     {
-2.         PLFLT p0[3], p1[3];
-1.         int   axis;

 /*copy the end points of the segment to allow clipping*/

1.         p0[0] = x[i]; p0[1] = y[i]; p0[2] = z[i];
2.         p1[0] = x[i + 1]; p1[1] = y",Useful
/*check against each axis of the bounding box*/,"-2.         p0[0] = x[i]; p0[1] = y[i]; p0[2] = z[i];
-1.         p1[0] = x[i + 1]; p1[1] = y[i + 1]; p1[2] = z[i + 1];

 /*check against each axis of the bounding box*/

1.         for ( axis = 0; axis < 3; axis++ )
2.         {",Useful
/*first out*/,"-2.         for ( axis = 0; axis < 3; axis++ )
-1.         {

 /*first out*/

1.             {
2.                 if ( p1[axis] < vmin[axis] )
3.                 {",Useful
/*both endpoints out so quit*/,"-3.             {
-2.                 if ( p1[axis] < vmin[axis] )
-1.                 {

 /*both endpoints out so quit*/

1.                 }
2.                 else
3.                 {
4.                     int   j;",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*second out*/,"-9.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                     p0[axis] = vmin[axis];
-7.                     for ( j = 1; j < 3; j++ )
-6.                     {
-5.                         int k = ( axis + ",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*first out*/,"-2.         for ( axis = 0; axis < 3; axis++ )
-1.         {

 /*first out*/

1.             {
2.                 if ( p1[axis] < vmin[axis] )
3.                 {",Useful
/*both out so quit*/,"-3.             {
-2.                 if ( p1[axis] > vmax[axis] )
-1.                 {

 /*both out so quit*/

1.                 }
2.                 else
3.                 {
4.                     int   j;",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*second out*/,"-9.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                     p0[axis] = vmin[axis];
-7.                     for ( j = 1; j < 3; j++ )
-6.                     {
-5.                         int k = ( axis + ",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
"/*if we made it to here without ""break""ing out of the loop, the
remaining segment is visible*/","-9.                 PLFLT t = ( vmax[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                 p1[axis] = vmax[axis];
-7.                 for ( j = 1; j < 3; j++ )
-6.                 {
-5.                     int k = ( axis + j ) % 3;
-4.        ",Useful
/*not clipped away*/,"-10.                 p1[axis] = vmax[axis];
-9.                 for ( j = 1; j < 3; j++ )
-8.                 {
-7.                     int k = ( axis + j ) % 3;
-6.                     p1[k] = ( 1 - t ) * p0[k] + t * p1[k];
-5.                 }
-4.     ",Useful
"/*--------------------------------------------------------------------------
void plpoly3( n, x, y, z, draw, ifcc )

Draws a polygon in 3 space.  This differs from plline3() in that
this attempts to determine if the polygon is viewable.  If the back
of polygon is facing the viewer, then it isn't drawn.  If this
isn't what you want, then use plline3 instead.

n specifies the number of points.  They are assumed to be in a
plane, and the directionality of the plane is determined from the
first three points.  Additional points do not /have/ to lie on the
plane defined by the first three, but if they do not, then the
determiniation of visibility obviously can't be 100% accurate...
So if you're 3 space polygons are too far from planar, consider
breaking them into smaller polygons.  ""3 points define a plane"" :-).

For ifcc == 1, the directionality of the polygon is determined by assuming
the points are laid out in counter-clockwise order.

For ifcc == 0, the directionality of the polygon is determined by assuming
the points are laid out in clockwise order.

BUGS:  If one of the first two segments is of zero length, or if
they are colinear, the calculation of visibility has a 50/50 chance
of being correct.  Avoid such situations :-).  See x18c for an
example of this problem.  (Search for ""20.1"").
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plpoly3( n, x, y, z, draw, ifcc )

Draws a polygon in 3 space.  This differs from plline3() in that
",Useful
/*Now figure out which side this is.*/,"-10.     if ( plsc->level < 3 )
-9.     {
-8.         plabort( ""plpoly3: Please set up window first"" );
-7.         return;
-6.     }
-5.     if ( n < 3 )
-4.     {
-3.         plabort( ""plpoly3: Must specify at least 3 points"" );
-2.         return;
-1. ",Useful
/*get the bounding box in 3d*/,"-10. void
-9. c_plline3( PLINT n, PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z )
-8. {
-7.     int   i;
-6.     PLFLT vmin[3], vmax[3], zscale;
-5.     if ( plsc->level < 3 )
-4.     {
-3.         plabort( ""plline3: Please set up window first"" );
-2.   ",Useful
/*interate over the vertices*/,"-2.     plP_gdom( &vmin[0], &vmax[0], &vmin[1], &vmax[1] );
-1.     plP_grange( &zscale, &vmin[2], &vmax[2] );

 /*interate over the vertices*/

1.     for ( i = 0; i < n - 1; i++ )
2.     {
3.         PLFLT p0[3], p1[3];
4.         int   axis;",Useful
/*copy the end points of the segment to allow clipping*/,"-4.     for ( i = 0; i < n - 1; i++ )
-3.     {
-2.         PLFLT p0[3], p1[3];
-1.         int   axis;

 /*copy the end points of the segment to allow clipping*/

1.         p0[0] = x[i]; p0[1] = y[i]; p0[2] = z[i];
2.         p1[0] = x[i + 1]; p1[1] = y",Useful
/*check against each axis of the bounding box*/,"-2.         p0[0] = x[i]; p0[1] = y[i]; p0[2] = z[i];
-1.         p1[0] = x[i + 1]; p1[1] = y[i + 1]; p1[2] = z[i + 1];

 /*check against each axis of the bounding box*/

1.         for ( axis = 0; axis < 3; axis++ )
2.         {",Useful
/*first out*/,"-2.         for ( axis = 0; axis < 3; axis++ )
-1.         {

 /*first out*/

1.             {
2.                 if ( p1[axis] < vmin[axis] )
3.                 {",Useful
/*both endpoints out so quit*/,"-3.             {
-2.                 if ( p1[axis] < vmin[axis] )
-1.                 {

 /*both endpoints out so quit*/

1.                 }
2.                 else
3.                 {
4.                     int   j;",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*second out*/,"-9.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                     p0[axis] = vmin[axis];
-7.                     for ( j = 1; j < 3; j++ )
-6.                     {
-5.                         int k = ( axis + ",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*first out*/,"-2.         for ( axis = 0; axis < 3; axis++ )
-1.         {

 /*first out*/

1.             {
2.                 if ( p1[axis] < vmin[axis] )
3.                 {",Useful
/*both out so quit*/,"-3.             {
-2.                 if ( p1[axis] > vmax[axis] )
-1.                 {

 /*both out so quit*/

1.                 }
2.                 else
3.                 {
4.                     int   j;",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*second out*/,"-9.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                     p0[axis] = vmin[axis];
-7.                     for ( j = 1; j < 3; j++ )
-6.                     {
-5.                         int k = ( axis + ",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
"/*if we made it to here without ""break""ing out of the loop, the
remaining segment is visible*/","-9.                 PLFLT t = ( vmax[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                 p1[axis] = vmax[axis];
-7.                 for ( j = 1; j < 3; j++ )
-6.                 {
-5.                     int k = ( axis + j ) % 3;
-4.        ",Useful
/*not clipped away*/,"-10.                 p1[axis] = vmax[axis];
-9.                 for ( j = 1; j < 3; j++ )
-8.                 {
-7.                     int k = ( axis + j ) % 3;
-6.                     p1[k] = ( 1 - t ) * p0[k] + t * p1[k];
-5.                 }
-4.     ",Useful
"/*--------------------------------------------------------------------------
void plstyl()

Set up a new line style of ""nms"" elements, with mark and space
lengths given by arrays ""mark"" and ""space"".
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plstyl()

Set up a new line style of ""nms"" elements, with mark and space
lengths given by arrays ""ma",Useful
/*Check for blank style*/,"-10.         if ( ( mark[i] < 0 ) || ( space[i] < 0 ) )
-9.         {
-8.             plabort( ""plstyl: Mark and space lengths must be > 0"" );
-7.             return;
-6.         }
-5.         if ( ( mark[i] != 0 ) || ( space[i] != 0 ) )
-4.         {
-3.",Useful
"/*--------------------------------------------------------------------------
void plP_movphy()

Move to physical coordinates (x,y).
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plP_movphy()

Move to physical coordinates (x,y).
--------------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plP_draphy()

Draw to physical coordinates (x,y).
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plP_draphy()

Draw to physical coordinates (x,y).
--------------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plP_movwor()

Move to world coordinates (x,y).
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plP_movwor()

Move to world coordinates (x,y).
-----------------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plP_drawor()

Draw to world coordinates (x,y).
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plP_drawor()

Draw to world coordinates (x,y).
-----------------------------------------------------",Useful
"/*--------------------------------------------------------------------------
void plP_draphy_poly()

Draw polyline in physical coordinates.
Need to draw buffers in increments of (PL_MAXPOLY-1) since the
last point must be repeated (for solid lines).
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plP_draphy_poly()

Draw polyline in physical coordinates.
Need to draw buffers in increments of (PL_",Useful
"/*--------------------------------------------------------------------------
void plP_drawor_poly()

Draw polyline in world coordinates.
Need to draw buffers in increments of (PL_MAXPOLY-1) since the
last point must be repeated (for solid lines).
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plP_drawor_poly()

Draw polyline in world coordinates.
Need to draw buffers in increments of (PL_MAX",Useful
"/*--------------------------------------------------------------------------
void pllclp()

Draws a polyline within the clip limits.
Merely a front-end to plP_pllclp().
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void pllclp()

Draws a polyline within the clip limits.
Merely a front-end to plP_pllclp().
-------------",Useful
"/*--------------------------------------------------------------------------
void plP_pllclp()

Draws a polyline within the clip limits.

(AM)
Wanted to change the type of xclp, yclp to avoid overflows!
But that changes the type for the drawing routines too!
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plP_pllclp()

Draws a polyline within the clip limits.

(AM)
Wanted to change the type of xclp, yclp",Useful
/*First point of polyline.*/,"-10.         x1 = x[i];
-9.         x2 = x[i + 1];
-8.         y1 = y[i];
-7.         y2 = y[i + 1];
-6.         drawable = ( INSIDE( x1, y1 ) && INSIDE( x2, y2 ) );
-5.         if ( !drawable )
-4.             drawable = !plP_clipline( &x1, &y1, &x2, &y2",Useful
"/*Not first point.  Check if first point of this segment matches up to
previous point, and if so, add it to the current polyline buffer.*/","-8.             if ( iclp == 0 )
-7.             {
-6.                 xclp[iclp] = (short) x1;
-5.                 yclp[iclp] = (short) y1;
-4.                 iclp++;
-3.                 xclp[iclp] = (short) x2;
-2.                 yclp[iclp] = (short) ",Useful
/*Otherwise it's time to start a new polyline*/,"-6.             else if ( x1 == xclp[iclp] && y1 == yclp[iclp] )
-5.             {
-4.                 iclp++;
-3.                 xclp[iclp] = (short) x2;
-2.                 yclp[iclp] = (short) y2;
-1.             }

 /*Otherwise it's time to start a n",Useful
/*Handle remaining polyline*/,"-10.                     ( *draw )( xclp, yclp, iclp + 1 );
-9.                 iclp       = 0;
-8.                 xclp[iclp] = (short) x1;
-7.                 yclp[iclp] = (short) y1;
-6.                 iclp++;
-5.                 xclp[iclp] = (short) ",Useful
"/*--------------------------------------------------------------------------
int plP_clipline()

Get clipped endpoints
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
int plP_clipline()

Get clipped endpoints
---------------------------------------------------------------",Useful
"/*If both points are outside clip region with no hope of intersection,
return with an error*/","-6. int
-5. plP_clipline( PLINT *p_x1, PLINT *p_y1, PLINT *p_x2, PLINT *p_y2,
-4.               PLINT xmin, PLINT xmax, PLINT ymin, PLINT ymax )
-3. {
-2.     PLINT  t, dx, dy, flipx, flipy;
-1.     double dydx = 0, dxdy = 0;

 /*If both points are outsid",Useful
/*If one of the coordinates is not finite then return with an error*/,"-5.     if ( ( *p_x1 <= xmin && *p_x2 <= xmin ) ||
-4.          ( *p_x1 >= xmax && *p_x2 >= xmax ) ||
-3.          ( *p_y1 <= ymin && *p_y2 <= ymin ) ||
-2.          ( *p_y1 >= ymax && *p_y2 >= ymax ) )
-1.         return 1;

 /*If one of the coordinates ",Useful
"/*--------------------------------------------------------------------------
void genlin()

General line-drawing routine.  Takes line styles into account.
If only 2 points are in the polyline, it is more efficient to use
plP_line() rather than plP_polyline().
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void genlin()

General line-drawing routine.  Takes line styles into account.
If only 2 points are in the",Useful
/*Check for solid line*/,"-10. //--------------------------------------------------------------------------
-9. // void genlin()
-8. //
-7. // General line-drawing routine.  Takes line styles into account.
-6. // If only 2 points are in the polyline, it is more efficient to use
-5",Useful
"/*Right now dashed lines don't use polyline capability -- this
should be improved*/","-7.     if ( plsc->nms == 0 )
-6.     {
-5.         if ( npts == 2 )
-4.             plP_line( x, y );
-3.         else
-2.             plP_polyline( x, y, npts );
-1.     }

 /*Right now dashed lines don't use polyline capability -- this
should be improv",Useful
"/*Call escape sequence to draw dashed lines, only for drivers
that have this capability*/","-3.     else
-2.     {
-1.         PLINT i;

 /*Call escape sequence to draw dashed lines, only for drivers
that have this capability*/

1.         if ( plsc->dev_dash )
2.         {
3.             plsc->dev_npts = npts;
4.             plsc->dev_x    = x;",Useful
"/*--------------------------------------------------------------------------
void grdashline()

Draws a dashed line to the specified point from the previous one.
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void grdashline()

Draws a dashed line to the specified point from the previous one.
--------------------",Useful
/*Check if pattern needs to be restarted*/,"-9. static void
-8. grdashline( short *x, short *y )
-7. {
-6.     PLINT  nx, ny, nxp, nyp, incr, temp;
-5.     PLINT  modulo, dx, dy, i, xtmp, ytmp;
-4.     PLINT  tstep, pix_distance, j;
-3.     int    loop_x;
-2.     short  xl[2], yl[2];
-1.     double",Useful
/*Compute the timer step*/,"-10.         incr   = nxp;
-9.         loop_x = 0;
-8.     }
-7.     else
-6.     {
-5.         modulo = nxp;
-4.         incr   = nyp;
-3.         loop_x = 1;
-2.     }
-1.     temp = modulo / 2;

 /*Compute the timer step*/

1.     nxstep = nxp * plsc->",Useful
/*tstep is distance per pixel moved*/,"-5.     nxstep = nxp * plsc->umx;
-4.     nystep = nyp * plsc->umy;
-3.     tstep  = (PLINT) ( sqrt( nxstep * nxstep + nystep * nystep ) / modulo );
-2.     if ( tstep < 1 )
-1.         tstep = 1;

 /*tstep is distance per pixel moved*/

1.     i = 0;
2. ",Useful
/*Update line style variables when alarm goes off*/,"-10.             ytmp += pix_distance * dy;
-9.         }
-8.         if ( plsc->pendn != 0 )
-7.         {
-6.             xl[0] = (short) lastx;
-5.             yl[0] = (short) lasty;
-4.             xl[1] = (short) xtmp;
-3.             yl[1] = (short)",Useful
"/*--------------------------------------------------------------------------
interpolate_between()

Returns a pointer to an array of PLFLT values which interpolate in n steps
from a to b.
Note:
The returned array is allocated by the function and needs to be freed by
the function's caller.
If the return value is NULL, the allocation failed and it is up to the
caller to handle the error.
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
interpolate_between()

Returns a pointer to an array of PLFLT values which interpolate in n steps
from a ",Useful
"/*
This include file has the declaration for _NSGetArgc().  See below.
*/","
//  Maurice LeBrun			mjl@dino.ph.utexas.edu


 /*
This include file has the declaration for _NSGetArgc().  See below.
*/

111",Useful
/*Support functions*/,"-2. #include <crt_externs.h>
-1. #endif

 /*Support functions*/

1. static int  ParseOpt( int *, char ***, int *, char ***, PLOptionTable * );
2. static int  ProcessOpt( char *, PLOptionTable *, int *, char ***, int * );
3. static int  GetOptarg( char **,",Useful
/*Option handlers*/,"-5. static int  ParseOpt( int *, char ***, int *, char ***, PLOptionTable * );
-4. static int  ProcessOpt( char *, PLOptionTable *, int *, char ***, int * );
-3. static int  GetOptarg( char **, int *, char ***, int * );
-2. static void Help( void );
-1. s",Useful
/*Global variables*/,"-10. static int opt_plwindow( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-9. static int opt_portrait( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-8. static int opt_px( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-7. static int opt_py( PLCHAR_VECTOR, PLCHAR_VECTOR, ",Useful
/*Temporary buffer used for parsing*/,"-9. static PLCHAR_VECTOR program = NULL;
-8. static PLCHAR_VECTOR usage   = NULL;
-7. static int           mode_full;
-6. static int           mode_quiet;
-5. static int           mode_nodelete;
-4. static int           mode_showall;
-3. static int       ",Useful
"/*--------------------------------------------------------------------------
!
! PLPLOT options data structure definition.
!
! The table is defined as follows
!
! typedef struct {
!     PLCHAR_VECTOR opt;
!     int  (*handler)	(PLCHAR_VECTOR, PLCHAR_VECTOR, void *);
!     void *client_data;
!     void *var;
!     long mode;
!     PLCHAR_VECTOR syntax;
!     PLCHAR_VECTOR desc;
! } PLOptionTable;
!
! where each entry has the following meaning:
!
! opt		option string
! handler	pointer to function for processing the option and
!		 (optionally) its argument
! client_data	pointer to data that gets passed to (*handler)
! var		address of variable to set based on ""mode""
! mode		governs handling of option (see below)
! syntax	short syntax description
! desc		long syntax description
!
! The syntax and or desc strings can be NULL if the option is never to be
! described.  Usually this is only used for obsolete arguments; those we
! just wish to hide from normal use are better made invisible (which are
! made visible by either specifying -showall first or PL_PARSE_SHOWALL).
!
! The mode bits are:
!
! PL_OPT_ARG		Option has an argument
! PL_OPT_NODELETE	Don't delete after processing
! PL_OPT_INVISIBLE	Make invisible (usually for debugging)
! PL_OPT_DISABLED	Ignore this option
!
! The following mode bits cause the option to be processed as specified:
!
! PL_OPT_FUNC		Call function handler (opt, opt_arg)
! PL_OPT_BOOL		Set *var=1
! PL_OPT_INT		Set *var=atoi(opt_arg)
! PL_OPT_FLOAT		Set *var=atof(opt_arg)
! PL_OPT_STRING	Set *var=opt_arg
!
! where opt points to the option string and opt_arg points to the
! argument string.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
/*Turns on invisible options*/,"-10. //! PL_OPT_INT		Set *var=atoi(opt_arg)
-9. //! PL_OPT_FLOAT		Set *var=atof(opt_arg)
-8. //! PL_OPT_STRING	Set *var=opt_arg
-7. //!
-6. //! where opt points to the option string and opt_arg points to the
-5. //! argument string.
-4. //!
-3. //--------",Useful
/*Help*/,"-3. static int  ParseOpt( int *, char ***, int *, char ***, PLOptionTable * );
-2. static int  ProcessOpt( char *, PLOptionTable *, int *, char ***, int * );
-1. static int  GetOptarg( char **, int *, char ***, int * );
static void Help( void );

 /*Help*",Useful
/*Version*/,"-10. //  PLplot is distributed in the hope that it will be useful,
-9. //  but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. //  GNU Library General Public License for ",Useful
/*Be more verbose than usual*/,"-8.         opt_v,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-v"",
-3.         ""Print out the PLplot library version number""
-2.     },
-1.     {

 /*Be more verbose than usual*/

1.         opt_verbose,
2.         NULL,
3. ",Useful
/*Print debugging info*/,"-8.         opt_verbose,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-verbose"",
-3.         ""Be more verbose than usual""
-2.     },
-1.     {

 /*Print debugging info*/

1.         opt_debug,
2.         NULL,
3.         NULL,",Useful
/*Enable driver-specific hack(s)*/,"-8.         opt_debug,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-debug"",
-3.         ""Print debugging info (implies -verbose)""
-2.     },
-1.     {

 /*Enable driver-specific hack(s)*/

1.         opt_hack,
2.         NULL",Useful
/*Output device*/,"-8.         opt_hack,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_INVISIBLE,
-4.         ""-hack"",
-3.         ""Enable driver-specific hack(s)""
-2.     },
-1.     {

 /*Output device*/

1.         opt_dev,
2.         NULL,
3.      ",Useful
/*Output filename*/,"-8.         opt_dev,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-dev name"",
-3.         ""Output device name""
-2.     },
-1.     {

 /*Output filename*/

1.         opt_o,
2.         NULL,
3.         NULL,
4.    ",Useful
/*X server*/,"-8.         opt_o,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-o name"",
-3.         ""Output filename""
-2.     },
-1.     {

 /*X server*/

1.         opt_o,
2.         NULL,
3.         NULL,
4.         PL_OPT_FU",Useful
/*Plots per page in x*/,"-8.         opt_o,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-display name"",
-3.         ""X server to contact""
-2.     },
-1.     {

 /*Plots per page in x*/

1.         opt_px,
2.         NULL,
3.         NULL",Useful
/*Plots per page in y*/,"-8.         opt_px,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-px number"",
-3.         ""Plots per page in x""
-2.     },
-1.     {

 /*Plots per page in y*/

1.         opt_py,
2.         NULL,
3.         NULL,
",Useful
/*Geometry*/,"-8.         opt_py,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-py number"",
-3.         ""Plots per page in y""
-2.     },
-1.     {

 /*Geometry*/

1.         opt_geo,
2.         NULL,
3.         NULL,
4.        ",Useful
/*Geometry (alias)*/,"-8.         opt_geo,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-geometry geom"",
-3.         ""Window size/position specified as in X, e.g., 400x300, 400x300-100+200, +100-200, etc.""
-2.     },
-1.     {

 /*Geom",Useful
/*Plot window*/,"-8.         opt_geo,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-geo geom"",
-3.         ""Window size/position specified as in X, e.g., 400x300, 400x300-100+200, +100-200, etc.""
-2.     },
-1. ",Useful
/*Margin*/,"-8.         opt_wplt,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-wplt xl,yl,xr,yr"",
-3.         ""Relative coordinates [0-1] of window into plot""
-2.     },
-1.     {

 /*Margin*/

1.         opt_mar,
2.        ",Useful
/*Aspect ratio*/,"-8.         opt_mar,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-mar margin"",
-3.         ""Margin space in relative coordinates (0 to 0.5, def 0)""
-2.     },
-1.     {

 /*Aspect ratio*/

1.         opt_a,
2.   ",Useful
/*Justification in x*/,"-8.         opt_a,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-a aspect"",
-3.         ""Page aspect ratio (def: same as output device)""
-2.     },
-1.     {

 /*Justification in x*/

1.         opt_jx,
2.        ",Useful
/*Justification in y*/,"-8.         opt_jx,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-jx justx"",
-3.         ""Page justification in x (-0.5 to 0.5, def 0)""
-2.     },
-1.     {

 /*Justification in y*/

1.         opt_jy,
2.         ",Useful
/*Orientation*/,"-8.         opt_jy,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-jy justy"",
-3.         ""Page justification in y (-0.5 to 0.5, def 0)""
-2.     },
-1.     {

 /*Orientation*/

1.         opt_ori,
2.         NULL,
",Useful
/*floating aspect ratio*/,"-8.         opt_ori,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-ori orient"",
-3.         ""Plot orientation (0,1,2,3=landscape,portrait,seascape,upside-down)""
-2.     },
-1.     {

 /*floating aspect ratio*/

1.",Useful
/*floating aspect ratio*/,"-8.         opt_ori,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-ori orient"",
-3.         ""Plot orientation (0,1,2,3=landscape,portrait,seascape,upside-down)""
-2.     },
-1.     {

 /*floating aspect ratio*/

1.",Useful
/*Pen width*/,"-8.         opt_portrait,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-portrait"",
-3.         ""Sets portrait mode (both orientation and aspect ratio)""
-2.     },
-1.     {

 /*Pen width*/

1.         opt_width,
2.         NUL",Useful
/*Background color*/,"-8.         opt_width,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-width width"",
-3.         ""Sets pen width (0 <= width)""
-2.     },
-1.     {

 /*Background color*/

1.         opt_bg,
2.         NULL,
3.     ",Useful
/*Allocated colors in cmap 0*/,"-8.         opt_bg,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-bg color"",
-3.         ""Background color (e.g., FF0000=opaque red, 0000FF_0.1=blue with alpha of 0.1)""
-2.     },
-1.     {

 /*Allocated colors in",Useful
/*Allocated colors in cmap 1*/,"-8.         opt_ncol0,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-ncol0 n"",
-3.         ""Number of colors to allocate in cmap 0 (upper bound)""
-2.     },
-1.     {

 /*Allocated colors in cmap 1*/

1.         o",Useful
/*Familying on switch*/,"-8.         opt_ncol1,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-ncol1 n"",
-3.         ""Number of colors to allocate in cmap 1 (upper bound)""
-2.     },
-1.     {

 /*Familying on switch*/

1.         opt_fam,",Useful
/*Family file size*/,"-8.         opt_fam,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-fam"",
-3.         ""Create a family of output files""
-2.     },
-1.     {

 /*Family file size*/

1.         opt_fsiz,
2.         NULL,
3.         NULL,
4.     ",Useful
/*Family starting member*/,"-8.         opt_fsiz,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-fsiz size[kKmMgG]"",
-3.         ""Output family file size (e.g. -fsiz 0.5G, def MB)""
-2.     },
-1.     {

 /*Family starting member*/

1.        ",Useful
/*Family member increment*/,"-8.         opt_fbeg,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-fbeg number"",
-3.         ""First family member number on output""
-2.     },
-1.     {

 /*Family member increment*/

1.         opt_finc,
2.     ",Useful
/*Family member min field width*/,"-8.         opt_finc,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-finc number"",
-3.         ""Increment between family members""
-2.     },
-1.     {

 /*Family member min field width*/

1.         opt_fflen,
2.  ",Useful
/*Do not use pixmaps*/,"-8.         opt_fflen,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-fflen length"",
-3.         ""Family member number minimum field width""
-2.     },
-1.     {

 /*Do not use pixmaps*/

1.         opt_nopixmap,
2.",Useful
/*Double buffering on switch*/,"-8.         opt_nopixmap,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-nopixmap"",
-3.         ""Don't use pixmaps in X-based drivers""
-2.     },
-1.     {

 /*Double buffering on switch*/

1.         opt_db,
2.         NULL,
3",Useful
/*Page pause off switch*/,"-8.         opt_db,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-db"",
-3.         ""Double buffer X window output""
-2.     },
-1.     {

 /*Page pause off switch*/

1.         opt_np,
2.         NULL,
3.         NULL,
4.      ",Useful
/*# bytes sent before flushing output*/,"-8.         opt_np,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-np"",
-3.         ""No pause between pages""
-2.     },
-1.     {

 /*# bytes sent before flushing output*/

1.         opt_bufmax,
2.         NULL,
3.         NUL",Useful
/*Main window name of server*/,"-8.         opt_bufmax,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-bufmax"",
-3.         ""bytes sent before flushing output""
-2.     },
-1.     {

 /*Main window name of server*/

1.         o",Useful
/*PLplot server name*/,"-8.         opt_server_name,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-server_name name"",
-3.         ""Main window name of PLplot server (tk driver)""
-2.     },
-1.     {

 /*PLplot server name*/

1.         o",Useful
/*PLplot container window name*/,"-8.         opt_plserver,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-plserver name"",
-3.         ""Invoked name of PLplot server (tk driver)""
-2.     },
-1.     {

 /*PLplot container window n",Useful
/*Additional directory(s) to autoload*/,"-8.         opt_plwindow,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-plwindow name"",
-3.         ""Name of PLplot container window (tk driver)""
-2.     },
-1.     {

 /*Additional directory(s)",Useful
/*-file option for plserver*/,"-8.         opt_auto_path,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-auto_path dir"",
-3.         ""Additional directory(s) to autoload (tk driver)""
-2.     },
-1.     {

 /*-file option for p",Useful
/*Dots per inch*/,"-8.         opt_tk_file,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG | PL_OPT_INVISIBLE,
-4.         ""-tk_file file"",
-3.         ""file for plserver (tk driver)""
-2.     },
-1.     {

 /*Dots per inch*/

1.         opt_dpi,
2.",Useful
/*compression*/,"-10. static int opt_a( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-9. static int opt_auto_path( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-8. static int opt_bg( PLCHAR_VECTOR, PLCHAR_VECTOR, void * );
-7. static int opt_bufmax( PLCHAR_VECTOR, PLCHAR_VECTOR, vo",Useful
/*Driver specific options*/,"-10.     {
-9.         ""eofill"",
-8.         opt_eofill,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC,
-4.         ""-eofill"",
-3.         ""For the case where the boundary of the filled region is self-intersecting, use the even-odd fill rule",Useful
/*Metafile output option*/,"-8.         opt_drvopt,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_ARG | PL_OPT_FUNC,
-4.         ""-drvopt option[=value][,option[=value]]*"",
-3.         ""Driver specific options""
-2.     },
-1.     {

 /*Metafile output option*/

1.         o",Useful
/*Metafile output option*/,"-8.         opt_drvopt,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_ARG | PL_OPT_FUNC,
-4.         ""-drvopt option[=value][,option[=value]]*"",
-3.         ""Driver specific options""
-2.     },
-1.     {

 /*Metafile output option*/

1.         o",Useful
/*option*/,"-10. //  Copyright (C) 2009-2011 Hazen Babcock
-9. //  Copyright (C) 2009-2010 Hezekiah M. Carty
-8. //  Copyright (C) 2015 Jim Dishaw
-7. //  Copyright (C) 2017 Phil Rosenberg
-6. //
-5. //  This file is part of PLplot.
-4. //
-3. //  PLplot is free soft",Useful
/*handler*/,"-10. //                      All Rights Reserved
-9. //
-8. //  The full permission notice is given in the PLplot documentation.
-7. //
-6. //--------------------------------------------------------------------------
-5. //
-4. //! @file
-3. //!  This fil",Useful
/*client data*/,"-10.         opt_mfi,
-9.         NULL,
-8.         NULL,
-7.         PL_OPT_ARG | PL_OPT_FUNC,
-6.         ""-mfi PLplot metafile name"",
-5.         ""Read the specified PLplot metafile""
-4.     },
-3.     {

 /*client data*/

111",Useful
/*address of variable to set*/,"-10. //!     PLCHAR_VECTOR syntax;
-9. //!     PLCHAR_VECTOR desc;
-8. //! } PLOptionTable;
-7. //!
-6. //! where each entry has the following meaning:
-5. //!
-4. //! opt		option string
-3. //! handler	pointer to function for processing the option and
-2",Useful
/*mode flag*/,"-10.         NULL,
-9.         PL_OPT_ARG | PL_OPT_FUNC,
-8.         ""-mfi PLplot metafile name"",
-7.         ""Read the specified PLplot metafile""
-6.     },
-5.     {

 /*mode flag*/

111",Useful
/*short syntax*/,"-10. //! } PLOptionTable;
-9. //!
-8. //! where each entry has the following meaning:
-7. //!
-6. //! opt		option string
-5. //! handler	pointer to function for processing the option and
-4. //!		 (optionally) its argument
-3. //! client_data	pointer to d",Useful
/*long syntax*/,"-10. //!
-9. //! where each entry has the following meaning:
-8. //!
-7. //! opt		option string
-6. //! handler	pointer to function for processing the option and
-5. //!		 (optionally) its argument
-4. //! client_data	pointer to data that gets passed to (",Useful
"/*--------------------------------------------------------------------------
! @struct PLOptionInfo
!
! Array of option tables and associated info.
!
! The user may merge up to PL_MAX_OPT_TABLES custom option tables (of type
! PLOptionTable) with the internal one.  The resulting treatment is simple,
! powerful, and robust.  The tables are parsed in the order of last added
! first, to the internal table last.  If multiple options of the same name
! occur, only the first parsed is ""seen"", thus, the user can easily
! override any PLplot internal option merely by providing the same option.
! This same precedence is followed when printing help and usage messages,
! with each set of options given separately.  See example usage in
! plrender.c.
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
/*The structure that hold the driver specific command line options*/,"-10.     plplot_notes
-9. };
-8. #define PL_MAX_OPT_TABLES    10
-7. PLOptionInfo ploption_info[PL_MAX_OPT_TABLES] = {
-6.     {
-5.         ploption_table,
-4.         ""PLplot options"",
-3.         plplot_notes
-2.     }
-1. };

 /*The structure that hol",Useful
/*the variable where opt_drvopt() stores the driver specific command line options*/,"-6. typedef struct DrvOptCmd
-5. {
-4.     char             *option;
-3.     char             *value;
-2.     struct DrvOptCmd *next;
-1. } DrvOptCmd;

 /*the variable where opt_drvopt() stores the driver specific command line options*/

1. static DrvOptC",Useful
"/*--------------------------------------------------------------------------
plClearOpts()

! Clear internal option table info structure.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
plResetOpts()

! Reset internal option table info structure.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
plparseopts()

! Process options list using current ploptions_info structure.
! An error in parsing the argument list causes a program exit if
! mode_full is set, otherwise the function returns with an error.
!
! @param p_argc pointer to a value that ONLY keeps track of number of arguments after processing.
! @param argv ?
! @param mode ?
!
! @returns 0 if successful.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
/*Initialize*/,"-10.         ""-compression num"",
-9.         ""Sets compression level in supporting devices""
-8.     },
-7.     {
-6.         ""cmap0"",
-5.         opt_cmap0,
-4.         NULL,
-3.         NULL,
-2.         PL_OPT_ARG | PL_OPT_FUNC,
-1.         ""-cmap0 file",Useful
"/*Just in case plparseopts has been called previously (e.g., with PL_PARSE_NODELETE).*/","-2.     if ( !mode_noprogram )
-1.     {

 /*Just in case plparseopts has been called previously (e.g., with PL_PARSE_NODELETE).*/

1.         if ( plsc->program )
2.             free_mem( plsc->program );",Useful
"/*If plparseopts is not called again, this is freed in plend1.*/","-2.         if ( plsc->program )
-1.             free_mem( plsc->program );

 /*If plparseopts is not called again, this is freed in plend1.*/

1.         plsc->program = plstrdup( argv[0] );
2.         program       = (PLCHAR_VECTOR) plsc->program;
3.   ",Useful
/*Check option table for option*/,"-2.             for ( i = tables - 1; i >= 0; i-- )
-1.             {

 /*Check option table for option*/

1.                 status = ParseOpt( &myargc, &argv, p_argc, &argsave,
2.                     ploption_info[i].options );
3.                 if ( !",Useful
"/*No match.  Keep going if mode_skip is set, otherwise abort if
fully parsing, else return without error.*/","-2.         if ( status == -1 )
-1.         {

 /*No match.  Keep going if mode_skip is set, otherwise abort if
fully parsing, else return without error.*/

1.             status = 0;
2.             if ( mode_skip )
3.             {
4.                 if ",Useful
/*Informational option encountered (-h or -v)*/,"-10.             {
-9.                 fprintf( stderr, ""\nBad command line option \""%s\""\n"", argv[0] );
-8.                 plOptUsage();
-7.             }
-6.             if ( mode_full )
-5.                 exit( 1 );
-4.             break;
-3.        ",Useful
/*Compress and NULL-terminate argv*/,"-3.             exit( 0 );
-2.         }
-1.     }

 /*Compress and NULL-terminate argv*/

1.     if ( !mode_nodelete )
2.     {
3.         for ( i = 0; i < myargc; i++ )
4.             *argsave++ = *argv++;
5.         if ( argsave < argend )
6.         {",Useful
"/*
Modify the global argc variable to match the shortened argv.
The global argc and argv must be kept consistent so that future
users of them (e.g. libraries loaded later with a device driver)
will not try to dereference the null pointer at the end of the
shortened argv array.
*/","
//  Maurice LeBrun			mjl@dino.ph.utexas.edu


 /*
Modify the global argc variable to match the shortened argv.
The global argc and argv must be kept consistent so that future
users of them (e.g. libraries loaded later with a device driver)
will not try to dereference the null pointer at the end of the
shortened argv array.
*/

111",Useful
"/*--------------------------------------------------------------------------
ParseOpt()

! Parses & determines appropriate action for input flag.
!
! @param p_myargc ?
! @param p_argv ?
! @param p_argc pointer to a value that ONLY keeps track of number of arguments after processing.
! @param p_argsave ?
! @param option_table ?
!
! @returns ?
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
ProcessOpt()

! Process option (and argument if applicable).
!
! @param opt ?
! @param tab ?
! @param p_myargc ?
! @param p_argv ?
! @param p_argc pointer to a value that ONLY keeps track of number of arguments after processing.
!
! @returns 0 if successful.
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*Skip -bg argument checking since, for example, ""-ffffff"" is
valid but would be considered invalid by the crude test at
the end of the if.  Instead, -bg always consumes the next
argument (which exists according to the test above) in any
form, and that argument is checked for validity by the
opt_bg routine.*/","-4.         result = 1;
-3.     if ( !result )
-2.     {
-1.         ( *p_argv )++;

 /*Skip -bg argument checking since, for example, ""-ffffff"" is
valid but would be considered invalid by the crude test at
the end of the if.  Instead, -bg always consumes",Useful
"/*--------------------------------------------------------------------------
plOptUsage()

! Print usage & syntax message.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
Syntax()

! Print short syntax message.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
/*Loop over all options tables*/,"-5.         if ( *argv == NULL || *argv[0] == '\0' )
-4.             continue;
-3.         if ( ( !mode_nodash && !strcmp( *argv, ""-debug"" ) ) || ( mode_nodash && !strcmp( *argv, ""debug"" ) ) )
-2.         {

 /*Loop over all options tables*/

1.          ",Useful
"/*--------------------------------------------------------------------------
Help()

! Print long help message.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
/*Usage line*/,"-10.     FILE          *outfile = stderr;
-9. #ifdef HAVE_POPEN
-8.     FILE *pager = NULL;
-7.     if ( getenv( ""PAGER"" ) != NULL )
-6.         pager = (FILE *) popen( ""$PAGER"", ""w"" );
-5.     if ( pager == NULL )
-4.         pager = (FILE *) popen( ""mor",Useful
"/*--------------------------------------------------------------------------
plParseDrvOpts

! Parse driver specific options
!
! @param acc_opt ?
!
! @returns 0 if successful.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
plHelpDrvOpts

! Give driver specific help
!
! @param acc_opt ?
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
tidyDrvOpts

! Tidy up and free memory associated with driver options
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*Free additional DrvOptCmd variables -
first entry in list is a static global variable*/","-10. plP_FreeDrvOpts()
-9. {
-8.     DrvOptCmd *drvp, *drvpl;
-7.     drvp = &drv_opt;
-6.     do
-5.     {
-4.         drvpl = drvp;
-3.         drvp  = drvpl->next;
-2.         free( drvpl->option );
-1.         free( drvpl->value );

 /*Free additional",Useful
/*initialize drv_opt if it's used again*/,"-3.         if ( drvpl != &drv_opt )
-2.             free( drvpl );
-1.     } while ( drvp != NULL );

 /*initialize drv_opt if it's used again*/

1.     drv_opt.option = NULL;
2.     drv_opt.value  = NULL;
3.     drv_opt.next   = NULL;
4. }",Useful
"/*--------------------------------------------------------------------------
Option handlers
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_h()

! Performs appropriate action for option ""h"":
! Issues help message
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 2.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_v()

! Performs appropriate action for option ""v"":
! Issues version message
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 2.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_verbose()

! Performs appropriate action for option ""verbose"":
! Turn on verbosity flag
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_debug()

! Performs appropriate action for option ""debug"":
! Turn on debugging flag
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_hack()

! Performs appropriate action for option ""hack"":
! Enables driver-specific hack(s)
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_dev()

! Performs appropriate action for option ""dev"":
! Sets output device keyword
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg The name of the output device.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_o()

! Performs appropriate action for option ""o"":
! Sets output file name
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg The file family name.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_mar()

! Performs appropriate action for option ""mar"":
! Sets relative margin width
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Plot margin width.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_a()

! Performs appropriate action for option ""a"":
! Sets plot aspect ratio on page
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Plot aspect ratio.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_jx()

! Performs appropriate action for option ""jx"":
! Sets relative justification in x
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Plot relative justification in x(?)
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_jy()

! Performs appropriate action for option ""jy"":
! Sets relative justification in y
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Plot relative justification in y(?)
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_ori()

! Performs appropriate action for option ""ori"":
! Sets orientation
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Plot orientation.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_freeaspect()

! Performs appropriate action for option ""freeaspect"":
! Allow aspect ratio to adjust to orientation swaps.
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_portrait()

! Performs appropriate action for option ""portrait"":
! Set portrait mode.  If plsc->portrait = 1, then the orientation for certain
! drivers is changed by 90 deg to portrait orientation from the default
! landscape orientation used by PLplot while the aspect ratio allowed to
! adjust using freeaspect.
! N.B. the driver list where this flag is honored is currently limited
! to psc, ps, and pstex.  A 90 deg rotation is just not
! appropriate for certain other drivers.  These drivers where portrait
! mode is ignored include display drivers (e.g., xwin, tk), drivers
! which are subequently going to be transformed to another form
! (e.g., meta), or drivers which are normally used for web
! publishing (e.g., png, jpeg).  That said, the case is not entirely clear
! for all drivers so the list of drivers where portrait mode is honored
! may increase in the future. To add to the list simply copy the small
! bit of code from  ps.c that has to do with pls->portrait to the
! appropriate driver file.
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_width()

! Performs appropriate action for option ""width"":
! Sets pen width
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Plot pen width.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_bg()

! Performs appropriate action for option ""bg"":
! Sets background color (rgb represented in hex on command line) and alpha
! (represented as floating point on the command line with underscore
! delimiter), e.g.,
! -bg ff0000 (set background to red with an alpha value of MAX_PLFLT_ALPHA ==> opaque)
! -bg ff0000_0.1 (set background to red with an alpha value of 0.1)
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Background RGB color in hex (in 3-digit of 6-digit format)
! followed by optional combination of ""_"" + floating-point alpha value.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*If no delimiter, then assume opaque.*/","-4.         alpha_field++;
-3.     }
-2.     else
-1.     {

 /*If no delimiter, then assume opaque.*/

1.         alpha_field = ""MAX_PLFLT_ALPHA"";
2.     }",Useful
/*Parse color_field*/,"-4.         alpha_field = ""MAX_PLFLT_ALPHA"";
-3.     }

 /*Parse color_field*/

111",Useful
"/*Find color_field without prefix where that prefix consists of optional whitespace followed
by optional sign followed by optional 0x or 0X.*/","-5.         *endptr = '\0';
-4.         fprintf( stderr, ""derived color_field = %s\n"", color_field );
-3.         fprintf( stderr, ""derived bgcolor = %#lx\n"", bgcolor );
-2.     }

 /*Find color_field without prefix where that prefix consists of optional ",Useful
"/*--------------------------------------------------------------------------
opt_ncol0()

! Performs appropriate action for option ""ncol0"":
! Sets number of colors to allocate in cmap 0 (upper bound).
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Number of color map 0 colors.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_ncol1()

! Performs appropriate action for option ""ncol1"":
! Sets number of colors to allocate in cmap 1 (upper bound).
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Number of color map 1 colors.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_wplt()

! Performs appropriate action for option ""wplt"":
! Sets (zoom) window into plot (e.g. ""0,0,0.5,0.5"")
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Zoom setting.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_drvopt()

! Get driver specific options in the form <option[=value]>[,option[=value]]*
! If ""value"" is not specified, it defaults to ""1"".
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg The driver specific option.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*it should not be release, because of familying*/","-10.         {
-9.         case ',':
-8.             if ( fl )
-7.                 fl = 0;
-6.             else
-5.             {
-4.                 value[0] = '1';
-3.                 value[1] = '\0';
-2.             }
-1.             *tt          = '\0",Useful
/*don't release*/,"-10.         case ',':
-9.             if ( fl )
-8.                 fl = 0;
-7.             else
-6.             {
-5.                 value[0] = '1';
-4.                 value[1] = '\0';
-3.             }
-2.             *tt          = '\0'; tt = option",Useful
/*don't release*/,"-10.         case ',':
-9.             if ( fl )
-8.                 fl = 0;
-7.             else
-6.             {
-5.                 value[0] = '1';
-4.                 value[1] = '\0';
-3.             }
-2.             *tt          = '\0'; tt = option",Useful
/*don't release*/,"-10.         case ',':
-9.             if ( fl )
-8.                 fl = 0;
-7.             else
-6.             {
-5.                 value[0] = '1';
-4.                 value[1] = '\0';
-3.             }
-2.             *tt          = '\0'; tt = option",Useful
/*don't release*/,"-10.         case ',':
-9.             if ( fl )
-8.                 fl = 0;
-7.             else
-6.             {
-5.                 value[0] = '1';
-4.                 value[1] = '\0';
-3.             }
-2.             *tt          = '\0'; tt = option",Useful
"/*--------------------------------------------------------------------------
opt_fam()

! Performs appropriate action for option ""fam"":
! Enables family output files
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_fsiz()

! Performs appropriate action for option ""fsiz"":
! Sets size of a family member file (may be somewhat larger since eof must
! occur at a page break).  Also turns on familying.  Example usage:
!
!	-fsiz 5M	(5 MB)
!	-fsiz 300K	(300 KB)
!	-fsiz .3M	(same)
!	-fsiz .5G	(half a GB)
!
! Note case of the trailing suffix doesn't matter.
! If no suffix, defaults to MB.
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Family size setting.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
/*Interpret optional suffix*/,"-10. static int
-9. opt_fsiz( PLCHAR_VECTOR PL_UNUSED( opt ), PLCHAR_VECTOR opt_arg, void * PL_UNUSED( client_data ) )
-8. {
-7.     PLINT  bytemax;
-6.     size_t len        = strlen( opt_arg );
-5.     char   lastchar   = opt_arg[len - 1];
-4.     PLFLT",Useful
"/*--------------------------------------------------------------------------
opt_fbeg()

! Performs appropriate action for option ""fbeg"":
! Starts with the specified family member number.
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Number of the first plot.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_finc()

! Performs appropriate action for option ""finc"":
! Specify increment between family members.
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Amount to increment the plot number between plots.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_fflen()

! Performs appropriate action for option ""fflen"":
! Specify minimum field length for family member number.
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Size of the family number field (e.g. ""1"", ""01"", ""001"" ?)
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_np()

! Performs appropriate action for option ""np"":
! Disables pause between pages
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_nopixmap()

! Performs appropriate action for option ""nopixmap"":
! Disables use of pixmaps in X drivers
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_db()

! Performs appropriate action for option ""db"":
! Double buffer X output (update only done on eop or Expose)
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_bufmax()

! Performs appropriate action for option ""bufmax"":
! Sets size of data buffer for tk driver
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Size of the data buffer for the tk driver.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_server_name()

! Performs appropriate action for option ""server_name"":
! Sets main window name of server (Tcl/TK driver only)
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg The name of the main window.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_plserver()

! Performs appropriate action for option ""plserver"":
! Sets name to use when invoking server (Tcl/TK driver only)
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Name of Tcl/TK server (?).
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_plwindow()

! Performs appropriate action for option ""plwindow"":
! Sets PLplot window name
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Name of the window.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_auto_path()

! Performs appropriate action for option ""auto_path"":
! Sets additional directories to autoload
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Additional directories to add the the load path (?).
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_px()

! Performs appropriate action for option ""px"":
! Set packing in x
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg X packing (?).
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_py()

! Performs appropriate action for option ""py"":
! Set packing in y
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Y packing (?).
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_geo()

! Performs appropriate action for option ""geo"": Set geometry for
! output window, i.e., ""-geometry WIDTHxHEIGHT+XOFF+YOFF"" where
! WIDTHxHEIGHT, +XOFF+YOFF, or both must be present, and +XOFF+YOFF
! stands for one of the four combinations +XOFF+YOFF, +XOFF-YOFF,
! -XOFF+YOFF, and -XOFF-YOFF.  Some examples are the following:
! -geometry 400x300, -geometry -100+200, and -geometry 400x300-100+200.
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Plot geometry descriptor.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
/*The TK driver uses the geometry string directly*/,"-6. static int
-5. opt_geo( PLCHAR_VECTOR PL_UNUSED( opt ), PLCHAR_VECTOR opt_arg, void * PL_UNUSED( client_data ) )
-4. {
-3.     int   numargs;
-2.     PLFLT xdpi = 0., ydpi = 0.;
-1.     PLINT xwid, ywid, xoff, yoff;

 /*The TK driver uses the geometry",Useful
"/*--------------------------------------------------------------------------
opt_tk_file()

! File name for plserver tk_file option
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Tk file name.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_dpi()

! Performs appropriate action for option ""dpi"":
! Set dpi resolution for output device
!   e.g.,  ""-dpi 600x300"", will set X dpi to 600 and Y dpi to 300
!              or
!   e.g., ""-dpi 1200""
! Will set both X and Y dpi to 1200 dpi
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg DPI descriptor string.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_dev_compression()

! Sets device compression
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Device compression (?).
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_cmap0()

! Sets color table 0 based on a cmap0.pal file.
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Name of color map 0 .pal file.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_cmap1()

! Sets color table 1 based on a cmap1.pal file.
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Name of a color map 1 .pal file.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_locale()

! Make PLplot portable to all LC_NUMERIC locales.
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_eofill()

! For the case where the boundary of the filled region is
! self-intersecting, use the even-odd fill rule rather than the
! default nonzero fill rule.
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_mfo()

! Sets the filename of the PLplot metafile that will be written.
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg  Output PLplot metafile.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_mfi()

! Sets the filename of the PLplot metafile that will be read.
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Input PLplot metafile.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
/*Data declarations for stripcharts.*/,"-10. // GNU Library General Public License for more details.
-9. //
-8. // You should have received a copy of the GNU Library General Public License
-7. // along with PLplot; if not, write to the Free Software
-6. // Foundation, Inc., 51 Franklin Street, ",Useful
/*FIXME - some redundancy might exist*/,"-4. #define PEN    4
-3. typedef struct
-2. {
-1.     PLFLT xmin, xmax, ymin, ymax, xjump, xlen;

 /*FIXME - some redundancy might exist*/

1.     char  *xspec, *yspec, *labx, *laby, *labtop;
2.     PLINT y_ascl, acc, colbox, collab;
3.     PLFLT xlpos, y",Useful
/*strip id number*/,"-8.     char  *xspec, *yspec, *labx, *laby, *labtop;
-7.     PLINT y_ascl, acc, colbox, collab;
-6.     PLFLT xlpos, ylpos;
-5.     PLFLT *x[PEN], *y[PEN];
-4.     PLINT npts[PEN], nptsmax[PEN];
-3.     PLINT colline[PEN], styline[PEN];
-2.     char  *leg",Useful
/*Max allowed*/,"-9.     char  *xspec, *yspec, *labx, *laby, *labtop;
-8.     PLINT y_ascl, acc, colbox, collab;
-7.     PLFLT xlpos, ylpos;
-6.     PLFLT *x[PEN], *y[PEN];
-5.     PLINT npts[PEN], nptsmax[PEN];
-4.     PLINT colline[PEN], styline[PEN];
-3.     char  *leg",Useful
/*Array of pointers*/,"-10.     char  *xspec, *yspec, *labx, *laby, *labtop;
-9.     PLINT y_ascl, acc, colbox, collab;
-8.     PLFLT xlpos, ylpos;
-7.     PLFLT *x[PEN], *y[PEN];
-6.     PLINT npts[PEN], nptsmax[PEN];
-5.     PLINT colline[PEN], styline[PEN];
-4.     char  *le",Useful
/*current strip chart*/,"-10.     PLINT y_ascl, acc, colbox, collab;
-9.     PLFLT xlpos, ylpos;
-8.     PLFLT *x[PEN], *y[PEN];
-7.     PLINT npts[PEN], nptsmax[PEN];
-6.     PLINT colline[PEN], styline[PEN];
-5.     char  *legline[PEN];
-4. } PLStrip;

 /*current strip chart*/
",Useful
/*Generates a complete stripchart plot.*/,"-10.     PLFLT xlpos, ylpos;
-9.     PLFLT *x[PEN], *y[PEN];
-8.     PLINT npts[PEN], nptsmax[PEN];
-7.     PLINT colline[PEN], styline[PEN];
-6.     char  *legline[PEN];
-5. } PLStrip;

 /*Generates a complete stripchart plot.*/

1. static void
2. plstri",Useful
/*draw legend*/,"-2. static void
-1. plstrip_gen( PLStrip *strip );

 /*draw legend*/

1. static void
2. plstrip_legend( PLStrip *strip, int flag );",Useful
"/*--------------------------------------------------------------------------
plstripc

Create 1d stripchart.
--------------------------------------------------------------------------*/","-2. static void
-1. plstrip_legend( PLStrip *strip, int flag );

 /*--------------------------------------------------------------------------
plstripc

Create 1d stripchart.
--------------------------------------------------------------------------*/

11",Useful
/*Get a free strip id and allocate it*/,"-10. void
-9. c_plstripc( PLINT *id, PLCHAR_VECTOR xspec, PLCHAR_VECTOR yspec,
-8.             PLFLT xmin, PLFLT xmax, PLFLT xjump, PLFLT ymin, PLFLT ymax,
-7.             PLFLT xlpos, PLFLT ylpos,
-6.             PLINT y_ascl, PLINT acc,
-5.             ",Useful
/*legend position [0..1]*/,"-10.         stripc->x[i]       = (PLFLT *) malloc( (size_t) sizeof ( PLFLT ) * (size_t) ( stripc->nptsmax[i] ) );
-9.         stripc->y[i]       = (PLFLT *) malloc( (size_t) sizeof ( PLFLT ) * (size_t) ( stripc->nptsmax[i] ) );
-8.         if ( stripc->x",Useful
/*initial bounding box*/,"-1.     stripc->ylpos  = ylpos;

 /*initial bounding box*/

1.     stripc->xmax   = xmax;
2.     stripc->ymin   = ymin;
3.     stripc->ymax   = ymax;",Useful
/*length of x scale*/,"-4.     stripc->xmax   = xmax;
-3.     stripc->ymin   = ymin;
-2.     stripc->ymax   = ymax;

 /*length of x scale*/

111",Useful
/*autoscale y between x jump scale*/,"-5.     stripc->xmax   = xmax;
-4.     stripc->ymin   = ymin;
-3.     stripc->ymax   = ymax;

 /*autoscale y between x jump scale*/

111",Useful
/*accumulate plot (not really stripchart)*/,"-6.     stripc->xmax   = xmax;
-5.     stripc->ymin   = ymin;
-4.     stripc->ymax   = ymax;

 /*accumulate plot (not really stripchart)*/

111",Useful
/*x axis specification*/,"-7.     stripc->xmax   = xmax;
-6.     stripc->ymin   = ymin;
-5.     stripc->ymax   = ymax;

 /*x axis specification*/

1.     stripc->yspec  = plstrdup( yspec );",Useful
/*x label*/,"-1.     stripc->yspec  = plstrdup( yspec );

 /*x label*/

1.     stripc->laby   = plstrdup( laby );",Useful
/*title*/,"-1.     stripc->laby   = plstrdup( laby );

 /*title*/

111",Useful
/*box color*/,"-2.     stripc->laby   = plstrdup( laby );

 /*box color*/

111",Useful
/*label color*/,"-3.     stripc->laby   = plstrdup( laby );

 /*label color*/

111",Useful
/*Generate the plot*/,"-4.     stripc->laby   = plstrdup( laby );

 /*Generate the plot*/

1.     plstrip_gen( stripc );
2.     plstrip_legend( stripc, 1 );
3. }
4. static void plstrip_legend( PLStrip *stripcloc, int first )
5. {
6.     int   i;
7.     PLFLT sc, dy;",Useful
/*draw legend*/,"-2. static void
-1. plstrip_gen( PLStrip *strip );

 /*draw legend*/

1. static void
2. plstrip_legend( PLStrip *strip, int flag );",Useful
"/*--------------------------------------------------------------------------
plstrip_gen

Generates a complete stripchart plot.  Used either initially or
during rescaling.
--------------------------------------------------------------------------*/","-2. static void
-1. plstrip_legend( PLStrip *strip, int flag );

 /*--------------------------------------------------------------------------
plstrip_gen

Generates a complete stripchart plot.  Used either initially or
during rescaling.
-----------------",Useful
/*Set up window*/,"-3. static void plstrip_gen( PLStrip *striploc )
-2. {
-1.     int i;

 /*Set up window*/

1.     plvpor( 0, 1, 0, 1 );
2.     plwind( 0, 1, 0, 1 );
3.     plcol0( 0 ); plpsty( 0 );
4.     plclear();
5.     plvsta();",Useful
/*Draw box and same window dimensions*/,"-5.     plvpor( 0, 1, 0, 1 );
-4.     plwind( 0, 1, 0, 1 );
-3.     plcol0( 0 ); plpsty( 0 );
-2.     plclear();
-1.     plvsta();

 /*Draw box and same window dimensions*/

1.     striploc->wxmin = striploc->xmin; striploc->wxmax = striploc->xmax;",Useful
/*FIXME - can exist some redundancy here*/,"-1.     striploc->wxmin = striploc->xmin; striploc->wxmax = striploc->xmax;

 /*FIXME - can exist some redundancy here*/

1.     plwind( striploc->xmin, striploc->xmax, striploc->ymin, striploc->ymax );
2.     pllsty( 1 );
3.     plcol0( striploc->colbox ",Useful
"/*--------------------------------------------------------------------------
plstripa

Add a point to a stripchart.
Points assumed to have increasing X value per pen, and X value of all pens
to increase relatively close together so that no pen's new point is ever
earlier than the current chart X range.
Allocates memory and rescales as necessary.
--------------------------------------------------------------------------*/","-2. static void
-1. plstrip_legend( PLStrip *strip, int flag );

 /*--------------------------------------------------------------------------
plstripa

Add a point to a stripchart.
Points assumed to have increasing X value per pen, and X value of all pen",Useful
"/*Add new point, allocating memory if necessary*/","-10.     {
-9.         plabort( ""Non existent pen"" );
-8.         return;
-7.     }
-6.     if ( ( id < 0 ) || ( id >= MAX_STRIPC ) ||
-5.          ( ( stripc = strip[id] ) == NULL ) )
-4.     {
-3.         plabort( ""Non existent stripchart"" );
-2.       ",Useful
/*Check for Y rescale*/,"-10.         if ( stripc->x[p] == NULL || stripc->y[p] == NULL )
-9.         {
-8.             plabort( ""plstripc: Out of memory."" );
-7.             plstripd( id );
-6.             return;
-5.         }
-4.     }
-3.     stripc->x[p][stripc->npts[p] - 1]",Useful
/*option to rescale immediately*/,"-10.         {
-9.             plabort( ""plstripc: Out of memory."" );
-8.             plstripd( id );
-7.             return;
-6.         }
-5.     }
-4.     stripc->x[p][stripc->npts[p] - 1] = x;
-3.     stripc->y[p][stripc->npts[p] - 1] = y;
-2.     str",Useful
/*Now either plot new point or regenerate plot*/,"-4.     if ( y > stripc->ymax )
-3.         stripc->ymax = stripc->ymin + 1.1 * ( y - stripc->ymin );
-2.     if ( y < stripc->ymin )
-1.         stripc->ymin = stripc->ymax - 1.1 * ( stripc->ymax - y );

 /*Now either plot new point or regenerate plot*/
",Useful
/*all data fits within chart X range*/,"-2.     if ( stripc->xmax - stripc->xmin < stripc->xlen )
-1.     {

 /*all data fits within chart X range*/

1.         if ( yasc == 0 )
2.         {",Useful
"/*all data fits within chart Y range, or not rescaling immediately
this is the normal update case simply plotting the new point
If user has changed subwindow, make shure we have the correct one*/","-2.         if ( yasc == 0 )
-1.         {

 /*all data fits within chart Y range, or not rescaling immediately
this is the normal update case simply plotting the new point
If user has changed subwindow, make shure we have the correct one*/

1.           ",Useful
/*FIXME - can exist some redundancy here*/,"-1.     striploc->wxmin = striploc->xmin; striploc->wxmax = striploc->xmax;

 /*FIXME - can exist some redundancy here*/

1.     plwind( striploc->xmin, striploc->xmax, striploc->ymin, striploc->ymax );
2.     pllsty( 1 );
3.     plcol0( striploc->colbox ",Useful
"/*data exceeds Y range, rescale the drawing immediately*/","-10.             plcol0( stripc->colline[p] ); pllsty( stripc->styline[p] );
-9.             if ( ( stripc->npts[p] - 2 ) < 0 )
-8.                 plP_movwor( stripc->x[p][stripc->npts[p] - 1], stripc->y[p][stripc->npts[p] - 1] );
-7.             else
-6",Useful
"/*data exceeds X range
Regenerating plot*/","-6.             stripc->xmax = stripc->xmin + stripc->xlen;
-5.             plstrip_gen( stripc );
-4.         }
-3.     }
-2.     else
-1.     {

 /*data exceeds X range
Regenerating plot*/

1.         if ( stripc->acc == 0 )
2.         {
3.             ",Useful
/*find the first point in the data where X lies beyond a jumped new chart X minimum*/,"-6.         if ( stripc->acc == 0 )
-5.         {
-4.             for ( jpen = 0; jpen < PEN; jpen++ )
-3.             {
-2.                 if ( stripc->npts[jpen] > 0 )
-1.                 {

 /*find the first point in the data where X lies beyond a jum",Useful
/*remove all data where X lies before the new starting point*/,"-3.                     istart = 0;
-2.                     while ( stripc->x[jpen][istart] < stripc->xmin + stripc->xlen * stripc->xjump )
-1.                         istart++;

 /*remove all data where X lies before the new starting point*/

1.         ",Useful
/*extend the chart if charting in accumulative mode*/,"-7.                     stripc->npts[jpen] = stripc->npts[jpen] - istart;
-6.                     memmove( &stripc->x[jpen][0], &stripc->x[jpen][istart], (size_t) ( stripc->npts[jpen] ) * sizeof ( PLFLT ) );
-5.                     memmove( &stripc->y[jpe",Useful
/*establish new X chart range by jump and redraw*/,"-1.             stripc->xlen = stripc->xlen * ( 1 + stripc->xjump );

 /*establish new X chart range by jump and redraw*/

1.         if ( stripc->acc == 0 )
2.             stripc->xmin = stripc->xmin + stripc->xlen * stripc->xjump;
3.         else
4.    ",Useful
"/*--------------------------------------------------------------------------
plstripd

Deletes and releases memory used by a stripchart.
--------------------------------------------------------------------------*/","-2. static void
-1. plstrip_legend( PLStrip *strip, int flag );

 /*--------------------------------------------------------------------------
plstripd

Deletes and releases memory used by a stripchart.
----------------------------------------------------",Useful
"/*default size of temporary text buffer
If we wanted to be fancy we could add sizing, but this should be big enough*/","-10. PLDLLIMPEXP_DATA( FCI_to_FontName_Table ) FontLookup[N_TrueTypeLookup];

 /*default size of temporary text buffer
If we wanted to be fancy we could add sizing, but this should be big enough*/

1. #define NTEXT_ALLOC    1024",Useful
"/*Public prototypes, generally available to the API*/","-2. #define Debug6( a, b, c, d, e, f )    do { if ( pls->debug ) { fprintf( stderr, a, b, c, d, e, f ); } } while ( 0 )

 /*Public prototypes, generally available to the API*/

1. void plD_FreeType_init( PLStream *pls );
2. void plD_render_freetype_text( ",Useful
/*Private prototypes for use in this file only*/,"-6. void plD_FreeType_init( PLStream *pls );
-5. void plD_render_freetype_text( PLStream *pls, EscText *args );
-4. void plD_FreeType_Destroy( PLStream *pls );
-3. void pl_set_extended_cmap0( PLStream *pls, int ncol0_width, int ncol0_org );
-2. void pl_Re",Useful
"/*--------------------------------------------------------------------------
FT_StrX_YW()

Returns the dimensions of the text box. It does this by fully parsing
the supplied text through the rendering engine. It does everything
but draw the text. This seems, to me, the easiest and most accurate
way of determining the text's dimensions. If/when caching is added,
the CPU hit for this ""double processing"" will be minimal.
--------------------------------------------------------------------------*/","-4. #define TEXT_SCALING_FACTOR    .7

 /*--------------------------------------------------------------------------
FT_StrX_YW()

Returns the dimensions of the text box. It does this by fully parsing
the supplied text through the rendering engine. It doe",Useful
"/*
Things seems to work better with this line than without it;
I guess because there is no vertical kerning or advancement for most
non-transformed fonts, so we need to define *something* for the y height,
and this is the best thing I could think of.
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

 /*
Things seems to work better with this line than without it;
I guess because there is no vertical kerning or advancement for most
non-transformed fonts, so we need to define *something* for the y height,
and this is the best thing I could think of.
*/

111",Useful
/*FCI in text stream; change font accordingly.*/,"-7.                 *underyy = startingy - y < *underyy ? startingy - y : *underyy;
-6.                 i++;
-5.                 break;
-4.             }
-3.         }
-2.         else if ( text[i] & PL_FCI_MARK )
-1.         {

 /*FCI in text stream; cha",Useful
/*see if we have kerning for the particular character pair*/,"-5.             FT_SetFace( pls, text[i] );
-4.             *yy = (int) ( FT->face->size->metrics.height > -*yy  ? -FT->face->size->metrics.height : *yy );
-3.         }
-2.         else
-1.         {

 /*see if we have kerning for the particular characte",Useful
/*add (or subtract) the kerning*/,"-7.             if ( ( i > 0 ) && FT_HAS_KERNING( FT->face ) )
-6.             {
-5.                 FT_Get_Kerning( FT->face,
-4.                     text[i - 1],
-3.                     text[i],
-2.                     ft_kerning_default,
-1.           ",Useful
"/*
Next we load the char. This also draws the char, transforms it, and
converts it to a bitmap. At present this is a bit wasteful, but
if/when I add cache support, then this data won't go to waste.
Since there is no sense in going to the trouble of doing anti-aliasing
calculations since we aren't REALLY plotting anything, we will render
this as monochrome since it is probably marginally quicker. If/when
cache support is added, naturally this will have to change.
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

 /*
Next we load the char. This also draws the char, transforms it, and
converts it to a bitmap. At present this is a bit wasteful, but
if/when I add cache support, then this data won't go to waste.
Since there is no sense in going to the trouble of doing anti-aliasing
calculations since we aren't REALLY plotting anything, we will render
this as monochrome since it is probably marginally quicker. If/when
cache support is added, naturally this will have to change.
*/

111",Useful
"/*
Add in the ""advancement"" needed to position the cursor for the next
character. Unless the text is transformed, ""y"" will always be zero.
Y is negative because freetype does things upside down
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

 /*
Add in the ""advancement"" needed to position the cursor for the next
character. Unless the text is transformed, ""y"" will always be zero.
Y is negative because freetype does things upside down
*/

111",Useful
"/*Convert from unit of 1/64 of a pixel to pixels, and do it real fast with
a bitwise shift (mind you, any decent compiler SHOULD optimise /64 this way
anyway...)*/","-5.             x += (int) ( FT->face->glyph->advance.x );
-4.             y -= (int) ( FT->face->glyph->advance.y );
-3.         }
-2.     }

 /*Convert from unit of 1/64 of a pixel to pixels, and do it real fast with
a bitwise shift (mind you, any decen",Useful
"/*(RL, on 2005-01-23) Removed the shift bellow to avoid truncation errors
later.
yy=y>> 6;
xx=x>> 6;*/","-9.             x += (int) ( FT->face->glyph->advance.x );
-8.             y -= (int) ( FT->face->glyph->advance.y );
-7.         }
-6.     }

 /*(RL, on 2005-01-23) Removed the shift bellow to avoid truncation errors
later.
yy=y>> 6;
xx=x>> 6;*/

111",Useful
"/*--------------------------------------------------------------------------
FT_WriteStrW()

Writes a string of FT text at the current cursor location.
most of the code here is identical to ""FT_StrX_Y"" and I will probably
collapse the two into some more efficient code eventually.
--------------------------------------------------------------------------*/","-4. #define TEXT_SCALING_FACTOR    .7

 /*--------------------------------------------------------------------------
FT_WriteStrW()

Writes a string of FT text at the current cursor location.
most of the code here is identical to ""FT_StrX_Y"" and I will pr",Useful
"/*Adjust for the descender - make sure the font is nice and centred
vertically. Freetype assumes we have a base-line, but plplot thinks of
centre-lines, so that's why we have to do this. Since this is one of our
own adjustments, rather than a freetype one, we have to run it through
the transform matrix manually.

For some odd reason, this works best if we triple the
descender's height and then adjust the height later on...
Don't ask me why, 'cause I don't know. But it does seem to work.

I really wish I knew *why* it worked better though...

y-=FT->face->descender >> 6;*/","-9. void
-8. FT_WriteStrW( PLStream *pls, const PLUNICODE *text, short len, int x, int y )
-7. {
-6.     FT_Data   *FT = (FT_Data *) pls->FT;
-5.     short     i = 0, last_char = -1;
-4.     FT_Vector akerning, adjust;
-3.     char      esc;
-2.     plges",Useful
"/*(RL, on 2005-01-25) The computation of cumulated glyph width within
the text is done now with full precision, using 26.6 Freetype
arithmetics.  We should then shift the x and y variables by 6 bits,
as below.  Inside the character for loop, all operations regarding
x and y will be done in 26.6 mode and  these variables will be
converted to integers when passed to FT_PlotChar.  Notrice that we
are using ROUND and float division instead of "">> 6"" now.  This
minimizes truncation errors.*/","-5.     adjust.x = 0;
-4.     adjust.y = 0;
-3.     FT_Vector_Transform( &adjust, &FT->matrix );
-2.     x += (int) adjust.x;
-1.     y -= (int) adjust.y;

 /*(RL, on 2005-01-25) The computation of cumulated glyph width within
the text is done now with fu",Useful
"/*
We run the OFFSET for the super-script and sub-script through the
transformation matrix so we can calculate nice and easy the required
offset no matter what's happened rotation wise. Everything else, like
kerning and advancing from character to character is transformed
automatically by freetype, but since the superscript/subscript is a
feature of plplot, and not freetype, we have to make allowances.
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

 /*
We run the OFFSET for the super-script and sub-script through the
transformation matrix so we can calculate nice and easy the required
offset no matter what's happened rotation wise. Everything else, like
kerning and advancing from character to character is transformed
automatically by freetype, but since the superscript/subscript is a
feature of plplot, and not freetype, we have to make allowances.
*/

111",Useful
/*FCI in text stream; change font accordingly.*/,"-7.                 *underyy = startingy - y < *underyy ? startingy - y : *underyy;
-6.                 i++;
-5.                 break;
-4.             }
-3.         }
-2.         else if ( text[i] & PL_FCI_MARK )
-1.         {

 /*FCI in text stream; cha",Useful
/*see if we have kerning for the particular character pair*/,"-5.             FT_SetFace( pls, text[i] );
-4.             *yy = (int) ( FT->face->size->metrics.height > -*yy  ? -FT->face->size->metrics.height : *yy );
-3.         }
-2.         else
-1.         {

 /*see if we have kerning for the particular characte",Useful
/*add (or subtract) the kerning*/,"-7.             if ( ( i > 0 ) && FT_HAS_KERNING( FT->face ) )
-6.             {
-5.                 FT_Get_Kerning( FT->face,
-4.                     text[i - 1],
-3.                     text[i],
-2.                     ft_kerning_default,
-1.           ",Useful
/*Do I need this in case of rotation ?*/,"-7.             if ( ( last_char != -1 ) && ( i > 0 ) && FT_HAS_KERNING( FT->face ) )
-6.             {
-5.                 FT_Get_Kerning( FT->face,
-4.                     text[last_char],
-3.                     text[i],
-2.                     ft_kern",Useful
/*render the text*/,"-3.             }
-2.             FT_Load_Char( FT->face, text[i], ( FT->smooth_text == 0 ) ? FT_LOAD_MONOCHROME + FT_LOAD_RENDER : FT_LOAD_RENDER | FT_LOAD_FORCE_AUTOHINT );
-1.             FT_PlotChar( pls, FT, FT->face->glyph,

 /*render the text*/

1.",Useful
"/*--------------------------------------------------------------------------
FT_PlotChar()

Plots an individual character. I know some of this stuff, like colour
could be parsed from plstream, but it was just quicker this way.
--------------------------------------------------------------------------*/","-4. #define TEXT_SCALING_FACTOR    .7

 /*--------------------------------------------------------------------------
FT_PlotChar()

Plots an individual character. I know some of this stuff, like colour
could be parsed from plstream, but it was just quicke",Useful
"/*Comment this out as it fails for cases where we want to plot text
in the background font, i.e. example 24.

if ((slot->bitmap.pixel_mode==ft_pixel_mode_mono)||(pls->icol0==0)) {*/","-10.         tmp      = clipxmax;
-9.         clipxmax = clipxmin;
-8.         clipxmin = tmp;
-7.     }
-6.     if ( clipymin > clipymax )
-5.     {
-4.         tmp      = clipymax;
-3.         clipymax = clipymin;
-2.         clipymin = tmp;
-1.     }

",Useful
/*this is the anti-aliased stuff*/,"-10.                     {
-9.                         xx = x + ( k * 8 ) + j;
-8.                         if ( ( xx >= clipxmin ) && ( xx <= clipxmax ) )
-7.                             FT->pixel( pls, xx, y + i );
-6.                     }
-5.          ",Useful
/*The New anti-aliasing technique*/,"-10.         kmin = (short) MAX( 0, clipxmin - x );
-9.         kmax = (short) MIN( slot->bitmap.width, clipxmax - x );
-8.         for ( i = imin; i < imax; i++ )
-7.         {
-6.             for ( k = kmin; k < kmax; k++ )
-5.             {
-4.        ",Useful
/*The old anti-aliasing technique*/,"-6.                             R = (int) ( ( ( plsc->curcolor.r - R ) * alpha_a ) + R );
-5.                             G = (int) ( ( ( plsc->curcolor.g - G ) * alpha_a ) + G );
-4.                             B = (int) ( ( ( plsc->curcolor.b - B ) * al",Useful
"/*--------------------------------------------------------------------------
plD_FreeType_init()

Allocates memory to Freetype structure
Initialises the freetype library.
Initialises freetype structure
--------------------------------------------------------------------------*/","-4. #define TEXT_SCALING_FACTOR    .7

 /*--------------------------------------------------------------------------
plD_FreeType_init()

Allocates memory to Freetype structure
Initialises the freetype library.
Initialises freetype structure
-------------",Useful
/*font paths and file names can be long so leave generous (1024) room*/,"-4. void plD_FreeType_init( PLStream *pls )
-3. {
-2.     FT_Data       *FT;
-1.     char          *a;

 /*font paths and file names can be long so leave generous (1024) room*/

1.     char          font_dir[PLPLOT_MAX_PATH];",Useful
/*N.B. must be in exactly same order as TrueTypeLookup*/,"-1.     char          font_dir[PLPLOT_MAX_PATH];

 /*N.B. must be in exactly same order as TrueTypeLookup*/

1.     PLCHAR_VECTOR env_font_names[N_TrueTypeLookup] = {
2.         ""PLPLOT_FREETYPE_SANS_FONT"",
3.         ""PLPLOT_FREETYPE_SERIF_FONT"",
4.     ",Useful
/*set to an impossible value for an FCI*/,"-10.         plwarn( ""Freetype seems already to have been initialised!"" );
-9.         return;
-8.     }
-7.     if ( ( pls->FT = calloc( 1, (size_t) sizeof ( FT_Data ) ) ) == NULL )
-6.         plexit( ""Could not allocate memory for Freetype"" );
-5.     ",Useful
/*try to guess the font location by looking for arial font on C:*/,"-6.     if ( ( a = getenv( ""PLPLOT_FREETYPE_FONT_DIR"" ) ) != NULL )
-5.         strncpy( font_dir, a, PLPLOT_MAX_PATH - 1 );
-4.     else if ( strlen( PL_FREETYPE_FONT_DIR ) > 0 )
-3.         strncpy( font_dir, PL_FREETYPE_FONT_DIR, PLPLOT_MAX_PATH - 1 );",Useful
/*Try to guess the font location by looking for Arial font in the Windows Path*/,"-10.         }
-9.         else if ( access( ""c:\\windows\\system\\arial.ttf"", F_OK ) == 0 )
-8.         {
-7.             strcpy( font_dir, ""c:/windows/system/"" );
-6.         }
-5.         else
-4.             plwarn( ""Could not find font path; I sure h",Useful
"/*
For Unix systems, we will set the font path up a little differently in
that the configured PL_FREETYPE_FONT_DIR has been set as the default path,
but the user can override this by setting the environmental variable
""PLPLOT_FREETYPE_FONT_DIR"" to something else.
NOTE WELL - the trailing slash must be added for now !
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

 /*
For Unix systems, we will set the font path up a little differently in
that the configured PL_FREETYPE_FONT_DIR has been set as the default path,
but the user can override this by setting the environmental variable
""PLPLOT_FREETYPE_FONT_DIR"" to something else.
NOTE WELL - the trailing slash must be added for now !
*/

111",Useful
"/*Work out if we have been given an absolute path to a font name, or just
a font name sans-path. To do this we will look for a directory separator
character, which means some system specific junk. DJGPP is all wise, and
understands both Unix and DOS conventions. DOS only knows DOS, and
I assume everything else knows Unix-speak. (Why Bill, didn't you just
pay the extra 15c and get a REAL separator???)*/","-5.     for ( i = 0; i < N_TrueTypeLookup; i++ )
-4.     {
-3.         if ( ( a = getenv( env_font_names[i] ) ) != NULL )
-2.         {

 /*Work out if we have been given an absolute path to a font name, or just
a font name sans-path. To do this we will l",Useful
"/*--------------------------------------------------------------------------
FT_SetFace( PLStream *pls, PLUNICODE fci )

Sets up the font face and size
--------------------------------------------------------------------------*/","-4. #define TEXT_SCALING_FACTOR    .7

 /*--------------------------------------------------------------------------
FT_SetFace( PLStream *pls, PLUNICODE fci )

Sets up the font face and size
---------------------------------------------------------------",Useful
"/*font_size in points, chrht is in mm*/","-3. void FT_SetFace( PLStream *pls, PLUNICODE fci )
-2. {
-1.     FT_Data *FT       = (FT_Data *) pls->FT;

 /*font_size in points, chrht is in mm*/

111",Useful
"/*--------------------------------------------------------------------------
plD_render_freetype_text()

Transforms the font
calculates real-world bitmap coordinates from plplot ones
renders text using freetype
--------------------------------------------------------------------------*/","-4. #define TEXT_SCALING_FACTOR    .7

 /*--------------------------------------------------------------------------
plD_render_freetype_text()

Transforms the font
calculates real-world bitmap coordinates from plplot ones
renders text using freetype
----",Useful
"/*
Work out if either the font size, the font face or the
resolution has changed.
If either has, then we will reload the font face.
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

 /*
Work out if either the font size, the font face or the
resolution has changed.
If either has, then we will reload the font face.
*/

111",Useful
/*this will help work out underlining and overlining*/,"-3.         plgfci( &fci );
-2.         if ( ( FT->fci != fci ) || ( FT->chrht != pls->chrht ) || ( FT->xdpi != pls->xdpi ) || ( FT->ydpi != pls->ydpi ) )
-1.             FT_SetFace( pls, fci );

 /*this will help work out underlining and overlining*/

1.",Useful
"/*
Split the text into lines based on the newline character
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

 /*
Split the text into lines based on the newline character
*/

111",Useful
"/*
Now we work out how long the text is (for justification etc...) and how
high the text is. This is done on UN-TRANSFORMED text, since we will
apply our own transformations on it later, so it's necessary for us
to to turn all transformations off first, before calling the function
that calculates the text size.
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

 /*
Now we work out how long the text is (for justification etc...) and how
high the text is. This is done on UN-TRANSFORMED text, since we will
apply our own transformations on it later, so it's necessary for us
to to turn all transformations off first, before calling the function
that calculates the text size.
*/

111",Useful
"/*
Set up the transformation Matrix

Fortunately this is almost identical to plplot's own transformation matrix;
you have NO idea how much effort that saves ! Some params are in a
different order, and Freetype wants integers whereas plplot likes floats,
but such differences are quite trivial.

For some odd reason, this needs to be set a different way for DJGPP. Why ?
I wish I knew.
*/","// Copyright (C) 2002, 2004, 2005  Andrew Roach

 /*
Set up the transformation Matrix

Fortunately this is almost identical to plplot's own transformation matrix;
you have NO idea how much effort that saves ! Some params are in a
different order, and Freetype wants integers whereas plplot likes floats,
but such differences are quite trivial.

For some odd reason, this needs to be set a different way for DJGPP. Why ?
I wish I knew.
*/

111",Useful
"/*(RL, on 2005-01-21) The height_factor variable is introduced below.
It is used here and farther below when computing the vertical
adjustment.  The rationale for its introduction is as follow: up to
now, the text produced with Hershey fonts was systematically taller
than the same text produced with TT fonts, and tha by a factor of
around 1.125 (I discovered this empirically).  This corresponds
roughly to the ratio between total height and the ascender of some
TT faces.  Hence the computation below.  Remember that descender is
always a negative quantity.*/","-10. //      Set up the transformation Matrix
-9. //
-8. // Fortunately this is almost identical to plplot's own transformation matrix;
-7. // you have NO idea how much effort that saves ! Some params are in a
-6. // different order, and Freetype wants in",Useful
/*scale was set*/,"-9.     clipxmin = pls->clpxmi;
-8.     clipxmax = pls->clpxma;
-7.     clipymin = pls->clpymi;
-6.     clipymax = pls->clpyma;
-5.     if ( plsc->difilt )
-4.     {
-3.         difilt( &clipxmin, &clipymin, 1, &clpxmi, &clpxma, &clpymi, &clpyma );
-2.   ",Useful
"/*(RL, on 2005-01-24) The code below uses floating point and division
operations instead of integer shift used before. This is slower but
gives accurate placement of text in plots.*/","-5. #ifdef DODGIE_DECENDER_HACK
-4.             adjust.y = h;
-3. #else
-2.             adjust.y = 0;
-1. #endif

 /*(RL, on 2005-01-24) The code below uses floating point and division
operations instead of integer shift used before. This is slower but
gi",Useful
"/*(RL, on 2005-01-21) The hack below is intended to align single
glyphs being generated via plpoin.  The way to detect this
situation is completely hackish, I must admit, by checking whether the
length of the Unicode array is equal 2 and whether the first
character is actually a font-changing command to font number 4 (for
symbols).  This is ugly because it depends on definitions set
elsewhere, but it works.

The computation of the vertical and horizontal adjustments are
based on the bouding box of the glyph being loaded (since there is
only one glyph in the string in this case, we are okay here).*/","-9. #ifdef DODGIE_DECENDER_HACK
-8.             adjust.y = h;
-7. #else
-6.             adjust.y = 0;
-5. #endif

 /*(RL, on 2005-01-21) The hack below is intended to align single
glyphs being generated via plpoin.  The way to detect this
situation is com",Useful
"/*(RL, on 2005-01-21) The vertical adjustment is set below, making
the DODGIE conditional moot.  I use the value of h as return by FT_StrX_YW,
which should correspond to the total height of the text being
drawn.  Freetype aligns text around the baseline, while PLplot
aligns to the center of the ascender portion.  We must then adjust
by half of the ascender and this is why there is a division by
height_factor below.*/","-8.             if ( ( args->unicode_array_len == 2 )
-7.                  && ( args->unicode_array[0] == ( PL_FCI_MARK | 0x004 ) ) )
-6.             {
-5.                 adjust.x = (FT_Pos) ( args->just * ROUND( (PLFLT) FT->face->glyph->metrics.width / ",Useful
"/*--------------------------------------------------------------------------
plD_FreeType_Destroy()

Restores cmap0 if it had been modifed for anti-aliasing
closes the freetype library.
Deallocates memory to the Freetype structure
--------------------------------------------------------------------------*/","-4. #define TEXT_SCALING_FACTOR    .7

 /*--------------------------------------------------------------------------
plD_FreeType_Destroy()

Restores cmap0 if it had been modifed for anti-aliasing
closes the freetype library.
Deallocates memory to the Fre",Useful
"/*--------------------------------------------------------------------------
PLFLT CalculateIncrement( int bg, int fg, int levels)

Takes the value of the foreground, and the background, and when
given the number of desired steps, calculates how much to incriment
a value to transition from fg to bg.
This function only does it for one colour channel at a time.
--------------------------------------------------------------------------*/","-4. #define TEXT_SCALING_FACTOR    .7

 /*--------------------------------------------------------------------------
PLFLT CalculateIncrement( int bg, int fg, int levels)

Takes the value of the foreground, and the background, and when
given the number of",Useful
"/*--------------------------------------------------------------------------
void pl_set_extended_cmap0(PLStream *pls, int ncol0_width, int ncol0_org)

ncol0_width - how many greyscale levels to accolate to each CMAP0 entry
ncol0_org - the originl number of CMAP0 entries.

This function calcualtes and sets an extended CMAP0 entry for the
driver. It is assumed that the caller has checked to make sure there is
room for extending CMAP0 already.

NOTES
We don't bother calculating an entry for CMAP[0], the background.
It is assumed the caller has already expanded the size of CMAP[0]
--------------------------------------------------------------------------*/","-4. #define TEXT_SCALING_FACTOR    .7

 /*--------------------------------------------------------------------------
void pl_set_extended_cmap0(PLStream *pls, int ncol0_width, int ncol0_org)

ncol0_width - how many greyscale levels to accolate to each CMA",Useful
"/*--------------------------------------------------------------------------
plD_render_freetype_sym( PLStream *pls, EscText *args )
PLStream *pls - pointer to plot stream
EscText *args - pointer to standard ""string"" object.

This function is a simple rendering function which draws a single
character at a time. The function is an alternative to the text
functions which are considerably, and needlessly, more complicated
than what we need here.
--------------------------------------------------------------------------*/","-4. #define TEXT_SCALING_FACTOR    .7

 /*--------------------------------------------------------------------------
plD_render_freetype_sym( PLStream *pls, EscText *args )
PLStream *pls - pointer to plot stream
EscText *args - pointer to standard ""string",Useful
/*scale was set*/,"-9.     clipxmin = pls->clpxmi;
-8.     clipxmax = pls->clpxma;
-7.     clipymin = pls->clpymi;
-6.     clipymax = pls->clpyma;
-5.     if ( plsc->difilt )
-4.     {
-3.         difilt( &clipxmin, &clipymin, 1, &clpxmi, &clpxma, &clpymi, &clpyma );
-2.   ",Useful
"/*Adjust for the descender - make sure the font is nice and centred
vertically. Freetype assumes we have a base-line, but plplot thinks of
centre-lines, so that's why we have to do this. Since this is one of our
own adjustments, rather than a freetype one, we have to run it through
the transform matrix manually.

For some odd reason, this works best if we triple the
descender's height and then adjust the height later on...
Don't ask me why, 'cause I don't know. But it does seem to work.

I really wish I knew *why* it worked better though...

y-=FT->face->descender >> 6;*/","-9. void
-8. FT_WriteStrW( PLStream *pls, const PLUNICODE *text, short len, int x, int y )
-7. {
-6.     FT_Data   *FT = (FT_Data *) pls->FT;
-5.     short     i = 0, last_char = -1;
-4.     FT_Vector akerning, adjust;
-3.     char      esc;
-2.     plges",Useful
"/*Now we have to try and componsate for the fact that the freetype glyphs are left
justified, and plplot's glyphs are centred. To do this, we will just work out the
advancment, halve it, and take it away from the x position. This wont be 100%
accurate because ""spacing"" is factored into the right hand side of the glyph,
but it is as good a way as I can think of.*/","-10.     adjust.x = 0;
-9.     FT_Vector_Transform( &adjust, &FT->matrix );
-8.     x += (int) adjust.x;
-7.     y -= (int) adjust.y;
-6.     plgfci( &fci );
-5.     FT_SetFace( pls, fci );
-4.     FT = (FT_Data *) pls->FT;
-3.     FT_Set_Transform( FT->f",Useful
/*render the text*/,"-3.             }
-2.             FT_Load_Char( FT->face, text[i], ( FT->smooth_text == 0 ) ? FT_LOAD_MONOCHROME + FT_LOAD_RENDER : FT_LOAD_RENDER | FT_LOAD_FORCE_AUTOHINT );
-1.             FT_PlotChar( pls, FT, FT->face->glyph,

 /*render the text*/

1.",Useful
"/*Older versions of Visual Studio (2005 perhaps 2008) do not define uint8_t
The newer versions of Visual Studio will not install on Vista or older
versions of Windows.*/","-6. #define NEED_PLDEBUG
-5. #include ""plplotP.h""
-4. #include ""drivers.h""
-3. #include ""metadefs.h""
-2. #include <string.h>
-1. #if defined ( _MSC_VER ) && _MSC_VER <= 1500

 /*Older versions of Visual Studio (2005 perhaps 2008) do not define uint8_t
The",Useful
"/*--------------------------------------------------------------------------
Plplot internal interface to the plot buffer
--------------------------------------------------------------------------*/","-10. static void     rdbuf_esc( PLStream *pls );
-9. static void     rdbuf_image( PLStream *pls );
-8. static void     rdbuf_text( PLStream *pls );
-7. static void     rdbuf_text_unicode( PLINT op, PLStream *pls );
-6. static void     rdbuf_fill( PLStream",Useful
"/*! @file
!  These functions provide allocation and deallocation of two-dimensional
!  arrays.
!*/","-10. //  but WITHOUT ANY WARRANTY; without even the implied warranty of
-9. //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-8. //  GNU Library General Public License for more details.
-7. //
-6. //  You should have received a copy of th",Useful
"/*--------------------------------------------------------------------------

! Determine the Iliffe column vector of pointers to PLFLT row
! vectors corresponding to a 2D matrix of PLFLT's that is statically
! allocated. As a result the matrix can be accessed using C/C++
! syntax like zIliffe[i][j].
! Example usage:
!
!   PLFLT zStatic[XPTS][YPTS];
!   PLFLT_NC_VECTOR zIliffe[XPTS];
!
!   plStatic2dGrid((PLFLT_NC_MATRIX)zIliffe, (PLFLT_VECTOR)(&zStatic[0][0]), XPTS, YPTS);
!   plshade((PLFLT_NC_MATRIX)zIliffe,....);
!
! @param zIliffe Pre-existing location of the storage for the Iliffe column vectors.
! @param zStatic Pre-existing location of the storage for the 2D z array that is statically allocated.
! @param nx Size of the grid in x = length of the (Iliffe) column vectors.
! @param ny Size of the grid in y = length of the row vectors.
!
--------------------------------------------------------------------------*/","-10. //
-9. //  PLplot is distributed in the hope that it will be useful,
-8. //  but WITHOUT ANY WARRANTY; without even the implied warranty of
-7. //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-6. //  GNU Library General Public Licen",Useful
"/*--------------------------------------------------------------------------

! Allocate a block of memory for use as a matrix of type
! PLFLT_MATRIX (organized as an Iliffe column vector of pointers to
! row vectors).  As a result the matrix can be accessed using C/C++
! syntax like *f[i][j]. The memory associated with this matrix must
! be freed by calling plFree2dGrid once it is no longer required.
! Example usage:
!
!   PLFLT **z;
!
!   plAlloc2dGrid(&z, XPTS, YPTS);
!
! @param f Location of the storage (address of a **).
! @param nx Size of the grid in x.
! @param ny Size of the grid in y.
!
--------------------------------------------------------------------------*/","-10. //
-9. //  PLplot is distributed in the hope that it will be useful,
-8. //  but WITHOUT ANY WARRANTY; without even the implied warranty of
-7. //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-6. //  GNU Library General Public Licen",Useful
"/*--------------------------------------------------------------------------
plFree2dGrid()

! Frees a block of memory allocated with plAlloc2dGrid().
!
! @param f The [][] to the storage.
! @param nx Size of the grid in x.
! @param PL_UNUSED( ny) Not used.
--------------------------------------------------------------------------*/","-10. //
-9. //  PLplot is distributed in the hope that it will be useful,
-8. //  but WITHOUT ANY WARRANTY; without even the implied warranty of
-7. //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-6. //  GNU Library General Public Licen",Useful
"/*--------------------------------------------------------------------------
plMinMax2dGrid()

! Finds the maximum and minimum of a 2d matrix allocated with plAlloc2dGrid().
! NaN and +/- infinity values are ignored.
!
! param f 2d matrix pointer.
! param nx Size of the grid in x.
! param ny Size of the grid in y.
! param fnmax Maximum value in the matrix.
! param fnmin Minimum value in the matrix.
!
--------------------------------------------------------------------------*/","-10. //
-9. //  PLplot is distributed in the hope that it will be useful,
-8. //  but WITHOUT ANY WARRANTY; without even the implied warranty of
-7. //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-6. //  GNU Library General Public Licen",Useful
"/*! @file
!
! Point-, symbol-, and string-plotting routines.
!*/","-10. //
-9. // PLplot is distributed in the hope that it will be useful,
-8. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-7. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-6. // GNU Library General Public License f",Useful
"/*moved to plstr.h, plsc->cfont  static PLINT font = 1;  current font*/","-6. static short int   *fntlkup;
-5. static short int   *fntindx;
-4. static signed char *fntbffr;
-3. static short int   numberfonts, numberchars;
-2. static short int   indxleng;
-1. static short       fontloaded = 0;

 /*moved to plstr.h, plsc->cfont  ",Useful
"/*--------------------------------------------------------------------------
! Plot a glyph at the specified points.  (This function largely
! supersedes plpoin and plsym because many[!] more glyphs are
! accessible with plstring.)  The glyph is specified with a PLplot
! user string.  Note that the user string is not actually limited to
! one glyph so it is possible (but not normally useful) to plot more
! than one glyph at the specified points with this function.  As
! with plmtex and plptex, the user string can contain FCI escapes to
! determine the font, UTF-8 code to determine the glyph or else
! PLplot escapes for Hershey or unicode text to determine the glyph.
! @param n Number of points in x and y arrays.
! @param x Array of X coordinates of points.
! @param y Array of Y coordinates of points.
! @param string PLplot user string corresponding to the glyph to
! be plotted at each of the n points.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
! Plot a glyph at the specified points.  (This function is largely
! superseded by plstring which gives access to many[!] more glyphs.)
! @param n Number of points in x and y arrays.
! @param x Pointer to an array with X coordinates of points.
! @param y Pointer to an array with Y coordinates of points.
! @param code Hershey symbol code corresponding to a glyph to be
! plotted at each of the n points.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
! Plot a glyph at the specified points.  (This function is largely
! superseded by plstring which gives access to many[!] more glyphs.)
! code=-1 means try to just draw a point.  Right now it's just a
! move and a draw at the same place.  Not ideal, since a
! sufficiently intelligent output device may optimize it away, or
! there may be faster ways of doing it.  This is OK for now, though,
! and offers a 4X speedup over drawing a Hershey font ""point"" (which
! is actually diamond shaped and and therefore takes 4 strokes to
! draw).  If 0 < code < 32, then a useful (but small subset) of
! Hershey symbols is plotted.  If 32 <= code <= 127 the
! corresponding printable ASCII character is plotted.
! @param n Number of points in x and y arrays.
! @param x Pointer to an array with X coordinates of points.
! @param y Pointer to an array with Y coordinates of points.
! @param code Hershey symbol code (in ""ascii-indexed"" form with
! -1 <= code <= 127) corresponding to a glyph to be plotted at each
! of the n points.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
! Plot a glyph at the specified 3D points.  (This function is
! largely superseded by plstring3 which gives access to many[!] more
! glyphs.)  Set up the call to this function similar to what is done
! for plline3.  code=-1 means try to just draw a point.  Right now
! it's just a move and a draw at the same place.  Not ideal, since a
! sufficiently intelligent output device may optimize it away, or
! there may be faster ways of doing it.  This is OK for now, though,
! and offers a 4X speedup over drawing a Hershey font ""point"" (which
! is actually diamond shaped and therefore takes 4 strokes to draw).
! If 0 < code < 32, then a useful (but small subset) of Hershey
! symbols is plotted.  If 32 <= code <= 127 the corresponding
! printable ASCII character is plotted.
! @param n Number of points in x, y, and z arrays.
! @param x Pointer to an array with X coordinates of points.
! @param y Pointer to an array with Y coordinates of points.
! @param z Pointer to an array with Z coordinates of points.
! @param code Hershey symbol code (in ""ascii-indexed"" form with
! -1 <= code <= 127) corresponding to a glyph to be plotted at each
! of the n points.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
! Plot a glyph at the specified 3D points.  (This function
! largely supersedes plpoin3 because many[!] more glyphs are
! accessible with plstring3).  Set up the call to this function
! similar to what is done for plline3.  The glyph is specified with
! a PLplot user string.  Note that the user string is not actually
! limited to one glyph so it is possible (but not normally useful)
! to plot more than one glyph at the specified points with this
! function.  As with plmtex and plptex, the user string can contain
! FCI escapes to determine the font, UTF-8 code to determine the
! glyph or else PLplot escapes for Hershey or unicode text to
! determine the glyph.
! @param n Number of points in x, y, and z arrays.
! @param x Array of X coordinates of points.
! @param y Array of Y coordinates of points.
! @param z Array of Z coordinates of points.
! @param string PLplot user string corresponding to the glyph to
! be plotted at each of the n points.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
void plhrsh(PLINT ch, PLINT x, PLINT y)
PLINT ch - hershey code to plot
PLINT x - device-world x coordinate of hershey character
PLINT y - device-world y coordinate of hershey character

Writes the Hershey symbol ""ch"" centred at the physical coordinate (x,y).
This function is now just a ""spoof"" front end to the old plhersh,
which has now been renamed to plhrsh2(). All this function does is
decide whether or not we should render natively as unicode, and then
convert between hershey and unicode.

If the function KNOWS there isn't a unicode equivalent, then it will
try to render it as a hershey font. Understandably, this might make
testing out the unicode functions a little tricky, so if you want
to disable this behaviour, recompile with PL_TEST_FOR_MISSING_GLYPHS
defined.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
/*Get the index in the lookup table and the unicode character*/,"-2.     if ( ( plsc->dev_text ) && ( plsc->dev_unicode ) && ( !plsc->dev_hrshsym ) )
-1.     {

 /*Get the index in the lookup table and the unicode character*/

1.         idx = plhershey2unicode( ch );
2.         if ( 0 <= idx && idx <= number_of_entrie",Useful
"/*
Test to see if there is a defined unicode glyph for this hershey
code; if there isn't, then we pass the glyph to plhersh, and have
it rendered the old fashioned way.
Otherwise, we let the driver render it as unicode
*/","
//      Point, symbol, and string plotting routines.


 /*
Test to see if there is a defined unicode glyph for this hershey
code; if there isn't, then we pass the glyph to plhersh, and have
it rendered the old fashioned way.
Otherwise, we let the driver render it as unicode
*/

111",Useful
/*Get the current escape character*/,"-10.         {
-9. #ifndef PL_TEST_FOR_MISSING_GLYPHS
-8.             plhrsh2( ch, x, y );
-7. #endif
-6.         }
-5.         else
-4.         {
-3.             PLUNICODE plhrsh_unicode_buffer[3], fci;
-2.             PLFLT     xform[] = { 1.0, 0.0, 0.0",Useful
/*Unknown font face indicated by 0 value.*/,"-5.             args.text_type    = PL_STRING_SYMBOL;
-4.             args.unicode_char = unicode_char;
-3.             if ( 0 <= idx && idx <= number_of_entries_in_hershey_to_unicode_table )
-2.                 args.font_face = hershey_to_unicode_lookup_",Useful
"/*Comment out to fix problem with ps, psttf drivers
args.base = 1;*/","-1.                 args.font_face = 0;

 /*Comment out to fix problem with ps, psttf drivers
args.base = 1;*/

1.             args.base   = 0;
2.             args.just   = 0.5;
3.             args.xform  = xform;
4.             args.x      = x;
5.       ",Useful
"/*Get address of the unicode buffer (even though it is
currently static)*/","-7.             args.base   = 0;
-6.             args.just   = 0.5;
-5.             args.xform  = xform;
-4.             args.x      = x;
-3.             args.y      = y;
-2.             args.string = NULL;
-1.             args.symbol = ch;

 /*Get addres",Useful
"/*--------------------------------------------------------------------------
void plhrsh2()

Writes the Hershey symbol ""ch"" centred at the physical coordinate (x,y).
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
void pllab()

Simple routine for labelling graphs.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
void plmtex()

Prints out ""text"" at specified position relative to viewport
(may be inside or outside)

side	String which is one of the following:
B or b  :  Bottom of viewport
T or t  :  Top of viewport
BV or bv : Bottom of viewport, vertical text
TV or tv : Top of viewport, vertical text
L or l  :  Left of viewport
R or r  :  Right of viewport
LV or lv : Left of viewport, vertical text
RV or rv : Right of viewport, vertical text

disp Displacement from specified edge of viewport, measured outwards from
the viewport in units of the current character height. The
centerlines of the characters are aligned with the specified
position.

pos	Position of the reference point of the string relative to the
viewport edge, ranging from 0.0 (left-hand edge) to 1.0 (right-hand
edge)

just	Justification of string relative to reference point
just = 0.0 => left hand edge of string is at reference
just = 1.0 => right hand edge of string is at reference
just = 0.5 => center of string is at reference
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
void plptex()

Prints out ""text"" at world cooordinate (wx,wy). The text may be
at any angle ""angle"" relative to the horizontal. The parameter
""just"" adjusts the horizontal justification of the string:
just = 0.0 => left hand edge of string is at (wx,wy)
just = 1.0 => right hand edge of string is at (wx,wy)
just = 0.5 => center of string is at (wx,wy) etc.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
void plstr()

Prints out a ""string"" at reference position with physical coordinates
(refx,refy). The coordinates of the vectors defining the string are
passed through the linear mapping defined by the 2 x 2 matrix xform()
before being plotted.  The reference position is at the left-hand edge of
the string. If base = 1, it is aligned with the baseline of the string.
If base = 0, it is aligned with the center of the character box.

Note, all calculations are done in terms of millimetres. These are scaled
as necessary before plotting the string on the page.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
plchar()

Plots out a given stroke font character.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
PLFLT plstrl()

Computes the length of a string in mm, including escape sequences.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
PLINT plcvec()

Gets the character digitisation of Hershey table entry ""char"".
Returns 1 if there is a valid entry.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
void pldeco()

Decode a character string, and return an array of float integer symbol
numbers. This routine is responsible for interpreting all escape sequences.
At present the following escape sequences are defined (the letter following
the <esc> may be either upper or lower case):

<esc>u	: up one level (returns -1)
<esc>d	: down one level (returns -2)
<esc>b	: backspace (returns -3)
<esc>+	: toggles overline mode (returns -4)
<esc>-	: toggles underline mode (returns -5)
<esc><esc>	: <esc>
<esc>gx	: greek letter corresponding to roman letter x
<esc>fn	: switch to Normal font
<esc>fr	: switch to Roman font
<esc>fi	: switch to Italic font
<esc>fs	: switch to Script font
<esc>(nnn)	: Hershey symbol number nnn (any number of digits)

The escape character defaults to '#', but can be changed to any of
[!#$%&*@^~] via a call to plsesc.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
/*Initialize parameters.*/,"-6. static void
-5. pldeco( short int **symbol, PLINT *length, PLCHAR_VECTOR text )
-4. {
-3.     PLINT     ch, ifont = plsc->cfont, ig, j = 0, lentxt = (PLINT) strlen( text );
-2.     char      test, esc;
-1.     short int *sym = symbol_buffer;

 /*Initi",Useful
"/*If we didn't load the font file, then just return now.*/","-5.     *length = 0;
-4.     *symbol = symbol_buffer;
-3.     plgesc( &esc );
-2.     if ( ifont > numberfonts )
-1.         ifont = 1;

 /*If we didn't load the font file, then just return now.*/

1.     if ( !fntlkup )
2.     {
3.         plwarn( ""Attem",Useful
/*Get next character; treat non-printing characters as spaces.*/,"-5.     if ( !fntlkup )
-4.     {
-3.         plwarn( ""Attempt to decode hershy font symbol was made, but the hershey font data does not exist."" );
-2.         return;
-1.     }

 /*Get next character; treat non-printing characters as spaces.*/

1.     wh",Useful
/*Test for escape sequence (#)*/,"-8.     while ( j < lentxt )
-7.     {
-6.         if ( *length >= PLMAXSTR )
-5.             return;
-4.         test = text[j++];
-3.         ch   = test;
-2.         if ( ch < 0 || ch > 175 )
-1.             ch = 32;

 /*Test for escape sequence (#)*/
",Useful
"/*Decode character.
>>PC<< removed increment from following expression to fix
compiler bug*/","-10.                 sym[( *length )++] =
-9.                     *( fntlkup + ( ifont - 1 ) * numberchars + 127 + ig );
-8.             }
-7.             else
-6.             {
-5.                 ;
-4.             }
-3.         }
-2.         else
-1.   ",Useful
"/*--------------------------------------------------------------------------
PLINT plP_strpos()

Searches string str for first occurence of character chr.  If found
the position of the character in the string is returned (the first
character has position 0).  If the character is not found a -1 is
returned.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
PLINT plP_stindex()

Similar to strpos, but searches for occurence of string str2.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
PLBOOL plP_stsearch()

Searches string str for character chr (case insensitive).
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
! Calculate scale of font size and scale of magnitude of vertical
! offset associated with superscripts and subscripts.
! Notes on arguments: ifupper must be either TRUE or FALSE on every
! call to plP_script_scale.  The contents of the location pointed to
! by the level pointer must be zero on the first call to
! plP_script_scale, but not modified externally from then on.  The
! contents of the locations pointed to by all other pointer
! arguments are initialized internally, and should not be modified
! externally.
!
! @param ifupper Value which is TRUE if superscripting, i.e., if
! incrementing the previous level, and FALSE if subscripting, i.e.,
! decrementing the previous level.
! @param level Pointer to a location which contains the value of the
! superscript/subscript level.  That value is 0, +-1, +-2, etc., for
! no superscript/subscript, the first level of
! superscript/subscript, the second level of superscript/subscript,
! etc.  Before the call the value is the old level, and after the
! call the value will be incremented (ifupper TRUE) or decremented
! (ifupper FALSE) from the previous value.
! @param old_scale A pointer to a location that contains after the
! call the old font size scale value.
! @param scale A pointer to a location that contains after the call
! the font size scale value.  This value is 0.75^{|level|} where
! |level| is the magnitude of the value of the superscript/subscript
! level after the call.
! @param old_offset A pointer to a location that contains after the
! call the old value of the magnitude of the superscript/subscript
! offset.
! @param offset A pointer to a location that contains after the call
! the value of the magnitude of the superscript/subscript offset
! which is zero for |level|=0 and sum_{i=1}^{i=|level|} 0.75^{i-1},
! otherwise.*/","-10. PLBOOL
-9. plP_stsearch( PLCHAR_VECTOR str, int chr )
-8. {
-7.     if ( strchr( str, chr ) )
-6.         return TRUE;
-5.     else if ( strchr( str, toupper( chr ) ) )
-4.         return TRUE;
-3.     else
-2.         return FALSE;
-1. }

 /*-------",Useful
/*If superscript of subscript moves further away from centerline....*/,"-10.         *old_scale  = 1.;
-9.         *old_offset = 0.;
-8.     }
-7.     else
-6.     {
-5.         *old_scale  = *scale;
-4.         *old_offset = *offset;
-3.     }
-2.     if ( ( *level >= 0 && ifupper ) || ( *level <= 0 && !ifupper ) )
-1.     {",Useful
/*If superscript of subscript moves closer to centerline....*/,"-5.         *scale  = 0.75 * *old_scale;
-4.         *offset = *old_offset + *old_scale;
-3.     }
-2.     else
-1.     {

 /*If superscript of subscript moves closer to centerline....*/

1.         *scale  = *old_scale / 0.75;
2.         *offset = *old_o",Useful
"/*--------------------------------------------------------------------------
void c_plfont(ifont)

Sets the global font flag to 'ifont'.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*normal = (medium, upright, sans serif)*/","-3.     switch ( ifont )
-2.     {
-1.     case 1:

 /*normal = (medium, upright, sans serif)*/

1.         plP_hex2fci( PL_FCI_SANS, PL_FCI_FAMILY, &fci );
2.         plsfci( fci );
3.         break;",Useful
"/*roman = (medium, upright, serif)*/","-3.         plP_hex2fci( PL_FCI_SANS, PL_FCI_FAMILY, &fci );
-2.         plsfci( fci );
-1.         break;

 /*roman = (medium, upright, serif)*/

1.     case 2:
2.         plP_hex2fci( PL_FCI_SERIF, PL_FCI_FAMILY, &fci );
3.         plsfci( fci );
4.    ",Useful
"/*italic = (medium, italic, serif)*/","-4.     case 2:
-3.         plP_hex2fci( PL_FCI_SERIF, PL_FCI_FAMILY, &fci );
-2.         plsfci( fci );
-1.         break;

 /*italic = (medium, italic, serif)*/

1.     case 3:
2.         plP_hex2fci( PL_FCI_ITALIC, PL_FCI_STYLE, &fci );
3.         plP_",Useful
"/*script = (medium, upright, script)*/","-5.     case 3:
-4.         plP_hex2fci( PL_FCI_ITALIC, PL_FCI_STYLE, &fci );
-3.         plP_hex2fci( PL_FCI_SERIF, PL_FCI_FAMILY, &fci );
-2.         plsfci( fci );
-1.         break;

 /*script = (medium, upright, script)*/

1.     case 4:
2.         p",Useful
"/*--------------------------------------------------------------------------
void plfntld(fnt)

Loads either the standard or extended font.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
void plfontrel()

Release memory for fonts.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
int plhershey2unicode ( int in )

Function searches for in, the input hershey code, in a lookup table and
returns the corresponding index in that table.
Using this index you can work out the unicode equivalent as well as
the closest approximate to the font-face. If the returned index is
-1 then no match was possible.

Two versions of the function exist, a simple linear search version,
and a more complex, but significantly faster, binary search version.
If there seem to be problems with the binary search method, the brain-dead
linear search can be enabled by defining SIMPLE_BUT_SAFE_HERSHEY_LOOKUP
at compile time.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
char *
plP_FCI2FontName ( PLUNICODE fci,
const FCI_to_FontName_Table lookup[], const int nlookup)

Function takes an input FCI (font characterization integer) index,
looks through the lookup table (which must be sorted by PLUNICODE fci),
then returns the corresponding pointer to a valid font name.  If the FCI
index is not present the returned value is NULL.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
void plmtex3()

This is the 3d equivalent of plmtex(). It prints out ""text"" at specified
position relative to viewport (may be inside or outside)

side	String contains one or more of the following characters
x,y,z : Specify which axis is to be labeled
p,s   : Label the ""primary"" or the ""secondary"" axis. The ""primary"" axis
being somewhat arbitrary, but basically it is the one that you'd
expect to labeled in a 3d graph of standard orientation. Example:
for z this would be the left hand axis.
v     : draw the text perpendicular to the axis.

disp Displacement from specified edge of axis, measured outwards from
the axis in units of the current character height. The
centerlines of the characters are aligned with the specified
position.

pos	Position of the reference point of the string relative to the
axis ends, ranging from 0.0 (left-hand end) to 1.0 (right-hand
end)

just	Justification of string relative to reference point
just = 0.0 => left hand edge of string is at reference
just = 1.0 => right hand edge of string is at reference
just = 0.5 => center of string is at reference

All calculations are done in physical coordinates.

--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
/*check that the plotting environment is set up*/,"-4.     PLFLT xpc, ypc, xrefpc, yrefpc;
-3.     PLFLT epx1 = 0.0, epy1 = 0.0, epx2 = 0.0, epy2 = 0.0, epx3 = 0.0, epy3 = 0.0;
-2.     PLFLT dispx, dispy, xform[4];
-1.     PLFLT shift, theta, temp;

 /*check that the plotting environment is set up*/

1.  ",Useful
/*get plotting environment information*/,"-5.     if ( plsc->level < 3 )
-4.     {
-3.         plabort( ""plmtex3: Please set up window first"" );
-2.         return;
-1.     }

 /*get plotting environment information*/

1.     plP_gdom( &xmin, &xmax, &ymin, &ymax );
2.     plP_grange( &zscale, &zm",Useful
/*handle x/y axises*/,"-3.     plP_gdom( &xmin, &xmax, &ymin, &ymax );
-2.     plP_grange( &zscale, &zmin, &zmax );
-1.     plgchr( &chrdef, &chrht );

 /*handle x/y axises*/

1.     if ( ( plP_stindex( side, ""x"" ) != -1 ) || ( plP_stindex( side, ""y"" ) != -1 ) )
2.     {",Useful
/*get the locations of the end points of the relevant axis*/,"-2.     if ( ( plP_stindex( side, ""x"" ) != -1 ) || ( plP_stindex( side, ""y"" ) != -1 ) )
-1.     {

 /*get the locations of the end points of the relevant axis*/

111",Useful
/*x axis label*/,"-3.     if ( ( plP_stindex( side, ""x"" ) != -1 ) || ( plP_stindex( side, ""y"" ) != -1 ) )
-2.     {

 /*x axis label*/

1.         if ( plP_stindex( side, ""x"" ) != -1 )
2.         {",Useful
/*primary*/,"-10.     return ( NULL );
-9. }

 /*primary*/

111",Useful
/*text always goes from left to right*/,"-10.                 epy2 = plP_wcpcy( plP_w3wcy( xmin, ymax, zmin ) );
-9.             }
-8.             else
-7.             {
-6.                 epx1 = plP_wcpcx( plP_w3wcx( xmax, ymin, zmin ) );
-5.                 epy1 = plP_wcpcy( plP_w3wcy( xmax, ",Useful
"/*recalculate position assuming the user specified
it in the min -> max direction of the axis.*/","-8.         if ( epx1 > epx2 )
-7.         {
-6.             temp = epx1;
-5.             epx1 = epx2;
-4.             epx2 = temp;
-3.             temp = epy1;
-2.             epy1 = epy2;
-1.             epy2 = temp;

 /*recalculate position assuming th",Useful
/*calculate location of text center point*/,"-2.             pos = 1.0 - pos;
-1.         }

 /*calculate location of text center point*/

111",Useful
"/*1. calculate the angle of the axis we are to
draw the text on relative to the horizontal*/","-3.             pos = 1.0 - pos;
-2.         }

 /*1. calculate the angle of the axis we are to
draw the text on relative to the horizontal*/

1.         if ( ( epx2 - epx1 ) != 0.0 )
2.         {
3.             theta = atan( ( epy2 - epy1 ) / ( epx2 - ep",Useful
/*2. calculate the perpendicular vector*/,"-10.         {
-9.             if ( epy2 > epy1 )
-8.             {
-7.                 theta = 0.5 * PI;
-6.             }
-5.             else
-4.             {
-3.                 theta = -0.5 * PI;
-2.             }
-1.         }

 /*2. calculate the ",Useful
/*3. calculate x & y center points*/,"-1.         dispy = disp * chrht;

 /*3. calculate x & y center points*/

1.         xpc = pos * ( epx2 - epx1 ) + epx1;
2.         ypc = pos * ( epy2 - epy1 ) + epy1;",Useful
/*5. compute transform matrix & draw text*/,"-10.         }
-9.         else
-8.         {
-7.             xrefpc = xpc - cos( theta ) * shift;
-6.             yrefpc = ypc - sin( theta ) * shift;
-5.         }
-4.         xpc    = plP_mmpcx( xpc );
-3.         ypc    = plP_mmpcy( ypc );
-2.        ",Useful
"/*perpendicular, rotate 90 degrees & shear*/","-10.         else
-9.         {
-8.             xrefpc = xpc - cos( theta ) * shift;
-7.             yrefpc = ypc - sin( theta ) * shift;
-6.         }
-5.         xpc    = plP_mmpcx( xpc );
-4.         ypc    = plP_mmpcy( ypc );
-3.         xrefpc = plP_",Useful
"/*parallel, rotate & shear by angle*/","-8.         if ( plP_stindex( side, ""v"" ) != -1 )
-7.         {
-6.             xform[0] = 0.0;
-5.             xform[1] = -cos( theta );
-4.             xform[2] = 1.0;
-3.             xform[3] = -sin( theta );
-2.             plP_text( 0, just, xform, (",Useful
/*handle z axises*/,"-9.         else
-8.         {
-7.             xform[0] = cos( theta );
-6.             xform[1] = 0.0;
-5.             xform[2] = sin( theta );
-4.             xform[3] = 1.0;
-3.             plP_text( 0, just, xform, (PLINT) xpc, (PLINT) ypc, (PLINT) xr",Useful
"/*find the right most of the 4 z axis options for ""primary""*/","-10.             }
-9.             if ( plP_wcpcx( plP_w3wcx( xmax, ymax, zmin ) ) < epx1 )
-8.             {
-7.                 epx1 = plP_wcpcx( plP_w3wcx( xmax, ymax, zmin ) );
-6.                 epy1 = plP_wcpcy( plP_w3wcy( xmax, ymax, zmin ) );
-5.",Useful
"/*Calculate location of text center point.
This is very similiar for the z axis.*/","-10.             }
-9.             if ( plP_wcpcx( plP_w3wcx( xmax, ymax, zmin ) ) > epx1 )
-8.             {
-7.                 epx1 = plP_wcpcx( plP_w3wcx( xmax, ymax, zmin ) );
-6.                 epy1 = plP_wcpcy( plP_w3wcy( xmax, ymax, zmin ) );
-5.",Useful
/*primary and secondary have to be handled separately here*/,"-10.             {
-9.                 epx1 = plP_wcpcx( plP_w3wcx( xmax, ymax, zmin ) );
-8.                 epy1 = plP_wcpcy( plP_w3wcy( xmax, ymax, zmin ) );
-7.                 epy2 = plP_wcpcy( plP_w3wcy( xmax, ymax, zmax ) );
-6.                 epx",Useful
"/*1. Calculate the angle of the axis we are to
draw the text on relative to the horizontal.*/","-2.         if ( plP_stindex( side, ""p"" ) != -1 )
-1.         {

 /*1. Calculate the angle of the axis we are to
draw the text on relative to the horizontal.*/

1.             if ( ( epx3 - epx1 ) != 0.0 )
2.             {
3.                 theta = atan(",Useful
/*2. Calculate the perpendicular vector.*/,"-10.             {
-9.                 if ( epy3 > epy1 )
-8.                 {
-7.                     theta = 0.5 * PI;
-6.                 }
-5.                 else
-4.                 {
-3.                     theta = -0.5 * PI;
-2.                 }",Useful
/*3. Calculate x & y center points.*/,"-10.                     theta = -0.5 * PI;
-9.                 }
-8.                 else
-7.                 {
-6.                     theta = 0.5 * PI;
-5.                 }
-4.             }
-3.             dispx = cos( theta ) * disp * chrht;
-2.    ",Useful
/*4. Compute the reference point.*/,"-2.         xpc = epx1;
-1.         ypc = pos * ( epy2 - epy1 ) + epy1;

 /*4. Compute the reference point.*/

1.         xpc = plP_dcmmx( plP_pcdcx( (PLINT) xpc ) ) + dispx;
2.         ypc = plP_dcmmy( plP_pcdcy( (PLINT) ypc ) ) + dispy;
3.         shift",Useful
/*5. Compute transform matrix & draw text.*/,"-10.         }
-9.         else
-8.         {
-7.             xrefpc = xpc;
-6.             yrefpc = ypc - shift;
-5.         }
-4.         xpc    = plP_mmpcx( xpc );
-3.         ypc    = plP_mmpcy( ypc );
-2.         xrefpc = plP_mmpcx( xrefpc );
-1.    ",Useful
"/*--------------------------------------------------------------------------
void plptex3()

Prints out ""text"" at world cooordinate (wx,wy,wz).

The text is drawn parallel to the line between (wx,wy,wz) and
(wx+dx,wy+dy,wz+dz).

The text is sheared so that it is ""vertically"" parallel to the
line between (wx,wy,wz) and (wx+sx, wy+sy, wz+sz). If sx=sy=sz=0 then
the text is simply rotated to parallel to the baseline.

""just"" adjusts the horizontal justification of the string:
just = 0.0 => left hand edge of string is at (wx,wy)
just = 1.0 => right hand edge of string is at (wx,wy)
just = 0.5 => center of string is at (wx,wy) etc.

Calculations are done in physical coordinates.

--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
/*check that the plotting environment is set up*/,"-4.     PLFLT xpc, ypc, xrefpc, yrefpc;
-3.     PLFLT epx1 = 0.0, epy1 = 0.0, epx2 = 0.0, epy2 = 0.0, epx3 = 0.0, epy3 = 0.0;
-2.     PLFLT dispx, dispy, xform[4];
-1.     PLFLT shift, theta, temp;

 /*check that the plotting environment is set up*/

1.  ",Useful
"/*compute text x,y location in physical coordinates*/","-5.     if ( plsc->level < 3 )
-4.     {
-3.         plabort( ""plptex3: Please set up window first"" );
-2.         return;
-1.     }

 /*compute text x,y location in physical coordinates*/

1.     xpc = plP_wcpcx( plP_w3wcx( wx, wy, wz ) );
2.     ypc = p",Useful
/*determine angle to rotate text in the x-y plane*/,"-2.     xpc = plP_wcpcx( plP_w3wcx( wx, wy, wz ) );
-1.     ypc = plP_wcpcy( plP_w3wcy( wx, wy, wz ) );

 /*determine angle to rotate text in the x-y plane*/

1.     xdpc  = plP_wcpcx( plP_w3wcx( wx + dx, wy + dy, wz + dz ) );
2.     ydpc  = plP_wcpcy( pl",Useful
/*compute the reference point*/,"-8.     x_o  = plP_w3wcx( wx, wy, wz );
-7.     y_o  = plP_w3wcy( wx, wy, wz );
-6.     z_o  = plP_w3wcz( wx, wy, wz );
-5.     x_dx = x_o - plP_w3wcx( wx + dx, wy + dy, wz + dz );
-4.     y_dy = y_o - plP_w3wcy( wx + dx, wy + dy, wz + dz );
-3.     z_dz ",Useful
"/*compute the transform
This affine transformation corresponds to transforming from old
coordinates to new coordinates by rotating axes, y shearing
or (y skewing), and scaling.
Comment out the explicit xform calculations because we use
the affine utilities for that calculation instead.

xform[0] = cos( theta ) * stride;
xform[1] = cos( theta ) * sin( phi ) - sin( theta ) * cos( phi );
xform[2] = sin( theta ) * stride;
xform[3] = sin( theta ) * sin( phi ) + cos( theta ) * cos( phi );*/","-9.     xpc = plP_dcmmx( plP_pcdcx( (PLINT) xpc ) );
-8.     ypc = plP_dcmmy( plP_pcdcy( (PLINT) ypc ) );
-7.     shift  = plstrl( text ) * just;
-6.     xrefpc = xpc - cos( theta ) * shift * stride;
-5.     yrefpc = ypc - sin( theta ) * shift * stride;
-",Useful
"/*--------------------------------------------------------------------------
void plsfont()

Set the family, style and weight of the current font.
This is a user-friendly front-end to plsfci.
Note: A negative value signifies that this element should not be changed.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
/*Bounds checking assumes symbol is last font*/,"-7. void
-6. c_plsfont( PLINT family, PLINT style, PLINT weight )
-5. {
-4.     PLUNICODE fci;
-3.     plgfci( &fci );
-2.     if ( family >= 0 )
-1.     {

 /*Bounds checking assumes symbol is last font*/

1.         if ( family > PL_FCI_SYMBOL )
2.     ",Useful
/*Bounds checking assumes oblique is last style*/,"-7.         if ( family > PL_FCI_SYMBOL )
-6.             plwarn( ""plsfont: Value for family is out of range"" );
-5.         else
-4.             plP_hex2fci( (unsigned char) family, PL_FCI_FAMILY, &fci );
-3.     }
-2.     if ( style >= 0 )
-1.     {

 /",Useful
/*Bounds checking assumes bold is last weight*/,"-7.         if ( style > PL_FCI_OBLIQUE )
-6.             plwarn( ""plsfont: Value for style is out of range"" );
-5.         else
-4.             plP_hex2fci( (unsigned char) style, PL_FCI_STYLE, &fci );
-3.     }
-2.     if ( weight >= 0 )
-1.     {

 /*B",Useful
"/*--------------------------------------------------------------------------
void plgfont()

Get the family, style and weight of the current font.
This is a user-friendly front-end to plgfci.
Note: A NULL pointer signifies that this value should not be returned.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*--------------------------------------------------------------------------
void plenv()

Simple interface for defining viewport and window.

The ""just"" parameter control how the axes will be scaled:

just=-1 : The scales will not be set, the user must set up the scale
before calling plenv() using plsvpa(), plvasp() or other;
just= 0 : The scales will be set up to optimize plot area;
just= 1 : The scales will be the same;
just= 2 : The axes will be equal, the plot box will be square.

The ""axis"" parameter is interpreted as follows:

axis=-2 : draw no box, no tick marks, no numeric tick labels, no axes.
axis=-1 : draw box only.
axis= 0 : Draw box, ticks, and numeric tick labels.
axis= 1 : Also draw coordinate axes at X=0, and Y=0.
axis= 2 : Also draw a grid at major tick positions in both coordinates.
axis= 3 : Same as 2, but the grid will be also at the minor ticks.
axis=10 : Same as 0 except Logarithmic X tick marks. (The X data have
to be converted to logarithms separately.)
axis=11 : Same as 1 except Logarithmic X tick marks. (The X data have
to be converted to logarithms separately.)
axis=12 : Same as 2 except Logarithmic X tick marks. (The X data have
to be converted to logarithms separately.)
axis=13 : Same as 12, but the grid will be also at the minor ticks.
axis=20 : Same as 0 except Logarithmic Y tick marks. (The Y data have
to be converted to logarithms separately.)
axis=21 : Same as 1 except Logarithmic Y tick marks. (The Y data have
to be converted to logarithms separately.)
axis=22 : Same as 2 except Logarithmic Y tick marks. (The Y data have
to be converted to logarithms separately.)
axis=23 : Same as 22, but the grid will be also at the minor ticks.
axis=30 : Same as 0 except Logarithmic X,Y tick marks. (The X,Y data have
to be converted to logarithms separately.)
axis=31 : Same as 1 except Logarithmic X,Y tick marks. (The X,Y data have
to be converted to logarithms separately.)
axis=32 : Same as 2 except Logarithmic X,Y tick marks. (The X,Y data have
to be converted to logarithms separately.)
axis=33 : Same as 32, but the grid will be also at the minor ticks.
axis=40 : Same as 0 except date / time X tick marks.
axis=41 : Same as 1 except date / time X tick marks.
axis=42 : Same as 2 except date / time X tick marks.
axis=43 : Same as 42, but the grid will be also at the minor ticks.
axis=50 : Same as 0 except date / time Y tick marks.
axis=51 : Same as 1 except date / time Y tick marks.
axis=52 : Same as 2 except date / time Y tick marks.
axis=53 : Same as 52, but the grid will be also at the minor ticks.
axis=60 : Same as 0 except date / time X,Y tick marks.
axis=61 : Same as 1 except date / time X,Y tick marks.
axis=62 : Same as 2 except date / time X,Y tick marks.
axis=63 : Same as 62, but the grid will be also at the minor ticks.
axis=70 : Same as 0 except custom X,Y labels.
axis=71 : Same as 1 except custom X,Y labels.
axis=72 : Same as 2 except custom X,Y labels.
axis=73 : Same as 72, but the grid will be also at the minor ticks.
--------------------------------------------------------------------------*/","-4. #include ""plplotP.h""
-3. static void
-2. c_plenvi( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-1.           PLINT just, PLINT axis, PLINT old );

 /*--------------------------------------------------------------------------
void plenv()

Simple i",Useful
"/*--------------------------------------------------------------------------
void plenv0()

same as plenv() above, but if in multiplot mode does not advance the subpage,
instead clears it.
--------------------------------------------------------------------------*/","-4. #include ""plplotP.h""
-3. static void
-2. c_plenvi( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-1.           PLINT just, PLINT axis, PLINT old );

 /*--------------------------------------------------------------------------
void plenv0()

same as",Useful
/*not multiplot mode*/,"-10.     if ( ymin == ymax )
-9.     {
-8.         plabort( ""plenv: Invalid ymin and ymax arguments"" );
-7.         return;
-6.     }
-5.     if ( just < -1 || just > 2 )
-4.     {
-3.         plabort( ""plenv: Invalid just option"" );
-2.         return;
-",Useful
"/*--------------------------------------------------------------------------
void plvsta()

Defines a ""standard"" viewport with seven character heights for
the left margin and four character heights everywhere else.
--------------------------------------------------------------------------*/","-4. #include ""plplotP.h""
-3. static void
-2. c_plenvi( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-1.           PLINT just, PLINT axis, PLINT old );

 /*--------------------------------------------------------------------------
void plvsta()

Defines",Useful
"/*Find out position of subpage boundaries in millimetres, reduce by
the desired border, and convert back into normalized subpage
coordinates*/","lb = 8.0 * plsc->chrht;
    rb = 5.0 * plsc->chrht;
    tb = 5.0 * plsc->chrht;
    bb = 5.0 * plsc->chrht;

    xmin = plP_dcscx( plP_mmdcx( (PLFLT) ( plP_dcmmx( plsc->spdxmi ) + lb ) ) );
    xmax = plP_dcscx( plP_mmdcx( (PLFLT) ( plP_dcmmx( plsc->spdxma ) - rb ) ) );
    ymin = plP_dcscy( plP_mmdcy( (PLFLT) ( plP_dcmmy( plsc->spdymi ) + tb ) ) );
    ymax = plP_dcscy( plP_mmdcy( (PLFLT) ( plP_dcmmy( plsc->spdyma ) - bb ) ) );

    plvpor( xmin, xmax, ymin, ymax );
}

 /*Find out position of subpage boundaries in millimetres, reduce by
the desired border, and convert back into normalized subpage
coordinates*/

111",Useful
"/*--------------------------------------------------------------------------
void plvpor()

Creates a viewport with the specified normalized subpage coordinates.
--------------------------------------------------------------------------*/","-4. #include ""plplotP.h""
-3. static void
-2. c_plenvi( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-1.           PLINT just, PLINT axis, PLINT old );

 /*--------------------------------------------------------------------------
void plvpor()

Creates",Useful
"/*--------------------------------------------------------------------------
void plvpas()

Creates the largest viewport of the specified aspect ratio that fits
within the specified normalized subpage coordinates.
--------------------------------------------------------------------------*/","-4. #include ""plplotP.h""
-3. static void
-2. c_plenvi( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-1.           PLINT just, PLINT axis, PLINT old );

 /*--------------------------------------------------------------------------
void plvpas()

Creates",Useful
/*Adjust size for the requested edging*/,"-10.     }
-9.     plgspa( &spxmin, &spxmax, &spymin, &spymax );
-8.     xsize = spxmax - spxmin;
-7.     ysize = spymax - spymin;
-6.     xoffset = xsize * xmin;
-5.     yoffset = ysize * ymin;
-4.     spxmax = spxmin + xsize * xmax;
-3.     spxmin = spx",Useful
/*center plot within page*/,"-10.     if ( aspect * xsize > ysize )
-9.     {
-8.         nxsize = ysize / aspect;
-7.         nysize = ysize;
-6.     }
-5.     else
-4.     {
-3.         nxsize = xsize;
-2.         nysize = xsize * aspect;
-1.     }

 /*center plot within page*/

1.",Useful
"/*--------------------------------------------------------------------------
void plvasp()

Sets the edges of the viewport with the given aspect ratio, leaving
room for labels.
--------------------------------------------------------------------------*/","-4. #include ""plplotP.h""
-3. static void
-2. c_plenvi( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-1.           PLINT just, PLINT axis, PLINT old );

 /*--------------------------------------------------------------------------
void plvasp()

Sets th",Useful
/*adjust for labels*/,"-10.         plabort( ""plvasp: Please call plinit first"" );
-9.         return;
-8.     }
-7.     lb = 8.0 * plsc->chrht;
-6.     rb = 5.0 * plsc->chrht;
-5.     tb = 5.0 * plsc->chrht;
-4.     bb = 5.0 * plsc->chrht;
-3.     plgspa( &spxmin, &spxmax, &sp",Useful
/*center plot within page*/,"-10.     if ( aspect * xsize > ysize )
-9.     {
-8.         nxsize = ysize / aspect;
-7.         nysize = ysize;
-6.     }
-5.     else
-4.     {
-3.         nxsize = xsize;
-2.         nysize = xsize * aspect;
-1.     }

 /*center plot within page*/

1.",Useful
"/*--------------------------------------------------------------------------
void plsvpa()

Sets the edges of the viewport to the specified absolute coordinates
(mm), measured with respect to the current subpage boundaries.
--------------------------------------------------------------------------*/","-4. #include ""plplotP.h""
-3. static void
-2. c_plenvi( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-1.           PLINT just, PLINT axis, PLINT old );

 /*--------------------------------------------------------------------------
void plsvpa()

Sets th",Useful
"/***************************************

Defaults for contour label printing.

***************************************/","-1. static int error;

 /***************************************

Defaults for contour label printing.

***************************************/

111",Useful
"/*Offset of label from contour line (if set to 0.0, labels are printed on the lines).*/","-9. static int error;

 /*Offset of label from contour line (if set to 0.0, labels are printed on the lines).*/

1. static PLFLT
2.     contlabel_offset = 0.006;",Useful
"/*Activate labels, default off*/","-2. static PLFLT
-1.     contlabel_space = 0.1;

 /*Activate labels, default off*/

1. static PLINT
2.     contlabel_active = 0;",Useful
"/*not an empty list, allocate new*/","-10.         currline->npts++;
-9.     }
-8.     else
-7.         plP_drawor( xx, yy );
-6. }
-5. static void
-4. cont_mv_store( PLFLT xx, PLFLT yy )
-3. {
-2.     if ( cont3d )
-1.     {

 /*not an empty list, allocate new*/

1.         {
2.             ",Useful
/*and fill first element*/,"-4.         {
-3.             currline->next = alloc_line( );
-2.             currline       = currline->next;
-1.         }

 /*and fill first element*/

1.         currline->x[0] = xx;
2.         currline->y[0] = yy;
3.         currline->npts = 1;
4.   ",Useful
"/*small routine to set offset and spacing of contour labels, see desciption above*/","-7.         currline->x[0] = xx;
-6.         currline->y[0] = yy;
-5.         currline->npts = 1;
-4.     }
-3.     else
-2.         plP_movwor( xx, yy );
-1. }

 /*small routine to set offset and spacing of contour labels, see desciption above*/

1. void",Useful
"/*small routine to set the format of the contour labels, description of limexp and prec see above*/","-7. void c_pl_setcontlabelparam( PLFLT offset, PLFLT size, PLFLT spacing, PLINT active )
-6. {
-5.     contlabel_offset = offset;
-4.     contlabel_size   = size;
-3.     contlabel_space  = spacing;
-2.     contlabel_active = active;
-1. }

 /*small routi",Useful
/*Ensure labels appear the right way up*/,"-10.     delta_y = plP_pcdcy( plsc->curry ) - plP_pcdcy( plP_wcpcy( tpy ) );
-9.     currx_old = plsc->currx;
-8.     curry_old = plsc->curry;
-7.     *distance += sqrt( delta_x * delta_x + delta_y * delta_y );
-6.     plP_drawor( tpx, tpy );
-5.     if (",Useful
"/*form[10] gives enough space for all non-malicious formats.
tmpstring[15] gives enough room for 3 digits in a negative exponent
or 4 digits in a positive exponent + null termination.  That
should be enough for all non-malicious use.
Obviously there are security issues here that
should be addressed as well.*/","-3. static void plfloatlabel( PLFLT value, char *string, PLINT len )
-2. {
-1.     PLINT setpre, precis;

 /*form[10] gives enough space for all non-malicious formats.
tmpstring[15] gives enough room for 3 digits in a negative exponent
or 4 digits in a po",Useful
"/*--------------------------------------------------------------------------
plf2eval2()

Does a lookup from a 2d function array.  plf2eval_data is treated as type
(PLfGrid2 *).
--------------------------------------------------------------------------*/","-5. static PLFLT
-4. plP_pcwcy( PLINT y )
-3. {
-2.     return ( ( y - plsc->wpyoff ) / plsc->wpyscl );
-1. }

 /*--------------------------------------------------------------------------
plf2eval2()

Does a lookup from a 2d function array.  plf2eval_dat",Useful
"/*--------------------------------------------------------------------------

cont_store:

Draw contour lines in memory.
cont_clean_store() must be called after use to release allocated memory.

--------------------------------------------------------------------------*/","-5. static PLFLT
-4. plP_pcwcy( PLINT y )
-3. {
-2.     return ( ( y - plsc->wpyoff ) / plsc->wpyscl );
-1. }

 /*--------------------------------------------------------------------------

cont_store:

Draw contour lines in memory.
cont_clean_store() mus",Useful
"/*--------------------------------------------------------------------------
void plcont()

Draws a contour plot from data in f(nx,ny).  Is just a front-end to
plfcont, with a particular choice for f2eval and f2eval_data.
--------------------------------------------------------------------------*/","-5. static PLFLT
-4. plP_pcwcy( PLINT y )
-3. {
-2.     return ( ( y - plsc->wpyoff ) / plsc->wpyscl );
-1. }

 /*--------------------------------------------------------------------------
void plcont()

Draws a contour plot from data in f(nx,ny).  Is jus",Useful
"/*--------------------------------------------------------------------------
void plfcont()

Draws a contour plot using the function evaluator f2eval and data stored
by way of the f2eval_data pointer.  This allows arbitrary organizations
of 2d array data to be used.

The subrange of indices used for contouring is kx to lx in the x
direction and from ky to ly in the y direction. The array of contour
levels is clevel(nlevel), and ""pltr"" is the name of a function which
transforms array indicies into world coordinates.

Note that the fortran-like minimum and maximum indices (kx, lx, ky, ly)
are translated into more C-like ones.  I've only kept them as they are
for the plfcont() argument list because of backward compatibility.
--------------------------------------------------------------------------*/","-5. static PLFLT
-4. plP_pcwcy( PLINT y )
-3. {
-2.     return ( ( y - plsc->wpyoff ) / plsc->wpyscl );
-1. }

 /*--------------------------------------------------------------------------
void plfcont()

Draws a contour plot using the function evaluator ",Useful
"/*--------------------------------------------------------------------------
void plcntr()

The contour for a given level is drawn here.  Note iscan has nx
elements. ixstor and iystor each have nstor elements.
--------------------------------------------------------------------------*/","-5. static PLFLT
-4. plP_pcwcy( PLINT y )
-3. {
-2.     return ( ( y - plsc->wpyoff ) / plsc->wpyscl );
-1. }

 /*--------------------------------------------------------------------------
void plcntr()

The contour for a given level is drawn here.  Note ",Useful
/*Follow and draw a contour*/,"-10.         {
-9.             ipts[kcol][krow] = 0;
-8.         }
-7.     }
-6.     for ( krow = ky; krow < ly; krow++ )
-5.     {
-4.         for ( kcol = kx; kcol < lx; kcol++ )
-3.         {
-2.             if ( ipts[kcol][krow] == 0 )
-1.            ",Useful
"/*--------------------------------------------------------------------------
void pldrawcn()

Follow and draw a contour.
--------------------------------------------------------------------------*/","-5. static PLFLT
-4. plP_pcwcy( PLINT y )
-3. {
-2.     return ( ( y - plsc->wpyoff ) / plsc->wpyscl );
-1. }

 /*--------------------------------------------------------------------------
void pldrawcn()

Follow and draw a contour.
----------------------",Useful
/*Check if no contour has been crossed i.e. iedge[i] = -1*/,"-1.     ipts[kcol][krow] = 1;

 /*Check if no contour has been crossed i.e. iedge[i] = -1*/

1.     if ( ( iedge[0] == -1 ) && ( iedge[1] == -1 ) && ( iedge[2] == -1 )
2.          && ( iedge[3] == -1 ) )
3.         return;",Useful
"/*Check if this is a completely flat square - in which case
ignore it*/","-3.     if ( ( iedge[0] == -1 ) && ( iedge[1] == -1 ) && ( iedge[2] == -1 )
-2.          && ( iedge[3] == -1 ) )
-1.         return;

 /*Check if this is a completely flat square - in which case
ignore it*/

1.     if ( ( f[0] == 0.0 ) && ( f[1] == 0.0 ) ",Useful
/*Calculate intersection points*/,"-3.     if ( ( f[0] == 0.0 ) && ( f[1] == 0.0 ) && ( f[2] == 0.0 ) &&
-2.          ( f[3] == 0.0 ) )
-1.         return;

 /*Calculate intersection points*/

1.     num = 0;
2.     if ( startedge < 0 )
3.     {
4.         first = 1;
5.     }
6.     else
7",Useful
/*If the contour is an edge check it hasn't already been done*/,"-10.     {
-9.         locx[num] = lastx;
-8.         locy[num] = lasty;
-7.         num++;
-6.         first = 0;
-5.     }
-4.     for ( k = 0, i = ( startedge < 0 ? 0 : startedge ); k < 4; k++, i = ( i + 1 ) % 4 )
-3.     {
-2.         if ( i == starte",Useful
/*If this is the start of the contour then move to the point*/,"-10.             if ( f[i] != 0.0 )
-9.             {
-8.                 locx[num] = ( px[i] * fabs( f[j] ) + px[j] * fabs( f[i] ) ) / fabs( f[j] - f[i] );
-7.                 locy[num] = ( py[i] * fabs( f[j] ) + py[j] * fabs( f[i] ) ) / fabs( f[j] - f[i",Useful
/*Link to the next point on the contour*/,"-9.             if ( first == 1 )
-8.             {
-7.                 cont_mv_store( locx[num], locy[num] );
-6.                 first      = 0;
-5.                 *distance  = 0;
-4.                 *lastindex = 0;
-3.             }
-2.             el",Useful
"/*Need to follow contour into next grid box
Easy case where contour does not pass through corner*/","-4.                 if ( contlabel_active )
-3.                     pl_drawcontlabel( locx[num], locy[num], flabel, distance, lastindex );
-2.                 else
-1.                     cont_xy_store( locx[num], locy[num] );

 /*Need to follow contour i",Useful
"/*Hard case where contour passes through corner
This is still not perfect - it may lose the contour
which won't upset the contour itself (we can find it
again later) but might upset the labelling*/","-10.                          ( ipts[kcolnext][krownext] == 0 ) )
-9.                     {
-8.                         pldrawcn( f2eval, f2eval_data,
-7.                             nx, ny, kx, lx, ky, ly, flev, flabel,
-6.                             kc",Useful
/*Move back to first point*/,"-10.                         pldrawcn( f2eval, f2eval_data,
-9.                             nx, ny, kx, lx, ky, ly, flev, flabel,
-8.                             kcolnext, krownext,
-7.                             locx[num], locy[num], inext, ipts,
-6.   ",Useful
"/*--------------------------------------------------------------------------
pltr0()

Identity transformation.
--------------------------------------------------------------------------*/","-5. static PLFLT
-4. plP_pcwcy( PLINT y )
-3. {
-2.     return ( ( y - plsc->wpyoff ) / plsc->wpyscl );
-1. }

 /*--------------------------------------------------------------------------
pltr0()

Identity transformation.
--------------------------------",Useful
"/*--------------------------------------------------------------------------
pltr1()

Does linear interpolation from singly dimensioned coord arrays.

Just abort for now if coordinates are out of bounds (don't think it's
possible, but if so we could use linear extrapolation).
--------------------------------------------------------------------------*/","-5. static PLFLT
-4. plP_pcwcy( PLINT y )
-3. {
-2.     return ( ( y - plsc->wpyoff ) / plsc->wpyscl );
-1. }

 /*--------------------------------------------------------------------------
pltr1()

Does linear interpolation from singly dimensioned coord a",Useful
/*ur is out of bounds*/,"-4.     else
-3.     {
-2.         xll = xg[ul][vl];
-1.         yll = yg[ul][vl];

 /*ur is out of bounds*/

1.         if ( ur == nx && vr < ny )
2.         {
3.             xlr = xg[ul][vr];
4.             ylr = yg[ul][vr];
5.             *tx = xll * (",Useful
/*vr is out of bounds*/,"-7.         if ( ur == nx && vr < ny )
-6.         {
-5.             xlr = xg[ul][vr];
-4.             ylr = yg[ul][vr];
-3.             *tx = xll * ( 1 - dv ) + xlr * ( dv );
-2.             *ty = yll * ( 1 - dv ) + ylr * ( dv );
-1.         }

 /*vr is ",Useful
/*both ur and vr are out of bounds*/,"-7.         else if ( ur < nx && vr == ny )
-6.         {
-5.             xrl = xg[ur][vl];
-4.             yrl = yg[ur][vl];
-3.             *tx = xll * ( 1 - du ) + xrl * ( du );
-2.             *ty = yll * ( 1 - du ) + yrl * ( du );
-1.         }

 /*b",Useful
"/*--------------------------------------------------------------------------
pltr2p()

Just like pltr2() but uses pointer arithmetic to get coordinates from 2d
grid tables.  This form of grid tables is compatible with those from
PLplot 4.0.  The grid data must be pointed to by a PLcGrid structure.
--------------------------------------------------------------------------*/","-5. static PLFLT
-4. plP_pcwcy( PLINT y )
-3. {
-2.     return ( ( y - plsc->wpyoff ) / plsc->wpyscl );
-1. }

 /*--------------------------------------------------------------------------
pltr2p()

Just like pltr2() but uses pointer arithmetic to get coo",Useful
/*ur is out of bounds*/,"-4.     else
-3.     {
-2.         xll = xg[ul][vl];
-1.         yll = yg[ul][vl];

 /*ur is out of bounds*/

1.         if ( ur == nx && vr < ny )
2.         {
3.             xlr = xg[ul][vr];
4.             ylr = yg[ul][vr];
5.             *tx = xll * (",Useful
/*vr is out of bounds*/,"-7.         if ( ur == nx && vr < ny )
-6.         {
-5.             xlr = xg[ul][vr];
-4.             ylr = yg[ul][vr];
-3.             *tx = xll * ( 1 - dv ) + xlr * ( dv );
-2.             *ty = yll * ( 1 - dv ) + ylr * ( dv );
-1.         }

 /*vr is ",Useful
/*both ur and vr are out of bounds*/,"-7.         else if ( ur < nx && vr == ny )
-6.         {
-5.             xrl = xg[ur][vl];
-4.             yrl = yg[ur][vl];
-3.             *tx = xll * ( 1 - du ) + xrl * ( du );
-2.             *ty = yll * ( 1 - du ) + yrl * ( du );
-1.         }

 /*b",Useful
/*ur is out of bounds*/,"-4.     else
-3.     {
-2.         xll = xg[ul][vl];
-1.         yll = yg[ul][vl];

 /*ur is out of bounds*/

1.         if ( ur == nx && vr < ny )
2.         {
3.             xlr = xg[ul][vr];
4.             ylr = yg[ul][vr];
5.             *tx = xll * (",Useful
/*vr is out of bounds*/,"-7.         if ( ur == nx && vr < ny )
-6.         {
-5.             xlr = xg[ul][vr];
-4.             ylr = yg[ul][vr];
-3.             *tx = xll * ( 1 - dv ) + xlr * ( dv );
-2.             *ty = yll * ( 1 - dv ) + ylr * ( dv );
-1.         }

 /*vr is ",Useful
/*both ur and vr are out of bounds*/,"-7.         else if ( ur < nx && vr == ny )
-6.         {
-5.             xrl = xg[ur][vl];
-4.             yrl = yg[ur][vl];
-3.             *tx = xll * ( 1 - du ) + xrl * ( du );
-2.             *ty = yll * ( 1 - du ) + yrl * ( du );
-1.         }

 /*b",Useful
"/*--------------------------------------------------------------------------
plarc_approx : Plot an approximated arc with a series of lines

! Takes the same arguments, with the same units, as c_plarc below.
! This is the fallback function in the event that the output
! device does not have native support for drawing arcs.
!
! @param x Center coordinate of the arc in x.
! @param y Center coordinate of the arc in y.
! @param a Radius of the arcs major axis.
! @param b Radius of the arcs minor axis.
! @param angle1 Start angle in degrees.
! @param angle2 End angle in degrees.
! @param rotate How much to rotate the arc?
! @param fill Fill the arc.
!
--------------------------------------------------------------------------*/","-4. #include ""plplotP.h""
-3. #define CIRCLE_SEGMENTS    ( PL_MAXPOLY - 1 )
-2. #define DEG_TO_RAD( x )    ( ( x ) * M_PI / 180.0 )
-1. void plarc_approx( PLFLT x, PLFLT y, PLFLT a, PLFLT b, PLFLT angle1, PLFLT angle2, PLFLT rotate, PLBOOL fill );

 /*----",Useful
/*The difference between the start and end angles*/,"-8. void
-7. plarc_approx( PLFLT x, PLFLT y, PLFLT a, PLFLT b, PLFLT angle1, PLFLT angle2, PLFLT rotate, PLBOOL fill )
-6. {
-5.     PLINT i;
-4.     PLFLT theta0, theta_step, theta, d_angle;
-3.     PLINT segments;
-2.     PLFLT xs[CIRCLE_SEGMENTS + 1], ",Useful
/*Calculate cosine and sine of angle of major axis wrt the x axis*/,"-3.     d_angle = DEG_TO_RAD( angle2 - angle1 );
-2.     if ( fabs( d_angle ) > M_PI * 2.0 )
-1.         d_angle = M_PI * 2.0;

 /*Calculate cosine and sine of angle of major axis wrt the x axis*/

1.     cphi = cos( DEG_TO_RAD( rotate ) );
2.     sphi = ",Useful
/*The number of line segments used to approximate the arc*/,"-2.     cphi = cos( DEG_TO_RAD( rotate ) );
-1.     sphi = sin( DEG_TO_RAD( rotate ) );

 /*The number of line segments used to approximate the arc*/

1.     segments = (PLINT) ( fabs( d_angle ) / ( 2.0 * M_PI ) * CIRCLE_SEGMENTS );",Useful
"/*Always use at least 2 arc points, otherwise fills will break.*/","-1.     segments = (PLINT) ( fabs( d_angle ) / ( 2.0 * M_PI ) * CIRCLE_SEGMENTS );

 /*Always use at least 2 arc points, otherwise fills will break.*/

1.     if ( segments < 2 )
2.         segments = 2;",Useful
"/*The start angle in radians and number of radians in each approximating
segment.*/","-2.     if ( segments < 2 )
-1.         segments = 2;

 /*The start angle in radians and number of radians in each approximating
segment.*/

1.     theta0 = DEG_TO_RAD( angle1 );
2.     theta_step = d_angle / ( segments - 1 );",Useful
/*The coordinates for the circle outline*/,"-2.     theta0 = DEG_TO_RAD( angle1 );
-1.     theta_step = d_angle / ( segments - 1 );

 /*The coordinates for the circle outline*/

1.     for ( i = 0; i < segments; i++ )
2.     {
3.         theta  = theta0 + theta_step * (PLFLT) i;
4.         ctheta =",Useful
/*Add the center point if we aren't drawing a circle*/,"-10.     for ( i = 0; i < segments; i++ )
-9.     {
-8.         theta  = theta0 + theta_step * (PLFLT) i;
-7.         ctheta = cos( theta );
-6.         stheta = sin( theta );
-5.         xs[i]  = x + a * ctheta * cphi - b * stheta * sphi;
-4.         ys[",Useful
/*Draw a filled arc*/,"-6.         if ( fabs( d_angle ) < M_PI * 2.0 )
-5.         {
-4.             xs[segments] = x;
-3.             ys[segments] = y;
-2.             segments++;
-1.         }

 /*Draw a filled arc*/

1.         plfill( segments, xs, ys );
2.     }
3.     els",Useful
/*Draw the arc outline*/,"-4.         plfill( segments, xs, ys );
-3.     }
-2.     else
-1.     {

 /*Draw the arc outline*/

1.         plline( segments, xs, ys );
2.     }
3. }",Useful
"/*--------------------------------------------------------------------------
plarc : Plot an arc

! Plot an Arc.
!  Takes the following arguments:
!
!   x, y:
!      x and y coordinates for the center of the arc
!
!   a, b:
!      Radius of the arc's major and minor axes
!
!   angle1:
!      Start angle (degrees)
!
!   angle2:
!      End angle (degrees)
!
!   fill:
!      Should the arc be filled
!
! @param x Center coordinate of the arc in x.
! @param y Center coordinate of the arc in y.
! @param a Radius of the arcs major axis.
! @param b Radius of the arcs minor axis.
! @param angle1 Start angle in degrees.
! @param angle2 End angle in degrees.
! @param rotate How much to rotate the arc?
! @param fill Fill the arc.
!

--------------------------------------------------------------------------*/","-4. #include ""plplotP.h""
-3. #define CIRCLE_SEGMENTS    ( PL_MAXPOLY - 1 )
-2. #define DEG_TO_RAD( x )    ( ( x ) * M_PI / 180.0 )
-1. void plarc_approx( PLFLT x, PLFLT y, PLFLT a, PLFLT b, PLFLT angle1, PLFLT angle2, PLFLT rotate, PLBOOL fill );

 /*----",Useful
"/*TODO: For now, only unrotated plots use the driver-accelerated path.*/","-6. void
-5. c_plarc( PLFLT x, PLFLT y, PLFLT a, PLFLT b, PLFLT angle1, PLFLT angle2, PLFLT rotate, PLBOOL fill )
-4. {
-3.     PLINT      xscl[2], yscl[2];
-2.     PLINT      clpxmi, clpxma, clpymi, clpyma;
-1.     arc_struct *arc_info;

 /*TODO: For now",Useful
/*Minor tick*/,"-7. void
-6. plwxtik( PLFLT x, PLFLT y, PLBOOL minor, PLBOOL invert )
-5. {
-4.     PLINT length, below, above;
-3.     PLFLT height;
-2.     if ( minor )
-1.     {

 /*Minor tick*/

1.         height = plsc->minht;
2.     }
3.     else
4.     {",Useful
/*Major tick*/,"-4.         height = plsc->minht;
-3.     }
-2.     else
-1.     {

 /*Major tick*/

1.         height = plsc->majht;
2.     }
3.     length = MAX( ROUND( height * plsc->ypmm ), 1 );
4.     if ( invert )
5.     {
6.         below = 0;
7.         above = l",Useful
/*Actually draw the tick*/,"-10.     if ( invert )
-9.     {
-8.         below = 0;
-7.         above = length;
-6.     }
-5.     else
-4.     {
-3.         below = length;
-2.         above = 0;
-1.     }

 /*Actually draw the tick*/

1.     plxtik( plP_wcpcx( x ), plP_wcpcy( y ), ",Useful
/*Minor tick*/,"-7. void
-6. plwxtik( PLFLT x, PLFLT y, PLBOOL minor, PLBOOL invert )
-5. {
-4.     PLINT length, below, above;
-3.     PLFLT height;
-2.     if ( minor )
-1.     {

 /*Minor tick*/

1.         height = plsc->minht;
2.     }
3.     else
4.     {",Useful
/*Major tick*/,"-4.         height = plsc->minht;
-3.     }
-2.     else
-1.     {

 /*Major tick*/

1.         height = plsc->majht;
2.     }
3.     length = MAX( ROUND( height * plsc->ypmm ), 1 );
4.     if ( invert )
5.     {
6.         below = 0;
7.         above = l",Useful
/*Actually draw the tick*/,"-10.     if ( invert )
-9.     {
-8.         below = 0;
-7.         above = length;
-6.     }
-5.     else
-4.     {
-3.         below = length;
-2.         above = 0;
-1.     }

 /*Actually draw the tick*/

1.     plxtik( plP_wcpcx( x ), plP_wcpcy( y ), ",Useful
"/*--------------------------------------------------------------------------
Call syntax for plshade():

void plshade(PLFLT *a, PLINT nx, PLINT ny, char *defined,
PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
PLFLT shade_min, PLFLT shade_max,
PLINT sh_color, PLFLT sh_width, PLINT min_color, PLFLT min_width,
PLINT max_color, PLFLT max_width, void (*fill)(), PLINT
rectangular, ...)

arguments:

PLFLT &(a[0][0])

Contains array to be plotted. The array must have been declared as
PLFLT a[nx][ny].  See following note on fortran-style arrays.

PLINT nx, ny

Dimension of array ""a"".

char &(defined[0][0])

Contains array of flags, 1 = data is valid, 0 = data is not valid.
This array determines which sections of the data is to be plotted.
This argument can be NULL if all the values are valid.  Must have been
declared as char defined[nx][ny].

PLFLT xmin, xmax, ymin, ymax

Defines the ""grid"" coordinates.  The data a[0][0] has a position of
(xmin,ymin).

void (*mapform)()

Transformation from `grid' coordinates to world coordinates.  This
pointer to a function can be NULL in which case the grid coordinates
are the same as the world coordinates.

PLFLT shade_min, shade_max

Defines the interval to be shaded. If shade_max <= shade_min, plshade
does nothing.

PLINT sh_cmap, PLFLT sh_color, PLFLT sh_width

Defines color map, color map index, and width used by the fill pattern.

PLINT min_color, PLFLT min_width, PLINT max_color, PLFLT max_width

Defines pen color, width used by the boundary of shaded region. The min
values are used for the shade_min boundary, and the max values are used
on the shade_max boundary.  Set color and width to zero for no plotted
boundaries.

void (*fill)()

Routine used to fill the region.  Use plfill.  Future version of plplot
may have other fill routines.

PLINT rectangular

Flag. Set to 1 if rectangles map to rectangles after (*mapform)() else
set to zero. If rectangular is set to 1, plshade tries to save time by
filling large rectangles.  This optimization fails if (*mapform)()
distorts the shape of rectangles.  For example a plot in polor
coordinates has to have rectangular set to zero.

Example mapform's:

Grid to world coordinate transformation.
This example goes from a r-theta to x-y for a polar plot.

void mapform(PLINT n, PLFLT *x, PLFLT *y) {
int i;
double r, theta;
for (i = 0; i < n; i++) {
r = x[i];
theta = y[i];
x[i] = r*cos(theta);
y[i] = r*sin(theta);
}
}

Grid was in cm, convert to world coordinates in inches.
Expands in x direction.

void mapform(PLINT n, PLFLT *x, PLFLT *y) {
int i;
for (i = 0; i < n; i++) {
x[i] = (1.0 / 2.5) * x[i];
y[i] = (1.0 / 2.5) * y[i];
}
}

--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*The constants in order mean
(1) color map1,
(0, 0, 0, 0) all edge effects will be done with plcont rather
than the normal plshade drawing which gets partially blocked
when sequential shading is done as in the present case*/","-8.     color_min   = plsc->cmap1_min;
-7.     color_max   = plsc->cmap1_max;
-6.     color_range = color_max - color_min;
-5.     for ( i = 0; i < nlevel - 1; i++ )
-4.     {
-3.         shade_min   = clevel[i];
-2.         shade_max   = clevel[i + 1];
-",Useful
"/*plc2eval, (PLPointer) &cgrid,*/","-10. plshade_null( PLFLT_MATRIX a, PLINT nx, PLINT ny, PLDEFINED_callback defined,
-9.               PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-8.               PLFLT shade_min, PLFLT shade_max,
-7.               PLINT sh_cmap, PLFLT sh_color, PLFLT",Useful
"/*plc2eval, (PLPointer) &cgrid,*/","-10. plshade_null( PLFLT_MATRIX a, PLINT nx, PLINT ny, PLDEFINED_callback defined,
-9.               PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-8.               PLFLT shade_min, PLFLT shade_max,
-7.               PLINT sh_cmap, PLFLT sh_color, PLFLT",Useful
/*plshade1 deprecated as of plplot-5.14.0*/,"-7.         defined, nx, ny, xmin,
-6.         xmax, ymin, ymax, shade_min, shade_max,
-5.         sh_cmap, sh_color, sh_width,
-4.         min_color, min_width, max_color, max_width,
-3.         fill, rectangular, pltr, pltr_data );
-2. }
-1. #ifdef PL_D",Useful
"/*plc2eval, (PLPointer) &cgrid,*/","-10. plshade_null( PLFLT_MATRIX a, PLINT nx, PLINT ny, PLDEFINED_callback defined,
-9.               PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-8.               PLFLT shade_min, PLFLT shade_max,
-7.               PLINT sh_cmap, PLFLT sh_color, PLFLT",Useful
/*PL_DEPRECATED*/,"-6.         defined, nx, ny, xmin,
-5.         xmax, ymin, ymax, shade_min, shade_max,
-4.         sh_cmap, sh_color, sh_width,
-3.         min_color, min_width, max_color, max_width,
-2.         fill, rectangular, pltr, pltr_data );
-1. }
#ifdef PL_DEPRE",Useful
"/*plc2eval, (PLPointer) &cgrid,*/","-10. plshade_null( PLFLT_MATRIX a, PLINT nx, PLINT ny, PLDEFINED_callback defined,
-9.               PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax,
-8.               PLFLT shade_min, PLFLT shade_max,
-7.               PLINT sh_cmap, PLFLT sh_color, PLFLT",Useful
"/*--------------------------------------------------------------------------
plshade_int()

Shade region -- this routine does all the work

This routine is internal so the arguments can and will change.
To retain some compatibility between versions, you must go through
some stub routine!

4/95

parameters:

f2eval, f2eval_data:  data to plot
defined: defined mask (old API - implimented)
nx, ny: array dimensions
xmin, xmax, ymin, ymax: grid coordinates
shade_min, shade_max: shade region with values between ...
sh_cmap, sh_color, sh_width: shading parameters, width is only for hatching
min_color, min_width: line parameters for boundary (minimum)
max_color, max_width: line parameters for boundary (maximum)
set min_width == 0 and max_width == 0 for no contours
fill: fill function, set to NULL for no shading (contour plot)
rectangular: flag set to 1 if pltr() maps rectangles to rectangles
this helps optimize the plotting
pltr: function to map from grid to plot coordinates


--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*Cast to void to silence compiler warning about unused parameter*/,"-10.              PLINT min_color, PLFLT min_width,
-9.              PLINT max_color, PLFLT max_width,
-8.              PLFILL_callback fill, PLINT rectangular,
-7.              PLTRANSFORM_callback pltr, PLPointer pltr_data )
-6. {
-5.     PLINT n, slope",Useful
"/*alloc space for value array, and initialize
This is only a temporary kludge*/","-10.             plcol0( (PLINT) sh_color );
-9.             break;
-8.         case 1:
-7.             plcol1( sh_color );
-6.             break;
-5.         default:
-4.             plabort( ""plfshade: invalid color map selection"" );
-3.             ret",Useful
/*No filling needs to be done for these cases*/,"-10.     dy = ( ymax - ymin ) / ( ny - 1 );
-9.     a0 = a;
-8.     a1 = a + ny;
-7.     c0 = c;
-6.     c1 = c + ny;
-5.     for ( ix = 0; ix < nx - 1; ix++ )
-4.     {
-3.         for ( iy = 0; iy < ny - 1; iy++ )
-2.         {
-1.             count = c",Useful
/*Only part of rectangle can be filled*/,"-10.                     {
-9.                         x[i] = xmin + x[i] * dx;
-8.                         y[i] = ymin + y[i] * dy;
-7.                     }
-6.                 }
-5.                 if ( fill != NULL )
-4.                     exfill( fi",Useful
/*special cases: check number of times a contour is in a box*/,"-10.                     y[i] = ymin + y[i] * dy;
-9.                 }
-8.             }
-7.             if ( min_points == 4 )
-6.                 slope = plctestez( a, nx, ny, ix, iy, shade_min );
-5.             if ( max_points == 4 )
-4.             ",Useful
/*2 contour lines in box*/,"-9.             switch ( ( min_points << 3 ) + max_points )
-8.             {
-7.             case 000:
-6.             case 020:
-5.             case 002:
-4.             case 022:
-3.                 if ( fill != NULL && n > 0 )
-2.                     ",Useful
/*3 contours*/,"-10.                     selected_polygon( fill, defined, x, y, 4, 5, 6, 7 );
-9.                 }
-8.                 else
-7.                 {
-6.                     selected_polygon( fill, defined, x, y, 0, 1, 6, 7 );
-5.                     selecte",Useful
/*expand in vertical*/,"-10.     ok_x = ok_y = 1;
-9.     x    = y = 2;
-8.     while ( ok_x || ok_y )
-7.     {
-6. #ifdef RATIO
-5.         if ( RATIO * x <= y || RATIO * y <= x )
-4.             break;
-3. #endif
-2.         if ( ok_y )
-1.         {

 /*expand in vertical*/
",Useful
"/*--------------------------------------------------------------------------

plctest( &(x[0][0]), PLFLT level)
where x was defined as PLFLT x[4][4];

determines if the contours associated with level have
positive slope or negative slope in the box:

(2,3)   (3,3)

(2,2)   (3,2)

this is heuristic and can be changed by the user

return 1 if positive slope
0 if negative slope

algorithmn:
1st test:
find length of contours assuming positive and negative slopes
if the length of the negative slope contours is much bigger
than the positive slope, then the slope is positive.
(and vice versa)
(this test tries to minimize the length of contours)

2nd test:
if abs((top-right corner) - (bottom left corner)) >
abs((top-left corner) - (bottom right corner)) ) then
return negatiave slope.
(this test tries to keep the slope for different contour levels
the same)
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*find min contour*/,"-10.         temp = sorted[j];
-9.         i    = j - 1;
-8.         while ( i >= 0 && sorted[i] > temp )
-7.         {
-6.             sorted[i + 1] = sorted[i];
-5.             i--;
-4.         }
-3.         sorted[i + 1] = temp;
-2.     }

 /*find min ",Useful
/*one contour line*/,"-3.     temp = int_val * ceil( sorted[0] / int_val );
-2.     if ( temp < sorted[1] )
-1.     {

 /*one contour line*/

1.         for ( i = 0; i < 4; i++ )
2.         {
3.             if ( t[i] < temp )
4.                 return i / 2;
5.         }
6.   ",Useful
/*find max contour*/,"-6.         for ( i = 0; i < 4; i++ )
-5.         {
-4.             if ( t[i] < temp )
-3.                 return i / 2;
-2.         }
-1.     }

 /*find max contour*/

1.     temp = int_val * floor( sorted[3] / int_val );
2.     if ( temp > sorted[2] )
3",Useful
/*one contour line*/,"-3.     temp = int_val * ceil( sorted[0] / int_val );
-2.     if ( temp < sorted[1] )
-1.     {

 /*one contour line*/

1.         for ( i = 0; i < 4; i++ )
2.         {
3.             if ( t[i] < temp )
4.                 return i / 2;
5.         }
6.   ",Useful
/*nothing better to do - be consistant*/,"-6.         for ( i = 0; i < 4; i++ )
-5.         {
-4.             if ( t[i] > temp )
-3.                 return i / 2;
-2.         }
-1.     }

 /*nothing better to do - be consistant*/

1.     return POSITIVE_SLOPE;
2. }",Useful
/*To keep track of whether a sofware fallback warning has been issued.*/,"-10. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-9. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-8. // GNU Library General Public License for more details.
-7. //
-6. // You should have received a copy of the GN",Useful
/*Check the original number of points*/,"-10.         {
-9.             n++;
-8.             xpoly[n - 1] = plP_wcpcx( x[0] );
-7.             ypoly[n - 1] = plP_wcpcy( y[0] );
-6.         }
-5.         plP_plfclp( xpoly, ypoly, n, plsc->clpxmi, plsc->clpxma,
-4.             plsc->clpymi, plsc->",Useful
"/*--------------------------------------------------------------------------
Transformations returning physical coordinates.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
Transformations returning device coordinates.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*world coords into device coords (x)*/,"-5. PLFLT
-4. plP_mmdcy( PLFLT y )
-3. {
-2.     return ( (PLFLT) ( y * plsc->ypmm / ABS( plsc->phyyma - plsc->phyymi ) ) );
-1. }

 /*world coords into device coords (x)*/

1. PLFLT
2. plP_wcdcx( PLFLT x )
3. {
4.     return ( (PLFLT) ( plsc->wdxoff + pl",Useful
/*world coords into device coords (y)*/,"-5. PLFLT
-4. plP_wcdcx( PLFLT x )
-3. {
-2.     return ( (PLFLT) ( plsc->wdxoff + plsc->wdxscl * x ) );
-1. }

 /*world coords into device coords (y)*/

1. PLFLT
2. plP_wcdcy( PLFLT y )
3. {
4.     return ( (PLFLT) ( plsc->wdyoff + plsc->wdyscl * y ) );
",Useful
/*subpage coords to device coords (x)*/,"-5. PLFLT
-4. plP_wcdcy( PLFLT y )
-3. {
-2.     return ( (PLFLT) ( plsc->wdyoff + plsc->wdyscl * y ) );
-1. }

 /*subpage coords to device coords (x)*/

1. PLFLT
2. plP_scdcx( PLFLT x )
3. {
4.     return ( (PLFLT) ( plsc->spdxmi + ( plsc->spdxma - plsc-",Useful
/*subpage coords to device coords (y)*/,"-5. PLFLT
-4. plP_scdcx( PLFLT x )
-3. {
-2.     return ( (PLFLT) ( plsc->spdxmi + ( plsc->spdxma - plsc->spdxmi ) * x ) );
-1. }

 /*subpage coords to device coords (y)*/

1. PLFLT
2. plP_scdcy( PLFLT y )
3. {
4.     return ( (PLFLT) ( plsc->spdymi + ( p",Useful
"/*--------------------------------------------------------------------------
Transformations returning millimeters.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*--------------------------------------------------------------------------
Transformations returning subpage coordinates.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
/*device coords to subpage coords (x)*/,"-8. PLFLT
-7. plP_wcmmy( PLFLT y )
-6. {
-5.     return ( (PLFLT) ( plsc->wmyoff + plsc->wmyscl * y ) );
-4. }

 /*device coords to subpage coords (x)*/

1. PLFLT
2. plP_dcscx( PLFLT x )
3. {
4.     return ( (PLFLT) ( ( x - plsc->spdxmi ) / ( plsc->spdxma",Useful
/*device coords to subpage coords (y)*/,"-5. PLFLT
-4. plP_dcscx( PLFLT x )
-3. {
-2.     return ( (PLFLT) ( ( x - plsc->spdxmi ) / ( plsc->spdxma - plsc->spdxmi ) ) );
-1. }

 /*device coords to subpage coords (y)*/

1. PLFLT
2. plP_dcscy( PLFLT y )
3. {
4.     return ( (PLFLT) ( ( y - plsc->sp",Useful
"/*--------------------------------------------------------------------------
3-d plot transformations.
--------------------------------------------------------------------------*/","-10. // PLplot is distributed in the hope that it will be useful,
-9. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. // GNU Library General Public License for more",Useful
"/*3-d coords to 2-d projection (x)
See c_plw3d for a mathematical explanation of the transformation.*/","-8. PLFLT
-7. plP_dcscy( PLFLT y )
-6. {
-5.     return ( (PLFLT) ( ( y - plsc->spdymi ) / ( plsc->spdyma - plsc->spdymi ) ) );
-4. }

 /*3-d coords to 2-d projection (x)
See c_plw3d for a mathematical explanation of the transformation.*/

1. PLFLT
2. plP",Useful
"/*3-d coords to 2-d projection (y)
See c_plw3d for a mathematical explanation of the transformation.*/","PLFLT
plP_w3wcy( PLFLT x, PLFLT y, PLFLT z )
{
    return ( (PLFLT) ( ( x - plsc->basecx ) * plsc->cyx +
                       ( y - plsc->basecy ) * plsc->cyy +
                       ( z - plsc->ranmi ) * plsc->cyz ) );
}

 /*3-d coords to 2-d projection (y)
See c_plw3d for a mathematical explanation of the transformation.*/

1. PLFLT
2. plP_w3wcz( PLFLT x, PLFLT y, PLFLT z )
3. {
4.     return ( (PLFLT) ( ( x - plsc->basecx ) * plsc->czx +
5.                        ( y - plsc->basecy ) * plsc->czy +
6.                        ( z - plsc->ranmi ) * plsc->czz ) );
7. }",Useful
"/*3-d coords to 2-d projection (z), if that makes any sense...
See c_plw3d for a mathematical explanation of the transformation.*/","-7. PLFLT
-6. plP_w3wcy( PLFLT x, PLFLT y, PLFLT z )
-5. {
-4.     return ( (PLFLT) ( ( x - plsc->basecx ) * plsc->cyx +
-3.                        ( y - plsc->basecy ) * plsc->cyy +
-2.                        ( z - plsc->ranmi ) * plsc->cyz ) );
-1. }

 ",Useful
/*Best to just warn and recover on bounds errors*/,"-10. c_plwind( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax )
-9. {
-8.     PLFLT    dx, dy, mmxmi, mmxma, mmymi, mmyma;
-7.     PLFLT    xvpwxmin, xvpwxmax, xvpwymin, xvpwymax;
-6.     PLWindow w;
-5.     if ( plsc->level < 2 )
-4.     {
-3.         pl",Useful
"/*The true plot window is made slightly larger than requested so that
the end limits will be on the graph
Get the (slightly extended) window limits.*/","-10.     }
-9.     if ( ymin == ymax )
-8.     {
-7.         plwarn( ""plwind: Invalid window limits in y."" );
-6.         ymin--; ymax++;
-5.     }
-4.     plsc->vpwxmi = xmin;
-3.     plsc->vpwxma = xmax;
-2.     plsc->vpwymi = ymin;
-1.     plsc->vpwyma",Useful
/*Compute the scaling between coordinate systems*/,"-1.     plP_xgvpw( &xvpwxmin, &xvpwxmax, &xvpwymin, &xvpwymax );

 /*Compute the scaling between coordinate systems*/

1.     dx = xvpwxmax - xvpwxmin;
2.     dy = xvpwymax - xvpwymin;
3.     plsc->wpxscl = ( plsc->vppxma - plsc->vppxmi ) / dx;
4.     pls",Useful
/*Set transformation variables for world coordinates to mm*/,"-10.     dx = xvpwxmax - xvpwxmin;
-9.     dy = xvpwymax - xvpwymin;
-8.     plsc->wpxscl = ( plsc->vppxma - plsc->vppxmi ) / dx;
-7.     plsc->wpxoff = ( xmax * plsc->vppxmi - xmin * plsc->vppxma ) / dx;
-6.     plsc->wpyscl = ( plsc->vppyma - plsc->vppy",Useful
/*Set transformation variables for world coordinates to device coords*/,"-4.     plsc->wmxscl = ( mmxma - mmxmi ) / dx;
-3.     plsc->wmxoff = ( xmax * mmxmi - xmin * mmxma ) / dx;
-2.     plsc->wmyscl = ( mmyma - mmymi ) / dy;
-1.     plsc->wmyoff = ( ymax * mmymi - ymin * mmyma ) / dy;

 /*Set transformation variables for wo",Useful
/*Register plot window attributes*/,"-4.     plsc->wdxscl = plsc->wmxscl * plsc->xpmm / ( plsc->phyxma - plsc->phyxmi );
-3.     plsc->wdxoff = plsc->wmxoff * plsc->xpmm / ( plsc->phyxma - plsc->phyxmi );
-2.     plsc->wdyscl = plsc->wmyscl * plsc->ypmm / ( plsc->phyyma - plsc->phyymi );
-1.",Useful
/*Open the clip limits to the subpage limits*/,"-10.     PLINT  vppxmi, vppxma, vppymi, vppyma;
-9.     PLFLT  xtick1, ytick1, vpwxmi, vpwxma, vpwymi, vpwyma;
-8.     PLFLT  vpwxmin, vpwxmax, vpwymin, vpwymax;
-7.     PLFLT  xp0, yp0, tn, tp, temp;
-6.     PLFLT  factor, tstart;
-5.     if ( plsc->leve",Useful
/*Plot axes only if they are inside viewport.*/,"-4.     vpwxmi = ( vpwxmax > vpwxmin ) ? vpwxmin : vpwxmax;
-3.     vpwxma = ( vpwxmax > vpwxmin ) ? vpwxmax : vpwxmin;
-2.     vpwymi = ( vpwymax > vpwymin ) ? vpwymin : vpwymax;
-1.     vpwyma = ( vpwymax > vpwymin ) ? vpwymax : vpwymin;

 /*Plot axes o",Useful
/*Calculate tick spacing*/,"-2.     lax = lax && vpwymi < y0 && y0 < vpwyma;
-1.     lay = lay && vpwxmi < x0 && x0 < vpwxma;

 /*Calculate tick spacing*/

1.     if ( ltx || lgx || lxx )
2.         pldtik( vpwxmi, vpwxma, &xtick1, &nxsub1, ldx );
3.     if ( lty || lgy || lxy )
4. ",Useful
"/*Carefully follow logic below (and above) for the case where
an inverted major tick mark is written (in the X direction
for a Y axis and vice versa).  Ignore minor tick marks
which are assumed to be smaller.  Ignore axes and grids
which are all contained within the viewport.*/","-10.     }
-9.     else
-8.     {
-7.         i1y = 0;
-6.         i2y = yminor;
-5.         i3y = 0;
-4.         i4y = ymajor;
-3.     }
-2.     if ( plsc->if_boxbb )
-1.     {

 /*Carefully follow logic below (and above) for the case where
an inverted m",Useful
/*Draw the bottom frame of the box*/,"-10.             plsc->boxbb_ymin -= xmajor / plsc->ypmm;
-9.         if ( liy && ( lcy || lwy ) && ( lty && !lxy ) )
-8.             plsc->boxbb_xmax += ymajor / plsc->xpmm;
-7.         if ( lix && ( lcx || lwx ) && ( ltx && !lxx ) )
-6.             plsc",Useful
/*Draw the right-hand frame of box*/,"-10.                             }
-9.                         }
-8.                     }
-7.                     if ( !BETW( tn, vpwxmi, vpwxma ) )
-6.                         break;
-5.                     plxtik( plP_wcpcx( tn ), vppymi, i3x, i4x );
-",Useful
/*Draw the top frame of the box*/,"-10.                             }
-9.                         }
-8.                     }
-7.                     if ( !BETW( tn, vpwymi, vpwyma ) )
-6.                         break;
-5.                     plytik( vppxma, plP_wcpcy( tn ), i4y, i3y );
-",Useful
/*Draw the left-hand frame of box*/,"-10.                             }
-9.                         }
-8.                     }
-7.                     if ( !BETW( tn, vpwxmi, vpwxma ) )
-6.                         break;
-5.                     plxtik( plP_wcpcx( tn ), vppyma, i4x, i3x );
-",Useful
/*Draw the horizontal axis.*/,"-10.                             }
-9.                         }
-8.                     }
-7.                     if ( !BETW( tn, vpwymi, vpwyma ) )
-6.                         break;
-5.                     plytik( vppxmi, plP_wcpcy( tn ), i3y, i4y );
-",Useful
/*Convert world coordinates to physical*/,"-2.         if ( lax )
-1.         {

 /*Convert world coordinates to physical*/

1.             yp0 = plP_wcpcy( y0 );
2.             plP_movphy( vppxmi, (PLINT) yp0 );
3.             plP_draphy( vppxma, (PLINT) yp0 );
4.             if ( ltx && !lxx )
5",Useful
/*Draw the vertical axis.*/,"-10.                             }
-9.                         }
-8.                     }
-7.                     if ( !BETW( tn, vpwxmi, vpwxma ) )
-6.                         break;
-5.                     plxtik( plP_wcpcx( tn ), (PLINT) yp0, xmajor, ",Useful
/*Convert world coordinates to physical*/,"-2.         if ( lax )
-1.         {

 /*Convert world coordinates to physical*/

1.             yp0 = plP_wcpcy( y0 );
2.             plP_movphy( vppxmi, (PLINT) yp0 );
3.             plP_draphy( vppxma, (PLINT) yp0 );
4.             if ( ltx && !lxx )
5",Useful
/*save tick spacing*/,"-4.     plP_gzback( &zbflg, &zbcol, &zbtck, &zbwidth );
-3.     *zbflg = plP_stsearch( zopt, 'd' );
-2.     if ( *zbflg )
-1.     {

 /*save tick spacing*/

111",Useful
/*and color*/,"-5.     plP_gzback( &zbflg, &zbcol, &zbtck, &zbwidth );
-4.     *zbflg = plP_stsearch( zopt, 'd' );
-3.     if ( *zbflg )
-2.     {

 /*and color*/

111",Useful
/*and line width*/,"-6.     plP_gzback( &zbflg, &zbcol, &zbtck, &zbwidth );
-5.     *zbflg = plP_stsearch( zopt, 'd' );
-4.     if ( *zbflg )
-3.     {

 /*and line width*/

1.     }
2.     if ( cxx >= 0.0 && cxy <= 0.0 )
3.     {
4.         ln = plP_stsearch( xopt, 'n' );
5",Useful
"/*--------------------------------------------------------------------------
Support routines for 3d box draw.
--------------------------------------------------------------------------*/","-10. static void
-9. label_box( PLCHAR_VECTOR xopt, PLFLT xtick1, PLCHAR_VECTOR yopt, PLFLT ytick1 );
-8. static void
-7. plP_default_label_log( PLINT axis, PLFLT value, char *string, PLINT len, void *data );
-6. static void
-5. plP_default_label_log_fixe",Useful
/*Label the line*/,"-10.             if ( !BETW( temp, vmin, vmax ) )
-9.                 break;
-8.             lambda = ( vmax_in > vmin_in ) ?
-7.                      ( temp - vmin ) / ( vmax - vmin ) :
-6.                      ( vmax - temp ) / ( vmax - vmin );
-5.     ",Useful
/*Label the line*/,"-10.             if ( !BETW( temp, vmin, vmax ) )
-9.                 break;
-8.             lambda = ( vmax_in > vmin_in ) ?
-7.                      ( temp - vmin ) / ( vmax - vmin ) :
-6.                      ( vmax - temp ) / ( vmax - vmin );
-5.     ",Useful
/*Draw grid in x direction.*/,"-4.     vpwxmi = ( vpwxmax > vpwxmin ) ? vpwxmin : vpwxmax;
-3.     vpwxma = ( vpwxmax > vpwxmin ) ? vpwxmax : vpwxmin;
-2.     vpwymi = ( vpwymax > vpwymin ) ? vpwymin : vpwymax;
-1.     vpwyma = ( vpwymax > vpwymin ) ? vpwymax : vpwymin;

 /*Draw grid i",Useful
/*Draw grid in y direction*/,"-10.                         if ( BETW( temp, vpwxmi + tcrit, vpwxma - tcrit ) )
-9.                             pljoin( temp, vpwymi, temp, vpwyma );
-8.                     }
-7.                 }
-6.             }
-5.             tcrit = xtick1 * tspac",Useful
"/*pos, height, and just are unnecessarily set to quiet
-O3 -Wuninitialized warnings that are obvious false alarms from
the clarity of the code associated with the true or false
result for custom_exponent_placement.*/","-1.     PLBOOL custom_exponent_placement = !plsc->label_func && plsc->label_data;

 /*pos, height, and just are unnecessarily set to quiet
-O3 -Wuninitialized warnings that are obvious false alarms from
the clarity of the code associated with the true or ",Useful
/*Write label(s) for horizontal axes.*/,"-4.     vpwxmi = ( vpwxmax > vpwxmin ) ? vpwxmin : vpwxmax;
-3.     vpwxma = ( vpwxmax > vpwxmin ) ? vpwxmax : vpwxmin;
-2.     vpwymi = ( vpwymax > vpwymin ) ? vpwymin : vpwymax;
-1.     vpwyma = ( vpwymax > vpwymin ) ? vpwymax : vpwymin;

 /*Write label",Useful
/*Bottom axis.*/,"-10.                   ( vpwxma - tn ) / ( vpwxma - vpwxmi );
-9.             if ( plsc->if_boxbb )
-8.             {
-7.                 string_length_mm = plstrl( string );
-6.                 pos_mm           = ( plsc->vppxmi + pos *
-5.               ",Useful
/*Top axis.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""b"", height, pos, 0.5, s",Useful
/*Write label(s) for vertical axes.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""t"", height, pos, just, ",Useful
/*Left axis with text written perpendicular to edge.*/,"-10.             {
-9.                 plform( PL_Y_AXIS, tn, yscale, yprec, string, STRING_LEN, lly, lfy, loy );
-8.             }
-7.             pos = ( vpwymax > vpwymin ) ?
-6.                   ( tn - vpwymi ) / ( vpwyma - vpwymi ) :
-5.            ",Useful
"/*Expected offset is 0.5, but adjust to improve
look of result.*/","-7.                         height_mm        = ( height + 0.0 ) * char_height_mm;
-6.                         string_length_mm = plstrl( string );
-5.                         plsc->boxbb_xmin = MIN( plsc->boxbb_xmin, plsc->vppxmi /
-4.                    ",Useful
/*Left axis with text written parallel to edge.*/,"-10.                         plsc->boxbb_ymax = MAX( plsc->boxbb_ymax,
-9.                             pos_mm + 0.7 * char_height_mm );
-8.                     }
-7.                     else
-6.                     {
-5.                         plmtex( ""l",Useful
/*Right axis with text written perpendicular to edge.*/,"-10.                     else
-9.                     {
-8.                         plmtex( ""l"", height, pos, 0.5, string );
-7.                     }
-6.                 }
-5.             }
-4.             if ( lmy )
-3.             {
-2.                ",Useful
"/*Expected offset is 0.5, but adjust to improve
look of result.*/","-7.                         height_mm        = ( height + 0.0 ) * char_height_mm;
-6.                         string_length_mm = plstrl( string );
-5.                         plsc->boxbb_xmin = MIN( plsc->boxbb_xmin, plsc->vppxmi /
-4.                    ",Useful
/*Right axis with text written parallel to edge.*/,"-10.                         plsc->boxbb_ymax = MAX( plsc->boxbb_ymax,
-9.                             pos_mm + 0.7 * char_height_mm );
-8.                     }
-7.                     else
-6.                     {
-5.                         plmtex( ""r",Useful
"/*more space to clear labels in ""v"" mode*/","-10.         {
-9.             snprintf( string, STRING_LEN, ""(x10%su%d%sd)"", esc_string, (int) yscale, esc_string );
-8.             if ( custom_exponent_placement )
-7.             {
-6.                 height = ( (PLLabelDefaults *) plsc->label_data )-",Useful
/*Extra space for superscript*/,"-4.             if ( lmy )
-3.             {
-2.                 if ( !custom_exponent_placement )
-1.                 {

 /*Extra space for superscript*/

1.                     pos    = 1.0 + offset;
2.                     just   = 0.5;
3.              ",Useful
"/*pos, height, and just are unnecessarily set to quiet
-O3 -Wuninitialized warnings that are obvious false alarms from
the clarity of the code associated with the true or false
result for custom_exponent_placement.*/","-1.     PLBOOL custom_exponent_placement = !plsc->label_func && plsc->label_data;

 /*pos, height, and just are unnecessarily set to quiet
-O3 -Wuninitialized warnings that are obvious false alarms from
the clarity of the code associated with the true or ",Useful
/*Set plot options from input*/,"-5.         plsc->boxbb_xmin = plsc->vppxmi / plsc->xpmm;
-4.         plsc->boxbb_xmax = plsc->vppxma / plsc->xpmm;
-3.         plsc->boxbb_ymin = plsc->vppymi / plsc->ypmm;
-2.         plsc->boxbb_ymax = plsc->vppyma / plsc->ypmm;
-1.     }

 /*Set plot ",Useful
"/*Carefully follow logic below for the case where
an inverted major tick mark is written (in the X direction
for a Y axis and vice versa).  Ignore minor tick marks
which are assumed to be smaller.*/","-4.         plsc->boxbb_xmin = plsc->vppxmi / plsc->xpmm;
-3.         plsc->boxbb_xmax = plsc->vppxma / plsc->xpmm;
-2.         plsc->boxbb_ymin = plsc->vppymi / plsc->ypmm;
-1.         plsc->boxbb_ymax = plsc->vppyma / plsc->ypmm;

 /*Carefully follow lo",Useful
/*Write label(s) for horizontal axes.*/,"-4.     vpwxmi = ( vpwxmax > vpwxmin ) ? vpwxmin : vpwxmax;
-3.     vpwxma = ( vpwxmax > vpwxmin ) ? vpwxmax : vpwxmin;
-2.     vpwymi = ( vpwymax > vpwymin ) ? vpwymin : vpwymax;
-1.     vpwyma = ( vpwymax > vpwymin ) ? vpwymax : vpwymin;

 /*Write label",Useful
/*Bottom axis.*/,"-10.                   ( vpwxma - tn ) / ( vpwxma - vpwxmi );
-9.             if ( plsc->if_boxbb )
-8.             {
-7.                 string_length_mm = plstrl( string );
-6.                 pos_mm           = ( plsc->vppxmi + pos *
-5.               ",Useful
/*Top axis.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""b"", height, pos, 0.5, s",Useful
/*Write label(s) for vertical axes.*/,"-10.                     plsc->boxbb_xmax = MAX( plsc->boxbb_xmax,
-9.                         pos_mm + 0.5 * string_length_mm );
-8.                 }
-7.                 else
-6.                 {
-5.                     plmtex( ""t"", height, pos, just, ",Useful
/*Left axis with text written perpendicular to edge.*/,"-10.             {
-9.                 plform( PL_Y_AXIS, tn, yscale, yprec, string, STRING_LEN, lly, lfy, loy );
-8.             }
-7.             pos = ( vpwymax > vpwymin ) ?
-6.                   ( tn - vpwymi ) / ( vpwyma - vpwymi ) :
-5.            ",Useful
"/*Expected offset is 0.5, but adjust to improve
look of result.*/","-7.                         height_mm        = ( height + 0.0 ) * char_height_mm;
-6.                         string_length_mm = plstrl( string );
-5.                         plsc->boxbb_xmin = MIN( plsc->boxbb_xmin, plsc->vppxmi /
-4.                    ",Useful
/*Left axis with text written parallel to edge.*/,"-10.                         plsc->boxbb_ymax = MAX( plsc->boxbb_ymax,
-9.                             pos_mm + 0.7 * char_height_mm );
-8.                     }
-7.                     else
-6.                     {
-5.                         plmtex( ""l",Useful
/*Right axis with text written perpendicular to edge.*/,"-10.                     else
-9.                     {
-8.                         plmtex( ""l"", height, pos, 0.5, string );
-7.                     }
-6.                 }
-5.             }
-4.             if ( lmy )
-3.             {
-2.                ",Useful
"/*Expected offset is 0.5, but adjust to improve
look of result.*/","-7.                         height_mm        = ( height + 0.0 ) * char_height_mm;
-6.                         string_length_mm = plstrl( string );
-5.                         plsc->boxbb_xmin = MIN( plsc->boxbb_xmin, plsc->vppxmi /
-4.                    ",Useful
/*Right axis with text written parallel to edge.*/,"-10.                         plsc->boxbb_ymax = MAX( plsc->boxbb_ymax,
-9.                             pos_mm + 0.7 * char_height_mm );
-8.                     }
-7.                     else
-6.                     {
-5.                         plmtex( ""r",Useful
"/*more space to clear labels in ""v"" mode*/","-10.         {
-9.             snprintf( string, STRING_LEN, ""(x10%su%d%sd)"", esc_string, (int) yscale, esc_string );
-8.             if ( custom_exponent_placement )
-7.             {
-6.                 height = ( (PLLabelDefaults *) plsc->label_data )-",Useful
/*Extra space for superscript*/,"-4.             if ( lmy )
-3.             {
-2.                 if ( !custom_exponent_placement )
-1.                 {

 /*Extra space for superscript*/

1.                     pos    = 1.0 + offset;
2.                     just   = 0.5;
3.              ",Useful
/*Restore saved parameters*/,"-10.                         plmtex( ""rv"", height, pos, just, string );
-9.                     }
-8.                     else
-7.                     {
-6.                         plmtex( ""r"", height, pos, just, string );
-5.                     }
-4.   ",Useful
"/*Exponential, i.e. 10^-1, 10^0, 10^1, etc*/","-10. // These are the functions which are used internally by PLplot under various
-9. // conditions.
-8. //
-7. // They have been separated out for use in other PLplot functions and
-6. // potential exposure in the PLplot API.
-5. //
-4. //---------------",Useful
"/*Fixed point, i.e. .1, 1, 10, etc*/","-4.     snprintf( string, (size_t) len, ""10%su%d"", esc_string, (int) ROUND( value ) );
-3. }
-2. void plP_default_label_log_fixed( PLINT PL_UNUSED( axis ), PLFLT value, char *string, PLINT len, void * PL_UNUSED( data ) )
-1. {

 /*Fixed point, i.e. .1, 1,",Useful
"/*This is necessary to prevent labels like ""-0.0"" on some systems*/","-10.     PLINT  setpre, precis;
-9.     char   form[FORMAT_LEN], temp[TEMP_LEN];
-8.     double scale2;
-7.     scale = ( (PLINT *) data )[0];
-6.     prec  = ( (PLINT *) data )[1];
-5.     plP_gprec( &setpre, &precis );
-4.     if ( setpre )
-3.         ",Useful
/*Logarithmic*/,"-10. // xopt and yopt are character strings which define the box as follows:
-9. //
-8. // a: Draw axis (X is horizontal line Y=0, Y is vertical line X=0)
-7. // b: Draw bottom (X) or left (Y) frame of box
-6. // c: Draw top (X) or right (Y) frame of box
",Useful
"/*Fixed point, i.e. .1, 1, 10, etc*/","-4.     snprintf( string, (size_t) len, ""10%su%d"", esc_string, (int) ROUND( value ) );
-3. }
-2. void plP_default_label_log_fixed( PLINT PL_UNUSED( axis ), PLFLT value, char *string, PLINT len, void * PL_UNUSED( data ) )
-1. {

 /*Fixed point, i.e. .1, 1,",Useful
"/*Exponential, i.e. 10^-1, 10^0, 10^1, etc*/","-10. // These are the functions which are used internally by PLplot under various
-9. // conditions.
-8. //
-7. // They have been separated out for use in other PLplot functions and
-6. // potential exposure in the PLplot API.
-5. //
-4. //---------------",Useful
/*Linear*/,"-5.                 plP_default_label_log( axis, value, string, len, NULL );
-4.             }
-3.         }
-2.         else
-1.         {

 /*Linear*/

1.             PLINT scale_prec[2] = { scale, prec };
2.             plP_default_label( axis, value, ",Useful
/*plgridd.c: Plot grids data from irregularly sampled data.*/,"
// plgridd.c: Plot grids data from irregularly sampled data.


 /*plgridd.c: Plot grids data from irregularly sampled data.*/

111",Useful
/*#ifdef PLPLOT_NONN*/,"-7. #include ""plplotP.h""
-6. #ifdef WITH_CSA
-5. #include ""../lib/csa/csa.h""
-4. #endif
-3. #ifdef PL_HAVE_QHULL
-2. #include ""../lib/nn/nn.h""

 /*#ifdef PLPLOT_NONN*/

1. #include <libqhull_r/qhull_ra.h>",Useful
/*#ifdef PL_HAVE_QHUL*/,"-4. #include ""plplotP.h""
-3. #ifdef WITH_CSA
-2. #include ""../lib/csa/csa.h""
-1. #endif
#ifdef PL_HAVE_QHULL

 /*#ifdef PL_HAVE_QHUL*/

1. #include ""../lib/nn/nn.h""",Useful
/*clear array to return*/,"-10.         }
-9.     }
-8.     for ( i = 0; i < nptsy - 1; i++ )
-7.     {
-6.         if ( yg[i] >= yg[i + 1] )
-5.         {
-4.             plabort( ""plgriddata: yg array must be strictly increasing"" );
-3.             return;
-2.         }
-1.     }",Useful
/*NaN signals a not processed grid point*/,"-3.     for ( i = 0; i < nptsx; i++ )
-2.         for ( j = 0; j < nptsy; j++ )
-1.             zops->set( zgp, i, j, 0.0 );

 /*NaN signals a not processed grid point*/

1.     switch ( type )
2.     {",Useful
/*Bivariate Cubic Spline Approximation*/,"-2.     switch ( type )
-1.     {

 /*Bivariate Cubic Spline Approximation*/

1. #ifdef WITH_CSA
2.         grid_csa( x, y, z, npts, xg, nptsx, yg, nptsy, zops, zgp );
3. #else
4.         plwarn( ""plgriddata(): PLplot was configured to not use GRID_CSA.\n",Useful
/*Nearest Neighbors Inverse Distance Weighted*/,"-10. //    Real world data is frequently irregularly sampled, but most 3D plots
-9. //    require regularly gridded data. This function does exactly this
-8. //    using several methods:
-7. //    Irregularly sampled data x[npts], y[npts], z[npts] is grid",Useful
/*Nearest Neighbors Linear Interpolation*/,"-10. //    require regularly gridded data. This function does exactly this
-9. //    using several methods:
-8. //    Irregularly sampled data x[npts], y[npts], z[npts] is gridded into
-7. //    zg[nptsx, nptsy] according to methode 'type' and grid inform",Useful
"/*Nearest Neighbors ""Around"" Inverse Distance Weighted*/","-2.         grid_nnli( x, y, z, npts, xg, nptsx, yg, nptsy, zops, zgp, data );
-1.         break;

 /*Nearest Neighbors ""Around"" Inverse Distance Weighted*/

1.         grid_nnaidw( x, y, z, npts, xg, nptsx, yg, nptsy, zops, zgp );
2.         break;",Useful
/*Delaunay Triangulation Linear Interpolation*/,"-10. //    Irregularly sampled data x[npts], y[npts], z[npts] is gridded into
-9. //    zg[nptsx, nptsy] according to methode 'type' and grid information
-8. //    xg[nptsx], yg[nptsy].
-7. //
-6. //    'type' can be:
-5. //
-4. //       GRID_CSA:    Biva",Useful
/*Natural Neighbors*/,"-10. //    zg[nptsx, nptsy] according to methode 'type' and grid information
-9. //    xg[nptsx], yg[nptsy].
-8. //
-7. //    'type' can be:
-6. //
-5. //       GRID_CSA:    Bivariate Cubic Spline approximation (1)
-4. //       GRID_NNIDW:  Nearest Neighb",Useful
"/*
Bivariate Cubic Spline Approximation using Pavel Sakov's csa package

NaNs are returned where no interpolation can be done.
*/","
// plgridd.c: Plot grids data from irregularly sampled data.


 /*
Bivariate Cubic Spline Approximation using Pavel Sakov's csa package

NaNs are returned where no interpolation can be done.
*/

111",Useful
/*WITH_CSA*/,"-10. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-9. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-8. // GNU Library General Public License for more details.
-7. //
-6. // You should have received a copy of the GN",Useful
"/*alternative weight coeficients. I Don't like the results
find the maximum distance*/","-10.     if ( knn_order == 0 )
-9.     {
-8.         plwarn( ""plgriddata(): GRID_NNIDW: knn_order must be specified with 'data' arg. Using 15"" );
-7.         knn_order = 15;;
-6.     }
-5.     for ( i = 0; i < nptsx; i++ )
-4.     {
-3.         for ( j = ",Useful
/*not enough neighbors found ?!*/,"-9.             md = items[0].dist;
-8.             for ( k = 1; k < knn_order; k++ )
-7.                 if ( items[k].dist > md )
-6.                     md = items[k].dist;
-5. #endif
-4.             zops->set( zgp, i, j, 0.0 );
-3.             nt = 0.",Useful
/*see if the triangle is a thin one*/,"-10.     else if ( threshold > 2. || threshold < 1. )
-9.     {
-8.         plabort( ""plgriddata(): GRID_NNLI: 1. < threshold < 2."" );
-7.         return;
-6.     }
-5.     for ( i = 0; i < nptsx; i++ )
-4.     {
-3.         for ( j = 0; j < nptsy; j++ )
",Useful
/*coincident points*/,"-9.             for ( ii = 0; ii < 3; ii++ )
-8.             {
-7.                 xx[ii] = x[items[ii].item];
-6.                 yy[ii] = y[items[ii].item];
-5.                 zz[ii] = z[items[ii].item];
-4.             }
-3.             d1 = sqrt( ( x",Useful
/*thin triangle!*/,"-4.             if ( d2 > d3 )
-3.             {
-2.                 t = d2; d2 = d3; d3 = t;
-1.             }

 /*thin triangle!*/

1.             {",Useful
/*calculate the plane passing through the three points*/,"-1.             }

 /*calculate the plane passing through the three points*/

1.             {
2.                 A = yy[0] * ( zz[1] - zz[2] ) + yy[1] * ( zz[2] - zz[0] ) + yy[2] * ( zz[0] - zz[1] );
3.                 B = zz[0] * ( xx[1] - xx[2] ) + zz[",Useful
/*and interpolate (or extrapolate...)*/,"-5.             {
-4.                 A = yy[0] * ( zz[1] - zz[2] ) + yy[1] * ( zz[2] - zz[0] ) + yy[2] * ( zz[0] - zz[1] );
-3.                 B = zz[0] * ( xx[1] - xx[2] ) + zz[1] * ( xx[2] - xx[0] ) + zz[2] * ( xx[0] - xx[1] );
-2.                 C =",Useful
"/*now deal with NaNs resulting from thin triangles. The idea is
to use the 4 KNN points and exclude one at a time, creating
four triangles, evaluating their thickness and choosing the
most thick as the final one from where the interpolating
plane will be build.  Now that I'm talking of interpolating,
one should really check that the target point is interior to
the candidate triangle... otherwise one is extrapolating*/","-4.                 zops->set( zgp, i, j, -xg[i] * A / C - yg[j] * B / C - D / C );
-3.             }
-2.         }
-1.     }

 /*now deal with NaNs resulting from thin triangles. The idea is
to use the 4 KNN points and exclude one at a time, creating
fou",Useful
/*the excluded point*/,"-10.                     // for (jj=0; jj<ii; jj++) {
-9.                     // if (items[jj].dist > items[jj+1].dist) {
-8.                     // t = items[jj].dist;
-7.                     // items[jj].dist = items[jj+1].dist;
-6.                     ",Useful
/*coincident points*/,"-9.             for ( ii = 0; ii < 3; ii++ )
-8.             {
-7.                 xx[ii] = x[items[ii].item];
-6.                 yy[ii] = y[items[ii].item];
-5.                 zz[ii] = z[items[ii].item];
-4.             }
-3.             d1 = sqrt( ( x",Useful
/*all points are coincident?*/,"-10.                         {
-9.                             t = d2; d2 = d3; d3 = t;
-8.                         }
-7.                         t = ( d1 + d2 ) / d3;
-6.                         if ( t > max_thick )
-5.                         {
-4.     ",Useful
/*one has the thicker triangle constructed from the 4 KNN*/,"-1.                         continue;

 /*one has the thicker triangle constructed from the 4 KNN*/

1.                     cnt = 0;
2.                     for ( ii = 0; ii < 4; ii++ )
3.                     {
4.                         if ( ii != excl_it",Useful
/*and interpolate (or extrapolate...)*/,"-5.             {
-4.                 A = yy[0] * ( zz[1] - zz[2] ) + yy[1] * ( zz[2] - zz[0] ) + yy[2] * ( zz[0] - zz[1] );
-3.                 B = zz[0] * ( xx[1] - xx[2] ) + zz[1] * ( xx[2] - xx[0] ) + zz[2] * ( xx[0] - xx[1] );
-2.                 C =",Useful
"/*Nearest Neighbors ""Around"" Inverse Distance Weighted, brute force approach.

This uses the 1-KNN in each quadrant around the grid point, then
Inverse Distance Weighted is used as in GRID_NNIDW.*/","-7.                     zops->set( zgp, i, j, -xg[i] * A / C - yg[j] * B / C - D / C );
-6.                 }
-5.             }
-4.         }
-3.     }
-2. }

 /*Nearest Neighbors ""Around"" Inverse Distance Weighted, brute force approach.

This uses the 1-",Useful
/*was found*/,"-10.     int   i, j, k;
-9.     for ( i = 0; i < nptsx; i++ )
-8.     {
-7.         for ( j = 0; j < nptsy; j++ )
-6.         {
-5.             dist2( xg[i], yg[j], x, y, npts );
-4.             zops->set( zgp, i, j, 0. );
-3.             nt = 0.;
-2.    ",Useful
/*1/square distance*/,"-1.                 {

 /*1/square distance*/

1.                     zops->add( zgp, i, j, d * z[items[k].item] );
2.                     nt += d;
3.                 }
4.             }",Useful
/*no points found?!*/,"-4.                     zops->add( zgp, i, j, d * z[items[k].item] );
-3.                     nt += d;
-2.                 }
-1.             }

 /*no points found?!*/

1.                 zops->set( zgp, i, j, NAN );
2.             else
3.                 ",Useful
"/*
Delaunay Triangulation Linear Interpolation using Pavel Sakov's nn package

The Delaunay Triangulation on the data points is build and for
each grid point the triangle where it is enclosed found and a
linear interpolation performed.

Points exterior to the convex hull of the data points cannot
be interpolated and are set to NaN.
*/","
// plgridd.c: Plot grids data from irregularly sampled data.


 /*
Delaunay Triangulation Linear Interpolation using Pavel Sakov's nn package

The Delaunay Triangulation on the data points is build and for
each grid point the triangle where it is enclosed found and a
linear interpolation performed.

Points exterior to the convex hull of the data points cannot
be interpolated and are set to NaN.
*/

111",Useful
"/*
Natural Neighbors using Pavel Sakov's nn package

Points exterior to the convex hull of the data points cannot
be interpolated and are set to NaN.
*/","
// plgridd.c: Plot grids data from irregularly sampled data.


 /*
Natural Neighbors using Pavel Sakov's nn package

Points exterior to the convex hull of the data points cannot
be interpolated and are set to NaN.
*/

111",Useful
/*PL_HAVE_QHULL*/,"-4. #include ""plplotP.h""
-3. #ifdef WITH_CSA
-2. #include ""../lib/csa/csa.h""
-1. #endif
#ifdef PL_HAVE_QHULL

 /*PL_HAVE_QHULL*/

1. #include ""../lib/nn/nn.h""",Useful
/*save sqrt() time*/,"-10.     int   max_slot, i, j;
-9.     max_dist = PLFLT_MAX;
-8.     max_slot = 0;
-7.     for ( i = 0; i < knn_order; i++ )
-6.     {
-5.         items[i].dist = PLFLT_MAX;
-4.         items[i].item = -1;
-3.     }
-2.     for ( i = 0; i < npts; i++ )
-1",Useful
/*now calculate the distance*/,"-10.             {
-9.                 if ( items[j].dist > max_dist )
-8.                 {
-7.                     max_dist = items[j].dist;
-6.                     max_slot = j;
-5.                 }
-4.             }
-3.         }
-2.     }
-1.     fo",Useful
/*save sqrt() time*/,"-10.     int   max_slot, i, j;
-9.     max_dist = PLFLT_MAX;
-8.     max_slot = 0;
-7.     for ( i = 0; i < knn_order; i++ )
-6.     {
-5.         items[i].dist = PLFLT_MAX;
-4.         items[i].item = -1;
-3.     }
-2.     for ( i = 0; i < npts; i++ )
-1",Useful
/*now calculate the distance*/,"-10.             {
-9.                 if ( items[j].dist > max_dist )
-8.                 {
-7.                     max_dist = items[j].dist;
-6.                     max_slot = j;
-5.                 }
-4.             }
-3.         }
-2.     }
-1.     fo",Useful
/*True if qhull should free points*/,"-5. static void
-4. grid_adtli( PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z, int npts,
-3.             PLFLT_VECTOR xg, int nptsx, PLFLT_VECTOR yg, int nptsy, PLF2OPS zops, PLPointer zgp )
-2. {

 /*True if qhull should free points*/

111",Useful
/*memory remaining after qh_memfreeshort*/,"-2.     vertexT *vertex, **vertexp;
-1.     facetT  *neighbor, **neighborp;

 /*memory remaining after qh_memfreeshort*/

1.     FILE    *outfile = NULL;",Useful
/*error messages from qhull code*/,"-1.     FILE    *outfile = NULL;

 /*error messages from qhull code*/

1.     int     exitcode;
2.     int     i, j, k, l;
3.     int     dim = 2;
4.     PLFLT   xt[3], yt[3], zt[3];
5.     PLFLT   A, B, C, D;
6.     coordT  point[3];
7.     boolT   isout",Useful
/*easy way*/,"-10.     {
-9.         plexit( ""grid_adtli: Insufficient memory"" );
-8.     }
-7.     for ( i = 0; i < npts; i++ )
-6.     {
-5.         points[i * dim]     = x[i];
-4.         points[i * dim + 1] = y[i];
-3.     }
-2.     qhT context = { 0 };
-1.     qhT",Useful
/*if no error*/,"-10.     qh_init_A( stdin, stdout, stderr, 0, NULL );
-9.     exitcode = setjmp( qh errexit );
-8.     if ( !exitcode )
-7.     {
-6.         qh_initflags( flags );
-5.         qh PROJECTdelaunay = True;
-4.         qh_init_B( points, npts, dim, ismalloc ",Useful
/*print the triangles vertices*/,"-1.     {

 /*print the triangles vertices*/

1.         printf( ""Triangles\n"" );
2.         FORALLfacets {
3.             if ( !facet->upperdelaunay )
4.             {
5.                 FOREACHvertex_( facet->vertices )",Useful
/*vertices index*/,"-5.         printf( ""Triangles\n"" );
-4.         FORALLfacets {
-3.             if ( !facet->upperdelaunay )
-2.             {
-1.                 FOREACHvertex_( facet->vertices )

 /*vertices index*/

1.                 printf( ""\n"" );
2.             }
",Useful
/*print each triangle neighbors*/,"-4.                 printf( ""\n"" );
-3.             }
-2.         }
-1. #endif

 /*print each triangle neighbors*/

1.         printf( ""Neigbors\n"" );
2.         qh_findgood_all( qh facet_list );
3.         qh_countfacets( qh facet_list, NULL, !qh_ALL, &n",Useful
"/*Without the setjmp(), Qhull will exit() after reporting an error*/","-10.             &totneighbors, &numridges, &numcoplanars, &numtricoplanars );
-9.         FORALLfacets {
-8.             if ( !facet->upperdelaunay )
-7.             {
-6.                 FOREACHneighbor_( facet )
-5.                 printf( "" %d"", neigh",Useful
/*calculate the plane passing through the three points*/,"-1.             }

 /*calculate the plane passing through the three points*/

1.             {
2.                 A = yy[0] * ( zz[1] - zz[2] ) + yy[1] * ( zz[2] - zz[0] ) + yy[2] * ( zz[0] - zz[1] );
3.                 B = zz[0] * ( xx[1] - xx[2] ) + zz[",Useful
/*and interpolate*/,"-5.             {
-4.                 A = yy[0] * ( zz[1] - zz[2] ) + yy[1] * ( zz[2] - zz[0] ) + yy[2] * ( zz[0] - zz[1] );
-3.                 B = zz[0] * ( xx[1] - xx[2] ) + zz[1] * ( xx[2] - xx[0] ) + zz[2] * ( xx[0] - xx[1] );
-2.                 C =",Useful
/*free long memory*/,"-7.                         zops->set( zgp, i, j, -xg[i] * A / C - yg[j] * B / C - D / C );
-6.                     }
-5.                 }
-4.         }
-3.         qh->NOerrexit = True;
-2.     }
-1.     free( points );

 /*free long memory*/

111",Useful
/*free short memory and memory allocator*/,"-8.                         zops->set( zgp, i, j, -xg[i] * A / C - yg[j] * B / C - D / C );
-7.                     }
-6.                 }
-5.         }
-4.         qh->NOerrexit = True;
-3.     }
-2.     free( points );

 /*free short memory and memory ",Useful
/*PLPLOT_NONN*/,"-6. #include ""plplotP.h""
-5. #ifdef WITH_CSA
-4. #include ""../lib/csa/csa.h""
-3. #endif
-2. #ifdef PL_HAVE_QHULL
-1. #include ""../lib/nn/nn.h""

 /*PLPLOT_NONN*/

111",Useful
"/*! @file
!  These function perform variuos affine transformations.
!
! For background on these affine functions see SVG specification, e.g.,
! http://www.w3.org/TR/SVGTiny12/coords.html#EstablishingANewUserSpace.
! Affine 3x3 matrices with elements A_i,j always have a last row of
! 0, 0, 1 so the elements are conveniently stored in a vector in the order
! A_1_1, A_2_1, A_1_2, A_2_2, A_1_3, A_2_3, with the last row implied.
!
! N.B.  The PLplot affine interpretation of translate, scale, etc., is
! as actions on coordinate systems, rather than actions on objects.  This
! is identical to the SVG specficiation interpretation.  However, the
! SVG specification interprets the affine matrix as follows:
! old_coord_vector = affine_matrix * new_coordinate vector.  In PLplot
! we use the alternative interpretation
! new_coord_vector = affine_matrix * old_coordinate vector.
! The result is all affine matrices below are the inverses of the SVG
! equivalents.
!
! N.B. All PLplot affine functions below return the affine matrix result (in
! vector form) as the first argument).  It is the calling routine's
! responsibility to provide the space for all affine matrix arguments,
! i.e., a PLFLT array with a dimension of 6.
!*/","-10. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-9. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-8. // GNU Library General Public License for more details.
-7. //
-6. // You should have received a copy of the GN",Useful
/*TODO: store previous state*/,"-4. void
-3. NoBufferNoPixmap()
-2. {
-1.     PLINT op = ZEROW2B;

 /*TODO: store previous state*/

1.     plP_esc( PLESC_EXPOSE, NULL );
2.     plP_esc( PLESC_IMAGEOPS, &op );
3. }
4. void
5. RestoreWrite2BufferPixmap()
6. {
7.     PLINT op = ONEW2B;",Useful
/*TODO: revert from previous state*/,"-7.     plP_esc( PLESC_EXPOSE, NULL );
-6.     plP_esc( PLESC_IMAGEOPS, &op );
-5. }
-4. void
-3. RestoreWrite2BufferPixmap()
-2. {
-1.     PLINT op = ONEW2B;

 /*TODO: revert from previous state*/

1.     plP_esc( PLESC_IMAGEOPS, &op );
2. }",Useful
/*Indices*/,"-5. void
-4. plimageslow( PLFLT *idata, PLINT nx, PLINT ny,
-3.              PLFLT xmin, PLFLT ymin, PLFLT dx, PLFLT dy,
-2.              PLTRANSFORM_callback pltr, PLPointer pltr_data )
-1. {

 /*Indices*/

1.     PLINT ix, iy, i;",Useful
/*Float coordinates*/,"-1.     PLINT ix, iy, i;

 /*Float coordinates*/

1.     PLFLT xf[4], yf[4];",Useful
/*Translated (by pltr) coordinates*/,"-1.     PLFLT xf[4], yf[4];

 /*Translated (by pltr) coordinates*/

1.     PLFLT tx, ty;",Useful
/*Only plot values within in appropriate range*/,"-6.     PLFLT color;
-5.     plP_esc( PLESC_START_RASTERIZE, NULL );
-4.     for ( ix = 0; ix < nx; ix++ )
-3.     {
-2.         for ( iy = 0; iy < ny; iy++ )
-1.         {

 /*Only plot values within in appropriate range*/

1.             color = idata[i",Useful
/*Translate the points*/,"-9.             plcol1( color / COLOR_MAX );
-8.             xf[0] = xf[1] = ix;
-7.             xf[2] = xf[3] = ix + 1;
-6.             yf[0] = yf[3] = iy;
-5.             yf[1] = yf[2] = iy + 1;
-4.             if ( pltr )
-3.             {
-2.         ",Useful
/*Automatic translation to the specified plot area*/,"-9.                     ( *pltr )( xf[i], yf[i], &tx, &ty, pltr_data );
-8.                     xf[i] = tx;
-7.                     yf[i] = ty;
-6.                 }
-5.             }
-4.             else
-3.             {
-2.                 for ( i = 0;",Useful
"/*N.B. This routine only needed by the Fortran interface to distinguish
the case where pltr and pltr_data are NULL.  So don't put declaration in
header which might encourage others to use this in some other context.*/","-10. //       have color 1.0.  Values between valuemin and valuemax will
-9. //       map linearly to to the colors between 0.0 and 1.0.
-8. //       If you do not want to display values outside of the
-7. //       (valuemin -> valuemax) range, then set z",Useful
"/*This is used when looping through the image array, checking to
make sure the values are within an acceptable range.*/","-1.     PLFLT *z;

 /*This is used when looping through the image array, checking to
make sure the values are within an acceptable range.*/

1.     PLFLT datum;",Useful
/*Color range*/,"-1.     PLINT init_color;

 /*Color range*/

1.     PLFLT color_min, color_max, color_range;
2.     if ( plsc->level < 3 )
3.     {
4.         plabort( ""plimagefr: window must be set up first"" );
5.         return;
6.     }
7.     if ( nx <= 0 || ny <= 0 ",Useful
/*Save the currently-in-use color.*/,"-10.     }
-9.     if ( nx <= 0 || ny <= 0 )
-8.     {
-7.         plabort( ""plimagefr: nx and ny must be positive"" );
-6.         return;
-5.     }
-4.     if ( ( z = (PLFLT *) malloc( (size_t) ( ny * nx ) * sizeof ( PLFLT ) ) ) == NULL )
-3.     {
-2.  ",Useful
"/*If no acceptable data range is given, then set the min/max data range
to include all of the given data.*/","-1.     init_color = plsc->icol0;

 /*If no acceptable data range is given, then set the min/max data range
to include all of the given data.*/

1.     if ( zmin == zmax )
2.     {",Useful
"/*Go through the image values and scale them to fit in
the COLOR_MIN to COLOR_MAX range.
Any values greater than valuemax are set to valuemax,
and values less than valuemin are set to valuemin.
Any values outside of zmin to zmax are flagged so they
are not plotted.*/","-3.     color_min   = plsc->cmap1_min;
-2.     color_max   = plsc->cmap1_max;
-1.     color_range = color_max - color_min;

 /*Go through the image values and scale them to fit in
the COLOR_MIN to COLOR_MAX range.
Any values greater than valuemax are set ",Useful
/*Was any space allocated for z?*/,"-2.     PLFLT   **z;
-1.     PLF2OPS zops;

 /*Was any space allocated for z?*/

1.     PLBOOL  copied;
2.     copied = FALSE;
3.     if ( nx <= 0 || ny <= 0 )
4.     {
5.         plabort( ""plimage: nx and ny must be positive"" );
6.         return;
7.    ",Useful
"/*If the whole image should be shown, then no copying is needed.*/","-3.     idataops->minmax( idatap, nx, ny, &data_min, &data_max );
-2.     if ( xmin == Dxmin && xmax == Dxmax && ymin == Dymin && ymax == Dymax )
-1.     {

 /*If the whole image should be shown, then no copying is needed.*/

1.         z    = (PLFLT **) ",Useful
"/*Go through the image and select the pixels within the given
(Dxmin, Dymin) - (Dxmax, Dymax) window.*/","-2.         plAlloc2dGrid( &z, nnx, nny );
-1.         zops = plf2ops_c();

 /*Go through the image and select the pixels within the given
(Dxmin, Dymin) - (Dxmax, Dymax) window.*/

1.         ixx = -1;
2.         for ( ix = xm; ix < xm + nnx; ix++ )
3.  ",Useful
/*Set the appropriate values to pass in to plimagefr*/,"-9.         ixx = -1;
-8.         for ( ix = xm; ix < xm + nnx; ix++ )
-7.         {
-6.             ixx++; iyy = 0;
-5.             for ( iy = ym; iy < ym + nny; iy++ )
-4.             {
-3.                 z[ixx][iyy++] = idataops->get( idatap, ix, iy )",Useful
/*Only free the memory if it was allocated by us...*/,"-4.         copied = TRUE;
-3.     }
-2.     plfimagefr( zops, (PLPointer) z, nnx, nny, Dxmin, Dxmax, Dymin, Dymax, zmin, zmax,
-1.         data_min, data_max, NULL, NULL );

 /*Only free the memory if it was allocated by us...*/

1.     if ( copied == TR",Useful
"/*--------------------------------------------------------------------------
N.B. This routine only needed by the Fortran interface to distinguish
the case where both arrowx and arrowy are NULL.  So don't put declaration in
header which might encourage others to use this in some other context.
--------------------------------------------------------------------------*/","-1. static void plP_plotvect( PLFLT x, PLFLT y, PLFLT u, PLFLT v, PLFLT scale );

 /*--------------------------------------------------------------------------
N.B. This routine only needed by the Fortran interface to distinguish
the case where both arrow",Useful
"/*printf(""plvect: %f %f %f %f %f %f %f\n"",scale, x,0.5*uu, y,0.5*vv, xt, yt);*/","-10.     if ( ( ( a_x = (PLINT *) malloc( sizeof ( PLINT ) * (size_t) ( plsc->arrow_npts ) ) ) == NULL ) ||
-9.          ( ( a_y = (PLINT *) malloc( sizeof ( PLINT ) * (size_t) ( plsc->arrow_npts ) ) ) == NULL ) )
-8.     {
-7.         plexit( ""plP_plotve",Useful
/*Determines if a point is inside a polygon or not*/,"-2. static void
-1. grdashline( short *x, short *y );

 /*Determines if a point is inside a polygon or not*/

111",Useful
"/*Approximate the path in transformed space with a sequence of line
segments.*/","-4.         pljoin( x1, y1, x2, y2 );
-3.     }
-2.     else
-1.     {

 /*Approximate the path in transformed space with a sequence of line
segments.*/

1.         xs = interpolate_between( n, x1, x2 );
2.         ys = interpolate_between( n, y1, y2 );
3",Useful
"/*plP_interpolate allocates memory, so we have to free it here.*/","-8.         xs = interpolate_between( n, x1, x2 );
-7.         ys = interpolate_between( n, y1, y2 );
-6.         if ( xs == NULL || ys == NULL )
-5.         {
-4.             plexit( ""c_plpath: Insufficient memory"" );
-3.             return;
-2.         ",Useful
"/*--------------------------------------------------------------------------
void plline3(n, x, y, z)

Draws a line in 3 space.  You must first set up the viewport, the
2d viewing window (in world coordinates), and the 3d normalized
coordinate box.  See x18c.c for more info.

This version adds clipping against the 3d bounding box specified in plw3d
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plline3(n, x, y, z)

Draws a line in 3 space.  You must first set up the viewport, the
2d viewing wi",Useful
/*get the bounding box in 3d*/,"-10. void
-9. c_plline3( PLINT n, PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z )
-8. {
-7.     int   i;
-6.     PLFLT vmin[3], vmax[3], zscale;
-5.     if ( plsc->level < 3 )
-4.     {
-3.         plabort( ""plline3: Please set up window first"" );
-2.   ",Useful
/*interate over the vertices*/,"-2.     plP_gdom( &vmin[0], &vmax[0], &vmin[1], &vmax[1] );
-1.     plP_grange( &zscale, &vmin[2], &vmax[2] );

 /*interate over the vertices*/

1.     for ( i = 0; i < n - 1; i++ )
2.     {
3.         PLFLT p0[3], p1[3];
4.         int   axis;",Useful
/*copy the end points of the segment to allow clipping*/,"-4.     for ( i = 0; i < n - 1; i++ )
-3.     {
-2.         PLFLT p0[3], p1[3];
-1.         int   axis;

 /*copy the end points of the segment to allow clipping*/

1.         p0[0] = x[i]; p0[1] = y[i]; p0[2] = z[i];
2.         p1[0] = x[i + 1]; p1[1] = y",Useful
/*first out*/,"-2.         for ( axis = 0; axis < 3; axis++ )
-1.         {

 /*first out*/

1.             {
2.                 if ( p1[axis] < vmin[axis] )
3.                 {",Useful
/*both endpoints out so quit*/,"-3.             {
-2.                 if ( p1[axis] < vmin[axis] )
-1.                 {

 /*both endpoints out so quit*/

1.                 }
2.                 else
3.                 {
4.                     int   j;",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*second out*/,"-9.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                     p0[axis] = vmin[axis];
-7.                     for ( j = 1; j < 3; j++ )
-6.                     {
-5.                         int k = ( axis + ",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*first out*/,"-2.         for ( axis = 0; axis < 3; axis++ )
-1.         {

 /*first out*/

1.             {
2.                 if ( p1[axis] < vmin[axis] )
3.                 {",Useful
/*both out so quit*/,"-3.             {
-2.                 if ( p1[axis] > vmax[axis] )
-1.                 {

 /*both out so quit*/

1.                 }
2.                 else
3.                 {
4.                     int   j;",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*second out*/,"-9.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                     p0[axis] = vmin[axis];
-7.                     for ( j = 1; j < 3; j++ )
-6.                     {
-5.                         int k = ( axis + ",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
"/*if we made it to here without ""break""ing out of the loop, the
remaining segment is visible*/","-9.                 PLFLT t = ( vmax[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                 p1[axis] = vmax[axis];
-7.                 for ( j = 1; j < 3; j++ )
-6.                 {
-5.                     int k = ( axis + j ) % 3;
-4.        ",Useful
/*not clipped away*/,"-10.                 p1[axis] = vmax[axis];
-9.                 for ( j = 1; j < 3; j++ )
-8.                 {
-7.                     int k = ( axis + j ) % 3;
-6.                     p1[k] = ( 1 - t ) * p0[k] + t * p1[k];
-5.                 }
-4.     ",Useful
"/*--------------------------------------------------------------------------
void plpoly3( n, x, y, z, draw, ifcc )

Draws a polygon in 3 space.  This differs from plline3() in that
this attempts to determine if the polygon is viewable.  If the back
of polygon is facing the viewer, then it isn't drawn.  If this
isn't what you want, then use plline3 instead.

n specifies the number of points.  They are assumed to be in a
plane, and the directionality of the plane is determined from the
first three points.  Additional points do not /have/ to lie on the
plane defined by the first three, but if they do not, then the
determiniation of visibility obviously can't be 100% accurate...
So if you're 3 space polygons are too far from planar, consider
breaking them into smaller polygons.  ""3 points define a plane"" :-).

For ifcc == 1, the directionality of the polygon is determined by assuming
the points are laid out in counter-clockwise order.

For ifcc == 0, the directionality of the polygon is determined by assuming
the points are laid out in clockwise order.

BUGS:  If one of the first two segments is of zero length, or if
they are colinear, the calculation of visibility has a 50/50 chance
of being correct.  Avoid such situations :-).  See x18c for an
example of this problem.  (Search for ""20.1"").
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
void plpoly3( n, x, y, z, draw, ifcc )

Draws a polygon in 3 space.  This differs from plline3() in that
",Useful
/*get the bounding box in 3d*/,"-10. void
-9. c_plline3( PLINT n, PLFLT_VECTOR x, PLFLT_VECTOR y, PLFLT_VECTOR z )
-8. {
-7.     int   i;
-6.     PLFLT vmin[3], vmax[3], zscale;
-5.     if ( plsc->level < 3 )
-4.     {
-3.         plabort( ""plline3: Please set up window first"" );
-2.   ",Useful
/*interate over the vertices*/,"-2.     plP_gdom( &vmin[0], &vmax[0], &vmin[1], &vmax[1] );
-1.     plP_grange( &zscale, &vmin[2], &vmax[2] );

 /*interate over the vertices*/

1.     for ( i = 0; i < n - 1; i++ )
2.     {
3.         PLFLT p0[3], p1[3];
4.         int   axis;",Useful
/*copy the end points of the segment to allow clipping*/,"-4.     for ( i = 0; i < n - 1; i++ )
-3.     {
-2.         PLFLT p0[3], p1[3];
-1.         int   axis;

 /*copy the end points of the segment to allow clipping*/

1.         p0[0] = x[i]; p0[1] = y[i]; p0[2] = z[i];
2.         p1[0] = x[i + 1]; p1[1] = y",Useful
/*first out*/,"-2.         for ( axis = 0; axis < 3; axis++ )
-1.         {

 /*first out*/

1.             {
2.                 if ( p1[axis] < vmin[axis] )
3.                 {",Useful
/*both endpoints out so quit*/,"-3.             {
-2.                 if ( p1[axis] < vmin[axis] )
-1.                 {

 /*both endpoints out so quit*/

1.                 }
2.                 else
3.                 {
4.                     int   j;",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*second out*/,"-9.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                     p0[axis] = vmin[axis];
-7.                     for ( j = 1; j < 3; j++ )
-6.                     {
-5.                         int k = ( axis + ",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*first out*/,"-2.         for ( axis = 0; axis < 3; axis++ )
-1.         {

 /*first out*/

1.             {
2.                 if ( p1[axis] < vmin[axis] )
3.                 {",Useful
/*both out so quit*/,"-3.             {
-2.                 if ( p1[axis] > vmax[axis] )
-1.                 {

 /*both out so quit*/

1.                 }
2.                 else
3.                 {
4.                     int   j;",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
/*second out*/,"-9.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                     p0[axis] = vmin[axis];
-7.                     for ( j = 1; j < 3; j++ )
-6.                     {
-5.                         int k = ( axis + ",Useful
/*interpolate to find intersection with box*/,"-4.                 }
-3.                 else
-2.                 {
-1.                     int   j;

 /*interpolate to find intersection with box*/

1.                     PLFLT t = ( vmin[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
2.                ",Useful
"/*if we made it to here without ""break""ing out of the loop, the
remaining segment is visible*/","-9.                 PLFLT t = ( vmax[axis] - p0[axis] ) / ( p1[axis] - p0[axis] );
-8.                 p1[axis] = vmax[axis];
-7.                 for ( j = 1; j < 3; j++ )
-6.                 {
-5.                     int k = ( axis + j ) % 3;
-4.        ",Useful
/*not clipped away*/,"-10.                 p1[axis] = vmax[axis];
-9.                 for ( j = 1; j < 3; j++ )
-8.                 {
-7.                     int k = ( axis + j ) % 3;
-6.                     p1[k] = ( 1 - t ) * p0[k] + t * p1[k];
-5.                 }
-4.     ",Useful
/*Check for blank style*/,"-10.         if ( ( mark[i] < 0 ) || ( space[i] < 0 ) )
-9.         {
-8.             plabort( ""plstyl: Mark and space lengths must be > 0"" );
-7.             return;
-6.         }
-5.         if ( ( mark[i] != 0 ) || ( space[i] != 0 ) )
-4.         {
-3.",Useful
/*First point of polyline.*/,"-10.         x1 = x[i];
-9.         x2 = x[i + 1];
-8.         y1 = y[i];
-7.         y2 = y[i + 1];
-6.         drawable = ( INSIDE( x1, y1 ) && INSIDE( x2, y2 ) );
-5.         if ( !drawable )
-4.             drawable = !plP_clipline( &x1, &y1, &x2, &y2",Useful
"/*Not first point.  Check if first point of this segment matches up to
previous point, and if so, add it to the current polyline buffer.*/","-8.             if ( iclp == 0 )
-7.             {
-6.                 xclp[iclp] = (short) x1;
-5.                 yclp[iclp] = (short) y1;
-4.                 iclp++;
-3.                 xclp[iclp] = (short) x2;
-2.                 yclp[iclp] = (short) ",Useful
/*Otherwise it's time to start a new polyline*/,"-6.             else if ( x1 == xclp[iclp] && y1 == yclp[iclp] )
-5.             {
-4.                 iclp++;
-3.                 xclp[iclp] = (short) x2;
-2.                 yclp[iclp] = (short) y2;
-1.             }

 /*Otherwise it's time to start a n",Useful
/*Handle remaining polyline*/,"-10.                     ( *draw )( xclp, yclp, iclp + 1 );
-9.                 iclp       = 0;
-8.                 xclp[iclp] = (short) x1;
-7.                 yclp[iclp] = (short) y1;
-6.                 iclp++;
-5.                 xclp[iclp] = (short) ",Useful
"/*If both points are outside clip region with no hope of intersection,
return with an error*/","-6. int
-5. plP_clipline( PLINT *p_x1, PLINT *p_y1, PLINT *p_x2, PLINT *p_y2,
-4.               PLINT xmin, PLINT xmax, PLINT ymin, PLINT ymax )
-3. {
-2.     PLINT  t, dx, dy, flipx, flipy;
-1.     double dydx = 0, dxdy = 0;

 /*If both points are outsid",Useful
/*If one of the coordinates is not finite then return with an error*/,"-5.     if ( ( *p_x1 <= xmin && *p_x2 <= xmin ) ||
-4.          ( *p_x1 >= xmax && *p_x2 >= xmax ) ||
-3.          ( *p_y1 <= ymin && *p_y2 <= ymin ) ||
-2.          ( *p_y1 >= ymax && *p_y2 >= ymax ) )
-1.         return 1;

 /*If one of the coordinates ",Useful
/*Check for solid line*/,"-10. //--------------------------------------------------------------------------
-9. // void genlin()
-8. //
-7. // General line-drawing routine.  Takes line styles into account.
-6. // If only 2 points are in the polyline, it is more efficient to use
-5",Useful
"/*Right now dashed lines don't use polyline capability -- this
should be improved*/","-7.     if ( plsc->nms == 0 )
-6.     {
-5.         if ( npts == 2 )
-4.             plP_line( x, y );
-3.         else
-2.             plP_polyline( x, y, npts );
-1.     }

 /*Right now dashed lines don't use polyline capability -- this
should be improv",Useful
/*Check if pattern needs to be restarted*/,"-9. static void
-8. grdashline( short *x, short *y )
-7. {
-6.     PLINT  nx, ny, nxp, nyp, incr, temp;
-5.     PLINT  modulo, dx, dy, i, xtmp, ytmp;
-4.     PLINT  tstep, pix_distance, j;
-3.     int    loop_x;
-2.     short  xl[2], yl[2];
-1.     double",Useful
/*Compute the timer step*/,"-10.         incr   = nxp;
-9.         loop_x = 0;
-8.     }
-7.     else
-6.     {
-5.         modulo = nxp;
-4.         incr   = nyp;
-3.         loop_x = 1;
-2.     }
-1.     temp = modulo / 2;

 /*Compute the timer step*/

1.     nxstep = nxp * plsc->",Useful
"/*--------------------------------------------------------------------------
interpolate_between()

Returns a pointer to an array of PLFLT values which interpolate in n steps
from a to b.
Note:
The returned array is allocated by the function and needs to be freed by
the function's caller.
If the return value is NULL, the allocation failed and it is up to the
caller to handle the error.
--------------------------------------------------------------------------*/","-2. static PLFLT *
-1. interpolate_between( int n, PLFLT a, PLFLT b );

 /*--------------------------------------------------------------------------
interpolate_between()

Returns a pointer to an array of PLFLT values which interpolate in n steps
from a ",Useful
/*Support functions*/,"-2. #include <crt_externs.h>
-1. #endif

 /*Support functions*/

1. static int  ParseOpt( int *, char ***, int *, char ***, PLOptionTable * );
2. static int  ProcessOpt( char *, PLOptionTable *, int *, char ***, int * );
3. static int  GetOptarg( char **,",Useful
/*Temporary buffer used for parsing*/,"-9. static PLCHAR_VECTOR program = NULL;
-8. static PLCHAR_VECTOR usage   = NULL;
-7. static int           mode_full;
-6. static int           mode_quiet;
-5. static int           mode_nodelete;
-4. static int           mode_showall;
-3. static int       ",Useful
/*Turns on invisible options*/,"-10. //! PL_OPT_INT		Set *var=atoi(opt_arg)
-9. //! PL_OPT_FLOAT		Set *var=atof(opt_arg)
-8. //! PL_OPT_STRING	Set *var=opt_arg
-7. //!
-6. //! where opt points to the option string and opt_arg points to the
-5. //! argument string.
-4. //!
-3. //--------",Useful
/*Help*/,"-3. static int  ParseOpt( int *, char ***, int *, char ***, PLOptionTable * );
-2. static int  ProcessOpt( char *, PLOptionTable *, int *, char ***, int * );
-1. static int  GetOptarg( char **, int *, char ***, int * );
static void Help( void );

 /*Help*",Useful
/*Version*/,"-10. //  PLplot is distributed in the hope that it will be useful,
-9. //  but WITHOUT ANY WARRANTY; without even the implied warranty of
-8. //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-7. //  GNU Library General Public License for ",Useful
/*Geometry (alias)*/,"-8.         opt_geo,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-geometry geom"",
-3.         ""Window size/position specified as in X, e.g., 400x300, 400x300-100+200, +100-200, etc.""
-2.     },
-1.     {

 /*Geom",Useful
/*floating aspect ratio*/,"-8.         opt_ori,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-ori orient"",
-3.         ""Plot orientation (0,1,2,3=landscape,portrait,seascape,upside-down)""
-2.     },
-1.     {

 /*floating aspect ratio*/

1.",Useful
/*floating aspect ratio*/,"-8.         opt_ori,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_FUNC | PL_OPT_ARG,
-4.         ""-ori orient"",
-3.         ""Plot orientation (0,1,2,3=landscape,portrait,seascape,upside-down)""
-2.     },
-1.     {

 /*floating aspect ratio*/

1.",Useful
/*Metafile output option*/,"-8.         opt_drvopt,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_ARG | PL_OPT_FUNC,
-4.         ""-drvopt option[=value][,option[=value]]*"",
-3.         ""Driver specific options""
-2.     },
-1.     {

 /*Metafile output option*/

1.         o",Useful
/*Metafile output option*/,"-8.         opt_drvopt,
-7.         NULL,
-6.         NULL,
-5.         PL_OPT_ARG | PL_OPT_FUNC,
-4.         ""-drvopt option[=value][,option[=value]]*"",
-3.         ""Driver specific options""
-2.     },
-1.     {

 /*Metafile output option*/

1.         o",Useful
/*option*/,"-10. //  Copyright (C) 2009-2011 Hazen Babcock
-9. //  Copyright (C) 2009-2010 Hezekiah M. Carty
-8. //  Copyright (C) 2015 Jim Dishaw
-7. //  Copyright (C) 2017 Phil Rosenberg
-6. //
-5. //  This file is part of PLplot.
-4. //
-3. //  PLplot is free soft",Useful
/*client data*/,"-10.         opt_mfi,
-9.         NULL,
-8.         NULL,
-7.         PL_OPT_ARG | PL_OPT_FUNC,
-6.         ""-mfi PLplot metafile name"",
-5.         ""Read the specified PLplot metafile""
-4.     },
-3.     {

 /*client data*/

111",Useful
/*address of variable to set*/,"-10. //!     PLCHAR_VECTOR syntax;
-9. //!     PLCHAR_VECTOR desc;
-8. //! } PLOptionTable;
-7. //!
-6. //! where each entry has the following meaning:
-5. //!
-4. //! opt		option string
-3. //! handler	pointer to function for processing the option and
-2",Useful
/*mode flag*/,"-10.         NULL,
-9.         PL_OPT_ARG | PL_OPT_FUNC,
-8.         ""-mfi PLplot metafile name"",
-7.         ""Read the specified PLplot metafile""
-6.     },
-5.     {

 /*mode flag*/

111",Useful
/*short syntax*/,"-10. //! } PLOptionTable;
-9. //!
-8. //! where each entry has the following meaning:
-7. //!
-6. //! opt		option string
-5. //! handler	pointer to function for processing the option and
-4. //!		 (optionally) its argument
-3. //! client_data	pointer to d",Useful
/*long syntax*/,"-10. //!
-9. //! where each entry has the following meaning:
-8. //!
-7. //! opt		option string
-6. //! handler	pointer to function for processing the option and
-5. //!		 (optionally) its argument
-4. //! client_data	pointer to data that gets passed to (",Useful
"/*--------------------------------------------------------------------------
! @struct PLOptionInfo
!
! Array of option tables and associated info.
!
! The user may merge up to PL_MAX_OPT_TABLES custom option tables (of type
! PLOptionTable) with the internal one.  The resulting treatment is simple,
! powerful, and robust.  The tables are parsed in the order of last added
! first, to the internal table last.  If multiple options of the same name
! occur, only the first parsed is ""seen"", thus, the user can easily
! override any PLplot internal option merely by providing the same option.
! This same precedence is followed when printing help and usage messages,
! with each set of options given separately.  See example usage in
! plrender.c.
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
/*No room for more tables*/,"-10.     if ( ( tab->handler != NULL ) ||
-9.          ( tab->client_data != NULL ) ||
-8.          ( tab->var != NULL ) ||
-7.          ( tab->mode != 0 ) ||
-6.          ( tab->syntax != NULL ) ||
-5.          ( tab->desc != NULL ) )
-4.     {
-3.      ",Useful
"/*--------------------------------------------------------------------------
plparseopts()

! Process options list using current ploptions_info structure.
! An error in parsing the argument list causes a program exit if
! mode_full is set, otherwise the function returns with an error.
!
! @param p_argc pointer to a value that ONLY keeps track of number of arguments after processing.
! @param argv ?
! @param mode ?
!
! @returns 0 if successful.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
/*Initialize*/,"-10.         ""-compression num"",
-9.         ""Sets compression level in supporting devices""
-8.     },
-7.     {
-6.         ""cmap0"",
-5.         opt_cmap0,
-4.         NULL,
-3.         NULL,
-2.         PL_OPT_ARG | PL_OPT_FUNC,
-1.         ""-cmap0 file",Useful
"/*Just in case plparseopts has been called previously (e.g., with PL_PARSE_NODELETE).*/","-2.     if ( !mode_noprogram )
-1.     {

 /*Just in case plparseopts has been called previously (e.g., with PL_PARSE_NODELETE).*/

1.         if ( plsc->program )
2.             free_mem( plsc->program );",Useful
"/*If plparseopts is not called again, this is freed in plend1.*/","-2.         if ( plsc->program )
-1.             free_mem( plsc->program );

 /*If plparseopts is not called again, this is freed in plend1.*/

1.         plsc->program = plstrdup( argv[0] );
2.         program       = (PLCHAR_VECTOR) plsc->program;
3.   ",Useful
/*Process the command line*/,"-6.         plsc->program = plstrdup( argv[0] );
-5.         program       = (PLCHAR_VECTOR) plsc->program;
-4.         --myargc; ++argv;
-3.     }
-2.     if ( myargc == 0 )
-1.         return 0;

 /*Process the command line*/

111",Useful
"/*Special hack to deal with -debug option before
pllib_init() is called.*/","-7.         plsc->program = plstrdup( argv[0] );
-6.         program       = (PLCHAR_VECTOR) plsc->program;
-5.         --myargc; ++argv;
-4.     }
-3.     if ( myargc == 0 )
-2.         return 0;

 /*Special hack to deal with -debug option before
pllib_i",Useful
"/*Restore pointers to condition before the above loop
Although array length and content stored in those pointers
is likely changed.*/","-8.                 status = ParseOpt( &myargc, &argv, p_argc, &argsave,
-7.                     ploption_info[i].options );
-6.                 if ( !status )
-5.                     break;
-4.             }
-3.             break;
-2.         }
-1.     }",Useful
"/*Loop over all options tables, starting with the last*/","-5.         if ( *argv == NULL || *argv[0] == '\0' )
-4.             continue;
-3.         if ( ( !mode_nodash && !strcmp( *argv, ""-debug"" ) ) || ( mode_nodash && !strcmp( *argv, ""debug"" ) ) )
-2.         {

 /*Loop over all options tables, starting with ",Useful
/*Handle error return as specified by the mode flag*/,"-5.             status = ParseOpt( &myargc, &argv, p_argc, &argsave,
-4.                 ploption_info[i].options );
-3.             if ( !status )
-2.                 break;
-1.         }

 /*Handle error return as specified by the mode flag*/

1.       ",Useful
"/*No match.  Keep going if mode_skip is set, otherwise abort if
fully parsing, else return without error.*/","-2.         if ( status == -1 )
-1.         {

 /*No match.  Keep going if mode_skip is set, otherwise abort if
fully parsing, else return without error.*/

1.             status = 0;
2.             if ( mode_skip )
3.             {
4.                 if ",Useful
/*Informational option encountered (-h or -v)*/,"-10.             {
-9.                 fprintf( stderr, ""\nBad command line option \""%s\""\n"", argv[0] );
-8.                 plOptUsage();
-7.             }
-6.             if ( mode_full )
-5.                 exit( 1 );
-4.             break;
-3.        ",Useful
/*Only handle actual flags and their arguments*/,"-6. static int
-5. ParseOpt( int *p_myargc, char ***p_argv, int *p_argc, char ***p_argsave,
-4.           PLOptionTable *option_table )
-3. {
-2.     PLOptionTable *tab;
-1.     char          *opt;

 /*Only handle actual flags and their arguments*/

1.   ",Useful
"/*--------------------------------------------------------------------------
GetOptarg()

! Retrieves an option argument.
! If an error occurs here it is a true syntax error.
!
! @param popt_arg ?
! @param p_myargc ?
! @param p_argv ?
! @param p_argc pointer to a value that ONLY keeps track of number of arguments after processing.
!
! @returns 0 if successful.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*yeah, the user got it right*/","-3.             result = 1;
-2.         }
-1.     }

 /*yeah, the user got it right*/

1.     {
2.         if ( !mode_nodelete )
3.             ( *p_argc )--;
4.         *popt_arg = ( *p_argv )[0];
5.     }
6.     else
7.     {
8.         if ( !mode_quiet",Useful
/*Introducer*/,"-2.     for ( i = tables - 1; i >= 0; i-- )
-1.     {

 /*Introducer*/

1.         if ( ploption_info[i].name )
2.             fprintf( stderr, ""\n%s:"", ploption_info[i].name );
3.         else
4.             fputs( ""\nUser options:"", stderr );",Useful
/*space [ string ]*/,"-9.         col = 80;
-8.         for ( tab = ploption_info[i].options; tab->opt; tab++ )
-7.         {
-6.             if ( tab->mode & PL_OPT_DISABLED )
-5.                 continue;
-4.             if ( !mode_showall && ( tab->mode & PL_OPT_INVISIBLE )",Useful
/*Usage line*/,"-10.     FILE          *outfile = stderr;
-9. #ifdef HAVE_POPEN
-8.     FILE *pager = NULL;
-7.     if ( getenv( ""PAGER"" ) != NULL )
-6.         pager = (FILE *) popen( ""$PAGER"", ""w"" );
-5.     if ( pager == NULL )
-4.         pager = (FILE *) popen( ""mor",Useful
/*Introducer*/,"-2.     for ( i = tables - 1; i >= 0; i-- )
-1.     {

 /*Introducer*/

1.         if ( ploption_info[i].name )
2.             fprintf( stderr, ""\n%s:"", ploption_info[i].name );
3.         else
4.             fputs( ""\nUser options:"", stderr );",Useful
/*Usage notes*/,"-10.                 continue;
-9.             if ( !mode_showall && ( tab->mode & PL_OPT_INVISIBLE ) )
-8.                 continue;
-7.             if ( tab->desc == NULL )
-6.                 continue;
-5.             if ( tab->mode & PL_OPT_INVISIBLE ",Useful
"/*--------------------------------------------------------------------------
tidyDrvOpts

! Tidy up and free memory associated with driver options
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*Free additional DrvOptCmd variables -
first entry in list is a static global variable*/","-10. plP_FreeDrvOpts()
-9. {
-8.     DrvOptCmd *drvp, *drvpl;
-7.     drvp = &drv_opt;
-6.     do
-5.     {
-4.         drvpl = drvp;
-3.         drvp  = drvpl->next;
-2.         free( drvpl->option );
-1.         free( drvpl->value );

 /*Free additional",Useful
"/*--------------------------------------------------------------------------
opt_portrait()

! Performs appropriate action for option ""portrait"":
! Set portrait mode.  If plsc->portrait = 1, then the orientation for certain
! drivers is changed by 90 deg to portrait orientation from the default
! landscape orientation used by PLplot while the aspect ratio allowed to
! adjust using freeaspect.
! N.B. the driver list where this flag is honored is currently limited
! to psc, ps, and pstex.  A 90 deg rotation is just not
! appropriate for certain other drivers.  These drivers where portrait
! mode is ignored include display drivers (e.g., xwin, tk), drivers
! which are subequently going to be transformed to another form
! (e.g., meta), or drivers which are normally used for web
! publishing (e.g., png, jpeg).  That said, the case is not entirely clear
! for all drivers so the list of drivers where portrait mode is honored
! may increase in the future. To add to the list simply copy the small
! bit of code from  ps.c that has to do with pls->portrait to the
! appropriate driver file.
!
! @param PL_UNUSED( opt ) Not used.
! @param PL_UNUSED( opt_arg ) Not used.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*If no delimiter, then assume opaque.*/","-4.         alpha_field++;
-3.     }
-2.     else
-1.     {

 /*If no delimiter, then assume opaque.*/

1.         alpha_field = ""MAX_PLFLT_ALPHA"";
2.     }",Useful
/*To distinguish success/failure after call*/,"-5.         alpha_field = ""MAX_PLFLT_ALPHA"";
-4.     }

 /*To distinguish success/failure after call*/

1.     bgcolor    = strtol( color_field, &endptr, 16 );
2.     save_errno = errno;",Useful
/*Check for various possible errors*/,"-2.     bgcolor    = strtol( color_field, &endptr, 16 );
-1.     save_errno = errno;

 /*Check for various possible errors*/

1.     if ( ( errno == ERANGE && ( bgcolor == LONG_MIN || bgcolor == LONG_MAX ) ) || ( errno != 0 && bgcolor == 0 ) )
2.     {
3.",Useful
"/*If bgcolor has 3 digits, each is ""doubled"" (i.e. ABC becomes AABBCC).*/","-4.         *endptr = '\0';
-3.         fprintf( stderr, ""derived color_field = %s\n"", color_field );
-2.         fprintf( stderr, ""derived bgcolor = %#lx\n"", bgcolor );
-1.     }

 /*If bgcolor has 3 digits, each is ""doubled"" (i.e. ABC becomes AABBCC).*/",Useful
/*To distinguish success/failure after call*/,"-5.         alpha_field = ""MAX_PLFLT_ALPHA"";
-4.     }

 /*To distinguish success/failure after call*/

1.     bgcolor    = strtol( color_field, &endptr, 16 );
2.     save_errno = errno;",Useful
/*Check for various possible errors*/,"-2.     bgcolor    = strtol( color_field, &endptr, 16 );
-1.     save_errno = errno;

 /*Check for various possible errors*/

1.     if ( ( errno == ERANGE && ( bgcolor == LONG_MIN || bgcolor == LONG_MAX ) ) || ( errno != 0 && bgcolor == 0 ) )
2.     {
3.",Useful
"/*it should not be release, because of familying*/","-10.         {
-9.         case ',':
-8.             if ( fl )
-7.                 fl = 0;
-6.             else
-5.             {
-4.                 value[0] = '1';
-3.                 value[1] = '\0';
-2.             }
-1.             *tt          = '\0",Useful
/*don't release*/,"-10.         case ',':
-9.             if ( fl )
-8.                 fl = 0;
-7.             else
-6.             {
-5.                 value[0] = '1';
-4.                 value[1] = '\0';
-3.             }
-2.             *tt          = '\0'; tt = option",Useful
/*don't release*/,"-10.         case ',':
-9.             if ( fl )
-8.                 fl = 0;
-7.             else
-6.             {
-5.                 value[0] = '1';
-4.                 value[1] = '\0';
-3.             }
-2.             *tt          = '\0'; tt = option",Useful
/*don't release*/,"-10.         case ',':
-9.             if ( fl )
-8.                 fl = 0;
-7.             else
-6.             {
-5.                 value[0] = '1';
-4.                 value[1] = '\0';
-3.             }
-2.             *tt          = '\0'; tt = option",Useful
/*don't release*/,"-10.         case ',':
-9.             if ( fl )
-8.                 fl = 0;
-7.             else
-6.             {
-5.                 value[0] = '1';
-4.                 value[1] = '\0';
-3.             }
-2.             *tt          = '\0'; tt = option",Useful
"/*--------------------------------------------------------------------------
opt_cmap0()

! Sets color table 0 based on a cmap0.pal file.
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Name of color map 0 .pal file.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
"/*--------------------------------------------------------------------------
opt_cmap1()

! Sets color table 1 based on a cmap1.pal file.
!
! @param PL_UNUSED( opt ) Not used.
! @param opt_arg Name of a color map 1 .pal file.
! @param PL_UNUSED( client_data ) Not used.
!
! returns 0.
!
--------------------------------------------------------------------------*/","-10. //  the X-windows Version 11 distribution.  The copyright notice is
-9. //  reproduced here:
-8. //
-7. // Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
-6. // and the Massachusetts Institute of Technology, Cambridge,",Useful
/*FIXME - some redundancy might exist*/,"-4. #define PEN    4
-3. typedef struct
-2. {
-1.     PLFLT xmin, xmax, ymin, ymax, xjump, xlen;

 /*FIXME - some redundancy might exist*/

1.     char  *xspec, *yspec, *labx, *laby, *labtop;
2.     PLINT y_ascl, acc, colbox, collab;
3.     PLFLT xlpos, y",Useful
/*strip id number*/,"-8.     char  *xspec, *yspec, *labx, *laby, *labtop;
-7.     PLINT y_ascl, acc, colbox, collab;
-6.     PLFLT xlpos, ylpos;
-5.     PLFLT *x[PEN], *y[PEN];
-4.     PLINT npts[PEN], nptsmax[PEN];
-3.     PLINT colline[PEN], styline[PEN];
-2.     char  *leg",Useful
/*Max allowed*/,"-9.     char  *xspec, *yspec, *labx, *laby, *labtop;
-8.     PLINT y_ascl, acc, colbox, collab;
-7.     PLFLT xlpos, ylpos;
-6.     PLFLT *x[PEN], *y[PEN];
-5.     PLINT npts[PEN], nptsmax[PEN];
-4.     PLINT colline[PEN], styline[PEN];
-3.     char  *leg",Useful
/*Array of pointers*/,"-10.     char  *xspec, *yspec, *labx, *laby, *labtop;
-9.     PLINT y_ascl, acc, colbox, collab;
-8.     PLFLT xlpos, ylpos;
-7.     PLFLT *x[PEN], *y[PEN];
-6.     PLINT npts[PEN], nptsmax[PEN];
-5.     PLINT colline[PEN], styline[PEN];
-4.     char  *le",Useful
/*current strip chart*/,"-10.     PLINT y_ascl, acc, colbox, collab;
-9.     PLFLT xlpos, ylpos;
-8.     PLFLT *x[PEN], *y[PEN];
-7.     PLINT npts[PEN], nptsmax[PEN];
-6.     PLINT colline[PEN], styline[PEN];
-5.     char  *legline[PEN];
-4. } PLStrip;

 /*current strip chart*/
",Useful
/*legend position [0..1]*/,"-10.         stripc->x[i]       = (PLFLT *) malloc( (size_t) sizeof ( PLFLT ) * (size_t) ( stripc->nptsmax[i] ) );
-9.         stripc->y[i]       = (PLFLT *) malloc( (size_t) sizeof ( PLFLT ) * (size_t) ( stripc->nptsmax[i] ) );
-8.         if ( stripc->x",Useful
/*initial bounding box*/,"-1.     stripc->ylpos  = ylpos;

 /*initial bounding box*/

1.     stripc->xmax   = xmax;
2.     stripc->ymin   = ymin;
3.     stripc->ymax   = ymax;",Useful
/*x label*/,"-1.     stripc->yspec  = plstrdup( yspec );

 /*x label*/

1.     stripc->laby   = plstrdup( laby );",Useful
/*title*/,"-1.     stripc->laby   = plstrdup( laby );

 /*title*/

111",Useful
/*box color*/,"-2.     stripc->laby   = plstrdup( laby );

 /*box color*/

111",Useful
/*label color*/,"-3.     stripc->laby   = plstrdup( laby );

 /*label color*/

111",Useful
/*Draw box and same window dimensions*/,"-5.     plvpor( 0, 1, 0, 1 );
-4.     plwind( 0, 1, 0, 1 );
-3.     plcol0( 0 ); plpsty( 0 );
-2.     plclear();
-1.     plvsta();

 /*Draw box and same window dimensions*/

1.     striploc->wxmin = striploc->xmin; striploc->wxmax = striploc->xmax;",Useful
/*FIXME - can exist some redundancy here*/,"-1.     striploc->wxmin = striploc->xmin; striploc->wxmax = striploc->xmax;

 /*FIXME - can exist some redundancy here*/

1.     plwind( striploc->xmin, striploc->xmax, striploc->ymin, striploc->ymax );
2.     pllsty( 1 );
3.     plcol0( striploc->colbox ",Useful
"/*--------------------------------------------------------------------------
plstripa

Add a point to a stripchart.
Points assumed to have increasing X value per pen, and X value of all pens
to increase relatively close together so that no pen's new point is ever
earlier than the current chart X range.
Allocates memory and rescales as necessary.
--------------------------------------------------------------------------*/","-2. static void
-1. plstrip_legend( PLStrip *strip, int flag );

 /*--------------------------------------------------------------------------
plstripa

Add a point to a stripchart.
Points assumed to have increasing X value per pen, and X value of all pen",Useful
"/*Add new point, allocating memory if necessary*/","-10.     {
-9.         plabort( ""Non existent pen"" );
-8.         return;
-7.     }
-6.     if ( ( id < 0 ) || ( id >= MAX_STRIPC ) ||
-5.          ( ( stripc = strip[id] ) == NULL ) )
-4.     {
-3.         plabort( ""Non existent stripchart"" );
-2.       ",Useful
/*option to rescale immediately*/,"-10.         {
-9.             plabort( ""plstripc: Out of memory."" );
-8.             plstripd( id );
-7.             return;
-6.         }
-5.     }
-4.     stripc->x[p][stripc->npts[p] - 1] = x;
-3.     stripc->y[p][stripc->npts[p] - 1] = y;
-2.     str",Useful
/*all data fits within chart X range*/,"-2.     if ( stripc->xmax - stripc->xmin < stripc->xlen )
-1.     {

 /*all data fits within chart X range*/

1.         if ( yasc == 0 )
2.         {",Useful
"/*all data fits within chart Y range, or not rescaling immediately
this is the normal update case simply plotting the new point
If user has changed subwindow, make shure we have the correct one*/","-2.         if ( yasc == 0 )
-1.         {

 /*all data fits within chart Y range, or not rescaling immediately
this is the normal update case simply plotting the new point
If user has changed subwindow, make shure we have the correct one*/

1.           ",Useful
/*FIXME - can exist some redundancy here*/,"-1.     striploc->wxmin = striploc->xmin; striploc->wxmax = striploc->xmax;

 /*FIXME - can exist some redundancy here*/

1.     plwind( striploc->xmin, striploc->xmax, striploc->ymin, striploc->ymax );
2.     pllsty( 1 );
3.     plcol0( striploc->colbox ",Useful
"/*data exceeds Y range, rescale the drawing immediately*/","-10.             plcol0( stripc->colline[p] ); pllsty( stripc->styline[p] );
-9.             if ( ( stripc->npts[p] - 2 ) < 0 )
-8.                 plP_movwor( stripc->x[p][stripc->npts[p] - 1], stripc->y[p][stripc->npts[p] - 1] );
-7.             else
-6",Useful
/*extend the chart if charting in accumulative mode*/,"-7.                     stripc->npts[jpen] = stripc->npts[jpen] - istart;
-6.                     memmove( &stripc->x[jpen][0], &stripc->x[jpen][istart], (size_t) ( stripc->npts[jpen] ) * sizeof ( PLFLT ) );
-5.                     memmove( &stripc->y[jpe",Useful
"/*--------------------------------------------------------------------------
plstripd

Deletes and releases memory used by a stripchart.
--------------------------------------------------------------------------*/","-2. static void
-1. plstrip_legend( PLStrip *strip, int flag );

 /*--------------------------------------------------------------------------
plstripd

Deletes and releases memory used by a stripchart.
----------------------------------------------------",Useful
"/*! @file
!
! Point-, symbol-, and string-plotting routines.
!*/","-10. //
-9. // PLplot is distributed in the hope that it will be useful,
-8. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-7. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-6. // GNU Library General Public License f",Useful
"/*moved to plstr.h, plsc->cfont  static PLINT font = 1;  current font*/","-6. static short int   *fntlkup;
-5. static short int   *fntindx;
-4. static signed char *fntbffr;
-3. static short int   numberfonts, numberchars;
-2. static short int   indxleng;
-1. static short       fontloaded = 0;

 /*moved to plstr.h, plsc->cfont  ",Useful
"/*--------------------------------------------------------------------------
! Plot a glyph at the specified points.  (This function largely
! supersedes plpoin and plsym because many[!] more glyphs are
! accessible with plstring.)  The glyph is specified with a PLplot
! user string.  Note that the user string is not actually limited to
! one glyph so it is possible (but not normally useful) to plot more
! than one glyph at the specified points with this function.  As
! with plmtex and plptex, the user string can contain FCI escapes to
! determine the font, UTF-8 code to determine the glyph or else
! PLplot escapes for Hershey or unicode text to determine the glyph.
! @param n Number of points in x and y arrays.
! @param x Array of X coordinates of points.
! @param y Array of Y coordinates of points.
! @param string PLplot user string corresponding to the glyph to
! be plotted at each of the n points.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
"/*One-time diagnostic output.
fprintf(stdout, ""plploin code, sym = %d, %d\n"", code, sym);*/","-10.         {
-9.             TRANSFORM( x[i], y[i], &xt, &yt );
-8.             pljoin( xt, yt, xt, yt );
-7.         }
-6.     }
-5.     else
-4.     {
-3.         if ( ifont > numberfonts )
-2.             ifont = 1;
-1.         sym = *( fntlkup + ( i",Useful
/*Get the current escape character*/,"-10.         {
-9. #ifndef PL_TEST_FOR_MISSING_GLYPHS
-8.             plhrsh2( ch, x, y );
-7. #endif
-6.         }
-5.         else
-4.         {
-3.             PLUNICODE plhrsh_unicode_buffer[3], fci;
-2.             PLFLT     xform[] = { 1.0, 0.0, 0.0",Useful
/*Unknown font face indicated by 0 value.*/,"-5.             args.text_type    = PL_STRING_SYMBOL;
-4.             args.unicode_char = unicode_char;
-3.             if ( 0 <= idx && idx <= number_of_entries_in_hershey_to_unicode_table )
-2.                 args.font_face = hershey_to_unicode_lookup_",Useful
"/*Comment out to fix problem with ps, psttf drivers
args.base = 1;*/","-1.                 args.font_face = 0;

 /*Comment out to fix problem with ps, psttf drivers
args.base = 1;*/

1.             args.base   = 0;
2.             args.just   = 0.5;
3.             args.xform  = xform;
4.             args.x      = x;
5.       ",Useful
"/*watch out for escape character and unescape it by appending
one extra.*/","-3.             args.unicode_array       = &plhrsh_unicode_buffer[0];
-2.             args.unicode_array_len   = 1;
-1.             plhrsh_unicode_buffer[0] = unicode_char;

 /*watch out for escape character and unescape it by appending
one extra.*/

1.  ",Useful
/*No need to change font back since only one character.*/,"-5.             if ( unicode_char == (PLUNICODE) esc )
-4.             {
-3.                 args.unicode_array_len   = 2;
-2.                 plhrsh_unicode_buffer[1] = unicode_char;
-1.             }

 /*No need to change font back since only one charac",Useful
/*Character at a time method*/,"-6.             plsc->original_chrht  = plsc->chrht;
-5.             plsc->original_chrdef = plsc->chrdef;
-4.             plsc->chrht           = plsc->symht;
-3.             plsc->chrdef          = plsc->symdef;
-2.             if ( plsc->alt_unicode )
",Useful
/*Compute how many physical pixels correspond to a character pixel*/,"-2.     style     = plsc->nms;
-1.     plsc->nms = 0;

 /*Compute how many physical pixels correspond to a character pixel*/

1.     xscale = scale * plsc->xpmm;
2.     yscale = scale * plsc->ypmm;
3.     k = 4;
4.     for (;; )
5.     {
6.         cx = v",Useful
/*Open clip limits to subpage limits*/,"-10.     PLINT clpxmi, clpxma, clpymi, clpyma;
-9.     PLINT vert, refx, refy, x, y;
-8.     PLFLT xdv, ydv, xmm, ymm, refxmm, refymm, shift, xform[4];
-7.     PLFLT chrdef, chrht;
-6.     PLFLT dispx, dispy;
-5.     if ( plsc->level < 2 )
-4.     {
-3.  ",Useful
/*get and store current clip limits*/,"-10.     PLINT vert, refx, refy, x, y;
-9.     PLFLT xdv, ydv, xmm, ymm, refxmm, refymm, shift, xform[4];
-8.     PLFLT chrdef, chrht;
-7.     PLFLT dispx, dispy;
-6.     if ( plsc->level < 2 )
-5.     {
-4.         plabort( ""plmtex: Please set up viewpor",Useful
/*restore initial clip limits*/,"-10.     else if ( plP_stsearch( side, 'r' ) )
-9.     {
-8.         vert  = 1;
-7.         xdv   = plsc->vpdxma;
-6.         ydv   = plsc->vpdymi + ( plsc->vpdyma - plsc->vpdymi ) * pos;
-5.         dispx = disp;
-4.         dispy = 0;
-3.     }
-2.     ",Useful
/*Transformation matrix*/,"-2.         return;
-1.     }

 /*Transformation matrix*/

1.     if ( vert != 0 )
2.     {
3.         xform[0] = 0.0;
4.         xform[1] = -1.0;
5.         xform[2] = 1.0;
6.         xform[3] = 0.0;
7.     }
8.     else
9.     {
10.         xform[0] = 1",Useful
/*restore clip limits*/,"-5.     x    = plP_mmpcx( xmm );
-4.     y    = plP_mmpcy( ymm );
-3.     refx = plP_mmpcx( refxmm );
-2.     refy = plP_mmpcy( refymm );
-1.     plP_text( 0, just, xform, x, y, refx, refy, text );

 /*restore clip limits*/

1. }",Useful
/*superscript*/,"-6.     style     = plsc->nms;
-5.     plsc->nms = 0;
-4.     pldeco( &symbol, &length, string );
-3.     for ( i = 0; i < length; i++ )
-2.     {
-1.         ch = symbol[i];

 /*superscript*/

1.         {
2.             plP_script_scale( TRUE, &level,
3",Useful
/*subscript*/,"-6.         {
-5.             plP_script_scale( TRUE, &level,
-4.                 &old_sscale, &sscale, &old_soffset, &soffset );
-3.             yorg  = 16.0 * dscale * soffset;
-2.             scale = dscale * sscale;
-1.         }

 /*subscript*/

1.  ",Useful
/*back-char*/,"-6.         {
-5.             plP_script_scale( FALSE, &level,
-4.                 &old_sscale, &sscale, &old_soffset, &soffset );
-3.             yorg  = -16.0 * dscale * soffset;
-2.             scale = dscale * sscale;
-1.         }

 /*back-char*/

1.",Useful
/*toogle overline*/,"-1.             xorg -= width * scale;

 /*toogle overline*/

1.             oline = !oline;",Useful
/*toogle underline*/,"-1.             oline = !oline;

 /*toogle underline*/

1.             uline = !uline;
2.         else
3.         {
4.             if ( plcvec( ch, &vxygrid ) )
5.                 plchar( vxygrid, xform, base, oline, uline, refx, refy, scale,
6.          ",Useful
/*This is bad if we get here*/,"-10.     do
-9.     {
-8.         ib++;
-7.         x           = fntbffr[2 * ib];
-6.         y           = fntbffr[2 * ib + 1];
-5.         xygrid[k++] = x;
-4.         xygrid[k++] = y;
-3.     } while ( ( x != 64 || y != 64 ) && k <= ( STLEN - 2 ) );
-",Useful
"/*If we didn't load the font file, then just return now.*/","-5.     *length = 0;
-4.     *symbol = symbol_buffer;
-3.     plgesc( &esc );
-2.     if ( ifont > numberfonts )
-1.         ifont = 1;

 /*If we didn't load the font file, then just return now.*/

1.     if ( !fntlkup )
2.     {
3.         plwarn( ""Attem",Useful
"/*This accesses the Hershey glyphs using the same
""ascii"" index as plpoin.  So the order of the Greek
glyphs in this case depends on the subhersh[0-3]
indices in fonts/font11.c which for lower-case epsilon,
theta, and phi substitutes (684, 685, and 686) for
(631, 634, and 647) in the compact case and (2184,
2185, and 2186) for (2131, 2134, and 2147) in the
extended case.*/","-10.                 test  = text[j++];
-9.                 ifont = 1 + plP_strpos( font_types,
-8.                     isupper( test ) ? tolower( test ) : test );
-7.                 if ( ifont == 0 || ifont > numberfonts )
-6.                     ifont ",Useful
"/*Decode character.
>>PC<< removed increment from following expression to fix
compiler bug*/","-10.                 sym[( *length )++] =
-9.                     *( fntlkup + ( ifont - 1 ) * numberchars + 127 + ig );
-8.             }
-7.             else
-6.             {
-5.                 ;
-4.             }
-3.         }
-2.         else
-1.   ",Useful
"/*--------------------------------------------------------------------------
PLINT plP_strpos()

Searches string str for first occurence of character chr.  If found
the position of the character in the string is returned (the first
character has position 0).  If the character is not found a -1 is
returned.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
/*If superscript of subscript moves further away from centerline....*/,"-10.         *old_scale  = 1.;
-9.         *old_offset = 0.;
-8.     }
-7.     else
-6.     {
-5.         *old_scale  = *scale;
-4.         *old_offset = *offset;
-3.     }
-2.     if ( ( *level >= 0 && ifupper ) || ( *level <= 0 && !ifupper ) )
-1.     {",Useful
/*If superscript of subscript moves closer to centerline....*/,"-5.         *scale  = 0.75 * *old_scale;
-4.         *offset = *old_offset + *old_scale;
-3.     }
-2.     else
-1.     {

 /*If superscript of subscript moves closer to centerline....*/

1.         *scale  = *old_scale / 0.75;
2.         *offset = *old_o",Useful
/*Done*/,"-10.         if ( !fntbffr )
-9.             failed = 1;
-8.         else
-7. #if PLPLOT_USE_TCL_CHANNELS
-6.             pdf_rdx( fntbffr, sizeof ( signed char ) * (size_t) ( 2 * bffrleng ), pdfs );
-5. #else
-4.             plio_fread( (void *) fntbffr,",Useful
"/*--------------------------------------------------------------------------
int plhershey2unicode ( int in )

Function searches for in, the input hershey code, in a lookup table and
returns the corresponding index in that table.
Using this index you can work out the unicode equivalent as well as
the closest approximate to the font-face. If the returned index is
-1 then no match was possible.

Two versions of the function exist, a simple linear search version,
and a more complex, but significantly faster, binary search version.
If there seem to be problems with the binary search method, the brain-dead
linear search can be enabled by defining SIMPLE_BUT_SAFE_HERSHEY_LOOKUP
at compile time.
--------------------------------------------------------------------------*/","-10. static void
-9. pldeco( short int **sym, PLINT *length, PLCHAR_VECTOR text );
-8. static void
-7. plchar( signed char *xygrid, PLFLT *xform, PLINT base, PLINT oline, PLINT uline,
-6.         PLINT refx, PLINT refy, PLFLT scale, PLFLT xpmm, PLFLT ypmm",Useful
/*local storage*/,"-10. //	just = 0.0 => left hand edge of string is at reference
-9. //	just = 1.0 => right hand edge of string is at reference
-8. //	just = 0.5 => center of string is at reference
-7. //
-6. // All calculations are done in physical coordinates.
-5. //
-4.",Useful
/*get plotting environment information*/,"-5.     if ( plsc->level < 3 )
-4.     {
-3.         plabort( ""plmtex3: Please set up window first"" );
-2.         return;
-1.     }

 /*get plotting environment information*/

1.     plP_gdom( &xmin, &xmax, &ymin, &ymax );
2.     plP_grange( &zscale, &zm",Useful
/*get the locations of the end points of the relevant axis*/,"-2.     if ( ( plP_stindex( side, ""x"" ) != -1 ) || ( plP_stindex( side, ""y"" ) != -1 ) )
-1.     {

 /*get the locations of the end points of the relevant axis*/

111",Useful
/*text always goes from left to right*/,"-10.                 epy2 = plP_wcpcy( plP_w3wcy( xmin, ymax, zmin ) );
-9.             }
-8.             else
-7.             {
-6.                 epx1 = plP_wcpcx( plP_w3wcx( xmax, ymin, zmin ) );
-5.                 epy1 = plP_wcpcy( plP_w3wcy( xmax, ",Useful
/*calculate location of text center point*/,"-2.             pos = 1.0 - pos;
-1.         }

 /*calculate location of text center point*/

111",Useful
"/*1. calculate the angle of the axis we are to
draw the text on relative to the horizontal*/","-3.             pos = 1.0 - pos;
-2.         }

 /*1. calculate the angle of the axis we are to
draw the text on relative to the horizontal*/

1.         if ( ( epx2 - epx1 ) != 0.0 )
2.         {
3.             theta = atan( ( epy2 - epy1 ) / ( epx2 - ep",Useful
/*2. calculate the perpendicular vector*/,"-10.         {
-9.             if ( epy2 > epy1 )
-8.             {
-7.                 theta = 0.5 * PI;
-6.             }
-5.             else
-4.             {
-3.                 theta = -0.5 * PI;
-2.             }
-1.         }

 /*2. calculate the ",Useful
"/*4. compute reference point
It appears that drivers that cannot handle text justification
use this as the starting point of the string.
Calculations must be done in millimeters for this part
so we convert to mm, do the calculation and convert back.
The calculation is also dependent of the orientation
(perpendicular or parallel) of the text.*/","-2.         xpc = pos * ( epx2 - epx1 ) + epx1;
-1.         ypc = pos * ( epy2 - epy1 ) + epy1;

 /*4. compute reference point
It appears that drivers that cannot handle text justification
use this as the starting point of the string.
Calculations must be",Useful
"/*perpendicular, rotate 90 degrees & shear*/","-10.         else
-9.         {
-8.             xrefpc = xpc - cos( theta ) * shift;
-7.             yrefpc = ypc - sin( theta ) * shift;
-6.         }
-5.         xpc    = plP_mmpcx( xpc );
-4.         ypc    = plP_mmpcy( ypc );
-3.         xrefpc = plP_",Useful
"/*parallel, rotate & shear by angle*/","-8.         if ( plP_stindex( side, ""v"" ) != -1 )
-7.         {
-6.             xform[0] = 0.0;
-5.             xform[1] = -cos( theta );
-4.             xform[2] = 1.0;
-3.             xform[3] = -sin( theta );
-2.             plP_text( 0, just, xform, (",Useful
"/*Find the left most of the 4 z axis options for ""primary""
Also find the location of frontmost point in the graph,
which will be needed to calculate at what angle to shear
the text.*/","-2.     if ( plP_stindex( side, ""z"" ) != -1 )
-1.     {

 /*Find the left most of the 4 z axis options for ""primary""
Also find the location of frontmost point in the graph,
which will be needed to calculate at what angle to shear
the text.*/

1.         i",Useful
"/*find the right most of the 4 z axis options for ""primary""*/","-10.             }
-9.             if ( plP_wcpcx( plP_w3wcx( xmax, ymax, zmin ) ) < epx1 )
-8.             {
-7.                 epx1 = plP_wcpcx( plP_w3wcx( xmax, ymax, zmin ) );
-6.                 epy1 = plP_wcpcy( plP_w3wcy( xmax, ymax, zmin ) );
-5.",Useful
"/*Calculate location of text center point.
This is very similiar for the z axis.*/","-10.             }
-9.             if ( plP_wcpcx( plP_w3wcx( xmax, ymax, zmin ) ) > epx1 )
-8.             {
-7.                 epx1 = plP_wcpcx( plP_w3wcx( xmax, ymax, zmin ) );
-6.                 epy1 = plP_wcpcy( plP_w3wcy( xmax, ymax, zmin ) );
-5.",Useful
/*primary and secondary have to be handled separately here*/,"-10.             {
-9.                 epx1 = plP_wcpcx( plP_w3wcx( xmax, ymax, zmin ) );
-8.                 epy1 = plP_wcpcy( plP_w3wcy( xmax, ymax, zmin ) );
-7.                 epy2 = plP_wcpcy( plP_w3wcy( xmax, ymax, zmax ) );
-6.                 epx",Useful
"/*1. Calculate the angle of the axis we are to
draw the text on relative to the horizontal.*/","-2.         if ( plP_stindex( side, ""p"" ) != -1 )
-1.         {

 /*1. Calculate the angle of the axis we are to
draw the text on relative to the horizontal.*/

1.             if ( ( epx3 - epx1 ) != 0.0 )
2.             {
3.                 theta = atan(",Useful
/*2. Calculate the perpendicular vector.*/,"-10.             {
-9.                 if ( epy3 > epy1 )
-8.                 {
-7.                     theta = 0.5 * PI;
-6.                 }
-5.                 else
-4.                 {
-3.                     theta = -0.5 * PI;
-2.                 }",Useful
"/*Determine angle to shear text in the x-y plane. This is a little
messy, but basically the idea is:

Compute the dot product of the vector d and the vector s to
determine the angle between them (acos(t) = d . s / |d| |s|).
Then because acos will return a number from 0.0 to PI, i.e.
only in quadrants 1 or 2, compute the cross product of the
two vectors. If this is negative then the angle is adjusted
0.0 to -PI.*/","-3.     xdpc  = plP_wcpcx( plP_w3wcx( wx + dx, wy + dy, wz + dz ) );
-2.     ydpc  = plP_wcpcy( plP_w3wcy( wx + dx, wy + dy, wz + dz ) );
-1.     theta = atan2( ydpc - ypc, xdpc - xpc );

 /*Determine angle to shear text in the x-y plane. This is a little",Useful
"/*Determine how to adjust the ""stride"" of the text to make it
appear that it is going into (or out of) the page. Basically
scale the x baseline of the text by the normalized length of
the d vector projected into the x-y plane.*/","-10.         ld   = sqrt( ( xpc - xdpc ) * ( xpc - xdpc ) + ( ypc - ydpc ) * ( ypc - ydpc ) );
-9.         ls   = sqrt( ( xpc - xspc ) * ( xpc - xspc ) + ( ypc - yspc ) * ( ypc - yspc ) );
-8.         phi  = acos( ( ( xdpc - xpc ) * ( xspc - xpc ) + ( ydp",Useful
/*not multiplot mode*/,"-10.     if ( ymin == ymax )
-9.     {
-8.         plabort( ""plenv: Invalid ymin and ymax arguments"" );
-7.         return;
-6.     }
-5.     if ( just < -1 || just > 2 )
-4.     {
-3.         plabort( ""plenv: Invalid just option"" );
-2.         return;
-",Useful
"/*Find out position of subpage boundaries in millimetres, reduce by
the desired border, and convert back into normalized subpage
coordinates*/","lb = 8.0 * plsc->chrht;
    rb = 5.0 * plsc->chrht;
    tb = 5.0 * plsc->chrht;
    bb = 5.0 * plsc->chrht;

    xmin = plP_dcscx( plP_mmdcx( (PLFLT) ( plP_dcmmx( plsc->spdxmi ) + lb ) ) );
    xmax = plP_dcscx( plP_mmdcx( (PLFLT) ( plP_dcmmx( plsc->spdxma ) - rb ) ) );
    ymin = plP_dcscy( plP_mmdcy( (PLFLT) ( plP_dcmmy( plsc->spdymi ) + tb ) ) );
    ymax = plP_dcscy( plP_mmdcy( (PLFLT) ( plP_dcmmy( plsc->spdyma ) - bb ) ) );

    plvpor( xmin, xmax, ymin, ymax );
}

 /*Find out position of subpage boundaries in millimetres, reduce by
the desired border, and convert back into normalized subpage
coordinates*/

111",Useful
/*center plot within page*/,"-10.     if ( aspect * xsize > ysize )
-9.     {
-8.         nxsize = ysize / aspect;
-7.         nysize = ysize;
-6.     }
-5.     else
-4.     {
-3.         nxsize = xsize;
-2.         nysize = xsize * aspect;
-1.     }

 /*center plot within page*/

1.",Useful
/*adjust for labels*/,"-10.         plabort( ""plvasp: Please call plinit first"" );
-9.         return;
-8.     }
-7.     lb = 8.0 * plsc->chrht;
-6.     rb = 5.0 * plsc->chrht;
-5.     tb = 5.0 * plsc->chrht;
-4.     bb = 5.0 * plsc->chrht;
-3.     plgspa( &spxmin, &spxmax, &sp",Useful
/*center plot within page*/,"-10.     if ( aspect * xsize > ysize )
-9.     {
-8.         nxsize = ysize / aspect;
-7.         nysize = ysize;
-6.     }
-5.     else
-4.     {
-3.         nxsize = xsize;
-2.         nysize = xsize * aspect;
-1.     }

 /*center plot within page*/

1.",Useful
/*Error flag for aborts*/,"-10.           PLINT **ipts, PLFLT *distance, PLINT *lastindex,
-9.           PLTRANSFORM_callback pltr, PLPointer pltr_data );
-8. static void
-7. plfloatlabel( PLFLT value, char *string, PLINT len );
-6. static PLFLT
-5. plP_pcwcx( PLINT x );
-4. static",Useful
/*Ensure labels appear the right way up*/,"-10.     delta_y = plP_pcdcy( plsc->curry ) - plP_pcdcy( plP_wcpcy( tpy ) );
-9.     currx_old = plsc->currx;
-8.     curry_old = plsc->curry;
-7.     *distance += sqrt( delta_x * delta_x + delta_y * delta_y );
-6.     plP_drawor( tpx, tpy );
-5.     if (",Useful
/*physical coords (x) to world coords*/,"-10.         if ( exponent >= 0 )
-9.             prec = prec - 1 - exponent;
-8.         else
-7.             prec = prec - 1 + abs( exponent );
-6.         if ( prec < 0 )
-5.             prec = 0;
-4.         snprintf( form, FORM_LEN, ""%%.%df"", (int) p",Useful
/*physical coords (y) to world coords*/,"-5. static PLFLT
-4. plP_pcwcx( PLINT x )
-3. {
-2.     return ( ( x - plsc->wpxoff ) / plsc->wpxscl );
-1. }

 /*physical coords (y) to world coords*/

1. static PLFLT
2. plP_pcwcy( PLINT y )
3. {
4.     return ( ( y - plsc->wpyoff ) / plsc->wpyscl );
5.",Useful
"/*--------------------------------------------------------------------------

cont_store:

Draw contour lines in memory.
cont_clean_store() must be called after use to release allocated memory.

--------------------------------------------------------------------------*/","-5. static PLFLT
-4. plP_pcwcy( PLINT y )
-3. {
-2.     return ( ( y - plsc->wpyoff ) / plsc->wpyscl );
-1. }

 /*--------------------------------------------------------------------------

cont_store:

Draw contour lines in memory.
cont_clean_store() mus",Useful
"/*Use intermediates to avoid possible floating point
under / over flow during multiplication.*/","-10.     ( *pltr )( kcol, krow + 1, &px[0], &py[0], pltr_data );
-9.     ( *pltr )( kcol, krow, &px[1], &py[1], pltr_data );
-8.     ( *pltr )( kcol + 1, krow, &px[2], &py[2], pltr_data );
-7.     ( *pltr )( kcol + 1, krow + 1, &px[3], &py[3], pltr_data )",Useful
"/*Check if this is a completely flat square - in which case
ignore it*/","-3.     if ( ( iedge[0] == -1 ) && ( iedge[1] == -1 ) && ( iedge[2] == -1 )
-2.          && ( iedge[3] == -1 ) )
-1.         return;

 /*Check if this is a completely flat square - in which case
ignore it*/

1.     if ( ( f[0] == 0.0 ) && ( f[1] == 0.0 ) ",Useful
/*Calculate intersection points*/,"-3.     if ( ( f[0] == 0.0 ) && ( f[1] == 0.0 ) && ( f[2] == 0.0 ) &&
-2.          ( f[3] == 0.0 ) )
-1.         return;

 /*Calculate intersection points*/

1.     num = 0;
2.     if ( startedge < 0 )
3.     {
4.         first = 1;
5.     }
6.     else
7",Useful
/*If the contour is an edge check it hasn't already been done*/,"-10.     {
-9.         locx[num] = lastx;
-8.         locy[num] = lasty;
-7.         num++;
-6.         first = 0;
-5.     }
-4.     for ( k = 0, i = ( startedge < 0 ? 0 : startedge ); k < 4; k++, i = ( i + 1 ) % 4 )
-3.     {
-2.         if ( i == starte",Useful
"/*Need to follow contour into next grid box
Easy case where contour does not pass through corner*/","-4.                 if ( contlabel_active )
-3.                     pl_drawcontlabel( locx[num], locy[num], flabel, distance, lastindex );
-2.                 else
-1.                     cont_xy_store( locx[num], locy[num] );

 /*Need to follow contour i",Useful
/*ur is out of bounds*/,"-4.     else
-3.     {
-2.         xll = xg[ul][vl];
-1.         yll = yg[ul][vl];

 /*ur is out of bounds*/

1.         if ( ur == nx && vr < ny )
2.         {
3.             xlr = xg[ul][vr];
4.             ylr = yg[ul][vr];
5.             *tx = xll * (",Useful
/*vr is out of bounds*/,"-7.         if ( ur == nx && vr < ny )
-6.         {
-5.             xlr = xg[ul][vr];
-4.             ylr = yg[ul][vr];
-3.             *tx = xll * ( 1 - dv ) + xlr * ( dv );
-2.             *ty = yll * ( 1 - dv ) + ylr * ( dv );
-1.         }

 /*vr is ",Useful
/*ur is out of bounds*/,"-4.     else
-3.     {
-2.         xll = xg[ul][vl];
-1.         yll = yg[ul][vl];

 /*ur is out of bounds*/

1.         if ( ur == nx && vr < ny )
2.         {
3.             xlr = xg[ul][vr];
4.             ylr = yg[ul][vr];
5.             *tx = xll * (",Useful
/*vr is out of bounds*/,"-7.         if ( ur == nx && vr < ny )
-6.         {
-5.             xlr = xg[ul][vr];
-4.             ylr = yg[ul][vr];
-3.             *tx = xll * ( 1 - dv ) + xlr * ( dv );
-2.             *ty = yll * ( 1 - dv ) + ylr * ( dv );
-1.         }

 /*vr is ",Useful
/*ur is out of bounds*/,"-4.     else
-3.     {
-2.         xll = xg[ul][vl];
-1.         yll = yg[ul][vl];

 /*ur is out of bounds*/

1.         if ( ur == nx && vr < ny )
2.         {
3.             xlr = xg[ul][vr];
4.             ylr = yg[ul][vr];
5.             *tx = xll * (",Useful
/*vr is out of bounds*/,"-7.         if ( ur == nx && vr < ny )
-6.         {
-5.             xlr = xg[ul][vr];
-4.             ylr = yg[ul][vr];
-3.             *tx = xll * ( 1 - dv ) + xlr * ( dv );
-2.             *ty = yll * ( 1 - dv ) + ylr * ( dv );
-1.         }

 /*vr is ",Useful
"/*! @file
!  Functions for drawing an arc.
!*/","-10. //
-9. // PLplot is distributed in the hope that it will be useful,
-8. // but WITHOUT ANY WARRANTY; without even the implied warranty of
-7. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-6. // GNU Library General Public License f",Useful
/*The coordinates for the circle outline*/,"-2.     theta0 = DEG_TO_RAD( angle1 );
-1.     theta_step = d_angle / ( segments - 1 );

 /*The coordinates for the circle outline*/

1.     for ( i = 0; i < segments; i++ )
2.     {
3.         theta  = theta0 + theta_step * (PLFLT) i;
4.         ctheta =",Useful
/*Add the center point if we aren't drawing a circle*/,"-10.     for ( i = 0; i < segments; i++ )
-9.     {
-8.         theta  = theta0 + theta_step * (PLFLT) i;
-7.         ctheta = cos( theta );
-6.         stheta = sin( theta );
-5.         xs[i]  = x + a * ctheta * cphi - b * stheta * sphi;
-4.         ys[",Useful
"/*TODO: For now, only unrotated plots use the driver-accelerated path.*/","-6. void
-5. c_plarc( PLFLT x, PLFLT y, PLFLT a, PLFLT b, PLFLT angle1, PLFLT angle2, PLFLT rotate, PLBOOL fill )
-4. {
-3.     PLINT      xscl[2], yscl[2];
-2.     PLINT      clpxmi, clpxma, clpymi, clpyma;
-1.     arc_struct *arc_info;

 /*TODO: For now",Useful
/*savestring.c*/,"
/* savestring.c  */


 /*savestring.c*/

1. /* Copyright (C) 1998,2003 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
/*histsearch.c -- searching the history list.*/,"
/* histsearch.c -- searching the history list. */


 /*histsearch.c -- searching the history list.*/

1. /* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
2.    This file contains the GNU History Library (the Library), a set of
3.    routines for managing the text of previously typed lines.
4.    The Library is free software; you can redistribute it and/or modify
5.    it under the terms of the GNU General Public License as published by
6.    the Free Software Foundation; either version 2, or (at your option)
7.    any later version.
8.    The Library is distributed in the hope that it will be useful, but
9.    WITHOUT ANY WARRANTY; without even the implied warranty of
10.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",Useful
/*HAVE_STDLIB_H*/,"-10.    General Public License for more details.
-9.    The GNU General Public License is often shipped with GNU software, and
-8.    is generally kept in a file called COPYING or LICENSE.  If you do not
-7.    have a copy of the license, write to the Fre",Useful
/*local*/,"-10.    returned. */
-9. static int
-8. history_search_internal (string, direction, anchored)
-7.      const char *string;
-6.      int direction, anchored;
-5. {
-4.   register int i, reverse;
-3.   register char *line;
-2.   register int line_index;
-1.",Useful
/*Take care of trivial cases first.*/,"-2.   i = history_offset;
-1.   reverse = (direction < 0);

 /*Take care of trivial cases first.*/

1.   if (string == 0 || *string == '\0')
2.     return (-1);
3.   if (!history_length || ((i >= history_length) && !reverse))
4.     return (-1);
5.   if (",Useful
/*Search each line in the history list for STRING.*/,"-10.     return (-1);
-9.   if (!history_length || ((i >= history_length) && !reverse))
-8.     return (-1);
-7.   if (reverse && (i >= history_length))
-6.     i = history_length - 1;
-5. #define NEXT_LINE() do { if (reverse) i--; else i++; } while (0)
-",Useful
/*At limit for direction?*/,"-10.   if (!history_length || ((i >= history_length) && !reverse))
-9.     return (-1);
-8.   if (reverse && (i >= history_length))
-7.     i = history_length - 1;
-6. #define NEXT_LINE() do { if (reverse) i--; else i++; } while (0)
-5.   the_history = hi",Useful
"/*If STRING is longer than line, no match.*/","-4.       if ((reverse && i < 0) || (!reverse && i == history_length))
-3. 	return (-1);
-2.       line = the_history[i]->line;
-1.       line_index = strlen (line);

 /*If STRING is longer than line, no match.*/

1.       if (string_len > line_index)
2. ",Useful
/*Do substring search.*/,"-10.       if (anchored == ANCHORED_SEARCH)
-9. 	{
-8. 	  if (STREQN (string, line, string_len))
-7. 	    {
-6. 	      history_offset = i;
-5. 	      return (0);
-4. 	    }
-3. 	  NEXT_LINE ();
-2. 	  continue;
-1. 	}

 /*Do substring search.*/

1.       ",Useful
/*!HAVE_STRING_H*/,"-10. #  include ""config_readline.h""
-9. #endif
-8. #if defined (HAVE_UNISTD_H)
-7. #  ifdef _MINIX
-6. #    include <sys/types.h>
-5. #  endif
-4. #  include <unistd.h>
-3. #endif
-2. #if defined (HAVE_STRING_H)
-1. #  include <string.h>

 /*!HAVE_STRING_",Useful
/*!HAVE_STRING_H*/,"-10. #  include ""config_readline.h""
-9. #endif
-8. #if defined (HAVE_UNISTD_H)
-7. #  ifdef _MINIX
-6. #    include <sys/types.h>
-5. #  endif
-4. #  include <unistd.h>
-3. #endif
-2. #if defined (HAVE_STRING_H)
-1. #  include <string.h>

 /*!HAVE_STRING_",Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



 /*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Useful
/*TEST || STATIC_MALLOC*/,"-9. #include <sys/types.h>
-8. #if defined (HAVE_PWD_H)
-7. #include <pwd.h>
-6. #endif
-5. #include ""tilde.h""
-4. #if defined (TEST) || defined (STATIC_MALLOC)
-3. static void *xmalloc (), *xrealloc ();
-2. #else
-1. #  include ""xmalloc.h""

 /*TEST || ST",Useful
/*!HAVE_GETPW_DECLS*/,"-7. #if !defined (HAVE_GETPW_DECLS)
-6. #  if defined (HAVE_GETPWUID)
-5. extern struct passwd *getpwuid PARAMS((uid_t));
-4. #  endif
-3. #  if defined (HAVE_GETPWNAM)
-2. extern struct passwd *getpwnam PARAMS((const char *));
-1. #  endif

 /*!HAVE_GETP",Useful
/*!savestring*/,"-2. #if !defined (savestring)
-1. #define savestring(x) strcpy ((char *)xmalloc (1 + strlen (x)), (x))

 /*!savestring*/

1. #if !defined (NULL)
2. #  if defined (__STDC__)
3. #    define NULL ((void *) 0)
4. #  else
5. #    define NULL 0x0",Useful
/*!__STDC__*/,"-5. #if !defined (NULL)
-4. #  if defined (__STDC__)
-3. #    define NULL ((void *) 0)
-2. #  else
-1. #    define NULL 0x0

 /*!__STDC__*/

111",Useful
/*!NULL*/,"-6. #if !defined (NULL)
-5. #  if defined (__STDC__)
-4. #    define NULL ((void *) 0)
-3. #  else
-2. #    define NULL 0x0

 /*!NULL*/

111",Useful
"/*If being compiled as part of bash, these will be satisfied from
   variables.o.  If being compiled as part of readline, they will
   be satisfied from shell.o.*/","-7. #if !defined (NULL)
-6. #  if defined (__STDC__)
-5. #    define NULL ((void *) 0)
-4. #  else
-3. #    define NULL 0x0

 /*If being compiled as part of bash, these will be satisfied from
   variables.o.  If being compiled as part of readline, they wi",Useful
"/*The default value of tilde_additional_prefixes.  This is set to
   whitespace preceding a tilde so that simple programs which do not
   perform any word separation get desired behaviour.*/","-2. extern char *sh_get_home_dir PARAMS((void));
-1. extern char *sh_get_env_value PARAMS((const char *));

 /*The default value of tilde_additional_prefixes.  This is set to
   whitespace preceding a tilde so that simple programs which do not
   perform ",Useful
"/*If non-null, this contains the address of a function that the application
   wants called before trying the standard tilde expansions.  The function
   is called with the text sans tilde, and returns a malloc()'ed string
   which is the expansion, or a NULL pointer if the expansion fails.*/","-2. static const char *default_suffixes[] =
-1.   { "" "", ""\n"", (const char *)NULL };

 /*If non-null, this contains the address of a function that the application
   wants called before trying the standard tilde expansions.  The function
   is called with",Useful
"/*If non-null, this contains the address of a function to call if the
   standard meaning for expanding a tilde fails.  The function is called
   with the text (sans tilde, as in ""foo""), and returns a malloc()'ed string
   which is the expansion, or a NULL pointer if there is no expansion.*/","-1. tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;

 /*If non-null, this contains the address of a function to call if the
   standard meaning for expanding a tilde fails.  The function is called
   with the text (sans t",Useful
"/*When non-null, this is a NULL terminated array of strings which
   are duplicates for a tilde prefix.  Bash uses this to expand
   `=~' and `:~'.*/","-1. tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;

 /*When non-null, this is a NULL terminated array of strings which
   are duplicates for a tilde prefix.  Bash uses this to expand
   `=~' and `:~'.*/

1. char **tilde_addit",Useful
"/*When non-null, this is a NULL terminated array of strings which match
   the end of a username, instead of just ""/"".  Bash sets this to
   `:' and `=~'.*/","-1. char **tilde_additional_prefixes = (char **)default_prefixes;

 /*When non-null, this is a NULL terminated array of strings which match
   the end of a username, instead of just ""/"".  Bash sets this to
   `:' and `=~'.*/

1. char **tilde_additional_su",Useful
"/*Find the start of a tilde expansion in STRING, and return the index of
   the tilde which starts the expansion.  Place the length of the text
   which identified this tilde starter in LEN, excluding the tilde itself.*/","-5. char **tilde_additional_suffixes = (char **)default_suffixes;
-4. static int tilde_find_prefix PARAMS((const char *, int *));
-3. static int tilde_find_suffix PARAMS((const char *));
-2. static char *isolate_tilde_prefix PARAMS((const char *, int *));",Useful
"/*Find the end of a tilde expansion in STRING, and return the index of
   the character which ends the tilde definition.*/","-10. 	      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
-9. 		{
-8. 		  *len = strlen (prefixes[j]) - 1;
-7. 		  return (i + *len);
-6. 		}
-5. 	    }
-4. 	}
-3.     }
-2.   return (string_len);
-1. }

 /*Find the end of a tilde expa",Useful
/*|| !string[i]*/,"-10. tilde_find_suffix (string)
-9.      const char *string;
-8. {
-7.   register int i, j, string_len;
-6.   register char **suffixes;
-5.   suffixes = tilde_additional_suffixes;
-4.   string_len = strlen (string);
-3.   for (i = 0; i < string_len; i++)
",Useful
/*Return a new string which is the result of tilde expanding STRING.*/,"-10. #endif
-9. 	break;
-8.       for (j = 0; suffixes && suffixes[j]; j++)
-7. 	{
-6. 	  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
-5. 	    return (i);
-4. 	}
-3.     }
-2.   return (i);
-1. }

 /*Return a new string which is the ",Useful
/*Scan through STRING expanding tildes as we come to them.*/,"-10. tilde_expand (string)
-9.      const char *string;
-8. {
-7.   char *result;
-6.   int result_size, result_index;
-5.   result_index = result_size = 0;
-4.   if ((result = strchr (string, '~')))
-3.     result = (char *)xmalloc (result_size = (strlen",Useful
/*Make START point to the tilde which starts the expansion.*/,"-5.   while (1)
-4.     {
-3.       register int start, end;
-2.       char *tilde_word, *expansion;
-1.       int len;

 /*Make START point to the tilde which starts the expansion.*/

1.       start = tilde_find_prefix (string, &len);",Useful
/*Copy the skipped text into the result.*/,"-1.       start = tilde_find_prefix (string, &len);

 /*Copy the skipped text into the result.*/

1.       if ((result_index + start + 1) > result_size)
2. 	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));
3.       strncpy (result + ",Useful
"/*Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
	 $HOME for `user' is /.  On cygwin, // denotes a network drive.*/","-8.       tilde_word = (char *)xmalloc (1 + end);
-7.       strncpy (tilde_word, string, end);
-6.       tilde_word[end] = '\0';
-5.       string += end;
-4.       expansion = tilde_expand_word (tilde_word);
-3.       free (tilde_word);
-2.       len = st",Useful
"/*Take FNAME and return the tilde prefix we want expanded.  If LENP is
   non-null, the index of the end of the prefix into FNAME is returned in
   the location it points to.*/","-10. 	  if ((result_index + len + 1) > result_size)
-9. 	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));
-8. 	  strcpy (result + result_index, expansion);
-7. 	  result_index += len;
-6. 	}
-5.       free (expansion);
-4.     }
-3",Useful
"/*Public function to scan a string (FNAME) beginning with a tilde and find
   the portion of the string that should be passed to the tilde expansion
   function.  Right now, it just calls tilde_find_suffix and allocates new
   memory, but it can be expanded to do different things later.*/","-10. #else
-9.   for (i = 1; fname[i] && fname[i] != '/'; i++)
-8. #endif
-7.     ret[i - 1] = fname[i];
-6.   ret[i - 1] = '\0';
-5.   if (lenp)
-4.     *lenp = i;
-3.   return ret;
-2. }
-1. #if 0

 /*Public function to scan a string (FNAME) beginning w",Useful
"/*Return a string that is PREFIX concatenated with SUFFIX starting at
   SUFFIND.*/","-10.     {
-9.       r = (char *)xmalloc (1 + x);
-8.       strncpy (r, fname, x);
-7.       r[x] = '\0';
-6.       if (lenp)
-5. 	*lenp = x;
-4.     }
-3.   return r;
-2. }
-1. #endif

 /*Return a string that is PREFIX concatenated with SUFFIX starting a",Useful
"/*Do the work of tilde expansion on FILENAME.  FILENAME starts with a
   tilde.  If there is no expansion, call tilde_expansion_failure_hook.
   This always returns a newly-allocated string, never static storage.*/","-10.   char *ret;
-9.   int plen, slen;
-8.   plen = (prefix && *prefix) ? strlen (prefix) : 0;
-7.   slen = strlen (suffix + suffind);
-6.   ret = (char *)xmalloc (plen + slen + 1);
-5.   if (plen)
-4.     strcpy (ret, prefix);
-3.   strcpy (ret + plen, ",Useful
"/*A leading `~/' or a bare `~' is *always* translated to the value of
     $HOME or the home directory of the current user, regardless of any
     preexpansion hook.*/","-10. tilde_expand_word (filename)
-9.      const char *filename;
-8. {
-7.   char *dirname, *expansion, *username;
-6.   int user_len;
-5.   struct passwd *user_entry;
-4.   if (filename == 0)
-3.     return ((char *)NULL);
-2.   if (*filename != '~')
-1.",Useful
"/*If there is no HOME variable, look up the directory in
	 the password database.*/","-1.       expansion = sh_get_env_value (""HOME"");

 /*If there is no HOME variable, look up the directory in
	 the password database.*/

1.       if (expansion == 0)
2. 	expansion = sh_get_home_dir ();
3.       return (glue_prefix_and_suffix (expansion, fi",Useful
"/*No preexpansion hook, or the preexpansion hook failed.  Look in the
     password database.*/","-10.     {
-9.       expansion = (*tilde_expansion_preexpansion_hook) (username);
-8.       if (expansion)
-7. 	{
-6. 	  dirname = glue_prefix_and_suffix (expansion, filename, user_len);
-5. 	  free (username);
-4. 	  free (expansion);
-3. 	  return (dirn",Useful
"/*If the calling program has a special syntax for expanding tildes,
	 and we couldn't find a standard expansion, then let them try.*/","-8.   dirname = (char *)NULL;
-7. #if defined (HAVE_GETPWNAM)
-6.   user_entry = getpwnam (username);
-5. #else
-4.   user_entry = 0;
-3. #endif
-2.   if (user_entry == 0)
-1.     {

 /*If the calling program has a special syntax for expanding tildes,
	 a",Useful
"/*If we don't have a failure hook, or if the failure hook did not
	 expand the tilde, return a copy of what we were passed.*/","-10. 	 and we couldn't find a standard expansion, then let them try. */
-9.       if (tilde_expansion_failure_hook)
-8. 	{
-7. 	  expansion = (*tilde_expansion_failure_hook) (username);
-6. 	  if (expansion)
-5. 	    {
-4. 	      dirname = glue_prefix_and",Useful
"/** Local variables:
 * compile-command: ""gcc -g -DTEST -o tilde tilde.c""
 * end:*/","-10.     memory_error_and_abort ();
-9.   return (temp);
-8. }
-7. static void
-6. memory_error_and_abort ()
-5. {
-4.   fprintf (stderr, ""readline: out of virtual memory\n"");
-3.   abort ();
-2. }
-1. /*
 * Local variables:
 * compile-command: ""gcc -g -D",Useful
/*TEST*/,"-5. #include <sys/types.h>
-4. #if defined (HAVE_PWD_H)
-3. #include <pwd.h>
-2. #endif
-1. #include ""tilde.h""
#if defined (TEST) || defined (STATIC_MALLOC)

 /*TEST*/

1. static void *xmalloc (), *xrealloc ();
2. #else
3. #  include ""xmalloc.h""",Useful
/*HAVE_UNISTD_H*/,"-10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-9.    GNU General Public License for more details.
-8.    The GNU General Public License is often shipped with GNU software, and
-7.    is generally kept in a file called COPYING or",Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



 /*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Useful
/*System-specific feature definitions and include files.*/,"-4. #if defined (HAVE_LOCALE_H)
-3. #  include <locale.h>
-2. #endif
-1. #include <stdio.h>

 /*System-specific feature definitions and include files.*/

1. #include ""rldefs.h""
2. #include ""rlmbutil.h""
3. #if defined (__EMX__)
4. #  define INCL_DOSPROCESS",Useful
/*__EMX__*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""
#if defined (__EMX__)

 /*__EMX__*/

1. #  define INCL_DOSPROCESS
2. #  include <os2.h>",Useful
/*Some standard library routines.*/,"-6. #include ""rldefs.h""
-5. #include ""rlmbutil.h""
-4. #if defined (__EMX__)
-3. #  define INCL_DOSPROCESS
-2. #  include <os2.h>

 /*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include ",Useful
/*Forward declarations.*/,"-5. #include ""readline.h""
-4. #include ""history.h""
-3. #include ""rlprivate.h""
-2. #include ""rlshell.h""
-1. #include ""xmalloc.h""

 /*Forward declarations.*/

1. static int rl_change_case PARAMS((int, int));
2. static int _rl_char_search PARAMS((int, int, i",Useful
"/*Insert a string of text into the line at point.  This is the only
   way that you should do insertion.  _rl_insert_char () calls this
   function.  Returns the number of characters inserted.*/","-10. static int _rl_char_search PARAMS((int, int, int));
-9. #if defined (READLINE_CALLBACKS)
-8. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-7. static int _rl_char_search_callback PARAMS((_rl_callback_generic_arg *));
-6. #",Useful
"/*Delete the string between FROM and TO.  FROM is inclusive, TO is not.
   Returns the number of characters deleted.*/","-10. 	  (rl_undo_list->end - rl_undo_list->start < 20))
-9. 	rl_undo_list->end++;
-8.       else
-7. 	rl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);
-6.     }
-5.   rl_point += l;
-4.   rl_end += l;
-3.   rl_line_buffer[rl_end] = '\0';
-",Useful
/*Fix it if the caller is confused.*/,"-6. int
-5. rl_delete_text (from, to)
-4.      int from, to;
-3. {
-2.   register char *text;
-1.   register int diff, i;

 /*Fix it if the caller is confused.*/

1.   if (from > to)
2.     SWAP (from, to);",Useful
/*fix boundaries*/,"-2.   if (from > to)
-1.     SWAP (from, to);

 /*fix boundaries*/

1.   if (to > rl_end)
2.     {
3.       to = rl_end;
4.       if (from > to)
5. 	from = to;
6.     }
7.   if (from < 0)
8.     from = 0;
9.   text = rl_copy_text (from, to);",Useful
/*Some versions of strncpy() can't handle overlapping arguments.*/,"-9.   if (to > rl_end)
-8.     {
-7.       to = rl_end;
-6.       if (from > to)
-5. 	from = to;
-4.     }
-3.   if (from < 0)
-2.     from = 0;
-1.   text = rl_copy_text (from, to);

 /*Some versions of strncpy() can't handle overlapping arguments.*/

1.",Useful
"/*Replace the contents of the line buffer between START and END with
   TEXT.  The operation is undoable.  To replace the entire line in an
   undoable mode, use _rl_replace_text(text, 0, rl_end);*/","-10. 	} while (0)
-9. void
-8. _rl_fix_point (fix_mark_too)
-7.      int fix_mark_too;
-6. {
-5.   _RL_FIX_POINT (rl_point);
-4.   if (fix_mark_too)
-3.     _RL_FIX_POINT (rl_mark);
-2. }
-1. #undef _RL_FIX_POINT

 /*Replace the contents of the line buffe",Useful
"/*Replace the current line buffer contents with TEXT.  If CLEAR_UNDO is
   non-zero, we free the current undo list.*/","-10.      int start, end;
-9. {
-8.   int n;
-7.   rl_begin_undo_group ();
-6.   rl_delete_text (start, end + 1);
-5.   rl_point = start;
-4.   n = rl_insert_text (text);
-3.   rl_end_undo_group ();
-2.   return n;
-1. }

 /*Replace the current line buffe",Useful
/*Readline character functions*/,"-10.   if (len >= rl_line_buffer_len)
-9.     rl_extend_line_buffer (len);
-8.   strcpy (rl_line_buffer, text);
-7.   rl_end = len;
-6.   if (clear_undo)
-5.     rl_free_undo_list ();
-4.   _rl_fix_point (1);
-3. }

 /*Readline character functions*/

111",Useful
"/*This is not a gap editor, just a stupid line input routine.  No hair
   is involved in writing any of the functions, and none should be.*/","-10.   rl_end = len;
-9.   if (clear_undo)
-8.     rl_free_undo_list ();
-7.   _rl_fix_point (1);
-6. }

 /*This is not a gap editor, just a stupid line input routine.  No hair
   is involved in writing any of the functions, and none should be.*/

111",Useful
"/*Note that:

   rl_end is the place in the string that we would place '\0';
   i.e., it is always safe to place '\0' there.

   rl_point is the place in the string where the cursor is.  Sometimes
   this is the same as rl_end.

   Any command that is called interactively receives two arguments.
   The first is a count: the numeric arg pased to this command.
   The second is the key which invoked this command.*/","/* Note that:

   rl_end is the place in the string that we would place '\0';
   i.e., it is always safe to place '\0' there.

   rl_point is the place in the string where the cursor is.  Sometimes
   this is the same as rl_end.

   Any command that is called interactively receives two arguments.
   The first is a count: the numeric arg pased to this command.
   The second is the key which invoked this command.

 /*Note that:

   rl_end is the place in the string that we would place '\0';
   i.e., it is always safe to place '\0' there.

   rl_point is the place in the string where the cursor is.  Sometimes
   this is the same as rl_end.

   Any command that is called interactively receives two arguments.
   The first is a count: the numeric arg pased to this command.
   The second is the key which invoked this command.*/

1. */",Useful
/*Movement Commands*/,"-10.    rl_end is the place in the string that we would place '\0';
-9.    i.e., it is always safe to place '\0' there.
-8.    rl_point is the place in the string where the cursor is.  Sometimes
-7.    this is the same as rl_end.
-6.    Any command that i",Useful
"/*Note that if you `optimize' the display for these functions, you cannot
   use said functions in other functions which do not do optimizing display.
   I.e., you will have to update the data base for rl_redisplay, and you
   might as well let rl_redisplay do that job.*/","-10.    this is the same as rl_end.
-9.    Any command that is called interactively receives two arguments.
-8.    The first is a count: the numeric arg pased to this command.
-7.    The second is the key which invoked this command.
-6. */

 /*Note that i",Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

 /*!HANDLE_M",Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

 /*!HANDLE_M",Useful
/*Backwards compatibility.*/,"-7. int
-6. rl_forward_char (count, key)
-5.      int count, key;
-4. {
-3.   return (rl_forward_byte (count, key));
-2. }

 /*Backwards compatibility.*/

1. int
2. rl_forward (count, key)
3.      int count, key;
4. {
5.   return (rl_forward_char (count, ",Useful
"/*If we are not in a word, move forward until we are in one.
	 Then, move forward until we hit a non-alphabetic character.*/","-10. rl_forward_word (count, key)
-9.      int count, key;
-8. {
-7.   int c;
-6.   if (count < 0)
-5.     return (rl_backward_word (-count, key));
-4.   while (count)
-3.     {
-2.       if (rl_point == rl_end)
-1. 	return 0;

 /*If we are not in a word,",Useful
"/*Like rl_forward_word (), except that we look at the characters
	 just before point.*/","-10. rl_backward_word (count, key)
-9.      int count, key;
-8. {
-7.   int c, p;
-6.   if (count < 0)
-5.     return (rl_forward_word (-count, key));
-4.   while (count)
-3.     {
-2.       if (rl_point == 0)
-1. 	return 0;

 /*Like rl_forward_word (), e",Useful
/*XXX is this right*/,"-7. int
-6. rl_refresh_line (ignore1, ignore2)
-5.      int ignore1 __attribute__((unused)), ignore2 __attribute__((unused));
-4. {
-3.   int curr_line;
-2.   curr_line = _rl_current_display_line ();
-1.   _rl_move_vert (curr_line);

 /*XXX is this right*",Useful
/*arg of 0 means to not use spaces*/,"-8. int
-7. rl_refresh_line (ignore1, ignore2)
-6.      int ignore1 __attribute__((unused)), ignore2 __attribute__((unused));
-5. {
-4.   int curr_line;
-3.   curr_line = _rl_current_display_line ();
-2.   _rl_move_vert (curr_line);

 /*arg of 0 means to ",Useful
"/*C-l typed to a line without quoting clears the screen, and then reprints
   the prompt and the current input line.  Given a numeric arg, redraw only
   the current line.*/","-4.   rl_forced_update_display ();
-3.   rl_display_fixed = 1;
-2.   return 0;
-1. }

 /*C-l typed to a line without quoting clears the screen, and then reprints
   the prompt and the current input line.  Given a numeric arg, redraw only
   the current li",Useful
/*Text commands*/,"-10.       else
-9. 	rl_backward_byte (count, ch);
-8.       break;
-7.     default:
-6.       rl_ding ();
-5.     }
-4.   return 0;
-3. }

 /*Text commands*/

111",Useful
"/*Bytes too short to compose character, try to wait for next byte.
	     Restore the state of the byte sequence, because in this case the
	     effect of mbstate is undefined.*/","-10.       size_t ret;
-9.       if (stored_count <= 0)
-8. 	stored_count = count;
-7.       else
-6. 	count = stored_count;
-5.       ps_back = ps;
-4.       pending_bytes[pending_bytes_length++] = c;
-3.       ret = mbrtowc (&wc, pending_bytes, pending_",Useful
"/*Invalid byte sequence for the current locale.  Treat first byte
	     as a single character.*/","-5. 	  ps = ps_back;
-4. 	  return 1;
-3. 	}
-2.       else if (ret == (size_t)-1)
-1. 	{

 /*Invalid byte sequence for the current locale.  Treat first byte
	     as a single character.*/

1. 	  incoming[0] = pending_bytes[0];
2. 	  incoming[1] = '\0';
3",Useful
/*We successfully read a single multibyte character.*/,"-4. 	  memset (&ps, 0, sizeof (mbstate_t));
-3. 	}
-2.       else
-1. 	{

 /*We successfully read a single multibyte character.*/

1. 	  memcpy (incoming, pending_bytes, pending_bytes_length);
2. 	  incoming[pending_bytes_length] = '\0';
3. 	  incoming_le",Useful
/*HANDLE_MULTIBYTE*/,"-10. 	  rl_point = lend;
-9. 	  rl_ding ();
-8. 	}
-7.       else
-6. 	rl_point = end;
-5.     }
-4.   if (rl_end < 0)
-3.     rl_end = 0;
-2.   return 0;
-1. }
#if defined (HANDLE_MULTIBYTE)

 /*HANDLE_MULTIBYTE*/

111",Useful
"/*If we can optimize, then do it.  But don't let people crash
     readline because of extra large arguments.*/","-7. 	  memcpy (incoming, pending_bytes, pending_bytes_length);
-6. 	  incoming[pending_bytes_length] = '\0';
-5. 	  incoming_length = pending_bytes_length;
-4. 	  pending_bytes_length = 0;
-3. 	}
-2.     }

 /*If we can optimize, then do it.  But don't le",Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

 /*!HANDLE_M",Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

 /*!HANDLE_M",Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

 /*!HANDLE_M",Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

 /*!HANDLE_M",Useful
"/*We are inserting a single character.
	 If there is pending input, then make a string of all of the
	 pending characters that are bound to rl_insert, and insert
	 them all.*/","-4.       return 0;
-3.     }
-2.   if (MB_CUR_MAX == 1 || rl_byte_oriented)
-1.     {

 /*We are inserting a single character.
	 If there is pending input, then make a string of all of the
	 pending characters that are bound to rl_insert, and insert
	 th",Useful
/*Read an entire multibyte character sequence to insert COUNT times.*/,"-7. int
-6. _rl_overwrite_char (count, c)
-5.      int count, c;
-4. {
-3.   int i;
-2. #if defined (HANDLE_MULTIBYTE)
-1.   char mbkey[MB_LEN_MAX];

 /*Read an entire multibyte character sequence to insert COUNT times.*/

1.   if (count > 0 && MB_CUR_MAX",Useful
"/*Deregister function, let rl_callback_read_char deallocate data*/","-10. #endif
-9.   return (_rl_insert_char (count, c));  
-8. }
-7. #if defined (READLINE_CALLBACKS)
-6. static int
-5. _rl_insert_next_callback (data)
-4.      _rl_callback_generic_arg *data;
-3. {
-2.   int count;
-1.   count = data->count;

 /*Deregiste",Useful
/*Let's see...should the callback interface futz with signal handling?*/,"-9.   _rl_callback_func = 0;
-8.   _rl_want_redisplay = 1;
-7.   return _rl_insert_next (count);
-6. }
-5. #endif
-4. int
-3. rl_quoted_insert (count, key)
-2.      int count, key __attribute__((unused));
-1. {

 /*Let's see...should the callback interfac",Useful
/*VI_MODE*/,"-9. int
-8. rl_forward_byte (count, key)
-7.      int count, key;
-6. {
-5.   if (count < 0)
-4.     return (rl_backward_byte (-count, key));
-3.   if (count > 0)
-2.     {
-1.       int end = rl_point + count;
#if defined (VI_MODE)

 /*VI_MODE*/

1.     ",Useful
"/*If we've been asked to erase empty lines, suppress the final update,
     since _rl_update_final calls rl_crlf().*/","-3. 	_rl_vi_reset_last ();
-2.     }

 /*If we've been asked to erase empty lines, suppress the final update,
     since _rl_update_final calls rl_crlf().*/

1.   if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
2.     return 0;
3.   if (readline_",Useful
"/*What to do for some uppercase characters, like meta characters,
   and some characters appearing in emacs_ctlx_keymap.  This function
   is just a stub, you bind keys to it and the code in _rl_dispatch ()
   is special cased.*/","-6.   if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
-5.     return 0;
-4.   if (readline_echoing_p)
-3.     _rl_update_final ();
-2.   return 0;
-1. }

 /*What to do for some uppercase characters, like meta characters,
   and some characters ap",Useful
"/*This is different from what vi does, so the code's not shared.  Emacs
   rubout in overwrite mode has one oddity:  it replaces a control
   character that's displayed as two characters (^X) with two spaces.*/","-6. int
-5. rl_do_lowercase_version (ignore1, ignore2)
-4.      int ignore1 __attribute__((unused)), ignore2 __attribute__((unused));
-3. {
-2.   return 0;
-1. }

 /*This is different from what vi does, so the code's not shared.  Emacs
   rubout in overwr",Useful
/*L == number of spaces to insert*/,"-10.      int count, key;
-9. {
-8.   int opoint;
-7.   int i, l;
-6.   if (rl_point == 0)
-5.     {
-4.       rl_ding ();
-3.       return 1;
-2.     }
-1.   opoint = rl_point;

 /*L == number of spaces to insert*/

1.   for (i = l = 0; i < count; i++)
2",Useful
/*not exactly right*/,"-3.   for (i = l = 0; i < count; i++)
-2.     {
-1.       rl_backward_char (1, key);

 /*not exactly right*/

1.     }
2.   rl_begin_undo_group ();
3.   if (count > 1 || rl_explicit_arg)
4.     rl_kill_text (opoint, rl_point);
5.   else
6.     rl_delete_t",Useful
/*Emacs puts point at the beginning of the sequence of spaces.*/,"-6.     }
-5.   rl_begin_undo_group ();
-4.   if (count > 1 || rl_explicit_arg)
-3.     rl_kill_text (opoint, rl_point);
-2.   else
-1.     rl_delete_text (opoint, rl_point);

 /*Emacs puts point at the beginning of the sequence of spaces.*/

1.   if (rl_",Useful
/*Duplicated code because this is called from other parts of the library.*/,"-10.   if (rl_insert_mode == RL_IM_OVERWRITE)
-9.     return (_rl_overwrite_rubout (count, key));
-8.   return (_rl_rubout_char (count, key));
-7. }
-6. int
-5. _rl_rubout_char (count, key)
-4.      int count, key;
-3. {
-2.   int orig_point;
-1.   unsign",Useful
"/*Delete the character under the cursor.  Given a numeric argument,
   kill that many characters instead.*/","-10. 	  _rl_erase_at_end_of_line (l);
-9. 	}
-8.     }
-7.   else
-6.     {
-5.       rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
-4.       rl_delete_text (rl_point, orig_point);
-3.     }
-2.   return 0;
-1. }

 /*Delete ",Useful
"/*Delete the character under the cursor, unless the insertion
   point is at the end of the line, in which case the character
   behind the cursor is deleted.  COUNT is obeyed and may be used
   to delete forward or backward that many characters.*/","-10.       rl_kill_text (xpoint, rl_point);
-9.       rl_point = xpoint;
-8.     }
-7.   else
-6.     {
-5.       xpoint = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
-4.       rl_delete_text (rl_point, xpoint);
-3.     }
-2.   return 0;
-",Useful
/*Changing Case*/,"-10. 	rl_delete_text (rl_point, rl_point + rl_comment_len);
-9.       else
-8. 	rl_insert_text (rl_comment_text);
-7.     }
-6.   (*rl_redisplay_function) ();
-5.   rl_newline (1, '\n');
-4.   return (0);
-3. }

 /*Changing Case*/

111",Useful
/*The three kinds of things that we know how to do.*/,"-10.     }
-9.   (*rl_redisplay_function) ();
-8.   rl_newline (1, '\n');
-7.   return (0);
-6. }

 /*The three kinds of things that we know how to do.*/

1. #define UpCase 1
2. #define DownCase 2
3. #define CapCase 3",Useful
/*Uppercase the word at point.*/,"-3. #define UpCase 1
-2. #define DownCase 2
-1. #define CapCase 3

 /*Uppercase the word at point.*/

1. int
2. rl_upcase_word (count, key)
3.      int count, key __attribute__((unused));
4. {
5.   return (rl_change_case (count, UpCase));
6. }",Useful
/*Lowercase the word at point.*/,"-6. int
-5. rl_upcase_word (count, key)
-4.      int count, key __attribute__((unused));
-3. {
-2.   return (rl_change_case (count, UpCase));
-1. }

 /*Lowercase the word at point.*/

1. int
2. rl_downcase_word (count, key)
3.      int count, key __attrib",Useful
"/*Upcase the first letter, downcase the rest.*/","-6. int
-5. rl_downcase_word (count, key)
-4.      int count, key __attribute__((unused));
-3. {
-2.   return (rl_change_case (count, DownCase));
-1. }

 /*Upcase the first letter, downcase the rest.*/

1. int
2. rl_capitalize_word (count, key)
3.      in",Useful
"/*The meaty function.
   Change the case of COUNT words, performing OP on them.
   OP is one of UpCase, DownCase, or CapCase.
   If a negative argument is given, leave point where it started,
   otherwise, leave it where it moves to.*/","-6. int
-5. rl_capitalize_word (count, key)
-4.      int count, key __attribute__((unused));
-3. {
-2.  return (rl_change_case (count, CapCase));
-1. }

 /*The meaty function.
   Change the case of COUNT words, performing OP on them.
   OP is one of UpCas",Useful
/*This assumes that the upper and lower case versions are the same width.*/,"-5.   rl_modifying (start, end);
-4.   inword = 0;
-3.   while (start < end)
-2.     {
-1.       c = _rl_char_value (rl_line_buffer, start);

 /*This assumes that the upper and lower case versions are the same width.*/

1.       next = MB_NEXTCHAR (rl_lin",Useful
/*just skip unchanged characters*/,"-10.       if (MB_CUR_MAX == 1 || rl_byte_oriented || isascii (c))
-9. 	{
-8. 	  nc = (nop == UpCase) ? _rl_to_upper (c) : _rl_to_lower (c);
-7. 	  rl_line_buffer[start] = nc;
-6. 	}
-5. #if defined (HANDLE_MULTIBYTE)
-4.       else
-3. 	{
-2. 	  mbrtowc ",Useful
/*Assume the same width*/,"-4. 	    {
-3. 	      mlen = wcrtomb (mb, nwc, &mps);
-2. 	      if (mlen > 0)
-1. 		mb[mlen] = '\0';

 /*Assume the same width*/

1. 	      strncpy (rl_line_buffer + start, mb, mlen);
2. 	    }
3. 	}
4. #endif
5.       start = next;
6.     }
7.   rl_poin",Useful
/*Transposition*/,"-10. 	    }
-9. 	}
-8. #endif
-7.       start = next;
-6.     }
-5.   rl_point = end;
-4.   return 0;
-3. }

 /*Transposition*/

111",Useful
"/*Transpose the words at point.  If point is at the end of the line,
   transpose the two words before point.*/","-10.       start = next;
-9.     }
-8.   rl_point = end;
-7.   return 0;
-6. }

 /*Transpose the words at point.  If point is at the end of the line,
   transpose the two words before point.*/

1. int
2. rl_transpose_words (count, key)
3.      int count, ",Useful
/*Do some check to make sure that there really are two words.*/,"-8.   rl_forward_word (count, key);
-7.   w2_end = rl_point;
-6.   rl_backward_word (1, key);
-5.   w2_beg = rl_point;
-4.   rl_backward_word (count, key);
-3.   w1_beg = rl_point;
-2.   rl_forward_word (1, key);
-1.   w1_end = rl_point;

 /*Do some check",Useful
/*Get the text of the words.*/,"-6.   if ((w1_beg == w2_beg) || (w2_beg < w1_end))
-5.     {
-4.       rl_ding ();
-3.       rl_point = orig_point;
-2.       return -1;
-1.     }

 /*Get the text of the words.*/

1.   word1 = rl_copy_text (w1_beg, w1_end);
2.   word2 = rl_copy_text (w2_",Useful
"/*We are about to do many insertions and deletions.  Remember them
     as one operation.*/","-2.   word1 = rl_copy_text (w1_beg, w1_end);
-1.   word2 = rl_copy_text (w2_beg, w2_end);

 /*We are about to do many insertions and deletions.  Remember them
     as one operation.*/

1.   rl_begin_undo_group ();",Useful
"/*Do the stuff at word2 first, so that we don't have to worry
     about word1 moving.*/","-1.   rl_begin_undo_group ();

 /*Do the stuff at word2 first, so that we don't have to worry
     about word1 moving.*/

1.   rl_point = w2_beg;
2.   rl_delete_text (w2_beg, w2_end);
3.   rl_insert_text (word1);
4.   rl_point = w1_beg;
5.   rl_delete_tex",Useful
"/*This is exactly correct since the text before this point has not
     changed in length.*/","-6.   rl_point = w2_beg;
-5.   rl_delete_text (w2_beg, w2_end);
-4.   rl_insert_text (word1);
-3.   rl_point = w1_beg;
-2.   rl_delete_text (w1_beg, w1_end);
-1.   rl_insert_text (word2);

 /*This is exactly correct since the text before this point has no",Useful
/*Character Searching*/,"-10.   _rl_fix_point (0);
-9.   rl_insert_text (dummy);
-8.   rl_end_undo_group ();
-7. #if defined (HANDLE_MULTIBYTE)
-6.   free (dummy);
-5. #endif
-4.   return 0;
-3. }

 /*Character Searching*/

111",Useful
"/*Search COUNT times for a character read from the current input stream.
   FDIR is the direction to search if COUNT is non-negative; otherwise
   the search goes in BDIR.  So much is dependent on HANDLE_MULTIBYTE
   that there are two separate versions of this function.*/","-10. 	}
-9. #if defined (HANDLE_MULTIBYTE)
-8.       while ((dir < 0) ? (pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY)) != prepos
-7. 		       : (pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)) != prepos);
-6. #else
-5.  ",Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

 /*!HANDLE_M",Useful
/*!HANDLE_MULTIBYTE*/,"-10. 	point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
-9. #endif
-8.       if (rl_point == point)
-7. 	rl_ding ();
-6.       rl_point = point;
-5.       if (rl_end < 0)
-4. 	rl_end = 0;
-3.     }
-2.   return 0;
-1. }

 /*!HANDLE_M",Useful
/*The Mark and the Region.*/,"-10.       _rl_callback_data->i1 = BFIND;
-9.       _rl_callback_data->i2 = FFIND;
-8.       _rl_callback_func = _rl_char_search_callback;
-7.       return (0);
-6.     }
-5. #endif
-4.   return (_rl_char_search (count, BFIND, FFIND));
-3. }

 /*The Mark ",Useful
/*Set the mark at POSITION.*/,"-10.       return (0);
-9.     }
-8. #endif
-7.   return (_rl_char_search (count, BFIND, FFIND));
-6. }

 /*Set the mark at POSITION.*/

1. int
2. _rl_set_mark_at_pos (position)
3.      int position;
4. {
5.   if (position > rl_end)
6.     return -1;
7.  ",Useful
/*Exchange the position of mark and point.*/,"-6. int
-5. rl_set_mark (count, key)
-4.      int count, key __attribute__((unused));
-3. {
-2.   return (_rl_set_mark_at_pos (rl_explicit_arg ? count : rl_point));
-1. }

 /*Exchange the position of mark and point.*/

1. int
2. rl_exchange_point_and_mark",Useful
/*callback.c -- functions to use readline as an X `callback' mechanism.*/,"
/* callback.c -- functions to use readline as an X `callback' mechanism. */


 /*callback.c -- functions to use readline as an X `callback' mechanism.*/

1. /* Copyright (C) 1987-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
/*System-specific feature definitions and include files.*/,"-10. #endif
-9. #include ""rlconf.h""
-8. #if defined (READLINE_CALLBACKS)
-7. #include <sys/types.h>
-6. #ifdef HAVE_STDLIB_H
-5. #  include <stdlib.h>
-4. #else
-3. #  include ""ansi_stdlib.h""
-2. #endif
-1. #include <stdio.h>

 /*System-specific feature d",Useful
"/*Private data for callback registration functions.  See comments in
   rl_callback_read_char for more details.*/","-4. #include ""rldefs.h""
-3. #include ""readline.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

 /*Private data for callback registration functions.  See comments in
   rl_callback_read_char for more details.*/

1. _rl_callback_func_t *_rl_callback",Useful
/*user callback function*/,"-10. /*								    */
-9. /* **************************************************************** */
-8. /* Allow using readline in situations where a program may have multiple
-7.    things to handle at once, and dispatches them via select().  Call
-6.    rl",Useful
/*terminal_prepped and signals set?*/,"-10. /* **************************************************************** */
-9. /* Allow using readline in situations where a program may have multiple
-8.    things to handle at once, and dispatches them via select().  Call
-7.    rl_callback_handler_ins",Useful
"/*Make sure the terminal is set up, initialize readline, and prompt.*/","-10. /* Allow using readline in situations where a program may have multiple
-9.    things to handle at once, and dispatches them via select().  Call
-8.    rl_callback_handler_install() with the prompt and a function to call
-7.    whenever a complete li",Useful
/*XXX - this should handle _rl_last_command_was_kill better*/,"-10.       else if  (RL_ISSTATE (RL_STATE_NSEARCH))
-9. 	{
-8. 	  eof = _rl_nsearch_callback (_rl_nscxt);
-7. 	  return;
-6. 	}
-5.       else if (RL_ISSTATE (RL_STATE_NUMERICARG))
-4. 	{
-3. 	  eof = _rl_arg_callback (_rl_argcxt);
-2. 	  if (eof == 0 && ",Useful
/*For now*/,"-6. 	  else if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)
-5. 	    _rl_internal_char_cleanup ();
-4. 	  return;
-3. 	}
-2.       else if (RL_ISSTATE (RL_STATE_MULTIKEY))
-1. 	{

 /*For now*/

1. 	  while ((eof == -1 || eof == -2) && RL_ISSTATE (RL_STATE_MULT",Useful
"/*If the function `deregisters' itself, make sure the data is
	     cleaned up.*/","-1. 	  eof = (*_rl_callback_func) (_rl_callback_data);

 /*If the function `deregisters' itself, make sure the data is
	     cleaned up.*/

1. 	  if (_rl_callback_func == 0)
2. 	    {
3. 	      if (_rl_callback_data) 	
4. 		{
5. 		  _rl_callback_data_disp",Useful
"/*If the user did not clear out the line, do it for him.*/","-10.       if (rl_done)
-9. 	{
-8. 	  line = readline_internal_teardown (eof);
-7. 	  if (rl_deprep_term_function)
-6. 	    (*rl_deprep_term_function) ();
-5. #if defined (HANDLE_SIGNALS)
-4. 	  rl_clear_signals ();
-3. #endif
-2. 	  in_handler = 0;
-1. 	",Useful
"/*Redisplay the prompt if readline_handler_{install,remove}
	     not called.*/","-2. 	  if (rl_line_buffer[0])
-1. 	    _rl_init_line_state ();

 /*Redisplay the prompt if readline_handler_{install,remove}
	     not called.*/

1. 	  if (in_handler == 0 && rl_linefunc)
2. 	    _rl_callback_newline ();
3. 	}
4.     }
5.   while (rl_pend",Useful
"/*Remove the handler, and make sure the terminal is in its normal state.*/","-6. 	  if (in_handler == 0 && rl_linefunc)
-5. 	    _rl_callback_newline ();
-4. 	}
-3.     }
-2.   while (rl_pending_input || _rl_pushed_input_available () || RL_ISSTATE (RL_STATE_MACROINPUT));
-1. }

 /*Remove the handler, and make sure the terminal is ",Useful
/*Variables exported to other files in the readline library.*/,"-10. #  include <stdlib.h>
-9. #else
-8. #  include ""ansi_stdlib.h""
-7. #endif
-6. #include ""rldefs.h""
-5. #include ""rlmbutil.h""
-4. #include ""readline.h""
-3. #include ""history.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

 /*Variables exported ",Useful
/*Variables imported from other files in the readline library.*/,"-2. char *_rl_isearch_terminators = (char *)NULL;
-1. _rl_search_cxt *_rl_iscxt = 0;

 /*Variables imported from other files in the readline library.*/

1. extern HIST_ENTRY *_rl_saved_line_for_history;
2. static int rl_search_history PARAMS((int, int));
",Useful
"/*Last line found by the current incremental search, so we don't `find'
   identical lines many times in a row.  Now part of isearch context.*/","-5. extern HIST_ENTRY *_rl_saved_line_for_history;
-4. static int rl_search_history PARAMS((int, int));
-3. static _rl_search_cxt *_rl_isearch_init PARAMS((int));
-2. static void _rl_isearch_fini PARAMS((_rl_search_cxt *));
-1. static int _rl_isearch_clea",Useful
/*static char *prev_line_found;*/,"-7. extern HIST_ENTRY *_rl_saved_line_for_history;
-6. static int rl_search_history PARAMS((int, int));
-5. static _rl_search_cxt *_rl_isearch_init PARAMS((int));
-4. static void _rl_isearch_fini PARAMS((_rl_search_cxt *));
-3. static int _rl_isearch_clea",Useful
"/*Display the current state of the search in the echo-area.
   SEARCH_STRING contains the string that is being searched for,
   DIRECTION is zero for forward, or non-zero for reverse,
   WHERE is the history list number of the current line.  If it is
   -1, then this line is the starting one.*/","-6. int
-5. rl_forward_search_history (sign, key)
-4.      int sign, key;
-3. {
-2.   return (rl_search_history (sign, key));
-1. }

 /*Display the current state of the search in the echo-area.
   SEARCH_STRING contains the string that is being searched f",Useful
/*NOTDEF*/,"-10. static void
-9. rl_display_search (search_string, reverse_p, where)
-8.      char *search_string;
-7.      int reverse_p, where __attribute__((unused));
-6. {
-5.   char *message;
-4.   int msglen, searchlen;
-3.   searchlen = (search_string && *sear",Useful
/*Create an arrary of pointers to the lines that we want to search.*/,"-10.      int direction;
-9. {
-8.   _rl_search_cxt *cxt;
-7.   register int i;
-6.   HIST_ENTRY **hlist;
-5.   cxt = _rl_scxt_alloc (RL_SEARCH_ISEARCH, 0);
-4.   if (direction < 0)
-3.     cxt->sflags |= SF_REVERSE;
-2.   cxt->search_terminators = _rl_is",Useful
/*Keep track of this so we can free it.*/,"-7.   cxt->lines = (char **)xmalloc ((1 + (cxt->hlen = i)) * sizeof (char *));
-6.   for (i = 0; i < cxt->hlen; i++)
-5.     cxt->lines[i] = hlist[i]->line;
-4.   if (_rl_saved_line_for_history)
-3.     cxt->lines[i] = _rl_saved_line_for_history->line;
-2",Useful
/*The line where we start the search.*/,"-5.       cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
-4.       strcpy (cxt->allocated_line, &rl_line_buffer[0]);
-3.       cxt->lines[i] = cxt->allocated_line;
-2.     }
-1.   cxt->hlen++;

 /*The line where we start the search.*",Useful
/*Initialize search parameters.*/,"-2.   cxt->history_pos = cxt->save_line;
-1.   rl_save_prompt ();

 /*Initialize search parameters.*/

1.   cxt->search_string = (char *)xmalloc (cxt->search_string_size = 128);
2.   cxt->search_string[cxt->search_string_index = 0] = '\0';",Useful
/*save globally*/,"-4.   cxt->direction = (direction >= 0) ? 1 : -1;
-3.   cxt->sline = rl_line_buffer;
-2.   cxt->sline_len = strlen (cxt->sline);
-1.   cxt->sline_index = rl_point;

 /*save globally*/

1.   return cxt;
2. }
3. static void
4. _rl_isearch_fini (cxt)
5.     ",Useful
/*First put back the original state.*/,"-6.   return cxt;
-5. }
-4. static void
-3. _rl_isearch_fini (cxt)
-2.      _rl_search_cxt *cxt;
-1. {

 /*First put back the original state.*/

1.   strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
2.   rl_restore_prompt ();",Useful
"/*If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position.*/","-8.   FREE (last_isearch_string);
-7.   last_isearch_string = cxt->search_string;
-6.   last_isearch_string_len = cxt->search_string_index;
-5.   cxt->search_string = 0;
-4.   if (cxt->last_found_line < cxt->save_line)
-3.     rl_get_previous_history (cxt",Useful
"/*Don't worry about where to put the mark here; rl_get_previous_history
     and rl_get_next_history take care of it.*/","-10.      history lines at all, so put point back in its original position. */
-9.   if (cxt->sline_index < 0)
-8.     {
-7.       if (cxt->last_found_line == cxt->save_line)
-6. 	cxt->sline_index = cxt->save_point;
-5.       else
-4. 	cxt->sline_index = ",Useful
"/*Process just-read character C according to isearch context CXT.  Return
   -1 if the caller should just free the context and return, 0 if we should
   break out of the loop, and 1 if we should continue to read characters.*/","-9.   RL_SETSTATE(RL_STATE_MOREINPUT);
-8.   c = cxt->lastc = rl_read_key ();
-7.   RL_UNSETSTATE(RL_STATE_MOREINPUT);
-6. #if defined (HANDLE_MULTIBYTE)
-5.   if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
-4.     c = cxt->lastc = _rl_read_mbstring (cxt->l",Useful
/*Translate the keys we do something with to opcodes.*/,"-10.    -1 if the caller should just free the context and return, 0 if we should
-9.    break out of the loop, and 1 if we should continue to read characters. */
-8. int
-7. _rl_isearch_dispatch (cxt, c)
-6.      _rl_search_cxt *cxt;
-5.      int c;
-4. {",Useful
/*XXX*/,"-10.     {
-9.       f = _rl_keymap[c].function;
-8.       if (f == rl_reverse_search_history)
-7. 	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -1 : -2;
-6.       else if (f == rl_forward_search_history)
-5. 	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -2 : -",Useful
"/*ESC still terminates the search, but if there is pending
	 input or if input arrives within 0.1 seconds (on systems
	 with select(2)) it is used as a prefix character
	 with rl_execute_next.  WATCH OUT FOR THIS!  This is intended
	 to allow the arrow keys to be used like ^F and ^B are used
	 to terminate the search and execute the movement command.
	 XXX - since _rl_input_available depends on the application-
	 settable keyboard timeout value, this could alternatively
	 use _rl_input_queued(100000)*/","-2.   if (strchr (cxt->search_terminators, cxt->lastc))
-1.     {

 /*ESC still terminates the search, but if there is pending
	 input or if input arrives within 0.1 seconds (on systems
	 with select(2)) it is used as a prefix character
	 with rl_execute_",Useful
"/*This sets rl_pending_input to c; it will be picked up the next
	     time rl_read_key is called.*/","-10. 	rl_execute_next (ESC);
-9.       return (0);
-8.     }
-7. #define ENDSRCH_CHAR(c) \
-6.   ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))
-5. #if defined (HANDLE_MULTIBYTE)
-4.   if (MB_CUR_MAX > 1 && rl_byte_oriented == ",Useful
"/*This sets rl_pending_input to LASTC; it will be picked up the next
	   time rl_read_key is called.*/","-8. 	  rl_execute_next (cxt->lastc);
-7. 	  return (0);
-6. 	}
-5.     }
-4.   else
-3. #endif
-2.     if (cxt->lastc >= 0 && ENDSRCH_CHAR (cxt->lastc))
-1.       {

 /*This sets rl_pending_input to LASTC; it will be picked up the next
	   time rl_read_ke",Useful
"/*Now dispatch on the character.  `Opcodes' affect the search string or
     state.  Other characters are added to the string.*/","-3. 	rl_execute_next (cxt->lastc);
-2. 	return (0);
-1.       }

 /*Now dispatch on the character.  `Opcodes' affect the search string or
     state.  Other characters are added to the string.*/

1.   switch (cxt->lastc)
2.     {",Useful
/*search again*/,"-2.   switch (cxt->lastc)
-1.     {

 /*search again*/

1.     case -1:
2.       if (cxt->search_string_index == 0)
3. 	{
4. 	  if (last_isearch_string)
5. 	    {
6. 	      cxt->search_string_size = 64 + last_isearch_string_len;
7. 	      cxt->search_stri",Useful
/*delete character from search string.*/,"-7.     case -2:
-6.       cxt->direction = -cxt->direction;
-5.       if (cxt->direction < 0)
-4. 	cxt->sflags |= SF_REVERSE;
-3.       else
-2. 	cxt->sflags &= ~SF_REVERSE;
-1.       break;

 /*delete character from search string.*/

111",Useful
"/*This is tricky.  To do this right, we need to keep a
	 stack of search positions for the current search, with
	 sentinels marking the beginning and end.  But this will
	 do until we have a real isearch-undo.*/","-9.     case -2:
-8.       cxt->direction = -cxt->direction;
-7.       if (cxt->direction < 0)
-6. 	cxt->sflags |= SF_REVERSE;
-5.       else
-4. 	cxt->sflags &= ~SF_REVERSE;
-3.       break;

 /*This is tricky.  To do this right, we need to keep a
	 stac",Useful
"/*C-G, abort*/","-5.       if (cxt->search_string_index == 0)
-4. 	rl_ding ();
-3.       else
-2. 	cxt->search_string[--cxt->search_string_index] = '\0';
-1.       break;

 /*C-G, abort*/

1.       rl_replace_line (cxt->lines[cxt->save_line], 0);
2.       rl_point = cxt->",Useful
/*skip over portion of line we already matched and yank word*/,"-7.       rl_replace_line (cxt->lines[cxt->save_line], 0);
-6.       rl_point = cxt->save_point;
-5.       rl_mark = cxt->save_mark;
-4.       rl_restore_prompt();
-3.       rl_clear_message ();
-2.       return -1;

 /*skip over portion of line we alread",Useful
"/*if not in a word, move to one.*/","-6.       wstart = rl_point + cxt->search_string_index;
-5.       if (wstart >= rl_end)
-4. 	{
-3. 	  rl_ding ();
-2. 	  break;
-1. 	}

 /*if not in a word, move to one.*/

1.       cval = _rl_char_value (rl_line_buffer, wstart);
2.       if (_rl_walphabe",Useful
/*skip over portion of line we already matched and yank rest*/,"-10.       if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)
-9. 	{
-8. 	  cxt->search_string_size += wlen + 1;
-7. 	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
-6. 	}
-5.       for (; wstart < ",Useful
/*Add character to search string and continue search.*/,"-10.       n = rl_end - wstart + 1;
-9.       if (cxt->search_string_index + n + 1 >= cxt->search_string_size)
-8. 	{
-7. 	  cxt->search_string_size += n + 1;
-6. 	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
-5. ",Useful
"/*Move to the next line, but skip new copies of the line
	 we just found and lines shorter than the string we're
	 searching for.*/","-10. 	  if (STREQN (cxt->search_string, cxt->sline + cxt->sline_index, cxt->search_string_index))
-9. 	    {
-8. 	      cxt->sflags |= SF_FOUND;
-7. 	      break;
-6. 	    }
-5. 	  else
-4. 	    cxt->sline_index += cxt->direction;
-3. 	}
-2.       if (cxt",Useful
/*Move to the next line.*/,"-2.       do
-1. 	{

 /*Move to the next line.*/

1. 	  cxt->history_pos += cxt->direction;",Useful
/*At limit for direction?*/,"-1. 	  cxt->history_pos += cxt->direction;

 /*At limit for direction?*/

1. 	  if ((cxt->sflags & SF_REVERSE) ? (cxt->history_pos < 0) : (cxt->history_pos == cxt->hlen))
2. 	    {
3. 	      cxt->sflags |= SF_FAILED;
4. 	      break;
5. 	    }",Useful
/*We will need these later.*/,"-5. 	  if ((cxt->sflags & SF_REVERSE) ? (cxt->history_pos < 0) : (cxt->history_pos == cxt->hlen))
-4. 	    {
-3. 	      cxt->sflags |= SF_FAILED;
-2. 	      break;
-1. 	    }

 /*We will need these later.*/

1. 	  cxt->sline = cxt->lines[cxt->history_pos]",Useful
/*Now set up the line for searching...*/,"-7. 	  cxt->sline = cxt->lines[cxt->history_pos];
-6. 	  cxt->sline_len = strlen (cxt->sline);
-5. 	}
-4.       while ((cxt->prev_line_found && STREQ (cxt->prev_line_found, cxt->lines[cxt->history_pos])) ||
-3. 	     (cxt->search_string_index > cxt->sline",Useful
"/*We have found the search string.  Just display it.  But don't
     actually move there in the history list until the user accepts
     the location.*/","-4.       rl_ding ();
-3.       cxt->history_pos = cxt->last_found_line;
-2.       return 1;
-1.     }

 /*We have found the search string.  Just display it.  But don't
     actually move there in the history list until the user accepts
     the location.",Useful
"/*local for now, but saved globally*/","-4. static int
-3. rl_search_history (direction, invoking_key)
-2.      int direction, invoking_key __attribute__((unused));
-1. {

 /*local for now, but saved globally*/

1.   int r;
2.   RL_SETSTATE(RL_STATE_ISEARCH);
3.   cxt = _rl_isearch_init (direct",Useful
"/*If we are using the callback interface, all we do is set up here and
      return.  The key is that we leave RL_STATE_ISEARCH set.*/","-4.   int r;
-3.   RL_SETSTATE(RL_STATE_ISEARCH);
-2.   cxt = _rl_isearch_init (direction);
-1.   rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);

 /*If we are using the callback interface, all we do is set up here and
      return",Useful
/*We might want to handle EOF here (c == 0)*/,"-6.   if (RL_ISSTATE (RL_STATE_CALLBACK))
-5.     return (0);
-4.   r = -1;
-3.   for (;;)
-2.     {
-1.       _rl_search_getchar (cxt);

 /*We might want to handle EOF here (c == 0)*/

1.       r = _rl_isearch_dispatch (cxt, cxt->lastc);
2.       if (r <",Useful
"/*The searching is over.  The user may have found the string that she
     was looking for, or else she may have exited a failing search.  If
     LINE_INDEX is -1, then that shows that the string searched for was
     not found.  We use this to determine where to place rl_point.*/","-4.       r = _rl_isearch_dispatch (cxt, cxt->lastc);
-3.       if (r <= 0)
-2.         break;
-1.     }

 /*The searching is over.  The user may have found the string that she
     was looking for, or else she may have exited a failing search.  If
     L",Useful
"/*Called from the callback functions when we are ready to read a key.  The
   callback functions know to call this because RL_ISSTATE(RL_STATE_ISEARCH).
   If _rl_isearch_dispatch finishes searching, this function is responsible
   for turning off RL_STATE_ISEARCH, which it does using _rl_isearch_cleanup.*/","-3.   return (_rl_isearch_cleanup (cxt, r));
-2. }
-1. #if defined (READLINE_CALLBACKS)

 /*Called from the callback functions when we are ready to read a key.  The
   callback functions know to call this because RL_ISSTATE(RL_STATE_ISEARCH).
   If _rl_is",Useful
/*We might want to handle EOF here*/,"-6.   if (RL_ISSTATE (RL_STATE_CALLBACK))
-5.     return (0);
-4.   r = -1;
-3.   for (;;)
-2.     {
-1.       _rl_search_getchar (cxt);

 /*We might want to handle EOF here*/

1.       r = _rl_isearch_dispatch (cxt, cxt->lastc);
2.       if (r <= 0)
3.  ",Useful
/*complete.c -- filename completion for readline.*/,"
/* complete.c -- filename completion for readline. */


 /*complete.c -- filename completion for readline.*/

1. /* Copyright (C) 1987-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
"/*FreeBSD 5.3 will not declare u_int in sys/types.h, file.h needs it*/","-10.    The GNU General Public License is often shipped with GNU software, and
-9.    is generally kept in a file called COPYING or LICENSE.  If you do not
-8.    have a copy of the license, write to the Free Software Foundation,
-7.    51 Franklin Street",Useful
/*HAVE_UNISTD_H*/,"-3. #if defined (HAVE_SYS_FILE_H) && !defined(__FreeBSD__)
-2. #  include <sys/file.h>
-1. #endif
#if defined (HAVE_UNISTD_H)

 /*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



 /*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Useful
/*!errno*/,"-4. #include <stdio.h>
-3. #include <errno.h>
-2. #if !defined (errno)
-1. extern int errno;

 /*!errno*/

1. #if defined (HAVE_PWD_H)
2. #include <pwd.h>
3. #endif
4. #include ""posixdir.h""
5. #include ""posixstat.h""",Useful
/*System-specific feature definitions and include files.*/,"-5. #if defined (HAVE_PWD_H)
-4. #include <pwd.h>
-3. #endif
-2. #include ""posixdir.h""
-1. #include ""posixstat.h""

 /*System-specific feature definitions and include files.*/

1. #include ""rldefs.h""
2. #include ""rlmbutil.h""",Useful
/*Some standard library routines.*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""

 /*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""xmalloc.h""
3. #include ""rlprivate.h""
4. #ifdef __STDC__
5. typedef int QSFUNC (const void *, const void *);
6. #else
7. typedef ",Useful
"/*Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
   defined.*/","-1. #define HIDDEN_FILE(fname)	((fname)[0] == '.')

 /*Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
   defined.*/

1. #if defined (HAVE_GETPWENT) && (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))
2. extern struct passwd *ge",Useful
/*HAVE_GETPWENT && (!HAVE_GETPW_DECLS || _POSIX_SOURCE)*/,"-2. #if defined (HAVE_GETPWENT) && (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))
-1. extern struct passwd *getpwent PARAMS((void));

 /*HAVE_GETPWENT && (!HAVE_GETPW_DECLS || _POSIX_SOURCE)*/

111",Useful
"/*If non-zero, then this is the address of a function to call when
   completing a word would normally display the list of possible matches.
   This function is called instead of actually doing the display.
   It takes three arguments: (char **matches, int num_matches, int max_length)
   where MATCHES is the array of strings that matched, NUM_MATCHES is the
   number of strings in that array, and MAX_LENGTH is the length of the
   longest string in that array.*/","-3. #if defined (HAVE_GETPWENT) && (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))
-2. extern struct passwd *getpwent PARAMS((void));

 /*If non-zero, then this is the address of a function to call when
   completing a word would normally display",Useful
/*Variables known only to the readline library.*/,"-10. static void insert_all_matches PARAMS((char **, int, char *));
-9. static void display_matches PARAMS((char **));
-8. static int compute_lcd_of_matches PARAMS((char **, int, const char *));
-7. static int postprocess_matches PARAMS((char ***, int));
",Useful
"/*If non-zero, non-unique completions always show the list of matches.*/","-10. static void display_matches PARAMS((char **));
-9. static int compute_lcd_of_matches PARAMS((char **, int, const char *));
-8. static int postprocess_matches PARAMS((char ***, int));
-7. static char *make_quoted_replacement PARAMS((char *, int, char ",Useful
"/*If non-zero, non-unique completions show the list of matches, unless it
   is not possible to do partial completion and modify the line.*/","-10. static int postprocess_matches PARAMS((char ***, int));
-9. static char *make_quoted_replacement PARAMS((char *, int, char *));

 /*If non-zero, non-unique completions show the list of matches, unless it
   is not possible to do partial completion an",Useful
"/*If non-zero, completed directory names have a slash appended.*/","-4. int _rl_complete_show_all = 0;

 /*If non-zero, completed directory names have a slash appended.*/

1. int _rl_complete_mark_directories = 1;",Useful
"/*If non-zero, the symlinked directory completion behavior introduced in
   readline-4.2a is disabled, and symlinks that point to directories have
   a slash appended (subject to the value of _rl_complete_mark_directories).
   This is user-settable via the mark-symlinked-directories variable.*/","-1. int _rl_complete_mark_directories = 1;

 /*If non-zero, the symlinked directory completion behavior introduced in
   readline-4.2a is disabled, and symlinks that point to directories have
   a slash appended (subject to the value of _rl_complete_mark_",Useful
/*Non-zero means that case is not significant in filename completion.*/,"-1. int _rl_print_completions_horizontally;

 /*Non-zero means that case is not significant in filename completion.*/

1. #if defined (__MSDOS__) && !defined (__DJGPP__)
2. int _rl_completion_case_fold = 1;
3. #else
4. int _rl_completion_case_fold;
5. #en",Useful
/*Global variables available to applications using readline.*/,"-1. int _rl_match_hidden_files = 1;

 /*Global variables available to applications using readline.*/

1. #if defined (VISIBLE_STATS)",Useful
"/*Non-zero means add an additional character to each filename displayed
   during listing completion iff rl_filename_completion_desired which helps
   to indicate the type of file being listed.*/","-1. #if defined (VISIBLE_STATS)

 /*Non-zero means add an additional character to each filename displayed
   during listing completion iff rl_filename_completion_desired which helps
   to indicate the type of file being listed.*/

1. int rl_visible_stats ",Useful
/*VISIBLE_STATS*/,"-1. rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
#if defined (VISIBLE_STATS)

 /*VISIBLE_STATS*/

1. #  if !defined (X_OK)
2. #    define X_OK 1
3. #  endif
4. static int stat_char PARAMS((char *));
5. #endif
6. sta",Useful
"/*Pointer to alternative function to create matches.
   Function is called with TEXT, START, and END.
   START and END are indices in RL_LINE_BUFFER saying what the boundaries
   of TEXT are.
   If this function exists and returns NULL then call the value of
   rl_completion_entry_function to try to match, otherwise use the
   array of strings returned.*/","-1. rl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;

 /*Pointer to alternative function to create matches.
   Function is called with TEXT, START, and END.
   START and END are indices in RL_LINE_BUFFER saying what the bou",Useful
"/*Non-zero means to suppress normal filename completion after the
   user-specified completion function has been called.*/","-1. rl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;

 /*Non-zero means to suppress normal filename completion after the
   user-specified completion function has been called.*/

1. int rl_attempted_completion_over = ",Useful
"/*Up to this many items will be displayed in response to a
   possible-completions call.  After that, we ask the user if
   she is sure she wants to see them all.  A negative value means
   don't ask.*/","-1. int rl_completion_type = 0;

 /*Up to this many items will be displayed in response to a
   possible-completions call.  After that, we ask the user if
   she is sure she wants to see them all.  A negative value means
   don't ask.*/

1. int rl_complet",Useful
/*const*/,"-4. #include ""readline.h""
-3. #include ""xmalloc.h""
-2. #include ""rlprivate.h""
-1. #ifdef __STDC__
typedef int QSFUNC (const void *, const void *);

 /*const*/

1. #else
2. typedef int QSFUNC ();
3. #endif
4. #ifdef HAVE_LSTAT
5. #  define LSTAT lstat
6. #",Useful
/*const*/,"-4. #include ""readline.h""
-3. #include ""xmalloc.h""
-2. #include ""rlprivate.h""
-1. #ifdef __STDC__
typedef int QSFUNC (const void *, const void *);

 /*const*/

1. #else
2. typedef int QSFUNC ();
3. #endif
4. #ifdef HAVE_LSTAT
5. #  define LSTAT lstat
6. #",Useful
"/*Hook function to allow an application to set the completion word
   break characters before readline breaks up the line.  Allows
   position-dependent word break characters.*/","-5. const char *rl_basic_quote_characters = ""\""'"";

 /*Hook function to allow an application to set the completion word
   break characters before readline breaks up the line.  Allows
   position-dependent word break characters.*/

1. rl_cpvfunc_t *rl_com",Useful
"/*List of characters that are word break characters, but should be left
   in TEXT when it is passed to the completion function.  The shell uses
   this to help determine what kind of completing to do.*/","-1. const char *rl_filename_quote_characters = (const char *)NULL;

 /*List of characters that are word break characters, but should be left
   in TEXT when it is passed to the completion function.  The shell uses
   this to help determine what kind of co",Useful
"/*Non-zero means that the results of the matches are to be treated
   as filenames.  This is ALWAYS zero on entry, and can only be changed
   within a completion entry finder function.*/","-1. int rl_ignore_completion_duplicates = 1;

 /*Non-zero means that the results of the matches are to be treated
   as filenames.  This is ALWAYS zero on entry, and can only be changed
   within a completion entry finder function.*/

1. int rl_filename_c",Useful
"/*Non-zero means that the results of the matches are to be quoted using
   double quotes (or an application-specific quoting mechanism) if the
   filename contains any characters in rl_filename_quote_chars.  This is
   ALWAYS non-zero on entry, and can only be changed within a completion
   entry finder function.*/","-1. int rl_filename_completion_desired = 0;

 /*Non-zero means that the results of the matches are to be quoted using
   double quotes (or an application-specific quoting mechanism) if the
   filename contains any characters in rl_filename_quote_chars.  T",Useful
"/*This function, if defined, is called by the completer when real
   filename completion is done, after all the matching names have been
   generated. It is passed a (char**) known as matches in the code below.
   It consists of a NULL-terminated array of pointers to potential
   matching strings.  The 1st element (matches[0]) is the maximal
   substring that is common to all matches. This function can re-arrange
   the list of matches as required, but all elements of the array must be
   free()'d if they are deleted. The main intent of this function is
   to implement FIGNORE a la SunOS csh.*/","-1. int rl_filename_quoting_desired = 1;

 /*This function, if defined, is called by the completer when real
   filename completion is done, after all the matching names have been
   generated. It is passed a (char**) known as matches in the code below.
 ",Useful
"/*Function to call to remove quoting characters from a filename.  Called
   before completion is attempted, so the embedded quotes do not interfere
   with matching names in the file system.  Readline doesn't do anything
   with this; it's set only by applications.*/","-1. rl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;

 /*Function to call to remove quoting characters from a filename.  Called
   before completion is attempted, so the embedded quotes do not interfere
   with matching names in the file",Useful
"/*If non-zero, the completion functions don't append anything except a
   possible closing quote.  This is set to 0 by rl_complete_internal and
   may be changed by an application-specific completion function.*/","-1. rl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;

 /*If non-zero, the completion functions don't append anything except a
   possible closing quote.  This is set to 0 by rl_complete_internal and
   may be changed by an application-s",Useful
"/*If non-zero, the completion functions don't append any closing quote.
   This is set to 0 by rl_complete_internal and may be changed by an
   application-specific completion function.*/","-1. int rl_completion_append_character = ' ';

 /*If non-zero, the completion functions don't append any closing quote.
   This is set to 0 by rl_complete_internal and may be changed by an
   application-specific completion function.*/

1. int rl_completi",Useful
"/*Set to any quote character readline thinks it finds before any application
   completion function is called.*/","-1. int rl_completion_suppress_quote = 0;

 /*Set to any quote character readline thinks it finds before any application
   completion function is called.*/

1. int rl_completion_quote_character;",Useful
"/*If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored.*/","-1. int rl_completion_found_quote;

 /*If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that a",Useful
/*Variables local to this file.*/,"-1. int rl_inhibit_completion;

 /*Variables local to this file.*/

111",Useful
/*Local variable states what happened during the last completion attempt.*/,"-2. int rl_inhibit_completion;

 /*Local variable states what happened during the last completion attempt.*/

1. static int completion_changed_buffer;",Useful
"/*Return the correct value to pass to rl_complete_internal performing
   the same tests as rl_complete.  This allows consecutive calls to an
   application's completion function to list possible completions and for
   an application-specific completion function to honor the
   show-all-if-ambiguous readline variable.*/","-10.      int ignore __attribute__((unused)), invoking_key __attribute__((unused));
-9. {
-8.   return (rl_complete_internal ('?'));
-7. }
-6. int
-5. rl_insert_completions (ignore, invoking_key)
-4.      int ignore __attribute__((unused)), invoking_key _",Useful
/*Only the completion entry function can change these.*/,"-4. static void
-3. set_completion_defaults (what_to_do)
-2.      int what_to_do;
-1. {

 /*Only the completion entry function can change these.*/

1.   rl_filename_completion_desired = 0;
2.   rl_filename_quoting_desired = 1;
3.   rl_completion_type = wh",Useful
/*The completion entry function may optionally change this.*/,"-4.   rl_filename_completion_desired = 0;
-3.   rl_filename_quoting_desired = 1;
-2.   rl_completion_type = what_to_do;
-1.   rl_completion_suppress_append = rl_completion_suppress_quote = 0;

 /*The completion entry function may optionally change this.*/",Useful
"/*The user must press ""y"" or ""n"". Non-zero return means ""y"" pressed.*/","-2.   rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;
-1. }

 /*The user must press ""y"" or ""n"". Non-zero return means ""y"" pressed.*/

1. static int
2. get_y_or_n (for_pager)
3.      int for_pager;
4. {
5.   int c;
6.   for (;;)
7.     {
",Useful
"/*Return the character which best describes FILENAME.
     `@' for symbolic links
     `/' for directories
     `*' for executables
     `=' for sockets
     `|' for FIFOs
     `%' for character special devices
     `#' for block special devices*/","-10.     return 0;
-9. }
-8. static int
-7. path_isdir (filename)
-6.      const char *filename;
-5. {
-4.   struct stat finfo;
-3.   return (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode));
-2. }
-1. #if defined (VISIBLE_STATS)

 /*Return the ch",Useful
/*S_ISCHR*/,"-10. #if defined (HAVE_LSTAT) && defined (S_ISLNK)
-9.   r = lstat (filename, &finfo);
-8. #else
-7.   r = stat (filename, &finfo);
-6. #endif
-5.   if (r == -1)
-4.     return (0);
-3.   character = 0;
-2.   if (S_ISDIR (finfo.st_mode))
-1.     character",Useful
/*S_ISBLK*/,"
#if defined (S_ISBLK)



 /*S_ISBLK*/

1.   else if (S_ISBLK (finfo.st_mode))
2.     character = '#';",Useful
/*S_ISLNK*/,"-10.      `=' for sockets
-9.      `|' for FIFOs
-8.      `%' for character special devices
-7.      `#' for block special devices */
-6. static int
-5. stat_char (filename)
-4.      char *filename;
-3. {
-2.   struct stat finfo;
-1.   int character, r;
#",Useful
/*S_ISSOCK*/,"
#if defined (S_ISSOCK)



 /*S_ISSOCK*/

1.   else if (S_ISSOCK (finfo.st_mode))
2.     character = '=';",Useful
/*VISIBLE_STATS*/,"-1. rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
#if defined (VISIBLE_STATS)

 /*VISIBLE_STATS*/

1. #  if !defined (X_OK)
2. #    define X_OK 1
3. #  endif
4. static int stat_char PARAMS((char *));
5. #endif
6. sta",Useful
"/*Return the portion of PATHNAME that should be output when listing
   possible completions.  If we are hacking filename completion, we
   are only interested in the basename, the portion following the
   final slash.  Otherwise, we return what we were passed.  Since
   printing empty strings is not very informative, if we're doing
   filename completion, and the basename is the empty string, we look
   for the previous slash and return the portion following that.  If
   there's no previous slash, we just return what we were passed.*/","-10.     character = '|';
-9. #endif
-8.   else if (S_ISREG (finfo.st_mode))
-7.     {
-6.       if (access (filename, X_OK) == 0)
-5. 	character = '*';
-4.     }
-3.   return (character);
-2. }

 /*Return the portion of PATHNAME that should be output whe",Useful
/*don't need to do anything*/,"-10.    final slash.  Otherwise, we return what we were passed.  Since
-9.    printing empty strings is not very informative, if we're doing
-8.    filename completion, and the basename is the empty string, we look
-7.    for the previous slash and return",Useful
"/*If the basename is NULL, we might have a pathname like '/usr/src/'.
     Look for a previous slash and, if one is found, return the portion
     following that slash.  If there's no previous slash, just return the
     pathname we were passed.*/","-8.     return (pathname);
-7.   temp = strrchr (pathname, '/');
-6. #if defined (__MSDOS__)
-5.   if (temp == 0 && ISALPHA ((unsigned char)pathname[0]) && pathname[1] == ':')
-4.     temp = pathname + 1;
-3. #endif
-2.   if (temp == 0 || *temp == '\0')
-",Useful
/*Compute width of STRING when displayed on screen by print_filename*/,"-10.   else if (temp[1] == '\0')
-9.     {
-8.       for (x = temp - 1; x > pathname; x--)
-7.         if (*x == '/')
-6.           break;
-5.       return ((*x == '/') ? x + 1 : pathname);
-4.     }
-3.   else
-2.     return ++temp;
-1. }

 /*Compute wid",Useful
"/*Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
   are using it, check for and output a single character for `special'
   filenames.  Return the number of characters we output.*/","-10. 	  printed_len += width;
-9. #else
-8. 	  putc (*s, rl_outstream);
-7. 	  s++;
-6. 	  printed_len++;
-5. #endif
-4. 	}
-3.     }
-2.   return printed_len;
-1. }

 /*Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
   are using it,",Useful
"/*If to_print != full_pathname, to_print is the basename of the
	 path passed.  In this case, we try to expand the directory
	 name before checking for the stat character.*/","-10.   char *s, c, *new_full_pathname;
-9.   const char *dn;
-8.   extension_char = 0;
-7.   printed_len = fnprint (to_print);
-6. #if defined (VISIBLE_STATS)
-5.  if (rl_filename_completion_desired && (rl_visible_stats || _rl_complete_mark_directories))
",Useful
/*Terminate the directory name.*/,"-2.       if (to_print != full_pathname)
-1. 	{

 /*Terminate the directory name.*/

1. 	  c = to_print[-1];
2. 	  to_print[-1] = '\0';",Useful
"/*If setting the last slash in full_pathname to a NUL results in
	     full_pathname being the empty string, we are trying to complete
	     files in the root directory.  If we pass a null string to the
	     bash directory completion hook, for example, it will expand it
	     to the current directory.  We just want the `/'.*/","-2. 	  c = to_print[-1];
-1. 	  to_print[-1] = '\0';

 /*If setting the last slash in full_pathname to a NUL results in
	     full_pathname being the empty string, we are trying to complete
	     files in the root directory.  If we pass a null string to t",Useful
"/*"";		/* restore trailing slash to `//' */*/","-5. 	  if (full_pathname == 0 || *full_pathname == 0)
-4. 	    dn = ""/"";
-3. 	  else if (full_pathname[0] != '/')
-2. 	    dn = full_pathname;
-1. 	  else if (full_pathname[1] == 0)

 /*"";		/* restore trailing slash to `//' */*/

1. 	  else if (full_pathn",Useful
/*don't turn /// into //*/,"-1. 	  else if (full_pathname[1] == '/' && full_pathname[2] == 0)

 /*don't turn /// into //*/

1. 	  else
2. 	    dn = full_pathname;
3. 	  s = tilde_expand (dn);
4. 	  if (rl_directory_completion_hook)
5. 	    (*rl_directory_completion_hook) (&s);
6. 	 ",Useful
"/*Find the bounds of the current word for completion purposes, and leave
   rl_point set to the end of the word.  This function skips quoted
   substrings (characters between matched pairs of characters in
   rl_completer_quote_characters).  First we try to find an unclosed
   quoted substring on which to do matching.  If one is not found, we use
   the word break characters to find the boundaries of the current word.
   We call an application-specific function to decide whether or not a
   particular word break character is quoted; if that function returns a
   non-zero result, the character does not break a word.  This function
   returns the opening quote character if we found an unclosed quoted
   substring, '\0' otherwise.  FP, if non-null, is set to a value saying
   which (shell-like) quote characters we found (single quote, double
   quote, or backslash) anywhere in the string.  DP, if non-null, is set to
   the value of the delimiter character that caused a word break.*/","-10.      char *qcp;
-9. {
-8.   char *r;
-7.   r = (char *)xmalloc (strlen (s) + 2);
-6.   *r = *rl_completer_quote_characters;
-5.   strcpy (r + 1, s);
-4.   if (qcp)
-3.     *qcp = *rl_completer_quote_characters;
-2.   return r;
-1. }

 /*Find the boun",Useful
"/*We have a list of characters which can be used in pairs to
	 quote substrings for the completer.  Try to find the start
	 of an unclosed quoted substring.*/","-10.   end = rl_point;
-9.   found_quote = delimiter = 0;
-8.   quote_char = '\0';
-7.   brkchars = 0;
-6.   if (rl_completion_word_break_hook)
-5.     brkchars = (*rl_completion_word_break_hook) ();
-4.   if (brkchars == 0)
-3.     brkchars = rl_complete",Useful
/*FOUND_QUOTE is set so we know what kind of quotes we found.*/,"-10.   brkchars = 0;
-9.   if (rl_completion_word_break_hook)
-8.     brkchars = (*rl_completion_word_break_hook) ();
-7.   if (brkchars == 0)
-6.     brkchars = rl_completer_word_break_characters;
-5.   if (rl_completer_quote_characters)
-4.     {

 /*FO",Useful
"/*Shell-like semantics for single quotes -- don't allow backslash
	     to quote anything in single quotes, especially not the closing
	     quote.  If you don't like this, take out the check on the value
	     of quote_char.*/","-7.       for (scan = pass_next = 0; scan < end; scan = MB_NEXTCHAR (rl_line_buffer, scan, 1, MB_FIND_ANY))
-6. 	{
-5. 	  if (pass_next)
-4. 	    {
-3. 	      pass_next = 0;
-2. 	      continue;
-1. 	    }

 /*Shell-like semantics for single quotes -- don",Useful
/*Ignore everything until the matching close quote char.*/,"-10. 	     quote.  If you don't like this, take out the check on the value
-9. 	     of quote_char. */
-8. 	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
-7. 	    {
-6. 	      pass_next = 1;
-5. 	      found_quote |= RL_QF_BACKSLASH;
-4. 	    ",Useful
/*Found matching close.  Abandon this substring.*/,"-2. 	      if (rl_line_buffer[scan] == quote_char)
-1. 		{

 /*Found matching close.  Abandon this substring.*/

1. 		  quote_char = '\0';
2. 		  rl_point = end;
3. 		}
4. 	    }
5. 	  else if (strchr (rl_completer_quote_characters, rl_line_buffer[scan]))",Useful
/*Found start of a quoted substring.*/,"-6. 		  quote_char = '\0';
-5. 		  rl_point = end;
-4. 		}
-3. 	    }
-2. 	  else if (strchr (rl_completer_quote_characters, rl_line_buffer[scan]))
-1. 	    {

 /*Found start of a quoted substring.*/

1. 	      quote_char = rl_line_buffer[scan];
2. 	     ",Useful
/*Shell-like quoting conventions.*/,"-2. 	      quote_char = rl_line_buffer[scan];
-1. 	      rl_point = scan + 1;

 /*Shell-like quoting conventions.*/

1. 	      if (quote_char == '\'')
2. 		found_quote |= RL_QF_SINGLE_QUOTE;
3. 	      else if (quote_char == '""')
4. 		found_quote |= RL_QF_",Useful
"/*We didn't find an unclosed quoted substring upon which to do
         completion, so use the word break characters to find the
         substring on which to complete.*/","-10. 		found_quote |= RL_QF_SINGLE_QUOTE;
-9. 	      else if (quote_char == '""')
-8. 		found_quote |= RL_QF_DOUBLE_QUOTE;
-7. 	      else
-6. 		found_quote |= RL_QF_OTHER_QUOTE;      
-5. 	    }
-4. 	}
-3.     }
-2.   if (rl_point == end && quote_char == ",Useful
"/*Call the application-specific function to tell us whether
	     this word break character is quoted and should be skipped.*/","-5.       while ((rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_ANY)))
-4. 	{
-3. 	  scan = rl_line_buffer[rl_point];
-2. 	  if (strchr (brkchars, scan) == 0)
-1. 	    continue;

 /*Call the application-specific function to tell us whether
	  ",Useful
"/*Convoluted code, but it avoids an n^2 algorithm with calls
	     to char_is_quoted.*/","-3. 	  if (rl_char_is_quoted_p && found_quote &&
-2. 	      (*rl_char_is_quoted_p) (rl_line_buffer, rl_point))
-1. 	    continue;

 /*Convoluted code, but it avoids an n^2 algorithm with calls
	     to char_is_quoted.*/

1. 	  break;
2. 	}
3.     }",Useful
"/*If we are at an unquoted word break, then advance past it.*/","-3. 	  break;
-2. 	}
-1.     }

 /*If we are at an unquoted word break, then advance past it.*/

1.   scan = rl_line_buffer[rl_point];",Useful
"/*If there is an application-specific function to say whether or not
     a character is quoted and we found a quote character, let that
     function decide whether or not a character is a word break, even
     if it is found in rl_completer_word_break_characters.  Don't bother
     if we're at the end of the line, though.*/","-1.   scan = rl_line_buffer[rl_point];

 /*If there is an application-specific function to say whether or not
     a character is quoted and we found a quote character, let that
     function decide whether or not a character is a word break, even
     if",Useful
"/*If the character that caused the word break was a quoting
	     character, then remember it as the delimiter.*/","-10.   if (scan)
-9.     {
-8.       if (rl_char_is_quoted_p)
-7. 	isbrk = (found_quote == 0 ||
-6. 		(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&
-5. 		strchr (brkchars, scan) != 0;
-4.       else
-3. 	isbrk = strchr (brkchars, scan) != 0;
",Useful
"/*If the character isn't needed to determine something special
	     about what kind of completion to perform, then advance past it.*/","-4. 	  if (rl_basic_quote_characters &&
-3. 	      strchr (rl_basic_quote_characters, scan) &&
-2. 	      (end - rl_point) > 1)
-1. 	    delimiter = scan;

 /*If the character isn't needed to determine something special
	     about what kind of completion",Useful
"/*We have marked all the dead slots with (char *)&dead_slot.
     Copy all the non-dead entries into a new array.*/","-10.   for (i = newlen = 0; matches[i + 1]; i++)
-9.     {
-8.       if (strcmp (matches[i], matches[i + 1]) == 0)
-7. 	{
-6. 	  free (matches[i]);
-5. 	  matches[i] = (char *)&dead_slot;
-4. 	}
-3.       else
-2. 	newlen++;
-1.     }

 /*We have marked a",Useful
"/*If there is one string left, and it is identical to the
     lowest common denominator, then the LCD is the string to
     insert.*/","-1.   temp_array[0] = lowest_common;

 /*If there is one string left, and it is identical to the
     lowest common denominator, then the LCD is the string to
     insert.*/

1.   if (j == 2 && strcmp (temp_array[0], temp_array[1]) == 0)
2.     {
3.      ",Useful
/*Count of max-matched characters.*/,"-7. static int
-6. compute_lcd_of_matches (match_list, matches, text)
-5.      char **match_list;
-4.      int matches;
-3.      const char *text;
-2. {
-1.   register int i, c1, c2, si;

 /*Count of max-matched characters.*/

111",Useful
"/*dequoted TEXT, if needed*/","-8. static int
-7. compute_lcd_of_matches (match_list, matches, text)
-6.      char **match_list;
-5.      int matches;
-4.      const char *text;
-3. {
-2.   register int i, c1, c2, si;

 /*dequoted TEXT, if needed*/

1. #if defined (HANDLE_MULTIBYTE)
2.",Useful
/*XXX - this might need changes in the presence of multibyte chars*/,"-10.      first character, and the user typed something, use that as the
-9.      value of matches[0]. */
-8.   if (low == 0 && text && *text)
-7.     {
-6.       match_list[0] = (char *)xmalloc (strlen (text) + 1);
-5.       strcpy (match_list[0], text);",Useful
"/*If we are ignoring case, try to preserve the case of the string
	 the user typed in the face of multiple matches differing in case.*/","-10.      value of matches[0]. */
-9.   if (low == 0 && text && *text)
-8.     {
-7.       match_list[0] = (char *)xmalloc (strlen (text) + 1);
-6.       strcpy (match_list[0], text);
-5.     }
-4.   else
-3.     {
-2.       match_list[0] = (char *)xmallo",Useful
"/*We're making an assumption here:
		IF we're completing filenames AND
		   the application has defined a filename dequoting function AND
		   we found a quote character AND
		   the application has requested filename quoting
		THEN
		   we assume that TEXT was dequoted before checking against
		   the file system and needs to be dequoted here before we
		   check against the list of matches
		FI*/","-2.       if (_rl_completion_case_fold)
-1. 	{

 /*We're making an assumption here:
		IF we're completing filenames AND
		   the application has defined a filename dequoting function AND
		   we found a quote character AND
		   the application has request",Useful
"/*no casematch, use first entry*/","-10. 	  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);
-9. 	  si = strlen (text);
-8. 	  if (si <= low)
-7. 	    {
-6. 	      for (i = 1; i <= matches; i++)
-5. 		if (strncmp (match_list[i], text, si) == 0)
-4. 		  {
-3",Useful
"/*otherwise, just use the text the user typed.*/","-4. 	      if (i > matches)
-3. 		strncpy (match_list[0], match_list[1], low);
-2. 	    }
-1. 	  else

 /*otherwise, just use the text the user typed.*/

1. 	    strncpy (match_list[0], text, low);
2. 	  FREE (dtext);
3. 	}
4.       else
5.         strncp",Useful
"/*It seems to me that in all the cases we handle we would like
     to ignore duplicate possiblilities.  Scan for the text to
     insert being identical to the other completions.*/","-10. static int
-9. postprocess_matches (matchesp, matching_filenames)
-8.      char ***matchesp;
-7.      int matching_filenames;
-6. {
-5.   char *t, **matches, **temp_matches;
-4.   int nmatch, i;
-3.   matches = *matchesp;
-2.   if (matches == 0)
-1. ",Useful
"/*If we are matching filenames, then here is our chance to
     do clever processing by re-examining the list.  Call the
     ignore function with the array as a parameter.  It can
     munge the array, deleting matches as it desires.*/","-6.   if (rl_ignore_completion_duplicates)
-5.     {
-4.       temp_matches = remove_duplicate_matches (matches);
-3.       free (matches);
-2.       matches = temp_matches;
-1.     }

 /*If we are matching filenames, then here is our chance to
     do cl",Useful
"/*Avoid a possible floating exception.  If max > _rl_screenwidth,
     limit will be 0 and a divide-by-zero fault will result.*/","-4.   max += 2;
-3.   limit = _rl_screenwidth / max;
-2.   if (limit != 1 && (limit * max == _rl_screenwidth))
-1.     limit--;

 /*Avoid a possible floating exception.  If max > _rl_screenwidth,
     limit will be 0 and a divide-by-zero fault will result",Useful
/*How many iterations of the printing loop?*/,"-2.   if (limit == 0)
-1.     limit = 1;

 /*How many iterations of the printing loop?*/

1.   count = (len + (limit - 1)) / limit;",Useful
"/*Watch out for special case.  If LEN is less than LIMIT, then
     just do the inner printing loop.
	   0 < len <= limit  implies  count = 1.*/","-1.   count = (len + (limit - 1)) / limit;

 /*Watch out for special case.  If LEN is less than LIMIT, then
     just do the inner printing loop.
	   0 < len <= limit  implies  count = 1.*/

111",Useful
"/*Print the sorted items, up-and-down alphabetically, like ls.*/","-6.   if (rl_ignore_completion_duplicates == 0)
-5.     qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
-4.   rl_crlf ();
-3.   lines = 0;
-2.   if (_rl_print_completions_horizontally == 0)
-1.     {

 /*Print the sorted ite",Useful
"/*Print the sorted items, across alphabetically, like ls -x.*/","-10. 	  if (_rl_page_completions && lines >= (_rl_screenheight - 1) && i < count)
-9. 	    {
-8. 	      lines = _rl_internal_pager (lines);
-7. 	      if (lines < 0)
-6. 		return;
-5. 	    }
-4. 	}
-3.     }
-2.   else
-1.     {

 /*Print the sorted items",Useful
/*Have we reached the end of this line?*/,"-4.       for (i = 1; matches[i]; i++)
-3. 	{
-2. 	  temp = printable_part (matches[i]);
-1. 	  printed_len = print_filename (temp, matches[i]);

 /*Have we reached the end of this line?*/

1. 	  if (matches[i+1])
2. 	    {
3. 	      if (i && (limit > 1) ",Useful
/*Handle simple case first.  What if there is only one answer?*/,"-1.   _rl_move_vert (_rl_vis_botlin);

 /*Handle simple case first.  What if there is only one answer?*/

1.   if (matches[1] == 0)
2.     {
3.       temp = printable_part (matches[0]);
4.       rl_crlf ();
5.       print_filename (temp, matches[0]);
6.  ",Useful
"/*There is more than one answer.  Find out how many there are,
     and find the maximum printed length of a single entry.*/","-10.   if (matches[1] == 0)
-9.     {
-8.       temp = printable_part (matches[0]);
-7.       rl_crlf ();
-6.       print_filename (temp, matches[0]);
-5.       rl_crlf ();
-4.       rl_forced_update_display ();
-3.       rl_display_fixed = 1;
-2.       r",Useful
"/*If the caller has defined a display hook, then call that now.*/","-8.   for (max = 0, i = 1; matches[i]; i++)
-7.     {
-6.       temp = printable_part (matches[i]);
-5.       len = fnwidth (temp);
-4.       if (len > max)
-3. 	max = len;
-2.     }
-1.   len = i - 1;

 /*If the caller has defined a display hook, then ca",Useful
"/*If there are many items, then ask the user if she really wants to
     see them all.*/","-5.   if (rl_completion_display_matches_hook)
-4.     {
-3.       (*rl_completion_display_matches_hook) (matches, len, max);
-2.       return;
-1.     }

 /*If there are many items, then ask the user if she really wants to
     see them all.*/

1.   if (r",Useful
"/*Pointer to quoting character, if any*/","-10. 	}
-9.     }
-8.   rl_display_match_list (matches, len, max);
-7.   rl_forced_update_display ();
-6.   rl_display_fixed = 1;
-5. }
-4. static char *
-3. make_quoted_replacement (match, mtype, qc)
-2.      char *match;
-1.      int mtype;

 /*Pointer ",Useful
"/*If we are doing completion on quoted substrings, and any matches
     contain any of the completer_word_break_characters, then auto-
     matically prepend the substring with a quote character (just pick
     the first one from the list of such) if it does not already begin
     with a quote string.  FIXME: Need to remove any such automatically
     inserted quote character when it no longer is necessary, such as
     if we change the string we are completing on and the new set of
     matches don't require a quoted substring.*/","-3. {
-2.   int should_quote, do_replace;
-1.   char *replacement;

 /*If we are doing completion on quoted substrings, and any matches
     contain any of the completer_word_break_characters, then auto-
     matically prepend the substring with a quote c",Useful
"/*If there is a single match, see if we need to quote it.
         This also checks whether the common prefix of several
	 matches needs to be quoted.*/","-10.      matches don't require a quoted substring. */
-9.   replacement = match;
-8.   should_quote = match && rl_completer_quote_characters &&
-7. 			rl_filename_completion_desired &&
-6. 			rl_filename_quoting_desired;
-5.   if (should_quote)
-4.     s",Useful
"/*Quote the replacement, since we found an embedded
	 word break character in a potential match.*/","-4.       should_quote = rl_filename_quote_characters
-3. 			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
-2. 			: 0;
-1.       do_replace = should_quote ? mtype : NO_MATCH;

 /*Quote the replacement, since we found an embedded
	 word break ",Useful
/*Now insert the match.*/,"-10. static void
-9. insert_match (match, start, mtype, qc)
-8.      char *match;
-7.      int start, mtype;
-6.      char *qc;
-5. {
-4.   char *replacement;
-3.   char oqc;
-2.   oqc = qc ? *qc : '\0';
-1.   replacement = make_quoted_replacement (match,",Useful
/*Don't double an opening quote character.*/,"-2.   if (replacement)
-1.     {

 /*Don't double an opening quote character.*/

1.       if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&
2. 	    replacement[0] == *qc)
3. 	start--;",Useful
"/*If make_quoted_replacement changed the quoting character, remove
	 the opening quote and insert the (fully-quoted) replacement.*/","-3.       if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&
-2. 	    replacement[0] == *qc)
-1. 	start--;

 /*If make_quoted_replacement changed the quoting character, remove
	 the opening quote and insert the (fully-quoted) replacement.*/

1.",Useful
"/*Append any necessary closing quote and a separator character to the
   just-inserted match.  If the user has specified that directories
   should be marked by a trailing `/', append one of those instead.  The
   default trailing character is a space.  Returns the number of characters
   appended.  If NONTRIVIAL_MATCH is set, we test for a symlink (if the OS
   has them) and don't add a suffix for a symlink to a directory.  A
   nontrivial match is one that actually adds to the word being completed.
   The variable rl_completion_mark_symlink_dirs controls this behavior
   (it's initially set to the what the user has chosen, indicated by the
   value of _rl_complete_mark_symlink_dirs, but may be modified by an
   application's completion function).*/","-8.       else if (qc && (*qc != oqc) && start && rl_line_buffer[start - 1] == oqc &&
-7. 	    replacement[0] != oqc)
-6. 	start--;
-5.       _rl_replace_text (replacement, start, rl_point - 1);
-4.       if (replacement != match)
-3.         free (replac",Useful
"/*This is clumsy.  Avoid putting in a double slash if point
		 is at the end of the line and the previous character is a
		 slash.*/","-1. 	    {

 /*This is clumsy.  Avoid putting in a double slash if point
		 is at the end of the line and the previous character is a
		 slash.*/

1. 	      if (rl_point && rl_line_buffer[rl_point] == '\0' && rl_line_buffer[rl_point - 1] == '/')
2. 		;
3.",Useful
"/*Don't add anything if the filename is a symlink and resolves to a
	 directory.*/","-7. 	      if (rl_point && rl_line_buffer[rl_point] == '\0' && rl_line_buffer[rl_point - 1] == '/')
-6. 		;
-5. 	      else if (rl_line_buffer[rl_point] != '/')
-4. 		rl_insert_text (""/"");
-3. 	    }
-2. 	}
-1. #ifdef S_ISLNK

 /*Don't add anything if the",Useful
"/*remove any opening quote character; make_quoted_replacement will add
     it back.*/","-10. }
-9. static void
-8. insert_all_matches (matches, point, qc)
-7.      char **matches;
-6.      int point;
-5.      char *qc;
-4. {
-3.   int i;
-2.   char *rp;
-1.   rl_begin_undo_group ();

 /*remove any opening quote character; make_quoted_replace",Useful
"/*Complete the word at or before point.
   WHAT_TO_DO says what to do with the completion.
   `?' means list the possible completions.
   TAB means do standard completion.
   `*' means insert all of the possible completions.
   `!' means to do standard completion, and list all possible completions if
   there is more than one.
   `@' means to do standard completion, and list all possible completions if
   there is more than one and partial completion is not possible.*/","-10. _rl_free_match_list (matches)
-9.      char **matches;
-8. {
-7.   register int i;
-6.   if (matches == 0)
-5.     return;
-4.   for (i = 0; matches[i]; i++)
-3.     free (matches[i]);
-2.   free (matches);
-1. }

 /*Complete the word at or before po",Useful
/*We now look backwards for the start of a filename/variable word.*/,"-10.   rl_compentry_func_t *our_func;
-9.   int start, end, delimiter, found_quote, i, nontrivial_lcd;
-8.   char *text, *saved_line_buffer;
-7.   char quote_char;
-6.   RL_SETSTATE(RL_STATE_COMPLETING);
-5.   set_completion_defaults (what_to_do);
-4.   s",Useful
"/*This (possibly) changes rl_point.  If it returns a non-zero char,
       we know we have an open quote.*/","-4.   end = rl_point;
-3.   found_quote = delimiter = 0;
-2.   quote_char = '\0';
-1.   if (rl_point)

 /*This (possibly) changes rl_point.  If it returns a non-zero char,
       we know we have an open quote.*/

1.     quote_char = _rl_find_completion_wo",Useful
"/*If there are more matches, ring the bell to indicate.
	 If we are in vi mode, Posix.2 says to not ring the bell.
	 If the `show-all-if-ambiguous' variable is set, display
	 all the matches immediately.  Otherwise, if this was the
	 only match, and we are hacking files, check the file to
	 see if it was a directory.  If so, and the `mark-directories'
	 variable is set, add a '/' to the name.  If not, and we
	 are at the end of the line, then add a space.*/","-2.       if (*matches[0])
-1. 	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);

 /*If there are more matches, ring the bell to indicate.
	 If we are in vi mode, Posix.2 says to not ring the bell.
	 If the `show-all-",Useful
/*There are other matches remaining.*/,"-10. 	      display_matches (matches);
-9. 	      break;
-8. 	    }
-7. 	  else if (what_to_do == '@')
-6. 	    {
-5. 	      if (nontrivial_lcd == 0)
-4. 		display_matches (matches);
-3. 	      break;
-2. 	    }
-1. 	  else if (rl_editing_mode != vi_mode)",Useful
/*Check to see if the line has changed through all of this manipulation.*/,"-10.       display_matches (matches);
-9.       break;
-8.     default:
-7.       fprintf (stderr, ""\r\nreadline: bad value %d for what_to_do in rl_complete\n"", what_to_do);
-6.       rl_ding ();
-5.       FREE (saved_line_buffer);
-4.       RL_UNSETSTATE",Useful
/*Application-callable completion match generator functions*/,"-10.   if (saved_line_buffer)
-9.     {
-8.       completion_changed_buffer = strcmp (rl_line_buffer, saved_line_buffer) != 0;
-7.       free (saved_line_buffer);
-6.     }
-5.   RL_UNSETSTATE(RL_STATE_COMPLETING);
-4.   return 0;
-3. }

 /*Application-ca",Useful
/***************************************************************/,"-10. static int print_filename PARAMS((char *, char *));
-9. static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
-8. static char **remove_duplicate_matches PARAMS((char **));
-7. static void insert_match PARAM",Useful
"/*Return an array of (char *) which is a list of completions for TEXT.
   If there are no completions, return a NULL pointer.
   The first entry in the returned array is the substitution for TEXT.
   The remaining entries are the possible completions.
   The array is terminated with a NULL pointer.

   ENTRY_FUNCTION is a function of two args, and returns a (char *).
     The first argument is TEXT.
     The second is a state argument; it should be zero on the first call, and
     non-zero on subsequent calls.  It returns a NULL pointer to the caller
     when there are no more matches.*/","
/* Return an array of (char *) which is a list of completions for TEXT.
   If there are no completions, return a NULL pointer.
   The first entry in the returned array is the substitution for TEXT.
   The remaining entries are the possible completions.
   The array is terminated with a NULL pointer.

   ENTRY_FUNCTION is a function of two args, and returns a (char *).
     The first argument is TEXT.
     The second is a state argument; it should be zero on the first call, and
     non-zero on subsequent calls.  It returns a NULL pointer to the caller
     when there are no more matches.



 /*Return an array of (char *) which is a list of completions for TEXT.
   If there are no completions, return a NULL pointer.
   The first entry in the returned array is the substitution for TEXT.
   The remaining entries are the possible completions.
   The array is terminated with a NULL pointer.

   ENTRY_FUNCTION is a function of two args, and returns a (char *).
     The first argument is TEXT.
     The second is a state argument; it should be zero on the first call, and
     non-zero on subsequent calls.  It returns a NULL pointer to the caller
     when there are no more matches.*/

1.  */
2. char **
3. rl_completion_matches (text, entry_function)
4.      const char *text;
5.      rl_compentry_func_t *entry_function;
6. {",Useful
"/*If there were any matches, then look through them finding out the
     lowest common denominator.  That then becomes match_list[0].*/","-10.   match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
-9.   match_list[1] = (char *)NULL;
-8.   while ((string = (*entry_function) (text, matches)))
-7.     {
-6.       if (matches + 1 == match_list_size)
-5. 	match_list = (char ",Useful
/*There were no matches.*/,"-2.   if (matches)
-1.     compute_lcd_of_matches (match_list, matches, text);

 /*There were no matches.*/

1.     {
2.       free (match_list);
3.       match_list = (char **)NULL;
4.     }
5.   return (match_list);
6. }",Useful
/*!__WIN32__ && !__OPENNT)*/,"-7. char *
-6. rl_username_completion_function (text, state)
-5.      const char *text;
-4.      int state;
-3. {
-2. #if defined (__WIN32__) || defined (__OPENNT)
-1.   return (char *)NULL;

 /*!__WIN32__ && !__OPENNT)*/

1.   static char *username = (ch",Useful
/*Null usernames should result in all users as possible completions.*/,"-10.       first_char_loc = first_char == '~';
-9.       username = savestring (&text[first_char_loc]);
-8. #if defined (HAVE_GETPWENT)
-7.       namelen = strlen (username);
-6. #endif
-5.       setpwent ();
-4.     }
-3. #if defined (HAVE_GETPWENT)
-2. ",Useful
/*!__WIN32__ && !__OPENNT*/,"-7. char *
-6. rl_username_completion_function (text, state)
-5.      const char *text;
-4.      int state;
-3. {
-2. #if defined (__WIN32__) || defined (__OPENNT)
-1.   return (char *)NULL;

 /*!__WIN32__ && !__OPENNT*/

1.   static char *username = (cha",Useful
/*special hack for //X/...*/,"-10. 	}
-9.       FREE (dirname);
-8.       FREE (filename);
-7.       FREE (users_dirname);
-6.       filename = savestring (text);
-5.       if (*text == 0)
-4. 	text = ""."";
-3.       dirname = savestring (text);
-2.       temp = strrchr (dirname, '/');",Useful
/*searches from current directory on the drive*/,"-9.       if (dirname[0] == '/' && dirname[1] == '/' && ISALPHA ((unsigned char)dirname[2]) && dirname[3] == '/')
-8.         temp = strrchr (dirname + 3, '/');
-7. #endif
-6.       if (temp)
-5. 	{
-4. 	  strcpy (filename, ++temp);
-3. 	  *temp = '\0';
-",Useful
"/*We aren't done yet.  We also support the ""~user"" syntax.*/","-10.         {
-9.           strcpy (filename, dirname + 2);
-8.           dirname[2] = '\0';
-7.         }
-6. #endif
-5.       else
-4. 	{
-3. 	  dirname[0] = '.';
-2. 	  dirname[1] = '\0';
-1. 	}

 /*We aren't done yet.  We also support the ""~user"" syn",Useful
/*Save the version of the directory that the user typed.*/,"-10.           strcpy (filename, dirname + 2);
-9.           dirname[2] = '\0';
-8.         }
-7. #endif
-6.       else
-5. 	{
-4. 	  dirname[0] = '.';
-3. 	  dirname[1] = '\0';
-2. 	}

 /*Save the version of the directory that the user typed.*/

1.      ",Useful
/*delete single and double quotes*/,"-7.       if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
-6. 	{
-5. 	  free (users_dirname);
-4. 	  users_dirname = savestring (dirname);
-3. 	}
-2.       else if (rl_completion_found_quote && rl_filename_dequoting_functio",Useful
/*delete single and double quotes*/,"-7.       if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
-6. 	{
-5. 	  free (users_dirname);
-4. 	  users_dirname = savestring (dirname);
-3. 	}
-2.       else if (rl_completion_found_quote && rl_filename_dequoting_functio",Useful
"/*At this point we should entertain the possibility of hacking wildcarded
     filenames, like /usr/man/man<WILD>/te<TAB>.  If the directory name
     contains globbing characters, then build an array of directories, and
     then map over that list while completing.*/","-7. 	  temp = (*rl_filename_dequoting_function) (filename, rl_completion_quote_character);
-6. 	  free (filename);
-5. 	  filename = temp;
-4. 	}
-3.       filename_len = strlen (filename);
-2.       rl_filename_completion_desired = 1;
-1.     }

 /*At th",Useful
/**** UNIMPLEMENTED ****/,"-10. 	  free (filename);
-9. 	  filename = temp;
-8. 	}
-7.       filename_len = strlen (filename);
-6.       rl_filename_completion_desired = 1;
-5.     }

 /**** UNIMPLEMENTED ****/

111",Useful
"/*Canonicalization cuts off any final slash present.  We
		 may need to add it back.*/","-7.       if (dirname && (dirname[0] != '.' || dirname[1]))
-6. 	{
-5. 	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
-4. 	    {
-3. 	      dirlen = strlen (dirname);
-2. 	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
-1",Useful
"/*The first time through, we generate the list of matches and set things
     up to insert them.*/","-10. {
-9.   rl_compentry_func_t *our_func;
-8.   int matching_filenames, found_quote;
-7.   static char *orig_text;
-6.   static char **matches = (char **)0;
-5.   static int match_list_index = 0;
-4.   static int match_list_size = 0;
-3.   static int or",Useful
/*Only the completion entry function can change these.*/,"-4. static void
-3. set_completion_defaults (what_to_do)
-2.      int what_to_do;
-1. {

 /*Only the completion entry function can change these.*/

1.   rl_filename_completion_desired = 0;
2.   rl_filename_quoting_desired = 1;
3.   rl_completion_type = wh",Useful
/*We now look backwards for the start of a filename/variable word.*/,"-10.   rl_compentry_func_t *our_func;
-9.   int start, end, delimiter, found_quote, i, nontrivial_lcd;
-8.   char *text, *saved_line_buffer;
-7.   char quote_char;
-6.   RL_SETSTATE(RL_STATE_COMPLETING);
-5.   set_completion_defaults (what_to_do);
-4.   s",Useful
"/*This (possibly) changes rl_point.  If it returns a non-zero char,
	   we know we have an open quote.*/","-4.       orig_end = rl_point;
-3.       found_quote = delimiter = 0;
-2.       quote_char = '\0';
-1.       if (rl_point)

 /*This (possibly) changes rl_point.  If it returns a non-zero char,
	   we know we have an open quote.*/

1. 	quote_char = _rl_fin",Useful
"/*If we are matching filenames, the attempted completion function will
	 have set rl_filename_completion_desired to a non-zero value.  The basic
	 rl_filename_completion_function does this.*/","-6. 	quote_char = _rl_find_completion_word (&found_quote, &delimiter);
-5.       orig_start = rl_point;
-4.       rl_point = orig_end;
-3.       orig_text = rl_copy_text (orig_start, orig_end);
-2.       matches = gen_completion_matches (orig_text, orig_s",Useful
/*for _POSIX_VERSION*/,"-10.    The GNU General Public License is often shipped with GNU software, and
-9.    is generally kept in a file called COPYING or LICENSE.  If you do not
-8.    have a copy of the license, write to the Free Software Foundation,
-7.    51 Franklin Street",Useful
/*System-specific feature definitions and include files.*/,"-1. #include <stdio.h>

 /*System-specific feature definitions and include files.*/

1. #include ""rldefs.h""",Useful
/*Some standard library routines.*/,"-1. #include ""rldefs.h""

 /*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include ""xmalloc.h""",Useful
/*The real variable to look at to find out when to flush kills.*/,"-1. #define DEFAULT_MAX_KILLS 10

 /*The real variable to look at to find out when to flush kills.*/

1. static int rl_max_kills =  DEFAULT_MAX_KILLS;",Useful
/*Where to store killed text.*/,"-3. #define DEFAULT_MAX_KILLS 10

 /*Where to store killed text.*/

1. static char **rl_kill_ring = (char **)NULL;",Useful
"/*Add TEXT to the kill ring, allocating a new kill ring slot as necessary.
   This uses TEXT directly, so the caller must not free it.  If APPEND is
   non-zero, and the last command was a kill, the text is appended to the
   current kill ring slot, otherwise prepended.*/","-6. int
-5. rl_set_retained_kills (num)
-4.      int num __attribute__((unused));
-3. {
-2.   return 0;
-1. }

 /*Add TEXT to the kill ring, allocating a new kill ring slot as necessary.
   This uses TEXT directly, so the caller must not free it.  If APPE",Useful
"/*If we don't have any defined, then make one.*/","-2.       if (rl_kill_ring == 0)
-1. 	{

 /*If we don't have any defined, then make one.*/

1. 	  rl_kill_ring = (char **)
2. 	    xmalloc (((rl_kill_ring_length = 1) + 1) * sizeof (char *));
3. 	  rl_kill_ring[slot = 0] = (char *)NULL;
4. 	}
5.       els",Useful
"/*The way to kill something.  This appends or prepends to the last
   kill, if the last command was a kill command.  if FROM is less
   than TO, then the text is appended, otherwise prepended.  If the
   last command was not a kill command, then a new slot is made for
   this kill.*/","-10. 	}
-9.       free (old);
-8.       free (text);
-7.       rl_kill_ring[slot] = new;
-6.     }
-5.   else
-4.     rl_kill_ring[slot] = text;
-3.   rl_kill_index = slot;
-2.   return 0;
-1. }

 /*The way to kill something.  This appends or prepends to ",Useful
/*Is there anything to kill?*/,"-5. int
-4. rl_kill_text (from, to)
-3.      int from, to;
-2. {
-1.   char *text;

 /*Is there anything to kill?*/

1.   if (from == to)
2.     {
3.       _rl_last_command_was_kill++;
4.       return 0;
5.     }
6.   text = rl_copy_text (from, to);",Useful
/*Delete the copied text from the line.*/,"-6.   if (from == to)
-5.     {
-4.       _rl_last_command_was_kill++;
-3.       return 0;
-2.     }
-1.   text = rl_copy_text (from, to);

 /*Delete the copied text from the line.*/

1.   rl_delete_text (from, to);
2.   _rl_copy_to_kill_ring (text, from ",Useful
"/*Delete the word at point, saving the text in the kill ring.*/","-10.   return 0;
-9. }

 /*Delete the word at point, saving the text in the kill ring.*/

1. int
2. rl_kill_word (count, key)
3.      int count, key;
4. {
5.   int orig_point;
6.   if (count < 0)
7.     return (rl_backward_kill_word (-count, key));
8.   e",Useful
"/*Rubout the word before point, placing it on the kill ring.*/","-10.       orig_point = rl_point;
-9.       rl_forward_word (count, key);
-8.       if (rl_point != orig_point)
-7. 	rl_kill_text (orig_point, rl_point);
-6.       rl_point = orig_point;
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point",Useful
"/*Kill from here to the end of the line.  If DIRECTION is negative, kill
   back to the line start instead.*/","-10.     {
-9.       orig_point = rl_point;
-8.       rl_backward_word (count, ignore);
-7.       if (rl_point != orig_point)
-6. 	rl_kill_text (orig_point, rl_point);
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point;
-3.     }
-2.   r",Useful
"/*Kill backwards to the start of the line.  If DIRECTION is negative, kill
   forwards to the line end instead.*/","-10.       orig_point = rl_point;
-9.       rl_end_of_line (1, ignore);
-8.       if (orig_point != rl_point)
-7. 	rl_kill_text (orig_point, rl_point);
-6.       rl_point = orig_point;
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point;
",Useful
"/*Kill the whole line, no matter where point is.*/","-10. 	  orig_point = rl_point;
-9. 	  rl_beg_of_line (1, ignore);
-8. 	  if (rl_point != orig_point)
-7. 	    rl_kill_text (orig_point, rl_point);
-6. 	  if (rl_editing_mode == emacs_mode)
-5. 	    rl_mark = rl_point;
-4. 	}
-3.     }
-2.   return 0;
-1. ",Useful
"/*The next two functions mimic unix line editing behaviour, except they
   save the deleted text on the kill ring.  This is safer than not saving
   it, and since we have a ring, nobody should get screwed.*/","-10. rl_kill_full_line (count, ignore)
-9.      int count __attribute__((unused)), ignore __attribute__((unused));
-8. {
-7.   rl_begin_undo_group ();
-6.   rl_point = 0;
-5.   rl_kill_text (rl_point, rl_end);
-4.   rl_mark = 0;
-3.   rl_end_undo_group ()",Useful
"/*This does what C-w does in Unix.  We can't prevent people from
   using behaviour that they expect.*/","-10.   rl_begin_undo_group ();
-9.   rl_point = 0;
-8.   rl_kill_text (rl_point, rl_end);
-7.   rl_mark = 0;
-6.   rl_end_undo_group ();
-5.   return 0;
-4. }

 /*This does what C-w does in Unix.  We can't prevent people from
   using behaviour that they ",Useful
"/*This deletes one filename component in a Unix pathname.  That is, it
   deletes backward to directory separator (`/') or whitespace.*/","-10. 	    rl_point--;
-9. 	  while (rl_point && (whitespace (rl_line_buffer[rl_point - 1]) == 0))
-8. 	    rl_point--;
-7. 	}
-6.       rl_kill_text (orig_point, rl_point);
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point;
-3.     }
-2",Useful
"/*Here is C-u doing what Unix does.  You don't *have* to use these
   key-bindings.  We have a choice of killing the entire line, or
   killing from where we are to the start of the line.  We choose the
   latter, because if you are a Unix weenie, then you haven't backspaced
   into the line at all, and if you aren't, then you know what you are
   doing.*/","-10. 	      rl_point--;
-9. 	      c = rl_line_buffer[rl_point - 1];
-8. 	    }
-7. 	}
-6.       rl_kill_text (orig_point, rl_point);
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point;
-3.     }
-2.   return 0;
-1. }

 /*Here is C-u doi",Useful
"/*Copy the text in the `region' to the kill ring.  If DELETE is non-zero,
   delete the text from the line as well.*/","-10.     rl_ding ();
-9.   else
-8.     {
-7.       rl_kill_text (rl_point, 0);
-6.       rl_point = 0;
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point;
-3.     }
-2.   return 0;
-1. }

 /*Copy the text in the `region' to the kill rin",Useful
/*Copy the text in the region to the kill ring.*/,"-10.   if (rl_mark != rl_point)
-9.     {
-8.       text = rl_copy_text (rl_point, rl_mark);
-7.       if (delete)
-6. 	rl_delete_text (rl_point, rl_mark);
-5.       _rl_copy_to_kill_ring (text, rl_point < rl_mark);
-4.     }
-3.   _rl_last_command_was_ki",Useful
/*Kill the text between the point and mark.*/,"-6. int
-5. rl_copy_region_to_kill (count, ignore)
-4.      int count __attribute__((unused)), ignore __attribute__((unused));
-3. {
-2.   return (region_kill_internal (0));
-1. }

 /*Kill the text between the point and mark.*/

1. int
2. rl_kill_region (",Useful
"/*Copy COUNT words to the kill ring.  DIR says which direction we look
   to find the words.*/","-10. rl_kill_region (count, ignore)
-9.      int count __attribute__((unused)), ignore __attribute__((unused));
-8. {
-7.   int r, npoint;
-6.   npoint = (rl_point < rl_mark) ? rl_point : rl_mark;
-5.   r = region_kill_internal (1);
-4.   _rl_fix_point (1",Useful
/*Yank back the last killed text.  This ignores arguments.*/,"-10.   return (_rl_copy_word_as_kill (count, 1));
-9. }
-8. int
-7. rl_copy_backward_word (count, key)
-6.      int count, key;
-5. {
-4.   if (count < 0)
-3.     return (rl_copy_forward_word (-count, key));
-2.   return (_rl_copy_word_as_kill (count, -1)",Useful
"/*If the last command was yank, or yank_pop, and the text just
   before point is identical to the current kill item, then
   delete that text from the line, rotate the index down, and
   yank back some other text.*/","-10. {
-9.   if (rl_kill_ring == 0)
-8.     {
-7.       _rl_abort_internal ();
-6.       return -1;
-5.     }
-4.   _rl_set_mark_at_pos (rl_point);
-3.   rl_insert_text (rl_kill_ring[rl_kill_index]);
-2.   return 0;
-1. }

 /*If the last command was yank,",Useful
/*bind.c -- key binding and startup file support for the readline library.*/,"
/* bind.c -- key binding and startup file support for the readline library. */


 /*bind.c -- key binding and startup file support for the readline library.*/

1. /* Copyright (C) 1987-2006 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
/*HAVE_SYS_FILE_H*/,"-10. #define READLINE_LIBRARY
-9. #if defined (__TANDEM)
-8. #  include <floss.h>
-7. #endif
-6. #if defined (HAVE_CONFIG_H)
-5. #  include ""config_readline.h""
-4. #endif
-3. #include <stdio.h>
-2. #include <sys/types.h>
-1. #include <fcntl.h>
#if defined",Useful
/*HAVE_UNISTD_H*/,"
#if defined (HAVE_UNISTD_H)



 /*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



 /*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Useful
/*!errno*/,"-3. #include <errno.h>
-2. #if !defined (errno)
-1. extern int errno;

 /*!errno*/

1. #include ""posixstat.h""",Useful
/*System-specific feature definitions and include files.*/,"-1. #include ""posixstat.h""

 /*System-specific feature definitions and include files.*/

1. #include ""rldefs.h""",Useful
/*Some standard library routines.*/,"-1. #include ""rldefs.h""

 /*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include ""rlshell.h""
5. #include ""xmalloc.h""
6. #if !defined (strchr) && !defined (__STDC__)
7. extern char *strch",Useful
/*!strchr && !__STDC__*/,"-7. #include ""readline.h""
-6. #include ""history.h""
-5. #include ""rlprivate.h""
-4. #include ""rlshell.h""
-3. #include ""xmalloc.h""
-2. #if !defined (strchr) && !defined (__STDC__)
-1. extern char *strchr (), *strrchr ();

 /*!strchr && !__STDC__*/

111",Useful
/*Variables exported by this file.*/,"-8. #include ""readline.h""
-7. #include ""history.h""
-6. #include ""rlprivate.h""
-5. #include ""rlshell.h""
-4. #include ""xmalloc.h""
-3. #if !defined (strchr) && !defined (__STDC__)
-2. extern char *strchr (), *strrchr ();

 /*Variables exported by this file.*",Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

 /******************************************************************/

111",Useful
/*Binding keys*/,"-3. static int _rl_prefer_visible_bell = 1;

 /*Binding keys*/

111",Useful
/******************************************************************/,"-1. static int _rl_prefer_visible_bell = 1;

 /******************************************************************/

111",Useful
"/*rl_add_defun (char *name, rl_command_func_t *function, int key)
   Add NAME to the list of named functions.  Make FUNCTION be the function
   that gets called.  If KEY is not -1, then bind it.*/","-6. static int _rl_prefer_visible_bell = 1;

 /*rl_add_defun (char *name, rl_command_func_t *function, int key)
   Add NAME to the list of named functions.  Make FUNCTION be the function
   that gets called.  If KEY is not -1, then bind it.*/

1. int
2. r",Useful
/*Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range.*/,"-10. rl_add_defun (name, function, key)
-9.      const char *name;
-8.      rl_command_func_t *function;
-7.      int key;
-6. {
-5.   if (key != -1)
-4.     rl_bind_key (key, function);
-3.   rl_add_funmap_entry (name, function);
-2.   return 0;
-1. }

 ",Useful
"/*Bind KEY to FUNCTION in MAP.  Returns non-zero in case of invalid
   KEY.*/","-10. 	  escmap[key].function = function;
-9. 	  return (0);
-8. 	}
-7.       return (key);
-6.     }
-5.   _rl_keymap[key].type = ISFUNC;
-4.   _rl_keymap[key].function = function;
-3.   rl_binding_keymap = _rl_keymap;
-2.   return (0);
-1. }

 /*Bind KEY",Useful
"/*Make KEY do nothing in the currently selected keymap.
   Returns non-zero in case of error.*/","-10. int
-9. rl_bind_key_if_unbound (key, default_func)
-8.      int key;
-7.      rl_command_func_t *default_func;
-6. {
-5.   char keyseq[2];
-4.   keyseq[0] = (unsigned char)key;
-3.   keyseq[1] = '\0';
-2.   return (rl_bind_keyseq_if_unbound_in_map (k",Useful
"/*Make KEY do nothing in MAP.
   Returns non-zero in case of error.*/","-6. int
-5. rl_unbind_key (key)
-4.      int key;
-3. {
-2.   return (rl_bind_key (key, (rl_command_func_t *)NULL));
-1. }

 /*Make KEY do nothing in MAP.
   Returns non-zero in case of error.*/

1. int
2. rl_unbind_key_in_map (key, map)
3.      int key;
",Useful
"/*Bind the key sequence represented by the string KEYSEQ to
   FUNCTION, starting in the current keymap.  This makes new
   keymaps as necessary.*/","-10. rl_unbind_command_in_map (command, map)
-9.      const char *command;
-8.      Keymap map;
-7. {
-6.   rl_command_func_t *func;
-5.   func = rl_named_function (command);
-4.   if (func == 0)
-3.     return 0;
-2.   return (rl_unbind_function_in_map (",Useful
"/*Bind the key sequence represented by the string KEYSEQ to
   FUNCTION.  This makes new keymaps as necessary.  The initial
   place to do bindings is in MAP.*/","-7. int
-6. rl_bind_keyseq (keyseq, function)
-5.      const char *keyseq;
-4.      rl_command_func_t *function;
-3. {
-2.   return (rl_generic_bind (ISFUNC, keyseq, (char *)function, _rl_keymap));
-1. }

 /*Bind the key sequence represented by the string",Useful
/*Backwards compatibility; equivalent to rl_bind_keyseq_in_map()*/,"-10.    FUNCTION.  This makes new keymaps as necessary.  The initial
-9.    place to do bindings is in MAP. */
-8. int
-7. rl_bind_keyseq_in_map (keyseq, function, map)
-6.      const char *keyseq;
-5.      rl_command_func_t *function;
-4.      Keymap map",Useful
"/*Bind the key sequence represented by the string KEYSEQ to
   the string of characters MACRO.  This makes new keymaps as
   necessary.  The initial place to do bindings is in MAP.*/","-10.     }
-9.   return 0;
-8. }
-7. int
-6. rl_bind_keyseq_if_unbound (keyseq, default_func)
-5.      const char *keyseq;
-4.      rl_command_func_t *default_func;
-3. {
-2.   return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
",Useful
"/*Bind the key sequence represented by the string KEYSEQ to
   the arbitrary pointer DATA.  TYPE says what kind of data is
   pointed to by DATA, right now this can be a function (ISFUNC),
   a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps
   as necessary.  The initial place to do bindings is in MAP.*/","-10.   int macro_keys_len;
-9.   macro_keys = (char *)xmalloc ((2 * strlen (macro)) + 1);
-8.   if (rl_translate_keyseq (macro, macro_keys, &macro_keys_len))
-7.     {
-6.       free (macro_keys);
-5.       return -1;
-4.     }
-3.   rl_generic_bind (ISMA",Useful
"/*Translate the ASCII representation of KEYSEQ into an array of
     characters.  Stuff the characters into KEYS, and the length of
     KEYS into KEYS_LEN.*/","-7.   if (keyseq == 0 || *keyseq == 0)
-6.     {
-5.       if (type == ISMACR)
-4. 	free (data);
-3.       return -1;
-2.     }
-1.   keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));

 /*Translate the ASCII representation of KEYSEQ into an array of
   ",Useful
"/*Bind keys, making new keymaps as necessary.*/","-5.   if (rl_translate_keyseq (keyseq, keys, &keys_len))
-4.     {
-3.       free (keys);
-2.       return -1;
-1.     }

 /*Bind keys, making new keymaps as necessary.*/

1.   for (i = 0; i < keys_len; i++)
2.     {
3.       unsigned char uc = keys[i];
4",Useful
"/*We allow subsequences of keys.  If a keymap is being
		 created that will `shadow' an existing function or macro
		 key binding, we save that keybinding into the ANYOTHERKEY
		 index in the new map.  The dispatch code will look there
		 to find the function to execute if the subsequence is not
		 matched.  ANYOTHERKEY was chosen to be greater than
		 UCHAR_MAX.*/","-10.       if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
-9. 	{
-8. 	  ic = UNMETA (ic);
-7. 	  if (map[ESC].type == ISKMAP)
-6. 	    map = FUNCTION_TO_KEYMAP (map, ESC);
-5. 	}
-4.       if ((i + 1) < keys_len)
-3. 	{
-2. 	  if (map[ic].type != ",Useful
"/*The dispatch code will return this function if no matching
	     key sequence is found in the keymap.  This (with a little
	     help from the dispatch code in readline.c) allows `a' to be
	     mapped to something, `abc' to be mapped to something else,
	     and the function bound  to `a' to be executed when the user
	     types `abx', leaving `bx' in the input queue.*/","-10. 		 key binding, we save that keybinding into the ANYOTHERKEY
-9. 		 index in the new map.  The dispatch code will look there
-8. 		 to find the function to execute if the subsequence is not
-7. 		 matched.  ANYOTHERKEY was chosen to be greater than
-",Useful
"/*Translate the ASCII representation of SEQ, stuffing the values into ARRAY,
   an array of characters.  LEN gets the final length of ARRAY.  Return
   non-zero if there was an error parsing SEQ.*/","-10. 	      ic = ANYOTHERKEY;
-9. 	    }
-8. 	  map[ic].function = KEYMAP_TO_FUNCTION (data);
-7. 	  map[ic].type = type;
-6. 	}
-5.       rl_binding_keymap = map;
-4.     }
-3.   free (keys);
-2.   return 0;
-1. }

 /*Translate the ASCII representation o",Useful
"/*This doesn't yet handle things like \M-\a, which may
			 or may not have any reasonable meaning.  You're
			 probably better off using straight octal or hex.*/","-8. 		  else if (seq[i+1] == '\\' && seq[i+2] == 'C' && seq[i+3] == '-')
-7. 		    {
-6. 		      i += 4;
-5. 		      temp = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
-4. 		      array[l++] = META (temp);
-3. 		    }
-2. 		  else
-1. 		    {",Useful
/*Special hack for C-?...*/,"-7. 		      i++;
-6. 		      array[l++] = META (seq[i]);
-5. 		    }
-4. 		}
-3. 	      else if (c == 'C')
-2. 		{
-1. 		  i += 2;

 /*Special hack for C-?...*/

1. 		  array[l++] = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
2. 		}
3. 	     ",Useful
/*readline-specific*/,"-10. 	     preceding a character that is not special is stripped. */
-9. 	  switch (c)
-8. 	    {
-7. 	    case 'a':
-6. 	      array[l++] = '\007';
-5. 	      break;
-4. 	    case 'b':
-3. 	      array[l++] = '\b';
-2. 	      break;
-1. 	    case 'd':

 ",Useful
/*backslashes before non-special chars just add the char*/,"-2. 	      array[l++] = c & largest_char;
-1. 	      break;

 /*backslashes before non-special chars just add the char*/

1. 	      array[l++] = c;",Useful
/*the backslash is stripped*/,"-1. 	      array[l++] = c;

 /*the backslash is stripped*/

1. 	    }
2. 	  continue;
3. 	}
4.       array[l++] = c;
5.     }
6.   *len = l;
7.   array[l] = '\0';
8.   return (0);
9. }
10. char *",Useful
"/*Return a pointer to the function that STRING represents.
   If STRING doesn't have a matching function, then a NULL pointer
   is returned.*/","-10. 	  *r++ = '\\';
-9. 	  c = 'e';
-8. 	}
-7.       else if (c == '\\' || c == '""')
-6. 	*r++ = '\\';
-5.       *r++ = (unsigned char)c;
-4.     }
-3.   *r = '\0';
-2.   return ret;
-1. }

 /*Return a pointer to the function that STRING represents.
   I",Useful
"/*Return the function (or macro) definition which would be invoked via
   KEYSEQ if executed in MAP.  If MAP is NULL, then the current keymap is
   used.  TYPE, if non-NULL, is a pointer to an int which will receive the
   type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),
   or ISMACR (macro).*/","-10. rl_named_function (string)
-9.      const char *string;
-8. {
-7.   register int i;
-6.   rl_initialize_funmap ();
-5.   for (i = 0; funmap[i]; i++)
-4.     if (_rl_stricmp (funmap[i]->name, string) == 0)
-3.       return (funmap[i]->function);
-2.  ",Useful
"/*XXX - should we just return NULL here, since this obviously
	     doesn't match?*/","-10.   for (i = 0; keyseq && keyseq[i]; i++)
-9.     {
-8.       unsigned char ic = keyseq[i];
-7.       if (META_CHAR_FOR_UCHAR(ic) && _rl_convert_meta_chars_to_ascii)
-6. 	{
-5. 	  if (map[ESC].type == ISKMAP)
-4. 	    {
-3. 	      map = FUNCTION_TO_KEY",Useful
"/*If this is the last key in the key sequence, return the
	     map.*/","-10. 	     doesn't match? */
-9. 	  else
-8. 	    {
-7. 	      if (type)
-6. 		*type = map[ESC].type;
-5. 	      return (map[ESC].function);
-4. 	    }
-3. 	}
-2.       if (map[ic].type == ISKMAP)
-1. 	{

 /*If this is the last key in the key sequence, re",Useful
"/*If we're not at the end of the key sequence, and the current key
	 is bound to something other than a keymap, then the entire key
	 sequence is not bound.*/","-10. 	     map. */
-9. 	  if (keyseq[i + 1] == '\0')
-8. 	    {
-7. 	      if (type)
-6. 		*type = ISKMAP;
-5. 	      return (map[ic].function);
-4. 	    }
-3. 	  else
-2. 	    map = FUNCTION_TO_KEYMAP (map, ic);
-1. 	}

 /*If we're not at the end of the ",Useful
/*map[ic].type != ISKMAP && keyseq[i+1] == 0*/,"-2.       else if (map[ic].type != ISKMAP && keyseq[i+1])
-1. 	return ((rl_command_func_t *)NULL);

 /*map[ic].type != ISKMAP && keyseq[i+1] == 0*/

1. 	{
2. 	  if (type)
3. 	    *type = map[ic].type;
4. 	  return (map[ic].function);
5. 	}
6.     }
7.   r",Useful
/*The last key bindings file read.*/,"-8. 	{
-7. 	  if (type)
-6. 	    *type = map[ic].type;
-5. 	  return (map[ic].function);
-4. 	}
-3.     }
-2.   return ((rl_command_func_t *) NULL);
-1. }

 /*The last key bindings file read.*/

1. static char *last_readline_init_file = (char *)NULL;",Useful
"/*Read FILENAME into a locally-allocated buffer and return the buffer.
   The size of the buffer is returned in *SIZEP.  Returns NULL if any
   errors were encountered.*/","-3. static const char *current_readline_init_file;
-2. static int current_readline_init_include_level;
-1. static int current_readline_init_lineno;

 /*Read FILENAME into a locally-allocated buffer and return the buffer.
   The size of the buffer is retur",Useful
/*Re-read the current keybindings file.*/,"-10.   if (i < 0)
-9.     {
-8.       free (buffer);
-7.       return ((char *)NULL);
-6.     }
-5.   buffer[i] = '\0';
-4.   if (sizep)
-3.     *sizep = i;
-2.   return (buffer);
-1. }

 /*Re-read the current keybindings file.*/

1. int
2. rl_re_read_ini",Useful
"/*Do key bindings from a file.  If FILENAME is NULL it defaults
   to the first non-null filename from this list:
     1. the filename used for the previous call
     2. the value of the shell variable `INPUTRC'
     3. ~/.inputrc
     4. /etc/inputrc
   If the file existed and could be opened and read, 0 is returned,
   otherwise errno is returned.*/","-9. int
-8. rl_re_read_init_file (count, ignore)
-7.      int count __attribute__((unused)), ignore __attribute__((unused));
-6. {
-5.   int r;
-4.   r = rl_read_init_file ((const char *)NULL);
-3.   rl_set_keymap_from_edit_mode ();
-2.   return r;
-1. }
",Useful
"/*Loop over the lines in the file.  Lines that start with `#' are
     comments; all other lines are commands for readline initialization.*/","-10.   buffer = _rl_read_file (openname, &file_size);
-9.   free (openname);
-8.   if (buffer == 0)
-7.     return (errno);
-6.   if (include_level == 0 && filename != last_readline_init_file)
-5.     {
-4.       FREE (last_readline_init_file);
-3.       ",Useful
/*Parser Directives*/,"-10.      const char *msg;
-9. {
-8.   if (currently_reading_init_file)
-7.     fprintf (stderr, ""readline: %s: line %d: %s\n"", current_readline_init_file,
-6. 		     current_readline_init_lineno, msg);
-5.   else
-4.     fprintf (stderr, ""readline: %s\n""",Useful
/*Conditionals.*/,"-6. const char *_rl_possible_control_prefixes[] = {
-5.   ""Control-"", ""C-"", ""CTRL-"", (const char *)NULL
-4. };
-3. const char *_rl_possible_meta_prefixes[] = {
-2.   ""Meta"", ""M-"", (const char *)NULL
-1. };

 /*Conditionals.*/

111",Useful
/*Calling programs set this to have their argv[0].*/,"-7. const char *_rl_possible_control_prefixes[] = {
-6.   ""Control-"", ""C-"", ""CTRL-"", (const char *)NULL
-5. };
-4. const char *_rl_possible_meta_prefixes[] = {
-3.   ""Meta"", ""M-"", (const char *)NULL
-2. };

 /*Calling programs set this to have their argv[",Useful
"/*Push _rl_parsing_conditionalized_out, and set parser state based
   on ARGS.*/","-3. static unsigned char *if_stack = (unsigned char *)NULL;
-2. static int if_stack_depth;
-1. static int if_stack_size;

 /*Push _rl_parsing_conditionalized_out, and set parser state based
   on ARGS.*/

1. static int
2. parser_if (args)
3.      char *ar",Useful
/*Push parser state.*/,"-5. static int
-4. parser_if (args)
-3.      char *args;
-2. {
-1.   register int i;

 /*Push parser state.*/

1.   if (if_stack_depth + 1 >= if_stack_size)
2.     {
3.       if (!if_stack)
4. 	if_stack = (unsigned char *)xmalloc (if_stack_size = 20);
5. ",Useful
"/*If parsing is turned off, then nothing can turn it back on except
     for finding the matching endif.  In that case, return right now.*/","-8.   if (if_stack_depth + 1 >= if_stack_size)
-7.     {
-6.       if (!if_stack)
-5. 	if_stack = (unsigned char *)xmalloc (if_stack_size = 20);
-4.       else
-3. 	if_stack = (unsigned char *)xrealloc (if_stack, if_stack_size += 20);
-2.     }
-1.   if_s",Useful
"/*Handle ""$if term=foo"" and ""$if mode=emacs"" constructs.  If this
     isn't term=foo, or mode=emacs, then check to see if the first
     word in ARGS is the same as the value stored in rl_readline_name.*/","-3.   for (i = 0; args[i] && !whitespace (args[i]); i++);
-2.   if (args[i])
-1.     args[i++] = '\0';

 /*Handle ""$if term=foo"" and ""$if mode=emacs"" constructs.  If this
     isn't term=foo, or mode=emacs, then check to see if the first
     word in ARGS",Useful
"/*Terminals like ""aaa-60"" are equivalent to ""aaa"".*/","-3.   if (rl_terminal_name && _rl_strnicmp (args, ""term="", 5) == 0)
-2.     {
-1.       char *tem, *tname;

 /*Terminals like ""aaa-60"" are equivalent to ""aaa"".*/

1.       tname = savestring (rl_terminal_name);
2.       tem = strchr (tname, '-');
3.      ",Useful
"/*Test the `long' and `short' forms of the terminal name so that
	 if someone has a `sun-cmd' and does not want to have bindings
	 that will be executed if the terminal is a `sun', they can put
	 `$if term=sun-cmd' into their .inputrc.*/","-4.       tname = savestring (rl_terminal_name);
-3.       tem = strchr (tname, '-');
-2.       if (tem)
-1. 	*tem = '\0';

 /*Test the `long' and `short' forms of the terminal name so that
	 if someone has a `sun-cmd' and does not want to have bindings
	",Useful
/*VI_MODE*/,"-10. int
-9. rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
-8.      const char *keyseq;
-7.      rl_command_func_t *default_func;
-6.      Keymap kmap;
-5. {
-4.   rl_command_func_t *func;
-3.   if (keyseq)
-2.     {
-1.       func = rl_fu",Useful
"/*Check the previous (n - 1) levels of the stack to make sure that
     we haven't previously turned off parsing.*/","-10. parser_else (args)
-9.      char *args __attribute__((unused));
-8. {
-7.   register int i;
-6.   if (if_stack_depth == 0)
-5.     {
-4.       _rl_init_file_error (""$else found without matching $if"");
-3.       return 0;
-2.     }
-1. #if 0

 /*Check",Useful
"/*Check the previous (n) levels of the stack to make sure that
     we haven't previously turned off parsing.*/","-2.   for (i = 0; i < if_stack_depth - 1; i++)
-1. #else

 /*Check the previous (n) levels of the stack to make sure that
     we haven't previously turned off parsing.*/

1.   for (i = 0; i < if_stack_depth; i++)
2. #endif
3.     if (if_stack[i] == 1)
4.",Useful
/*Invert the state of parsing if at top level.*/,"-4.   for (i = 0; i < if_stack_depth; i++)
-3. #endif
-2.     if (if_stack[i] == 1)
-1.       return 0;

 /*Invert the state of parsing if at top level.*/

1.   _rl_parsing_conditionalized_out = !_rl_parsing_conditionalized_out;
2.   return 0;
3. }",Useful
/*Associate textual names with actual functions.*/,"-10.   old_include_level = current_readline_init_include_level;
-9.   e = strchr (args, '\n');
-8.   if (e)
-7.     *e = '\0';
-6.   r = _rl_read_init_file ((const char *)args, old_include_level + 1);
-5.   current_readline_init_file = old_init_file;
-4. ",Useful
/*Isolate the actual directive.*/,"-6. static int
-5. handle_parser_directive (statement)
-4.      char *statement;
-3. {
-2.   register int i;
-1.   char *directive, *args;

 /*Isolate the actual directive.*/

111",Useful
"/*Lookup the command, and act on it.*/","-7.   for (i = 0; whitespace (statement[i]); i++);
-6.   directive = &statement[i];
-5.   for (; statement[i] && !whitespace (statement[i]); i++);
-4.   if (statement[i])
-3.     statement[i++] = '\0';
-2.   for (; statement[i] && whitespace (statement[i]",Useful
"/*Read the binding command from STRING and perform it.
   A key binding command looks like: Keyname: function-name\0,
   a variable binding command looks like: set variable value.
   A new-style keybinding looks like ""\C-x\C-x"": exchange-point-and-mark.*/","-3.   _rl_init_file_error (""unknown parser directive"");
-2.   return (1);
-1. }

 /*Read the binding command from STRING and perform it.
   A key binding command looks like: Keyname: function-name\0,
   a variable binding command looks like: set variable ",Useful
"/*If this is a parser directive, act on it.*/","-10. rl_parse_and_bind (string)
-9.      char *string;
-8. {
-7.   char *funname, *kname;
-6.   register int c, i;
-5.   int key, equivalency;
-4.   while (string && whitespace (*string))
-3.     string++;
-2.   if (!string || !*string || *string == '#')
",Useful
"/*If we aren't supposed to be parsing right now, then we're done.*/","-5.   if (*string == '$')
-4.     {
-3.       handle_parser_directive (&string[1]);
-2.       return 0;
-1.     }

 /*If we aren't supposed to be parsing right now, then we're done.*/

1.   if (_rl_parsing_conditionalized_out)
2.     return 0;
3.   i = 0;",Useful
"/*If this keyname is a complex key expression surrounded by quotes,
     advance to after the matching close quote.  This code allows the
     backslash to quote characters in the key expression.*/","-3.   if (_rl_parsing_conditionalized_out)
-2.     return 0;
-1.   i = 0;

 /*If this keyname is a complex key expression surrounded by quotes,
     advance to after the matching close quote.  This code allows the
     backslash to quote characters in the",Useful
/*Advance to the colon (:) or whitespace which separates the two objects.*/,"-6.       if (string[i] == '\0')
-5.         {
-4.           _rl_init_file_error (""no closing `\""' in key binding"");
-3.           return 1;
-2.         }
-1.     }

 /*Advance to the colon (:) or whitespace which separates the two objects.*/

1.   for (;",Useful
"/*If this is a command to set a variable, then do that.*/","-2.   if (equivalency)
-1.     string[i++] = '\0';

 /*If this is a command to set a variable, then do that.*/

1.   if (_rl_stricmp (string, ""set"") == 0)
2.     {
3.       char *var, *value, *e;
4.       var = string + i;",Useful
"/*Strip trailing whitespace from values to boolean variables.  Temp
	 fix until I get a real quoted-string parser here.*/","-5.       value = var;
-4.       while (*value && !whitespace (*value)) value++;
-3.       if (*value)
-2. 	*value++ = '\0';
-1.       while (*value && whitespace (*value)) value++;

 /*Strip trailing whitespace from values to boolean variables.  Temp
	 f",Useful
/*skip back to whitespace or EOS*/,"-3. 	  e = value + strlen (value) - 1;
-2. 	  while (e >= value && whitespace (*e))
-1. 	    e--;

 /*skip back to whitespace or EOS*/

1. 	  if (*e && e >= value)
2. 	    *e = '\0';
3. 	}
4.       rl_variable_bind (var, value);
5.       return 0;
6.     ",Useful
"/*This code exists to allow whitespace in macro expansions, which
     would otherwise be gobbled up by the next `for' loop.*/","-8.   for (; string[i] && whitespace (string[i]); i++);
-7.   funname = &string[i];

 /*This code exists to allow whitespace in macro expansions, which
     would otherwise be gobbled up by the next `for' loop.*/

111",Useful
"/*XXX - it may be desirable to allow backslash quoting only if "" is
     the quoted string delimiter, like the shell.*/","-10.   for (; string[i] && whitespace (string[i]); i++);
-9.   funname = &string[i];

 /*XXX - it may be desirable to allow backslash quoting only if "" is
     the quoted string delimiter, like the shell.*/

1.   if (*funname == '\'' || *funname == '""')
2",Useful
"/*If this is a new-style key-binding, then do the binding with
     rl_bind_keyseq ().  Otherwise, let the older code deal with it.*/","-4.   if (equivalency)
-3.     {
-2.       return 0;
-1.     }

 /*If this is a new-style key-binding, then do the binding with
     rl_bind_keyseq ().  Otherwise, let the older code deal with it.*/

1.   if (*string == '""')
2.     {
3.       char *seq;
4",Useful
"/*Allow backslash to quote characters, but leave them in place.
	     This allows a string to end with a backslash quoting another
	     backslash, or with a backslash quoting a double quote.  The
	     backslashes are left in place for rl_translate_keyseq ().*/","-7.   if (*string == '""')
-6.     {
-5.       char *seq;
-4.       register int j, k, passc;
-3.       seq = (char *)xmalloc (1 + strlen (string));
-2.       for (j = 1, k = passc = 0; string[j]; j++)
-1. 	{

 /*Allow backslash to quote characters, but le",Useful
/*Binding macro?*/,"-10. 	    {
-9. 	      seq[k++] = string[j];
-8. 	      passc = !passc;
-7. 	      continue;
-6. 	    }
-5. 	  if (string[j] == '""')
-4. 	    break;
-3. 	  seq[k++] = string[j];
-2. 	}
-1.       seq[k] = '\0';

 /*Binding macro?*/

1.       if (*funname =",Useful
/*Get the actual character we want to deal with.*/,"-9. 	  if (j && funname[j - 1] == *funname)
-8. 	    funname[j - 1] = '\0';
-7. 	  rl_macro_bind (seq, &funname[1], _rl_keymap);
-6. 	}
-5.       else
-4. 	rl_bind_keyseq (seq, rl_named_function (funname));
-3.       free (seq);
-2.       return 0;
-1.   ",Useful
/*Temporary.  Handle old-style keyname with macro-binding.*/,"-4.   if (substring_member_of_array (string, _rl_possible_control_prefixes))
-3.     key = CTRL (_rl_to_upper (key));
-2.   if (substring_member_of_array (string, _rl_possible_meta_prefixes))
-1.     key = META (key);

 /*Temporary.  Handle old-style keyn",Useful
/*PREFIX_META_HACK*/,"-9.   if (*funname == '\'' || *funname == '""')
-8.     {
-7.       char useq[2];
-6.       int fl = strlen (funname);
-5.       useq[0] = key; useq[1] = '\0';
-4.       if (fl && funname[fl - 1] == *funname)
-3. 	funname[fl - 1] = '\0';
-2.       rl_macro",Useful
/*VISIBLE_STATS*/,"-10.   { ""mark-modified-lines"",	&_rl_mark_modified_lines,	0 },
-9.   { ""mark-symlinked-directories"", &_rl_complete_mark_symlink_dirs, 0 },
-8.   { ""match-hidden-files"",	&_rl_match_hidden_files,	0 },
-7.   { ""meta-flag"",		&_rl_meta_flag,			0 },
-6.   { ""ou",Useful
"/*These *must* correspond to the array indices for the appropriate
   string variable.  (Though they're not used right now.)*/","-10.     _rl_enable_paren_matching (rl_blink_matching_paren);
-9.   else if (_rl_stricmp (name, ""prefer-visible-bell"") == 0)
-8.     {
-7.       if (_rl_prefer_visible_bell)
-6. 	_rl_bell_preference = VISIBLE_BELL;
-5.       else
-4. 	_rl_bell_preference ",Useful
/*Forward declarations*/,"-7. #define V_BELLSTYLE	0
-6. #define V_COMBEGIN	1
-5. #define V_EDITMODE	2
-4. #define V_ISRCHTERM	3
-3. #define V_KEYMAP	4
-2. #define	V_STRING	1
-1. #define V_INT		2

 /*Forward declarations*/

1. static int sv_bell_style PARAMS((const char *));
2. sta",Useful
"/*A boolean value that can appear in a `set variable' command is true if
   the value is null or empty, `on' (case-insenstive), or ""1"".  Any other
   values result in 0 (false).*/","-10. static int
-9. find_string_var (name)
-8.      const char *name;
-7. {
-6.   register int i;
-5.   for (i = 0; string_varlist[i].name; i++)
-4.     if (_rl_stricmp (name, string_varlist[i].name) == 0)
-3.       return i;
-2.   return -1;
-1. }

 /*A ",Useful
/*Unknown variable names return NULL.*/,"-6.   i = find_boolean_var (name);
-5.   if (i >= 0)
-4.     return (*boolean_varlist[i].value ? ""on"" : ""off"");
-3.   i = find_string_var (name);
-2.   if (i >= 0)
-1.     return (_rl_get_string_variable_value (string_varlist[i].name));

 /*Unknown variab",Useful
"/*For the time being, unknown variable names or string names without a
     handler function are simply ignored.*/","-9.   i = find_boolean_var (name);
-8.   if (i >= 0)
-7.     {
-6.       *boolean_varlist[i].value = bool_to_int (value);
-5.       if (boolean_varlist[i].flags & V_SPECIAL)
-4. 	hack_special_boolean_var (i);
-3.       return 0;
-2.     }
-1.   i = find_s",Useful
/*VI_MODE*/,"-10. int
-9. rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
-8.      const char *keyseq;
-7.      rl_command_func_t *default_func;
-6.      Keymap kmap;
-5. {
-4.   rl_command_func_t *func;
-3.   if (keyseq)
-2.     {
-1.       func = rl_fu",Useful
/*The value starts at v + beg.  Translate it into a character string.*/,"-10.       delim = v[0];
-9.       for (beg = end = 1; v[end] && v[end] != delim; end++)
-8. 	;
-7.     }
-6.   else
-5.     {
-4.       for (beg = end = 0; whitespace (v[end]) == 0; end++)
-3. 	;
-2.     }
-1.   v[end] = '\0';

 /*The value starts at v +",Useful
"/*Return the character which matches NAME.
   For example, `Space' returns ' '.*/","-6.   _rl_isearch_terminators = (char *)xmalloc (2 * strlen (v) + 1);
-5.   rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
-4.   _rl_isearch_terminators[end] = '\0';
-3.   free (v);
-2.   return 0;
-1. }

 /*Return the character which match",Useful
/*XXX was return (*name)*/,"-10.   { (char *)0x0, 0 }
-9. };
-8. static int
-7. glean_key_from_name (name)
-6.      char *name;
-5. {
-4.   register int i;
-3.   for (i = 0; name_key_alist[i].name; i++)
-2.     if (_rl_stricmp (name, name_key_alist[i].name) == 0)
-1.       return (n",Useful
/*VI_MODE*/,"-10. int
-9. rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
-8.      const char *keyseq;
-7.      rl_command_func_t *default_func;
-6.      Keymap kmap;
-5. {
-4.   rl_command_func_t *func;
-3.   if (keyseq)
-2.     {
-1.       func = rl_fu",Useful
/*VI_MODE*/,"-10. int
-9. rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
-8.      const char *keyseq;
-7.      rl_command_func_t *default_func;
-6.      Keymap kmap;
-5. {
-4.   rl_command_func_t *func;
-3.   if (keyseq)
-2.     {
-1.       func = rl_fu",Useful
/*VI_MODE*/,"-10. int
-9. rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)
-8.      const char *keyseq;
-7.      rl_command_func_t *default_func;
-6.      Keymap kmap;
-5. {
-4.   rl_command_func_t *func;
-3.   if (keyseq)
-2.     {
-1.       func = rl_fu",Useful
/*Key Binding and Function Information*/,"-5.   else
-4.     return ""none"";
-3. }

 /*Key Binding and Function Information*/

111",Useful
"/*Each of the following functions produces information about the
   state of keybindings and functions known to Readline.  The info
   is always printed to rl_outstream, and in such a way that it can
   be read back in (i.e., passed to rl_parse_and_bind ()).*/","-8.   else
-7.     return ""none"";
-6. }

 /*Each of the following functions produces information about the
   state of keybindings and functions known to Readline.  The info
   is always printed to rl_outstream, and in such a way that it can
   be read ba",Useful
/*Print the names of functions known to Readline.*/,"-10. }

 /*Print the names of functions known to Readline.*/

1. void
2. rl_list_funmap_names ()
3. {
4.   register int i;
5.   const char **funmap_names;
6.   funmap_names = rl_funmap_names ();
7.   if (!funmap_names)
8.     return;
9.   for (i = 0; funm",Useful
"/*Since this is going to be used to write out keysequence-function
     pairs for possible inclusion in an inputrc file, we don't want to
     do any special meta processing on KEY.*/","-10.   free (funmap_names);
-9. }
-8. static char *
-7. _rl_get_keyname (key)
-6.      int key;
-5. {
-4.   char *keyname;
-3.   int i, c;
-2.   keyname = (char *)xmalloc (8);
-1.   c = key;

 /*Since this is going to be used to write out keysequence-func",Useful
/*XXX - Experimental*/,"-1. #if 1

 /*XXX - Experimental*/

111",Useful
"/*We might want to do this, but the old version of the code did not.*/","-2. #if 1

 /*We might want to do this, but the old version of the code did not.*/

111",Useful
"/*Now add special prefixes needed for control characters.  This can
     potentially change C.*/","-10.   if (key == RUBOUT)
-9.     {
-8.       keyname[0] = '\\';
-7.       keyname[1] = 'C';
-6.       keyname[2] = '-';
-5.       keyname[3] = '?';
-4.       keyname[4] = '\0';
-3.       return keyname;
-2.     }
-1.   i = 0;

 /*Now add special prefixes",Useful
"/*XXX experimental code.  Turn the characters that are not ASCII or
     ISO Latin 1 (128 - 159) into octal escape sequences (\200 - \237).
     This changes C.*/","-7.   if (CTRL_CHAR (c))
-6.     {
-5.       keyname[i++] = '\\';
-4.       keyname[i++] = 'C';
-3.       keyname[i++] = '-';
-2.       c = _rl_to_lower (UNCTRL (c));
-1.     }

 /*XXX experimental code.  Turn the characters that are not ASCII or
     ISO",Useful
"/*Now add the key, terminate the string, and return it.*/","-2.   if (c == '\\' || c == '""')
-1.     keyname[i++] = '\\';

 /*Now add the key, terminate the string, and return it.*/

1.   keyname[i++] = (char) c;
2.   keyname[i] = '\0';
3.   return keyname;
4. }",Useful
"/*Return a NULL terminated array of strings which represent the key
   sequences that are used to invoke FUNCTION in MAP.*/","-4.   keyname[i++] = (char) c;
-3.   keyname[i] = '\0';
-2.   return keyname;
-1. }

 /*Return a NULL terminated array of strings which represent the key
   sequences that are used to invoke FUNCTION in MAP.*/

1. char **
2. rl_invoking_keyseqs_in_map (fu",Useful
"/*Macros match, if, and only if, the pointers are identical.
	     Thus, they are treated exactly like functions in here.*/","-10.   register int key;
-9.   char **result;
-8.   int result_index, result_size;
-7.   result = (char **)NULL;
-6.   result_index = result_size = 0;
-5.   for (key = 0; key < KEYMAP_SIZE; key++)
-4.     {
-3.       switch (map[key].type)
-2. 	{
-1. 	cas",Useful
"/*Return a NULL terminated array of strings which represent the key
   sequences that can be used to invoke FUNCTION using the current keymap.*/","-10. 		result[result_index++] = keyname;
-9. 		result[result_index] = (char *)NULL;
-8. 	      }
-7. 	    free (seqs);
-6. 	  }
-5. 	  break;
-4. 	}
-3.     }
-2.   return (result);
-1. }

 /*Return a NULL terminated array of strings which represent the k",Useful
"/*Print all of the functions and their bindings to rl_outstream.  If
   PRINT_READABLY is non-zero, then print the output in such a way
   that it can be read back in.*/","-6. char **
-5. rl_invoking_keyseqs (function)
-4.      rl_command_func_t *function;
-3. {
-2.   return (rl_invoking_keyseqs_in_map (function, _rl_keymap));
-1. }

 /*Print all of the functions and their bindings to rl_outstream.  If
   PRINT_READABLY is ",Useful
"/*Print all of the current functions and their bindings to
   rl_outstream.  If an explicit argument is given, then print
   the output in such a way that it can be read back in.*/","-10. 		}
-9. 	      if (j == 5 && invokers[j])
-8. 		fprintf (rl_outstream, ""...\n"");
-7. 	      for (j = 0; invokers[j]; j++)
-6. 		free (invokers[j]);
-5. 	      free (invokers);
-4. 	    }
-3. 	}
-2.     }
-1. }

 /*Print all of the current functions a",Useful
/*_rl_isearch_terminators can be NULL*/,"-10.       if (print_readably)
-9.         fprintf (rl_outstream, ""set %s %s\n"", boolean_varlist[i].name,
-8. 			       *boolean_varlist[i].value ? ""on"" : ""off"");
-7.       else
-6.         fprintf (rl_outstream, ""%s is set to `%s'\n"", boolean_varlist[i].",Useful
"/*Print all of the current variables and their values to
   rl_outstream.  If an explicit argument is given, then print
   the output in such a way that it can be read back in.*/","-7. 	continue;
-6.       if (print_readably)
-5.         fprintf (rl_outstream, ""set %s %s\n"", string_varlist[i].name, v);
-4.       else
-3.         fprintf (rl_outstream, ""%s is set to `%s'\n"", string_varlist[i].name, v);
-2.     }
-1. }

 /*Print all o",Useful
/*Return non-zero if any members of ARRAY are a substring in STRING.*/,"-10. int
-9. rl_dump_variables (count, key)
-8.      int count __attribute__((unused)), key __attribute__((unused));
-7. {
-6.   if (rl_dispatching)
-5.     fprintf (rl_outstream, ""\r\n"");
-4.   rl_variable_dumper (rl_explicit_arg);
-3.   rl_on_new_line (",Useful
/*mbutil.c -- readline multibyte character utility functions*/,"
/* mbutil.c -- readline multibyte character utility functions */


 /*mbutil.c -- readline multibyte character utility functions*/

1. /* Copyright (C) 2001-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
/*for _POSIX_VERSION*/,"-10.    have a copy of the license, write to the Free Software Foundation,
-9.    51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA. */
-8. #define READLINE_LIBRARY
-7. #if defined (HAVE_CONFIG_H)
-6. #  include ""config_readline.h""
-5. #endif
-",Useful
/*HAVE_UNISTD_H*/,"-10.    is generally kept in a file called COPYING or LICENSE.  If you do not
-9.    have a copy of the license, write to the Free Software Foundation,
-8.    51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA. */
-7. #define READLINE_LIBRARY
-6",Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



 /*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Useful
/*System-specific feature definitions and include files.*/,"-2. #include <stdio.h>
-1. #include <ctype.h>

 /*System-specific feature definitions and include files.*/

1. #include ""rldefs.h""
2. #include ""rlmbutil.h""
3. #if defined (TIOCSTAT_IN_SYS_IOCTL)
4. #  include <sys/ioctl.h>",Useful
/*TIOCSTAT_IN_SYS_IOCTL*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""
#if defined (TIOCSTAT_IN_SYS_IOCTL)

 /*TIOCSTAT_IN_SYS_IOCTL*/

1. #  include <sys/ioctl.h>",Useful
/*Some standard library routines.*/,"-5. #include ""rldefs.h""
-4. #include ""rlmbutil.h""
-3. #if defined (TIOCSTAT_IN_SYS_IOCTL)
-2. #  include <sys/ioctl.h>

 /*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""rlprivate.h""
3. #include ""xmalloc.h""",Useful
"/*Declared here so it can be shared between the readline and history
   libraries.*/","-3. #include ""readline.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

 /*Declared here so it can be shared between the readline and history
   libraries.*/

1. #if defined (HANDLE_MULTIBYTE)
2. int rl_byte_oriented = 0;
3. #else
4. int rl_byte_or",Useful
/*invalid bytes. asume a byte represents a character*/,"-7.   if (seed < point)
-6.     count--;
-5.   while (count > 0)  
-4.     {
-3.       tmp = mbrtowc (&wc, string+point, strlen(string + point), &ps);
-2.       if (MB_INVALIDCH ((size_t)tmp))
-1. 	{

 /*invalid bytes. asume a byte represents a character*",Useful
/*found wide '\0'*/,"-3. 	  memset(&ps, 0, sizeof(mbstate_t));
-2. 	}
-1.       else if (MB_NULLWCH (tmp))

 /*found wide '\0'*/

1.       else
2. 	{",Useful
/*valid bytes*/,"-7.   if (seed < point)
-6.     count--;
-5.   while (count > 0)  
-4.     {
-3.       tmp = mbrtowc (&wc, string+point, strlen(string + point), &ps);
-2.       if (MB_INVALIDCH ((size_t)tmp))
-1. 	{

 /*valid bytes*/

1. 	  point++;
2. 	  count--;",Useful
"/*in this case, bytes are invalid or shorted to compose
	     multibyte char, so assume that the first byte represents
	     a single character anyway.*/","-10.   if (seed < 0)
-9.     return 0;
-8.   else if (length < seed)
-7.     return length;
-6.   prev = non_zero_prev = point = 0;
-5.   while (point < seed)
-4.     {
-3.       tmp = mbrtowc (&wc, string + point, length - point, &ps);
-2.       if (MB_I",Useful
"/*Since we're assuming that this byte represents a single
	     non-zero-width character, don't forget about it.*/","-1. 	  memset(&ps, 0, sizeof (mbstate_t));

 /*Since we're assuming that this byte represents a single
	     non-zero-width character, don't forget about it.*/

1. 	  prev = point;
2. 	}
3.       else if (MB_NULLWCH (tmp))",Useful
/*Found '\0' char.  Can this happen?*/,"-3. 	  prev = point;
-2. 	}
-1.       else if (MB_NULLWCH (tmp))

 /*Found '\0' char.  Can this happen?*/

1.       else
2. 	{
3. 	  if (find_non_zero)
4. 	    {
5. 	      if (wcwidth (wc) != 0)
6. 		prev = point;
7. 	    }
8. 	  else
9. 	    prev = point",Useful
"/*return the number of bytes parsed from the multibyte sequence starting
   at src, if a non-L'\0' wide character was recognized. It returns 0, 
   if a L'\0' wide character was recognized. It  returns (size_t)(-1), 
   if an invalid multibyte sequence was encountered. It returns (size_t)(-2) 
   if it couldn't parse a complete  multibyte character.*/","-10. 	      if (wcwidth (wc) != 0)
-9. 		prev = point;
-8. 	    }
-7. 	  else
-6. 	    prev = point;  
-5. 	}
-4.       point += tmp;
-3.     }
-2.   return prev;
-1. }

 /*return the number of bytes parsed from the multibyte sequence starting
   at src, ",Useful
/*shorted to compose multibyte char*/,"-10.    if it couldn't parse a complete  multibyte character.  */
-9. int
-8. _rl_get_char_len (src, ps)
-7.      char *src;
-6.      mbstate_t *ps;
-5. {
-4.   size_t tmp;
-3.   tmp = mbrlen((const char *)src, (size_t)strlen (src), ps);
-2.   if (tmp == ",Useful
/*invalid to compose multibyte char*/,"-6.       if (ps)
-5. 	memset (ps, 0, sizeof(mbstate_t));
-4.       return -2;
-3.     }
-2.   else if (tmp == (size_t)(-1))
-1.     {

 /*invalid to compose multibyte char*/

111",Useful
/*initialize the conversion state*/,"-7.       if (ps)
-6. 	memset (ps, 0, sizeof(mbstate_t));
-5.       return -2;
-4.     }
-3.   else if (tmp == (size_t)(-1))
-2.     {

 /*initialize the conversion state*/

1.       if (ps)
2. 	memset (ps, 0, sizeof(mbstate_t));
3.       return -1;
4.   ",Useful
"/*compare the specified two characters. If the characters matched,
   return 1. Otherwise return 0.*/","-9.       if (ps)
-8. 	memset (ps, 0, sizeof(mbstate_t));
-7.       return -1;
-6.     }
-5.   else if (tmp == (size_t)0)
-4.     return 0;
-3.   else
-2.     return (int)tmp;
-1. }

 /*compare the specified two characters. If the characters matched,
   r",Useful
"/*adjust pointed byte and find mbstate of the point of string.
   adjusted point will be point <= adjusted_point, and returns
   differences of the byte(adjusted_point - point).
   if point is invalied (point < 0 || more than string length),
   it returns -1*/","-10.   if ((w1 = _rl_get_char_len (&buf1[pos1], ps1)) <= 0 || 
-9. 	(w2 = _rl_get_char_len (&buf2[pos2], ps2)) <= 0 ||
-8. 	(w1 != w2) ||
-7. 	(buf1[pos1] != buf2[pos2]))
-6.     return 0;
-5.   for (i = 1; i < w1; i++)
-4.     if (buf1[pos1+i] != buf2[po",Useful
"/*in this case, bytes are invalid or shorted to compose
	     multibyte char, so assume that the first byte represents
	     a single character anyway.*/","-10.   if (seed < 0)
-9.     return 0;
-8.   else if (length < seed)
-7.     return length;
-6.   prev = non_zero_prev = point = 0;
-5.   while (point < seed)
-4.     {
-3.       tmp = mbrtowc (&wc, string + point, length - point, &ps);
-2.       if (MB_I",Useful
/*HANDLE_MULTIBYTE*/,"
#if defined (HANDLE_MULTIBYTE)



 /*HANDLE_MULTIBYTE*/

1. int rl_byte_oriented = 0;
2. #else
3. int rl_byte_oriented = 1;
4. #endif",Useful
/*keymaps.c -- Functions and keymaps for the GNU Readline library.*/,"
/* keymaps.c -- Functions and keymaps for the GNU Readline library. */


 /*keymaps.c -- Functions and keymaps for the GNU Readline library.*/

1. /* Copyright (C) 1988,1989 Free Software Foundation, Inc.
2.    This file is part of GNU Readline, a library for reading lines
3.    of text with interactive input and history editing.
4.    Readline is free software; you can redistribute it and/or modify it
5.    under the terms of the GNU General Public License as published by the
6.    Free Software Foundation; either version 2, or (at your option) any
7.    later version.
8.    Readline is distributed in the hope that it will be useful, but
9.    WITHOUT ANY WARRANTY; without even the implied warranty of
10.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU",Useful
/*HAVE_STDLIB_H*/,"-10.    WITHOUT ANY WARRANTY; without even the implied warranty of
-9.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-8.    General Public License for more details.
-7.    You should have received a copy of the GNU General Public Li",Useful
/*for FILE * definition for readline.h*/,"-10.    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA. */
-9. #define READLINE_LIBRARY
-8. #if defined (HAVE_CONFIG_H)
-7. #  include ""config_readline.h""
-6. #endif
-5. #if defined (HAVE_STDLIB_H)
-4. #  include <stdlib",Useful
"/*Return a new, empty keymap.
   Free it with free() when you are done.*/","-10. #include ""emacs_keymap.c""
-9. #if defined (VI_MODE)
-8. #include ""vi_keymap.c""
-7. #endif
-6. #include ""xmalloc.h""

 /*Return a new, empty keymap.
   Free it with free() when you are done.*/

1. Keymap
2. rl_make_bare_keymap ()
3. {
4.   register int",Useful
/*Return a new keymap which is a copy of MAP.*/,"-10.     }
-9. #if 0
-8.   for (i = 'A'; i < ('Z' + 1); i++)
-7.     {
-6.       keymap[i].type = ISFUNC;
-5.       keymap[i].function = rl_do_lowercase_version;
-4.     }
-3. #endif
-2.   return (keymap);
-1. }

 /*Return a new keymap which is a copy of ",Useful
"/*Return a new keymap with the printing characters bound to rl_insert,
   the uppercase Meta characters bound to run their lowercase equivalents,
   and the Meta digits bound to produce numeric arguments.*/","-10.   register int i;
-9.   Keymap temp;
-8.   temp = rl_make_bare_keymap ();
-7.   for (i = 0; i < KEYMAP_SIZE; i++)
-6.     {
-5.       temp[i].type = map[i].type;
-4.       temp[i].function = map[i].function;
-3.     }
-2.   return (temp);
-1. }

 /*R",Useful
/*All ASCII printing characters are self-inserting.*/,"-6. Keymap
-5. rl_make_keymap ()
-4. {
-3.   register int i;
-2.   Keymap newmap;
-1.   newmap = rl_make_bare_keymap ();

 /*All ASCII printing characters are self-inserting.*/

1.   for (i = ' '; i < 127; i++)
2.     newmap[i].function = rl_insert;
3.   ",Useful
/*Printing characters in ISO Latin-1 and some 8-bit character sets.*/,"-2.   newmap[CTRL('H')].function = rl_rubout;
-1. #if KEYMAP_SIZE > 128

 /*Printing characters in ISO Latin-1 and some 8-bit character sets.*/

1.   for (i = 128; i < 256; i++)
2.     newmap[i].function = rl_insert;",Useful
/*KEYMAP_SIZE > 128*/,"-1.   newmap[CTRL('H')].function = rl_rubout;
#if KEYMAP_SIZE > 128

 /*KEYMAP_SIZE > 128*/

111",Useful
/*Free the storage associated with MAP.*/,"-2.   return (newmap);
-1. }

 /*Free the storage associated with MAP.*/

1. void
2. rl_discard_keymap (map)
3.      Keymap map;
4. {
5.   int i;
6.   if (!map)
7.     return;
8.   for (i = 0; i < KEYMAP_SIZE; i++)
9.     {
10.       switch (map[i].type)",Useful
"/*readline.c -- a general facility for reading lines of input
   with emacs style editing and completion.*/","
/* readline.c -- a general facility for reading lines of input
   with emacs style editing and completion. */


 /*readline.c -- a general facility for reading lines of input
   with emacs style editing and completion.*/

1. /* Copyright (C) 1987, 1989, 1992, 2006 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
/*for _POSIX_VERSION*/,"-10.    The GNU General Public License is often shipped with GNU software, and
-9.    is generally kept in a file called COPYING or LICENSE.  If you do not
-8.    have a copy of the license, write to the Free Software Foundation,
-7.    51 Franklin Street",Useful
/*HAVE_UNISTD_H*/,"-10.    GNU General Public License for more details.
-9.    The GNU General Public License is often shipped with GNU software, and
-8.    is generally kept in a file called COPYING or LICENSE.  If you do not
-7.    have a copy of the license, write to the",Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



 /*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Useful
/*System-specific feature definitions and include files.*/,"-1. #include <stdio.h>

 /*System-specific feature definitions and include files.*/

1. #include ""rldefs.h""",Useful
/*Some standard library routines.*/,"-1. #include ""rldefs.h""

 /*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #include ""xmalloc.h""
5. extern void replace_history_data PARAMS((int, histdata_t *, histdata_t *));",Useful
"/*Non-zero tells rl_delete_text and rl_insert_text to not add to
   the undo list.*/","-5. #include ""readline.h""
-4. #include ""history.h""
-3. #include ""rlprivate.h""
-2. #include ""xmalloc.h""
-1. extern void replace_history_data PARAMS((int, histdata_t *, histdata_t *));

 /*Non-zero tells rl_delete_text and rl_insert_text to not add to
   th",Useful
/*How many unclosed undo groups we currently have.*/,"-1. int _rl_doing_an_undo = 0;

 /*How many unclosed undo groups we currently have.*/

1. int _rl_undo_group_level = 0;",Useful
"/*Remember how to undo something.  Concatenate some undos if that
   seems right.*/","-10. {
-9.   UNDO_LIST *temp;
-8.   temp = (UNDO_LIST *)xmalloc (sizeof (UNDO_LIST));
-7.   temp->what = what;
-6.   temp->start = start;
-5.   temp->end = end;
-4.   temp->text = text;
-3.   temp->next = (UNDO_LIST *)NULL;
-2.   return temp;
-1. }

 /*Re",Useful
/*Free the existing undo list.*/,"-10. rl_add_undo (what, start, end, text)
-9.      enum undo_code what;
-8.      int start, end;
-7.      char *text;
-6. {
-5.   UNDO_LIST *temp;
-4.   temp = alloc_undo_entry (what, start, end, text);
-3.   temp->next = rl_undo_list;
-2.   rl_undo_list ",Useful
"/*Undo the next thing in the list.  Return 0 if there
   is nothing to undo, or non-zero if there was.*/","-10.       else
-9. 	{
-8. 	  roving->next = c;
-7. 	  roving = roving->next;
-6. 	}
-5.       list = list->next;
-4.     }
-3.   roving->next = 0;
-2.   return new;
-1. }

 /*Undo the next thing in the list.  Return 0 if there
   is nothing to undo, or n",Useful
"/*To better support vi-mode, a start or end value of -1 means
	 rl_point, and a value of -2 means rl_end.*/","-10.   UNDO_LIST *release;
-9.   int waiting_for_begin, start, end;
-8. #define TRANS(i) ((i) == -1 ? rl_point : ((i) == -2 ? rl_end : (i)))
-7.   start = end = waiting_for_begin = 0;
-6.   do
-5.     {
-4.       if (!rl_undo_list)
-3. 	return (0);
-2.   ",Useful
/*Undoing deletes means inserting some text.*/,"-7.       if (rl_undo_list->what == UNDO_DELETE || rl_undo_list->what == UNDO_INSERT)
-6. 	{
-5. 	  start = TRANS (rl_undo_list->start);
-4. 	  end = TRANS (rl_undo_list->end);
-3. 	}
-2.       switch (rl_undo_list->what)
-1. 	{

 /*Undoing deletes means ",Useful
/*Undoing inserts means deleting some text.*/,"-5. 	case UNDO_DELETE:
-4. 	  rl_point = start;
-3. 	  rl_insert_text (rl_undo_list->text);
-2. 	  free (rl_undo_list->text);
-1. 	  break;

 /*Undoing inserts means deleting some text.*/

1. 	case UNDO_INSERT:
2. 	  rl_delete_text (start, end);
3. 	  rl_",Useful
/*Undoing an END means undoing everything 'til we get to a BEGIN.*/,"-4. 	case UNDO_INSERT:
-3. 	  rl_delete_text (start, end);
-2. 	  rl_point = start;
-1. 	  break;

 /*Undoing an END means undoing everything 'til we get to a BEGIN.*/

1. 	case UNDO_END:
2. 	  waiting_for_begin++;
3. 	  break;",Useful
/*Undoing a BEGIN means that we are done with this group.*/,"-3. 	case UNDO_END:
-2. 	  waiting_for_begin++;
-1. 	  break;

 /*Undoing a BEGIN means that we are done with this group.*/

1. 	case UNDO_BEGIN:
2. 	  if (waiting_for_begin)
3. 	    waiting_for_begin--;
4. 	  else
5. 	    rl_ding ();
6. 	  break;
7. 	}
8",Useful
/*Save an undo entry for the text from START to END.*/,"-7. int
-6. rl_end_undo_group ()
-5. {
-4.   rl_add_undo (UNDO_END, 0, 0, 0);
-3.   _rl_undo_group_level--;
-2.   return 0;
-1. }

 /*Save an undo entry for the text from START to END.*/

1. int
2. rl_modifying (start, end)
3.      int start, end;
4. {
5.",Useful
/*rl_end should be set correctly*/,"-10.      int count __attribute__((unused)), key __attribute__((unused));
-9. {
-8.   if (!rl_undo_list)
-7.     rl_ding ();
-6.   else
-5.     {
-4.       while (rl_undo_list)
-3. 	rl_do_undo ();
-2. #if defined (VI_MODE)
-1.       if (rl_editing_mode ==",Useful
/*Nothing to do.*/,"-5. int
-4. rl_undo_command (count, key)
-3.      int count, key __attribute__((unused));
-2. {
-1.   if (count < 0)

 /*Nothing to do.*/

1.   while (count)
2.     {
3.       if (rl_do_undo ())
4. 	count--;
5.       else
6. 	{
7. 	  rl_ding ();
8. 	  bre",Useful
/*Just for NULL.  Yuck.*/,"-10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-9.    GNU General Public License for more details.
-8.    The GNU General Public License is often shipped with GNU software, and
-7.    is generally kept in a file called COPYING or",Useful
/*System-specific feature definitions and include files.*/,"-5. #include <sys/types.h>
-4. #include <signal.h>
-3. #if defined (HAVE_UNISTD_H)
-2. #  include <unistd.h>

 /*System-specific feature definitions and include files.*/

1. #include ""rldefs.h""
2. #if defined (GWINSZ_IN_SYS_IOCTL)
3. #  include <sys/ioctl",Useful
/*Some standard library routines.*/,"-1. #if defined (HANDLE_SIGNALS)

 /*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""history.h""
3. #include ""rlprivate.h""
4. #if !defined (RETSIGTYPE)
5. #  if defined (VOID_SIGHANDLER)
6. #    define RETSIGTYPE void
7. #  else
8.",Useful
"/*If non-zero, readline will install its own signal handlers for
   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU.*/","-6. #ifndef SA_RESTART
-5. #  define SA_RESTART 0
-4. #endif
-3. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-2. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

 /*If non-zero, re",Useful
"/*If non-zero, readline will install a signal handler for SIGWINCH.*/","-1. int rl_catch_signals = 1;

 /*If non-zero, readline will install a signal handler for SIGWINCH.*/

1. #ifdef SIGWINCH
2. int rl_catch_sigwinch = 1;
3. #else",Useful
/*for the readline state struct in readline.c*/,"-3. #ifdef SIGWINCH
-2. int rl_catch_sigwinch = 1;
-1. #else

 /*for the readline state struct in readline.c*/

1. #endif
2. static int signals_set_flag;
3. static int sigwinch_set_flag;",Useful
/*needed for rl_set_sighandler call*/,"-3. #  if defined (HAVE_BSD_SIGNALS)
-2.   long omask;

 /*needed for rl_set_sighandler call*/

111",Useful
"/*Since the signal will not be blocked while we are in the signal
     handler, ignore it until rl_clear_signals resets the catcher.*/","-2.   RL_SETSTATE(RL_STATE_SIGHANDLER);
-1. #if !defined (HAVE_BSD_SIGNALS) && !defined (HAVE_POSIX_SIGNALS)

 /*Since the signal will not be blocked while we are in the signal
     handler, ignore it until rl_clear_signals resets the catcher.*/

1. #  if",Useful
/*assume we have raise*/,"-6. #if defined (__EMX__)
-5.       signal (sig, SIG_ACK);
-4. #endif
-3. #if defined (HAVE_KILL)
-2.       kill (getpid (), sig);
-1. #else

 /*assume we have raise*/

1. #endif",Useful
/*Let the signal that we just sent through.*/,"-1. #endif

 /*Let the signal that we just sent through.*/

1. #if defined (HAVE_POSIX_SIGNALS)
2.       sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL);",Useful
"/*If another sigwinch handler has been installed, call it.*/","-4.   rl_set_sighandler (SIGWINCH, rl_sigwinch_handler, &dummy_winch);
-3. #endif
-2.   RL_SETSTATE(RL_STATE_SIGHANDLER);
-1.   rl_resize_terminal ();

 /*If another sigwinch handler has been installed, call it.*/

1.   oh = (SigHandler *)old_winch.sa_han",Useful
/*Functions to manage signal handling.*/,"-7.   oh = (SigHandler *)old_winch.sa_handler;
-6.   if (oh &&  oh != (SigHandler *)SIG_IGN && oh != (SigHandler *)SIG_DFL)
-5.     (*oh) (sig);
-4.   RL_UNSETSTATE(RL_STATE_SIGHANDLER);
-3.   SIGHANDLER_RETURN;
-2. }

 /*Functions to manage signal handli",Useful
"/*Set up a readline-specific signal handler, saving the old signal
   information in OHANDLER.  Return the old signal handler, like
   signal().*/","-10. #if !defined (HAVE_POSIX_SIGNALS)
-9. static int
-8. rl_sigaction (sig, nh, oh)
-7.      int sig;
-6.      sighandler_cxt *nh, *oh;
-5. {
-4.   oh->sa_handler = signal (sig, nh->sa_handler);
-3.   return 0;
-2. }

 /*Set up a readline-specific signal",Useful
/*XXX -- assume we have memcpy*/,"-10. #if defined (HAVE_POSIX_SIGNALS)
-9.   struct sigaction act;
-8.   act.sa_handler = handler;
-7.   act.sa_flags = (sig == SIGWINCH) ? SA_RESTART : 0;
-6.   sigemptyset (&act.sa_mask);
-5.   sigemptyset (&ohandler->sa_mask);
-4.   sigaction (sig, &act",Useful
"/*If rl_set_signals is called twice in a row, don't set the old handler to
     rl_signal_handler, because that would cause infinite recursion.*/","-10.   struct sigaction act;
-9.   act.sa_handler = handler;
-8.   act.sa_flags = (sig == SIGWINCH) ? SA_RESTART : 0;
-7.   sigemptyset (&act.sa_mask);
-6.   sigemptyset (&ohandler->sa_mask);
-5.   sigaction (sig, &act, &old_handler);
-4. #else
-3.   old_",Useful
"/*If the application using readline has already installed a signal
	 handler with SA_RESTART, SIGALRM will cause reads to be restarted
	 automatically, so readline should just get out of the way.  Since
	 we tested for SIG_IGN above, we can just test for SIG_DFL here.*/","-10.       rl_maybe_set_sighandler (SIGINT, rl_signal_handler, &old_int);
-9.       rl_maybe_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
-8. #if defined (SIGQUIT)
-7.       rl_maybe_set_sighandler (SIGQUIT, rl_signal_handler, &old_quit);
-6. #",Useful
"/*If non-zero, we write timestamps to the history file in history_do_write()*/","-4. #include ""history.h""
-3. #include ""histlib.h""
-2. #include ""rlshell.h""
-1. #include ""xmalloc.h""

 /*If non-zero, we write timestamps to the history file in history_do_write()*/

1. int history_write_timestamps = 0;",Useful
"/*Return the string that should be used in the place of this
   filename.  This only matters when you don't specify the
   filename to read_history (), or write_history ().*/","-1. #define HIST_TIMESTAMP_START(s)		(*(s) == history_comment_char)

 /*Return the string that should be used in the place of this
   filename.  This only matters when you don't specify the
   filename to read_history (), or write_history ().*/

1. static",Useful
"/*Add the contents of FILENAME to the history list, a line at a time.
   If FILENAME is NULL, then read from ~/.history.  Returns 0 if
   successful, or errno if not.*/","-9.   strcpy (return_val, home);
-8.   return_val[home_len] = '/';
-7. #if defined (__MSDOS__)
-6.   strcpy (return_val + home_len + 1, ""_history"");
-5. #else
-4.   strcpy (return_val + home_len + 1, "".history"");
-3. #endif
-2.   return (return_val);
-1. ",Useful
"/*Read a range of lines from FILENAME, adding them to the history list.
   Start reading at the FROM'th line and end at the TO'th.  If FROM
   is zero, start at the beginning.  If TO is less than FROM, read
   until the end of the file.  If FILENAME is NULL, then read from
   ~/.history.  Returns 0 if successful, or errno if not.*/","-6. int
-5. read_history (filename)
-4.      const char *filename;
-3. {
-2.   return (read_history_range (filename, 0, -1));
-1. }

 /*Read a range of lines from FILENAME, adding them to the history list.
   Start reading at the FROM'th line and end at t",Useful
"/*We map read/write and private so we can change newlines to NULs without
     affecting the underlying object.*/","-7.   if ((sizeof(off_t) > sizeof(size_t) && finfo.st_size > (off_t)(size_t)~0) ||  
-6.     file_size + 1 < file_size)
-5.     {
-4.       errno = overflow_errno;
-3.       goto error_and_exit;
-2.     }
-1. #ifdef HISTORY_USE_MMAP

 /*We map read/write ",Useful
"/*Start at beginning of file, work to end.*/","-2.   if (to < 0)
-1.     to = chars_read;

 /*Start at beginning of file, work to end.*/

1.   bufend = buffer + chars_read;
2.   current_line = 0;",Useful
/*Skip lines until we are at FROM.*/,"-2.   bufend = buffer + chars_read;
-1.   current_line = 0;

 /*Skip lines until we are at FROM.*/

1.   for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
2.     if (*line_end == '\n')
3.       {
4.       	p = line",Useful
"/*If we see something we think is a timestamp, continue with this
	   line.  We should check more extensively here...*/","-4.   for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
-3.     if (*line_end == '\n')
-2.       {
-1.       	p = line_end + 1;

 /*If we see something we think is a timestamp, continue with this
	   line.  We shou",Useful
"/*If there are lines left to gobble, then gobble them now.*/","-4. 	if (HIST_TIMESTAMP_START(p) == 0)
-3. 	  current_line++;
-2. 	line_start = p;
-1.       }

 /*If there are lines left to gobble, then gobble them now.*/

1.   for (line_end = line_start; line_end < bufend; line_end++)
2.     if (*line_end == '\n')
3.",Useful
/*Change to allow Windows-like \r\n end of line delimiter.*/,"-3.   for (line_end = line_start; line_end < bufend; line_end++)
-2.     if (*line_end == '\n')
-1.       {

 /*Change to allow Windows-like \r\n end of line delimiter.*/

1. 	if (line_end > line_start && line_end[-1] == '\r')
2. 	  line_end[-1] = '\0';
3",Useful
"/*Truncate the history file FNAME, leaving only LINES trailing lines.
   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
   on failure.*/","-10. 	line_start = line_end + 1;
-9.       }
-8.   FREE (input);
-7. #ifndef HISTORY_USE_MMAP
-6.   FREE (buffer);
-5. #else
-4.   munmap (buffer, file_size);
-3. #endif
-2.   return (0);
-1. }

 /*Truncate the history file FNAME, leaving only LINES trail",Useful
/*Don't try to truncate non-regular files.*/,"-8.   int file, chars_read, rv;
-7.   struct stat finfo;
-6.   size_t file_size;
-5.   size_t bytes_written;
-4.   buffer = (char *)NULL;
-3.   filename = history_filename (fname);
-2.   file = open (filename, O_RDONLY|O_BINARY, 0666);
-1.   rv = 0;

 /*D",Useful
"/*If this is the first line, then the file contains exactly the
     number of lines we want to truncate to, so we don't need to do
     anything.  It's the first line if we don't find a newline between
     the current value of i and 0.  Otherwise, write from the start of
     this line until the end of the buffer.*/","-6.   for (bp1 = bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
-5.     {
-4.       if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
-3. 	lines--;
-2.       bp1 = bp;
-1.     }

 /*If this is the first line, then the file contains exactly the",Useful
"/*Write only if there are more lines in the file than we want to
     truncate to.*/","-10.      this line until the end of the buffer. */
-9.   for ( ; bp > buffer; bp--)
-8.     {
-7.       if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
-6.         {
-5. 	  bp++;
-4. 	  break;
-3.         }
-2.       bp1 = bp;
-1.     }

 /*Write only",Useful
/*BeOS ignores O_TRUNC.*/,"-5.   if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
-4.     {
-3.       bytes_written= write (file, bp, chars_read - (bp - buffer));
-2.       (void) bytes_written;
-1. #if defined (__BEOS__)

 /*BeOS ignores O_TRUN",Useful
"/*Build a buffer of all the lines to write, and write them in one syscall.
     Suggested by Peter Ho (peter@robosts.oxford.ac.uk).*/","-10.   if ((file = open (output, mode, 0600)) == -1)
-9.     {
-8.       FREE (output);
-7.       return (errno);
-6.     }
-5. #ifdef HISTORY_USE_MMAP
-4.   cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);
-3. #endif
-2.   if (nelements > history_len",Useful
"/*Overwrite FILENAME with the current history.  If FILENAME is NULL,
   then write the history list to ~/.history.  Values returned
   are as in read_history ().*/","-7. int
-6. append_history (nelements, filename)
-5.      int nelements;
-4.      const char *filename;
-3. {
-2.   return (history_do_write (filename, nelements, HISTORY_APPEND));
-1. }

 /*Overwrite FILENAME with the current history.  If FILENAME is NUL",Useful
/*HAVE_STDLIB_H*/,"-10.    General Public License for more details.
-9.    The GNU General Public License is often shipped with GNU software, and
-8.    is generally kept in a file called COPYING or LICENSE.  If you do not
-7.    have a copy of the license, write to the Fre",Useful
/*Variables exported by this file.*/,"-10. static char error_pointer;
-9. static char *subst_lhs;
-8. static char *subst_rhs;
-7. static int subst_lhs_len;
-6. static int subst_rhs_len;
-5. static char *get_history_word_specifier PARAMS((char *, char *, int *));
-4. static char *history_find_",Useful
"/*The list of characters which inhibit the expansion of text if found
   immediately following history_expansion_char.*/","-1. char history_comment_char = '\0';

 /*The list of characters which inhibit the expansion of text if found
   immediately following history_expansion_char.*/

1. const char *history_no_expand_chars = "" \t\n\r="";",Useful
/*Used to split words by history_tokenize_internal.*/,"-1. int history_quotes_inhibit_expansion = 0;

 /*Used to split words by history_tokenize_internal.*/

1. const char *history_word_delimiters = HISTORY_WORD_DELIMITERS;",Useful
"/*Hairy history expansion on text, not tokens.  This is of general
   use, and thus belongs in this library.*/","-6. rl_linebuf_func_t *history_inhibit_expansion_function;

 /*Hairy history expansion on text, not tokens.  This is of general
   use, and thus belongs in this library.*/

111",Useful
"/*Return the event specified at TEXT + OFFSET modifying OFFSET to
   point to after the event specifier.  Just a pointer to the history
   line is returned; NULL is returned in the event of a bad specifier.
   You pass STRING with *INDEX equal to the history_expansion_char that
   begins this specification.
   DELIMITING_QUOTE is a character that is allowed to end the string
   specification for what to search for in addition to the normal
   characters `:', ` ', `\t', `\n', and sometimes `?'.
   So you might call this function like:
   line = get_history_event (""!echo:p"", &index, 0);*/","-3. static char *search_string;

 /*Return the event specified at TEXT + OFFSET modifying OFFSET to
   point to after the event specifier.  Just a pointer to the history
   line is returned; NULL is returned in the event of a bad specifier.
   You pass ST",Useful
"/*The event can be specified in a number of ways.

     !!   the previous command
     !n   command line N
     !-n  current command-line minus N
     !str the most recent command starting with STR
     !?str[?]
	  the most recent command containing STR

     All values N are determined via HISTORY_BASE.*/","-10.      const char *string;
-9.      int *caller_index;
-8.      int delimiting_quote;
-7. {
-6.   register int i;
-5.   register char c;
-4.   HIST_ENTRY *entry;
-3.   int which, sign, local_index, substring_okay;
-2.   _hist_search_func_t *search_func",Useful
/*Move on to the specification.*/,"-10.      !!   the previous command
-9.      !n   command line N
-8.      !-n  current command-line minus N
-7.      !str the most recent command starting with STR
-6.      !?str[?]
-5. 	  the most recent command containing STR
-4.      All values N are d",Useful
/*Handle !! case.*/,"-5.   i++;
-4.   sign = 1;
-3.   substring_okay = 0;
-2. #define RETURN_ENTRY(e, w) \
-1. 	return ((e = history_get (w)) ? e->line : (char *)NULL)

 /*Handle !! case.*/

1.   if (string[i] == history_expansion_char)
2.     {
3.       i++;
4.       which =",Useful
/*Hack case of numeric line specification.*/,"-7.   if (string[i] == history_expansion_char)
-6.     {
-5.       i++;
-4.       which = history_base + (history_length - 1);
-3.       *caller_index = i;
-2.       RETURN_ENTRY (entry, which);
-1.     }

 /*Hack case of numeric line specification.*/

1.",Useful
"/*This must be something to search for.  If the spec begins with
     a '?', then the string may be anywhere on the line.  Otherwise,
     the string must be found at the start of a line.*/","-7.       for (which = 0; _rl_digit_p (string[i]); i++)
-6. 	which = (which * 10) + _rl_digit_value (string[i]);
-5.       *caller_index = i;
-4.       if (sign < 0)
-3. 	which = (history_length + history_base) - which;
-2.       RETURN_ENTRY (entry, whic",Useful
"/*These produce warnings because we're passing a const string to a
	     function that takes a non-const string.*/","-8.   for (local_index = i; (c = string[i]); i++)
-7.     {
-6. #if defined (HANDLE_MULTIBYTE)
-5.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
-4. 	{
-3. 	  int v;
-2. 	  mbstate_t ps;
-1. 	  memset (&ps, 0, sizeof (mbstate_t));

 /*These produce w",Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

 /*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Useful
"/*If this was a substring search, then remember the
	     string that we matched for word substitution.*/","-10.   search_func = substring_okay ? history_search : history_search_prefix;
-9.   while (1)
-8.     {
-7.       local_index = (*search_func) (temp, -1);
-6.       if (local_index < 0)
-5. 	FAIL_SEARCH ();
-4.       if (local_index == 0 || substring_okay",Useful
"/*Extract the contents of STRING as if it is enclosed in single quotes.
   SINDEX, when passed in, is the offset of the character immediately
   following the opening single quote; on exit, SINDEX is left pointing
   to the closing single quote.*/","-10.       if (history_offset)
-9. 	history_offset--;
-8.       else
-7. 	FAIL_SEARCH ();
-6.     }
-5. #undef FAIL_SEARCH
-4. #undef RETURN_ENTRY
-3. }

 /*Extract the contents of STRING as if it is enclosed in single quotes.
   SINDEX, when passed in, i",Useful
"/*Get a history substitution string from STR starting at *IPTR
   and return it.  The length is returned in LENPTR.

   A backslash can quote the delimiter.  If the string is the
   empty string, the previous pattern is used.  If there is
   no previous pattern for the lhs, the last history search
   string is used.

   If IS_RHS is 1, we ignore empty strings and set the pattern
   to """" anyway.  subst_lhs is not changed if the lhs is empty;
   subst_rhs is allowed to be set to the empty string.*/","-10.       elen = 23;
-9.       break;
-8.     }
-7.   temp = (char *)xmalloc (ll + elen + 3);
-6.   strncpy (temp, s + start, ll);
-5.   temp[ll] = ':';
-4.   temp[ll + 1] = ' ';
-3.   strcpy (temp + ll + 2, emsg);
-2.   return (temp);
-1. }

 /*Get a hi",Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

 /*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Useful
"/*Expand the bulk of a history specifier starting at STRING[START].
   Returns 0 if everything is OK, -1 if an error occurred, and 1
   if the `p' modifier was supplied and the caller should just print
   the returned string.  Returns the new index into string in
   *END_INDEX_PTR, and the expanded specifier in *RET_STRING.*/","-10. 	  if (j >= new_size)
-9. 	    new = (char *)xrealloc (new, new_size *= 2);
-8. 	  new[j++] = subst_rhs[i];
-7. 	}
-6.     }
-5.   new[j] = '\0';
-4.   free (subst_rhs);
-3.   subst_rhs = new;
-2.   subst_rhs_len = j;
-1. }

 /*Expand the bulk of a h",Useful
/*for !#*/,"-5. static int
-4. history_expand_internal (string, start, end_index_ptr, ret_string, current_line)
-3.      char *string;
-2.      int start, *end_index_ptr;
-1.      char **ret_string;

 /*for !#*/

1. {
2.   int i, n, starting_index;
3.   int substitut",Useful
"/*If it is followed by something that starts a word specifier,
     then !! is implied as the event specifier.*/","-10.   int i, n, starting_index;
-9.   int substitute_globally, subst_bywords, want_quotes, print_only;
-8.   char *event, *temp, *result, *tstr, *t, c, *word_spec;
-7.   int result_len;
-6. #if defined (HANDLE_MULTIBYTE)
-5.   mbstate_t ps;
-4.   memset ",Useful
/*XXX - original patch had i - 1 ???  If i == 0 it would fail.*/,"-6. #if defined (HANDLE_MULTIBYTE)
-5.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
-4. 	{
-3. 	  int ch, l;
-2. 	  l = _rl_find_prev_mbchar (string, i, MB_FIND_ANY);
-1. 	  ch = string[l];

 /*XXX - original patch had i - 1 ???  If i == 0 it would ",Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

 /*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Useful
"/*If a word specifier is found, then do what that requires.*/","-10. 	if (i && (string[i - 1] == '\'' || string[i - 1] == '""'))
-9. 	  quoted_search_delimiter = string[i - 1];
-8.       event = get_history_event (string, &i, quoted_search_delimiter);
-7.     }
-6.   if (event == 0)
-5.     {
-4.       *ret_string = hi",Useful
/*Perhaps there are other modifiers involved.  Do what they say.*/,"-2.   temp = word_spec ? savestring (word_spec) : savestring (event);
-1.   FREE (word_spec);

 /*Perhaps there are other modifiers involved.  Do what they say.*/

1.   want_quotes = substitute_globally = subst_bywords = print_only = 0;
2.   starting_inde",Useful
"/*:p means make this the last executed line.  So we
	     return an error state after adding this line to the
	     history.*/","-10. 	  *ret_string = hist_error (string, i+1, i+2, BAD_MODIFIER);
-9. 	  free (result);
-8. 	  free (temp);
-7. 	  return -1;
-6. 	case 'q':
-5. 	  want_quotes = 'q';
-4. 	  break;
-3. 	case 'x':
-2. 	  want_quotes = 'x';
-1. 	  break;

 /*:p means make ",Useful
/*:t discards all but the last part of the pathname.*/,"-3. 	case 'p':
-2. 	  print_only++;
-1. 	  break;

 /*:t discards all but the last part of the pathname.*/

1. 	case 't':
2. 	  tstr = strrchr (temp, '/');
3. 	  if (tstr)
4. 	    {
5. 	      tstr++;
6. 	      t = savestring (tstr);
7. 	      free (temp);",Useful
/*:h discards the last part of a pathname.*/,"-10. 	case 't':
-9. 	  tstr = strrchr (temp, '/');
-8. 	  if (tstr)
-7. 	    {
-6. 	      tstr++;
-5. 	      t = savestring (tstr);
-4. 	      free (temp);
-3. 	      temp = t;
-2. 	    }
-1. 	  break;

 /*:h discards the last part of a pathname.*/

1. 	c",Useful
"/*:s/this/that substitutes `that' for the first
	   occurrence of `this'.  :gs/this/that substitutes `that'
	   for each occurrence of `this'.  :& repeats the last
	   substitution.  :g& repeats the last substitution
	   globally.*/","-9. 	case 'e':
-8. 	  tstr = strrchr (temp, '.');
-7. 	  if (tstr)
-6. 	    {
-5. 	      t = savestring (tstr);
-4. 	      free (temp);
-3. 	      temp = t;
-2. 	    }
-1. 	  break;

 /*:s/this/that substitutes `that' for the first
	   occurrence of `this",Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

 /*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Useful
/*no search delimiter*/,"-3. 		      delimiter = string[i + 2];
-2. 		  }
-1. 		else

 /*no search delimiter*/

1. 		i += 3;
2. 		t = get_subst_pattern (string, &i, delimiter, 0, &subst_lhs_len);",Useful
"/*An empty substitution lhs with no previous substitution
		   uses the last search string as the lhs.*/","-2. 		i += 3;
-1. 		t = get_subst_pattern (string, &i, delimiter, 0, &subst_lhs_len);

 /*An empty substitution lhs with no previous substitution
		   uses the last search string as the lhs.*/

1. 		if (t)
2. 		  {
3. 		    FREE (subst_lhs);
4. 		    subs",Useful
"/*If `&' appears in the rhs, it's supposed to be replaced
		   with the lhs.*/","-10. 			subst_lhs_len = strlen (subst_lhs);
-9. 		      }
-8. 		    else
-7. 		      {
-6. 			subst_lhs = (char *) NULL;
-5. 			subst_lhs_len = 0;
-4. 		      }
-3. 		  }
-2. 		FREE (subst_rhs);
-1. 		subst_rhs = get_subst_pattern (string, &i, delimiter, ",Useful
"/*If there is no lhs, the substitution can't succeed.*/","-5. 		if (member ('&', subst_rhs))
-4. 		  postproc_subst_rhs ();
-3. 	      }
-2. 	    else
-1. 	      i += 2;

 /*If there is no lhs, the substitution can't succeed.*/

1. 	    if (subst_lhs_len == 0)
2. 	      {
3. 		*ret_string = hist_error (string, s",Useful
/*Ignore impossible cases.*/,"-8. 	    if (subst_lhs_len == 0)
-7. 	      {
-6. 		*ret_string = hist_error (string, starting_index, i, NO_PREV_SUBST);
-5. 		free (result);
-4. 		free (temp);
-3. 		return -1;
-2. 	      }
-1. 	    l_temp = strlen (temp);

 /*Ignore impossible cases.*/
",Useful
"/*Substitute SUBST_RHS for SUBST_LHS in TEMP.  There are three
	       cases to consider:

		 1.  substitute_globally == subst_bywords == 0
		 2.  substitute_globally == 1 && subst_bywords == 0
		 3.  substitute_globally == 0 && subst_bywords == 1

	       In the first case, we substitute for the first occurrence only.
	       In the second case, we substitute for every occurrence.
	       In the third case, we tokenize into words and substitute the
	       first occurrence of each word.*/","-8. 	    if (subst_lhs_len > l_temp)
-7. 	      {
-6. 		*ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
-5. 		free (result);
-4. 		free (temp);
-3. 		return (-1);
-2. 	      }

 /*Substitute SUBST_RHS for SUBST_LHS in TEMP.  There are ",Useful
"/*First skip whitespace and find word boundaries if
		   we're past the end of the word boundary we found
		   the last time.*/","-10. 		 1.  substitute_globally == subst_bywords == 0
-9. 		 2.  substitute_globally == 1 && subst_bywords == 0
-8. 		 3.  substitute_globally == 0 && subst_bywords == 1
-7. 	       In the first case, we substitute for the first occurrence only.
-6. 	    ",Useful
"/*Reported to fix a bug that causes it to skip every
			   other match when matching a single character.  Was
			   si += subst_rhs_len previously.*/","-10. 		    strncpy (new_event + si, subst_rhs, subst_rhs_len);
-9. 		    strncpy (new_event + si + subst_rhs_len,
-8. 			     temp + si + subst_lhs_len,
-7. 			     l_temp - (si + subst_lhs_len));
-6. 		    new_event[len] = '\0';
-5. 		    free (temp);
-4",Useful
/*don't want to increment i*/,"-10. 			l_temp = strlen (temp);
-9. 			continue;
-8. 		      }
-7. 		    else
-6. 		      break;
-5. 		  }
-4. 	      }
-3. 	    if (substitute_globally > 1)
-2. 	      {
-1. 		substitute_globally = 0;

 /*don't want to increment i*/

1. 	      }
2. 	    ",Useful
/*don't want to increment i*/,"-10. 			l_temp = strlen (temp);
-9. 			continue;
-8. 		      }
-7. 		    else
-6. 		      break;
-5. 		  }
-4. 	      }
-3. 	    if (substitute_globally > 1)
-2. 	      {
-1. 		substitute_globally = 0;

 /*don't want to increment i*/

1. 	      }
2. 	    ",Useful
"/*Believe it or not, we have to back the pointer up by one.*/","-9. 	    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
-8. 	    free (result);
-7. 	    free (temp);
-6. 	    return (-1);
-5. 	  }
-4. 	}
-3.       i += 2;
-2.     }

 /*Believe it or not, we have to back the pointer up by one.*/

1",Useful
"/*Expand the string STRING, placing the result into OUTPUT, a pointer
   to a string.  Returns:

  -1) If there was an error in expansion.
   0) If no expansions took place (or, if the only change in
      the text was the de-slashifying of the history expansion
      character)
   1) If expansions did take place
   2) If the `p' modifier was given and the caller should print the result

  If an error ocurred in expansion, then OUTPUT contains a descriptive
  error message.*/","-10.     }
-9.   n = strlen (temp);
-8.   if (n >= result_len)
-7.     result = (char *)xrealloc (result, n + 2);
-6.   strcpy (result, temp);
-5.   free (temp);
-4.   *end_index_ptr = i;
-3.   *ret_string = result;
-2.   return (print_only);
-1. }

 /*Ex",Useful
"/*The output string, and its length.*/","-10. 	  } \
-9. 	while (0)
-8. int
-7. history_expand (hstring, output)
-6.      char *hstring;
-5.      char **output;
-4. {
-3.   register int j;
-2.   int i, r, l, passc, cc, modified, eindex, only_printing, dquote;
-1.   char *string;

 /*The output s",Useful
/*Used when adding the string.*/,"-6.   int result_len;
-5.   char *result;
-4. #if defined (HANDLE_MULTIBYTE)
-3.   char mb[MB_LEN_MAX];
-2.   mbstate_t ps;
-1. #endif

 /*Used when adding the string.*/

1.   char *temp;
2.   if (output == 0)
3.     return 0;",Useful
"/*Grovel the string.  Only backslash and single quotes can quote the
     history escape character.  We also handle arg specifiers.*/","-4.   result = (char *)xmalloc (result_len = 256);
-3.   result[0] = '\0';
-2.   only_printing = modified = 0;
-1.   l = strlen (hstring);

 /*Grovel the string.  Only backslash and single quotes can quote the
     history escape character.  We also handl",Useful
"/*Before we grovel forever, see if the history_expansion_char appears
     anywhere within the text.*/","-6.   result = (char *)xmalloc (result_len = 256);
-5.   result[0] = '\0';
-4.   only_printing = modified = 0;
-3.   l = strlen (hstring);

 /*Before we grovel forever, see if the history_expansion_char appears
     anywhere within the text.*/

111",Useful
"/*The quick substitution character is a history expansion all right.  That
     is to say, ""^this^that^"" is equivalent to ""!!:s^this^that^"", and in fact,
     that is the substitution that we do.*/","-8.   result = (char *)xmalloc (result_len = 256);
-7.   result[0] = '\0';
-6.   only_printing = modified = 0;
-5.   l = strlen (hstring);

 /*The quick substitution character is a history expansion all right.  That
     is to say, ""^this^that^"" is equiva",Useful
"/*If not quick substitution, still maybe have to do expansion.*/","-10.       string[3] = 's';
-9.       strcpy (string + 4, hstring);
-8.       l += 4;
-7.     }
-6.   else
-5.     {
-4. #if defined (HANDLE_MULTIBYTE)
-3.       memset (&ps, 0, sizeof (mbstate_t));
-2. #endif
-1.       string = hstring;

 /*If not quick ",Useful
"/*`!' followed by one of the characters in history_no_expand_chars
	 is NOT an expansion.*/","-10.       strcpy (string + 4, hstring);
-9.       l += 4;
-8.     }
-7.   else
-6.     {
-5. #if defined (HANDLE_MULTIBYTE)
-4.       memset (&ps, 0, sizeof (mbstate_t));
-3. #endif
-2.       string = hstring;

 /*`!' followed by one of the characters in",Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

 /*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Useful
"/*If the calling application has set
		 history_inhibit_expansion_function to a function that checks
		 for special cases that should not be history expanded,
		 call the function and skip the expansion if it returns a
		 non-zero value.*/","-10. 	      (i == 0 || member (string[i - 1], history_word_delimiters)))
-9. 	    {
-8. 	      while (string[i])
-7. 		i++;
-6. 	      break;
-5. 	    }
-4. 	  else if (string[i] == history_expansion_char)
-3. 	    {
-2. 	      if (!cc || member (cc, hist",Useful
"/*More shell-like quoting:  if we're paying attention to single
	     quotes and letting them quote the history expansion character,
	     then we need to pay attention to double quotes, because single
	     quotes are not special inside double-quoted strings.*/","-2. 	  else if (dquote && string[i] == '\\' && cc == '""')
-1. 	    i++;

 /*More shell-like quoting:  if we're paying attention to single
	     quotes and letting them quote the history expansion character,
	     then we need to pay attention to double qu",Useful
"/*If this is bash, single quotes inhibit history expansion.*/","-6. 	  else if (history_quotes_inhibit_expansion && string[i] == '""')
-5. 	    {
-4. 	      dquote = 1 - dquote;
-3. 	    }
-2. 	  else if (dquote == 0 && history_quotes_inhibit_expansion && string[i] == '\'')
-1. 	    {

 /*If this is bash, single quotes",Useful
/*Extract and perform the substitution.*/,"-10. 		i++;
-9. 	    }
-8. 	}
-7.       if (string[i] != history_expansion_char)
-6. 	{
-5. 	  free (result);
-4. 	  *output = savestring (string);
-3. 	  return (0);
-2. 	}
-1.     }

 /*Extract and perform the substitution.*/

1.   for (passc = dquote =",Useful
/*HANDLE_MULTIBYTE*/,"-2.   for (local_index = i; (c = string[i]); i++)
-1.     {
#if defined (HANDLE_MULTIBYTE)

 /*HANDLE_MULTIBYTE*/

1.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
2. 	{
3. 	  int v;
4. 	  mbstate_t ps;
5. 	  memset (&ps, 0, sizeof (mbstate_t));",Useful
"/*If the history_expansion_char is followed by one of the
	     characters in history_no_expand_chars, then it is not a
	     candidate for expansion of any kind.*/","-1. 	  cc = string[i + 1];

 /*If the history_expansion_char is followed by one of the
	     characters in history_no_expand_chars, then it is not a
	     candidate for expansion of any kind.*/

1. 	  if (member (cc, history_no_expand_chars))
2. 	    {
3.",Useful
"/*Return a consed string which is the word specified in SPEC, and found
   in FROM.  NULL is returned if there is no spec.  The address of
   ERROR_POINTER is returned if the word specified cannot be found.
   CALLER_INDEX is the offset in SPEC to start looking; it is updated
   to point to just after the last character parsed.*/","-10.     free (string);
-9.   if (only_printing)
-8.     {
-7. #if 0
-6.       add_history (result);
-5. #endif
-4.       return (2);
-3.     }
-2.   return (modified != 0);
-1. }

 /*Return a consed string which is the word specified in SPEC, and found
 ",Useful
/*The range of words to return doesn't exist yet.*/,"-10.    to point to just after the last character parsed. */
-9. static char *
-8. get_history_word_specifier (spec, from, caller_index)
-7.      char *spec, *from;
-6.      int *caller_index;
-5. {
-4.   register int i = *caller_index;
-3.   int first, l",Useful
"/*If we found a colon, then this *must* be a word specification.  If
     it isn't, then it is an error.*/","-2.   first = last = 0;
-1.   result = (char *)NULL;

 /*If we found a colon, then this *must* be a word specification.  If
     it isn't, then it is an error.*/

1.   if (spec[i] == ':')
2.     {
3.       i++;
4.       expecting_word_spec++;
5.     }",Useful
"/*`*' matches all of the arguments, but not the command.*/","-5.   if (spec[i] == '%')
-4.     {
-3.       *caller_index = i + 1;
-2.       return (search_match ? savestring (search_match) : savestring (""""));
-1.     }

 /*`*' matches all of the arguments, but not the command.*/

1.   if (spec[i] == '*')
2.     {
3",Useful
/*no valid `first' for word specifier*/,"-10.     {
-9.       first = 1;
-8.       i++;
-7.     }
-6.   else if (_rl_digit_p (spec[i]) && expecting_word_spec)
-5.     {
-4.       for (first = 0; _rl_digit_p (spec[i]); i++)
-3. 	first = (first * 10) + _rl_digit_value (spec[i]);
-2.     }
-1.   el",Useful
"/*csh seems to allow anything to terminate the word spec here,
	   leaving it as an abbreviation.*/","-2. #else
-1.       else

 /*csh seems to allow anything to terminate the word spec here,
	   leaving it as an abbreviation.*/

1. #endif",Useful
"/*Extract the args specified, starting at FIRST, and ending at LAST.
   The args are taken from STRING.  If either FIRST or LAST is < 0,
   then make that arg count from the right (subtract from the number of
   tokens, so that FIRST = -1 means the next to last token on the line).
   If LAST is `$' the last arg from STRING is used.*/","-6.     }
-5.   *caller_index = i;
-4.   if (last >= first || last == '$' || last < 0)
-3.     result = history_arg_extract (first, last, from);
-2.   return (result ? result : (char *)&error_pointer);
-1. }

 /*Extract the args specified, starting at FIR",Useful
"/*Parse STRING into tokens and return an array of strings.  If WIND is
   not -1 and INDP is not null, we also want the word surrounding index
   WIND.  The position in the returned array of strings is returned in
   *INDP.*/","-10.      int start, end;
-9. {
-8.   register int len;
-7.   register char *result;
-6.   len = end - start;
-5.   result = (char *)xmalloc (len + 1);
-4.   strncpy (result, string + start, len);
-3.   result[len] = '\0';
-2.   return result;
-1. }

 /*P",Useful
"/*If we're searching for a string that's not part of a word (e.g., "" ""),
     make sure we set *INDP to a reasonable value.*/","-10.    not -1 and INDP is not null, we also want the word surrounding index
-9.    WIND.  The position in the returned array of strings is returned in
-8.    *INDP. */
-7. static char **
-6. history_tokenize_internal (string, wind, indp)
-5.      const c",Useful
"/*Get a token, and stuff it into RESULT.  The tokens are split
     exactly where the shell would split them.*/","-2.   if (indp && wind != -1)
-1.     *indp = -1;

 /*Get a token, and stuff it into RESULT.  The tokens are split
     exactly where the shell would split them.*/

1.   for (i = result_index = size = 0, result = (char **)NULL; string[i]; )
2.     {",Useful
"/*If we have a non-whitespace delimiter character (which would not be
	 skipped by the loop above), use it and any adjacent delimiters to
	 make a separate field.  Any adjacent white space will be skipped the
	 next time through the loop.*/","-6.       for (; string[i] && whitespace (string[i]); i++)
-5. 	;
-4.       if (string[i] == 0 || string[i] == history_comment_char)
-3. 	return (result);
-2.       start = i;
-1.       i = history_tokenize_word (string, start);

 /*If we have a non-white",Useful
"/*If we are looking for the word in which the character at a
	 particular index falls, remember it.*/","-6.       if (i == start && history_word_delimiters)
-5. 	{
-4. 	  i++;
-3. 	  while (string[i] && member (string[i], history_word_delimiters))
-2. 	    i++;
-1. 	}

 /*If we are looking for the word in which the character at a
	 particular index falls, r",Useful
"/*Return an array of tokens, much as the shell might.  The tokens are
   parsed out of STRING.*/","-10. 	 particular index falls, remember it. */
-9.       if (indp && wind != -1 && wind >= start && wind < i)
-8.         *indp = result_index;
-7.       if (result_index + 2 >= size)
-6. 	result = (char **)xrealloc (result, ((size += 10) * sizeof (char *",Useful
"/*Find and return the word which contains the character at index IND
   in the history line LINE.  Used to save the word matched by the
   last history !?string? search.*/","-6. char **
-5. history_tokenize (string)
-4.      const char *string;
-3. {
-2.   return (history_tokenize_internal (string, -1, (int *)NULL));
-1. }

 /*Find and return the word which contains the character at index IND
   in the history line LINE.  Use",Useful
/*input.c -- character input functions for readline.*/,"
/* input.c -- character input functions for readline. */


 /*input.c -- character input functions for readline.*/

1. /* Copyright (C) 1994-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
/*HAVE_SYS_FILE_H*/,"-10.    51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA. */
-9. #define READLINE_LIBRARY
-8. #if defined (__TANDEM)
-7. #  include <floss.h>
-6. #endif
-5. #if defined (HAVE_CONFIG_H)
-4. #  include ""config_readline.h""
-3. #endif
-2. #include",Useful
/*HAVE_UNISTD_H*/,"
#if defined (HAVE_UNISTD_H)



 /*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



 /*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Useful
/*HAVE_SELECT*/,"
#if defined (HAVE_SELECT)



 /*HAVE_SELECT*/

1. #  if !defined (HAVE_SYS_SELECT_H) || !defined (M_UNIX)
2. #    include <sys/time.h>
3. #  endif",Useful
/*!errno*/,"-10. #if defined (HAVE_SYS_SELECT_H)
-9. #  include <sys/select.h>
-8. #endif
-7. #if defined (FIONREAD_IN_SYS_IOCTL)
-6. #  include <sys/ioctl.h>
-5. #endif
-4. #include <stdio.h>
-3. #include <errno.h>
-2. #if !defined (errno)
-1. extern int errno;

 /*",Useful
/*System-specific feature definitions and include files.*/,"-10. #  include <sys/select.h>
-9. #endif
-8. #if defined (FIONREAD_IN_SYS_IOCTL)
-7. #  include <sys/ioctl.h>
-6. #endif
-5. #include <stdio.h>
-4. #include <errno.h>
-3. #if !defined (errno)
-2. extern int errno;

 /*System-specific feature definitions ",Useful
/*Some standard library routines.*/,"-2. #include ""rldefs.h""
-1. #include ""rlmbutil.h""

 /*Some standard library routines.*/

1. #include ""readline.h""
2. #include ""rlprivate.h""
3. #include ""rlshell.h""
4. #include ""xmalloc.h""",Useful
/*Posix style*/,"-1. #if !defined (O_NDELAY) && defined (O_NONBLOCK)

 /*Posix style*/

1. #endif",Useful
"/*Non-null means it is a pointer to a function to run while waiting for
   character input.*/","-1. #endif

 /*Non-null means it is a pointer to a function to run while waiting for
   character input.*/

1. rl_hook_func_t *rl_event_hook = (rl_hook_func_t *)NULL;
2. rl_getc_func_t *rl_getc_function = rl_getc;",Useful
/*0.1 seconds; it's in usec*/,"-2. rl_hook_func_t *rl_event_hook = (rl_hook_func_t *)NULL;
-1. rl_getc_func_t *rl_getc_function = rl_getc;

 /*0.1 seconds; it's in usec*/

1. static int ibuffer_space PARAMS((void));
2. static int rl_get_char PARAMS((int *));
3. static int rl_gather_tyi",Useful
"/*Return the amount of space available in the buffer for stuffing
   characters.*/","-9. static int pop_index, push_index;
-8. static unsigned char ibuffer[512];
-7. static int ibuffer_len = sizeof (ibuffer) - 1;
-6. #define any_typein (push_index != pop_index)
-5. int
-4. _rl_any_typein ()
-3. {
-2.   return any_typein;
-1. }

 /*Return ",Useful
"/*Get a key from the buffer of characters to be read.
   Return the key in KEY.
   Result is KEY if there was a key, or 0 if there wasn't.*/","-8. static int
-7. ibuffer_space ()
-6. {
-5.   if (pop_index > push_index)
-4.     return (pop_index - push_index - 1);
-3.   else
-2.     return (ibuffer_len - (push_index - pop_index));
-1. }

 /*Get a key from the buffer of characters to be read.
   R",Useful
"/*Stuff KEY into the *front* of the input buffer.
   Returns non-zero if successful, zero if there is
   no space left in the buffer.*/","-10. rl_get_char (key)
-9.      int *key;
-8. {
-7.   if (push_index == pop_index)
-6.     return (0);
-5.   *key = ibuffer[pop_index++];
-4.   if (pop_index >= ibuffer_len)
-3.     pop_index = 0;
-2.   return (1);
-1. }

 /*Stuff KEY into the *front* of ",Useful
"/*If a character is available to be read, then read it and stuff it into
   IBUFFER.  Otherwise, just return.  Returns number of characters read
   (0 if none available) and -1 on error (EIO).*/","-10.       ibuffer[pop_index] = key;
-9.       return (1);
-8.     }
-7.   return (0);
-6. }
-5. int
-4. _rl_pushed_input_available ()
-3. {
-2.   return (push_index != pop_index);
-1. }

 /*If a character is available to be read, then read it and stuff i",Useful
/*Nothing to read.*/,"-10.   tty = fileno (rl_instream);
-9. #if defined (HAVE_SELECT)
-8.   FD_ZERO (&readfds);
-7.   FD_ZERO (&exceptfds);
-6.   FD_SET (tty, &readfds);
-5.   FD_SET (tty, &exceptfds);
-4.   timeout.tv_sec = 0;
-3.   timeout.tv_usec = _keyboard_input_timeout;",Useful
/*O_NDELAY*/,"
#if !defined (O_NDELAY) && defined (O_NONBLOCK)



 /*O_NDELAY*/

111",Useful
"/*Use getch/_kbhit to check for available console input, in the same way
     that we read it normally.*/","-1. #if defined (__MINGW32__)

 /*Use getch/_kbhit to check for available console input, in the same way
     that we read it normally.*/

1.    chars_avail = isatty (tty) ? _kbhit () : 0;
2.    result = 0;
3. #endif",Useful
"/*If there's nothing available, don't waste time trying to read
     something.*/","-3.    chars_avail = isatty (tty) ? _kbhit () : 0;
-2.    result = 0;
-1. #endif

 /*If there's nothing available, don't waste time trying to read
     something.*/

1.   if (chars_avail <= 0)
2.     return 0;
3.   tem = ibuffer_space ();
4.   if (chars_a",Useful
"/*One cannot read all of the available input.  I can only read a single
     character at a time, or else programs which require input can be
     thwarted.  If the buffer is larger than one character, I lose.
     Damn!*/","-5.   if (chars_avail <= 0)
-4.     return 0;
-3.   tem = ibuffer_space ();
-2.   if (chars_avail > tem)
-1.     chars_avail = tem;

 /*One cannot read all of the available input.  I can only read a single
     character at a time, or else programs which ",Useful
"/*Add KEY to the buffer of characters to be read.  Returns 1 if the
   character was stuffed correctly; 0 otherwise.*/","-10.   while ((t = rl_get_char (&key)) &&
-9. 	 _rl_keymap[key].type == ISFUNC &&
-8. 	 _rl_keymap[key].function == rl_insert)
-7.     string[i++] = key;
-6.   if (t)
-5.     _rl_unget_char (key);
-4.   string[i] = '\0';
-3.   rl_insert_text (string);
-2.",Useful
"/*If input is coming from a macro, then use that.*/","-10. {
-9.   int c;
-8.   rl_key_sequence_length++;
-7.   if (rl_pending_input)
-6.     {
-5.       c = rl_pending_input;
-4.       rl_clear_pending_input ();
-3.     }
-2.   else
-1.     {

 /*If input is coming from a macro, then use that.*/

1.       i",Useful
/*XXX - experimental*/,"-5.       if (rl_event_hook)
-4. 	{
-3. 	  while (rl_event_hook && rl_get_char (&c) == 0)
-2. 	    {
-1. 	      (*rl_event_hook) ();

 /*XXX - experimental*/

1. 		return ('\n');",Useful
/*XXX - EIO*/,"-1. 		return ('\n');

 /*XXX - EIO*/

1. 		{
2. 		  rl_done = 1;
3. 		  return ('\n');
4. 		}
5. 	    }
6. 	}
7.       else
8. 	{
9. 	  if (rl_get_char (&c) == 0)
10. 	    c = (*rl_getc_function) (rl_instream);",Useful
"/*If zero characters are returned, then the file that we are
	 reading from is empty!  Return EOF in that case.*/","-10.   unsigned char c;
-9.   while (1)
-8.     {
-7. #if defined (__MINGW32__)
-6.       if (isatty (fileno (stream)))
-5. 	return (getch ());
-4. #endif
-3.       result = read (fileno (stream), &c, sizeof (unsigned char));
-2.       if (result == sizeo",Useful
/*invalid byte sequence for the current locale*/,"-10.   mbstate_t ps, ps_back;
-9.   memset(&ps, 0, sizeof (mbstate_t));
-8.   memset(&ps_back, 0, sizeof (mbstate_t));
-7.   while (mb_len < size)
-6.     {
-5.       RL_SETSTATE(RL_STATE_MOREINPUT);
-4.       mbchar[mb_len++] = rl_read_key ();
-3.       ",Useful
/*shorted bytes*/,"-2.       else if (mbchar_bytes_length == (size_t)(-2))
-1. 	{

 /*shorted bytes*/

1. 	  ps = ps_back;
2. 	  continue;
3. 	} 
4.       else if (mbchar_bytes_length == 0)
5. 	{",Useful
/*null wide character*/,"-5. 	  ps = ps_back;
-4. 	  continue;
-3. 	} 
-2.       else if (mbchar_bytes_length == 0)
-1. 	{

 /*null wide character*/

1. 	  mb_len = 1;
2. 	  break;
3. 	}
4.       else if (mbchar_bytes_length > (size_t)(0))
5. 	break;
6.     }
7.   return mb_len;
",Useful
"/*Read a multibyte-character string whose first character is FIRST into
   the buffer MB of length MLEN.  Returns the last character read, which
   may be FIRST.  Used by the search functions, among others.  Very similar
   to _rl_read_mbchar.*/","-8. 	  mb_len = 1;
-7. 	  break;
-6. 	}
-5.       else if (mbchar_bytes_length > (size_t)(0))
-4. 	break;
-3.     }
-2.   return mb_len;
-1. }

 /*Read a multibyte-character string whose first character is FIRST into
   the buffer MB of length MLEN.  Retu",Useful
/*Read more for multibyte character*/,"-10.   int i, c;
-9.   mbstate_t ps;
-8.   c = first;
-7.   memset (mb, 0, mlen);
-6.   for (i = 0; i < mlen; i++)
-5.     {
-4.       mb[i] = (char)c;
-3.       memset (&ps, 0, sizeof (mbstate_t));
-2.       if (_rl_get_char_len (mb, &ps) == -2)
-1. 	{

",Useful
/*HANDLE_MULTIBYTE*/,"-4.       if (errno != EINTR)
-3. 	return (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF);
-2.     }
-1. }
#if defined (HANDLE_MULTIBYTE)

 /*HANDLE_MULTIBYTE*/

111",Useful
/*options wich are passed directly to xtrabackup*/,"-10. 	OPT_SAFE_SLAVE_BACKUP_TIMEOUT,
-9. 	OPT_RSYNC,
-8. 	OPT_HISTORY,
-7. 	OPT_INCLUDE,
-6. 	OPT_FORCE_NON_EMPTY_DIRS,
-5. 	OPT_NO_TIMESTAMP,
-4. 	OPT_NO_VERSION_CHECK,
-3. 	OPT_NO_BACKUP_LOCKS,
-2. 	OPT_DATABASES,
-1. 	OPT_DECOMPRESS,

 /*options wich a",Useful
"/*Following command-line options are actually handled by xtrabackup.
	We put them here with only purpose for them to showup in
	innobackupex --help output*/","-10. 	 ""--ftwrl-wait-timeout is 0. Default value is 60 seconds."",
-9. 	 (uchar*) &opt_ibx_lock_wait_threshold,
-8. 	 (uchar*) &opt_ibx_lock_wait_threshold, 0, GET_UINT,
-7. 	 REQUIRED_ARG, 60, 0, 0, 0, 0, 0},
-6. 	{""safe-slave-backup-timeout"", OPT_SAFE_SL",Useful
/*set argv[0] to be the program name*/,"-10. 		++i;
-9. 	}
-8. 	*argc -= n_arguments;
-7. 	if (n_arguments > 1) {
-6. 		return(false);
-5. 	}
-4. 	if (ibx_position_arg == NULL) {
-3. 		ibx_msg(""Missing argument\n"");
-2. 		return(false);
-1. 	}

 /*set argv[0] to be the program name*/

111",Useful
"/**
Parse command-line options, connect to MySQL server,
detect server capabilities, etc.
@return	true on success.*/","-10. 		return(false);
-9. 	}
-8. 	/* set argv[0] to be the program name */
-7. 	--(*argv);
-6. 	++(*argc);
-5. 	return(true);
-4. }
-3. /*********************************************************************//**
-2. Parse command-line options, connect to M",Useful
/*setup xtrabackup options*/,"-10. 	opt_socket = opt_ibx_socket;
-9. 	opt_port = opt_ibx_port;
-8. 	opt_lock_wait_query_type = opt_ibx_lock_wait_query_type;
-7. 	opt_kill_long_query_type = opt_ibx_kill_long_query_type;
-6. 	opt_kill_long_queries_timeout = opt_ibx_kill_long_queries_tim",Useful
/*--tables and --tables-file options are xtrabackup only*/,"-10. 			""--incremental option.\n"");
-9. 		return(false);
-8. 	}
-7. 	if (opt_ibx_databases != NULL) {
-6. 		if (is_path_separator(*opt_ibx_databases)) {
-5. 			xtrabackup_databases_file = opt_ibx_databases;
-4. 		} else {
-3. 			xtrabackup_databases = opt",Useful
"/*--binlog-info is xtrabackup only, so force
	--binlog-info=ON. i.e. behavior before the feature had been
	implemented*/","-6. 	ibx_partial_backup = (opt_ibx_include || opt_ibx_databases);
-5. 	if (ibx_mode == IBX_MODE_BACKUP) {
-4. 		if (!make_backup_dir()) {
-3. 			return(false);
-2. 		}
-1. 	}

 /*--binlog-info is xtrabackup only, so force
	--binlog-info=ON. i.e. behavior ",Useful
"/*Need the following definitions to avoid linking with ds_*.o and their link
dependencies*/","-10. #include ""xbstream.h""
-9. #include ""datasink.h""
-8. #define XBSTREAM_VERSION ""1.0""
-7. #define XBSTREAM_BUFFER_SIZE (10 * 1024 * 1024UL)
-6. #define START_FILE_HASH_SIZE 16
-5. typedef enum {
-4. 	RUN_MODE_NONE,
-3. 	RUN_MODE_CREATE,
-2. 	RUN_MODE_EX",Useful
/*Write the qpress archive header*/,"-5. 	fn_format(new_name, path, """", "".qp"", MYF(MY_APPEND_EXT));
-4. 	dest_file = ds_open(dest_ctxt, new_name, mystat);
-3. 	if (dest_file == NULL) {
-2. 		return NULL;
-1. 	}

 /*Write the qpress archive header*/

1. 	if (ds_write(dest_file, ""qpress10"", 8)",Useful
"/*We are going to create a one-file ""flat"" (i.e. with no
	subdirectories) archive. So strip the directory part from the path and
	remove the '.qp' suffix.*/","-4. 	if (ds_write(dest_file, ""qpress10"", 8) ||
-3. 	    write_uint64_le(dest_file, COMPRESS_CHUNK_SIZE)) {
-2. 		goto err;
-1. 	}

 /*We are going to create a one-file ""flat"" (i.e. with no
	subdirectories) archive. So strip the directory part from the pat",Useful
/*Send data to worker threads for compression*/,"-10. 	const char		*ptr;
-9. 	ds_file_t		*dest_file;
-8. 	comp_file = (ds_compress_file_t *) file->ptr;
-7. 	comp_ctxt = comp_file->comp_ctxt;
-6. 	dest_file = comp_file->dest_file;
-5. 	threads = comp_ctxt->threads;
-4. 	nthreads = comp_ctxt->nthreads;
-3",Useful
/*Reap and stream the compressed data*/,"-10. 			thd->data_avail = TRUE;
-9. 			pthread_cond_signal(&thd->data_cond);
-8. 			pthread_mutex_unlock(&thd->data_mutex);
-7. 			len -= chunk_len;
-6. 			if (len == 0) {
-5. 				break;
-4. 			}
-3. 			ptr += chunk_len;
-2. 		}
-1. 		max_thread = (i < nt",Useful
/*Write the qpress file trailer*/,"-10. }
-9. static
-8. int
-7. compress_close(ds_file_t *file)
-6. {
-5. 	ds_compress_file_t	*comp_file;
-4. 	ds_file_t		*dest_file;
-3. 	int			rc;
-2. 	comp_file = (ds_compress_file_t *) file->ptr;
-1. 	dest_file = comp_file->dest_file;

 /*Write the qpre",Useful
"/*Supposedly the number of written bytes should be written as a
	""recovery information"" in the file trailer, but in reality qpress
	always writes 8 zeros here. Let's do the same*/","-1. 	ds_write(dest_file, ""ENDSENDS"", 8);

 /*Supposedly the number of written bytes should be written as a
	""recovery information"" in the file trailer, but in reality qpress
	always writes 8 zeros here. Let's do the same*/

1. 	write_uint64_le(dest_file, ",Useful
/*Initialize the control mutex and condition var*/,"-10. 	threads = (comp_thread_ctxt_t *) my_malloc(PSI_NOT_INSTRUMENTED,
-9.                                   sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));
-8. 	for (i = 0; i < n; i++) {
-7. 		comp_thread_ctxt_t *thd = threads + i;
-6. 		thd->num = i + 1;
",Useful
/*Initialize and data mutex and condition var*/,"-4. 		if (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||
-3. 		    pthread_cond_init(&thd->ctrl_cond, NULL)) {
-2. 			goto err;
-1. 		}

 /*Initialize and data mutex and condition var*/

1. 		if (pthread_mutex_init(&thd->data_mutex, NULL) ||
2. 		    pthre",Useful
/*Wait for the threads to start*/,"-10. 		}
-9. 		pthread_mutex_lock(&thd->ctrl_mutex);
-8. 		if (pthread_create(&thd->id, NULL, compress_worker_thread_func,
-7. 				   thd)) {
-6. 			msg(""compress: pthread_create() failed: ""
-5. 			    ""errno = %d"", errno);
-4. 			pthread_mutex_unlock(&th",Useful
"/*qpress uses 0x00010000 as the initial value, but its own
		Adler-32 implementation treats the value differently:
		  1. higher order bits are the sum of all bytes in the sequence
		  2. lower order bits are the sum of resulting values at every
		     step.
		So it's the other way around as compared to zlib's adler32().
		That's why  0x00000001 is being passed here to be compatible
		with qpress implementation.*/","-10. 	while (1) {
-9. 		thd->data_avail = FALSE;
-8. 		pthread_cond_signal(&thd->data_cond);
-7. 		while (!thd->data_avail && !thd->cancelled) {
-6. 			pthread_cond_wait(&thd->data_cond, &thd->data_mutex);
-5. 		}
-4. 		if (thd->cancelled)
-3. 			break;
-",Useful
/*The number of slots to increase the_history by.*/,"-9. #if defined (HAVE_UNISTD_H)
-8. #  ifdef _MINIX
-7. #    include <sys/types.h>
-6. #  endif
-5. #  include <unistd.h>
-4. #endif
-3. #include ""history.h""
-2. #include ""histlib.h""
-1. #include ""xmalloc.h""

 /*The number of slots to increase the_history",Useful
"/*Non-zero means that we have enforced a limit on the amount of
   history that we save.*/","-9. #define DEFAULT_HISTORY_GROW_SIZE 50
-8. static char *hist_inittime PARAMS((void));

 /*Non-zero means that we have enforced a limit on the amount of
   history that we save.*/

1. static int history_stifled;",Useful
/*The current number of slots allocated to the input_history.*/,"-4. static HIST_ENTRY **the_history = (HIST_ENTRY **)NULL;

 /*The current number of slots allocated to the input_history.*/

1. static int history_size;",Useful
/*backwards compatibility*/,"-1. int history_max_entries;

 /*backwards compatibility*/

111",Useful
"/*The current location of the interactive history pointer.  Just makes
   life easier for outside callers.*/","-2. int history_max_entries;

 /*The current location of the interactive history pointer.  Just makes
   life easier for outside callers.*/

1. int history_offset;",Useful
/*The logical `base' of the history array.  It defaults to 1.*/,"-1. int history_length;

 /*The logical `base' of the history array.  It defaults to 1.*/

1. int history_base = 1;",Useful
/*Return the current HISTORY_STATE of the history.*/,"-1. int history_base = 1;

 /*Return the current HISTORY_STATE of the history.*/

1. HISTORY_STATE *
2. history_get_history_state ()
3. {
4.   HISTORY_STATE *state;
5.   state = (HISTORY_STATE *)xmalloc (sizeof (HISTORY_STATE));
6.   state->entries = the_",Useful
"/*Begin a session in which the history functions might be used.  This
   initializes interactive variables.*/","-10. history_set_history_state (state)
-9.      HISTORY_STATE *state;
-8. {
-7.   the_history = state->entries;
-6.   history_offset = state->offset;
-5.   history_length = state->length;
-4.   history_size = state->size;
-3.   if (state->flags & HS_STIFL",Useful
"/*Return the number of bytes that the primary history entries are using.
   This just adds up the lengths of the_history->lines and the associated
   timestamps.*/","-5. void
-4. using_history ()
-3. {
-2.   history_offset = history_length;
-1. }

 /*Return the number of bytes that the primary history entries are using.
   This just adds up the lengths of the_history->lines and the associated
   timestamps.*/

1. int
",Useful
"/*Returns the magic number which says what history element we are
   looking at now.  In this implementation, it returns history_offset.*/","-10.    This just adds up the lengths of the_history->lines and the associated
-9.    timestamps. */
-8. int
-7. history_total_bytes ()
-6. {
-5.   register int i, result;
-4.   for (i = result = 0; the_history && the_history[i]; i++)
-3.     result += HI",Useful
"/*Make the current history item be the one at POS, an absolute index.
   Returns zero if POS is out of range, else non-zero.*/","-5. int
-4. where_history ()
-3. {
-2.   return (history_offset);
-1. }

 /*Make the current history item be the one at POS, an absolute index.
   Returns zero if POS is out of range, else non-zero.*/

1. int
2. history_set_pos (pos)
3.      int pos;
4. {",Useful
"/*Return the current history array.  The caller has to be carefull, since this
   is the actual array of data, and could be bashed or made corrupt easily.
   The array is terminated with a NULL pointer.*/","-10.    Returns zero if POS is out of range, else non-zero. */
-9. int
-8. history_set_pos (pos)
-7.      int pos;
-6. {
-5.   if (pos > history_length || pos < 0 || !the_history)
-4.     return (0);
-3.   history_offset = pos;
-2.   return (1);
-1. }

 /",Useful
"/*Return the history entry at the current position, as determined by
   history_offset.  If there is no entry there, return a NULL pointer.*/","-5. HIST_ENTRY **
-4. history_list ()
-3. {
-2.   return (the_history);
-1. }

 /*Return the history entry at the current position, as determined by
   history_offset.  If there is no entry there, return a NULL pointer.*/

1. HIST_ENTRY *
2. current_histo",Useful
"/*Back up history_offset to the previous history entry, and return
   a pointer to that entry.  If there is no previous entry then return
   a NULL pointer.*/","-7. HIST_ENTRY *
-6. current_history ()
-5. {
-4.   return ((history_offset == history_length) || the_history == 0)
-3. 		? (HIST_ENTRY *)NULL
-2. 		: the_history[history_offset];
-1. }

 /*Back up history_offset to the previous history entry, and return
",Useful
"/*Move history_offset forward to the next history entry, and return
   a pointer to that entry.  If there is no next entry then return a
   NULL pointer.*/","-5. HIST_ENTRY *
-4. previous_history ()
-3. {
-2.   return history_offset ? the_history[--history_offset] : (HIST_ENTRY *)NULL;
-1. }

 /*Move history_offset forward to the next history entry, and return
   a pointer to that entry.  If there is no next e",Useful
"/*Return the history entry which is logically at OFFSET in the history array.
   OFFSET is relative to history_base.*/","-5. HIST_ENTRY *
-4. next_history ()
-3. {
-2.   return (history_offset == history_length) ? (HIST_ENTRY *)NULL : the_history[++history_offset];
-1. }

 /*Return the history entry which is logically at OFFSET in the history array.
   OFFSET is relative to",Useful
/*XXX - should use strtol() here*/,"-10. history_get_time (hist)
-9.      HIST_ENTRY *hist;
-8. {
-7.   char *ts;
-6.   time_t t;
-5.   if (hist == 0 || hist->timestamp == 0)
-4.     return 0;
-3.   ts = hist->timestamp;
-2.   if (ts[0] != history_comment_char)
-1.     return 0;

 /*XXX - s",Useful
"/*Place STRING at the end of the history list.  The data field
   is  set to NULL.*/","-8.   snprintf (ts, sizeof (ts) - 1, ""X%lu"", (unsigned long) t);
-7. #else
-6.   sprintf (ts, ""X%lu"", (unsigned long) t);
-5. #endif
-4.   ret = savestring (ts);
-3.   ret[0] = history_comment_char;
-2.   return ret;
-1. }

 /*Place STRING at the end of t",Useful
"/*If the history is stifled, and history_length is zero,
	 and it equals history_max_entries, we don't save items.*/","-8. void
-7. add_history (string)
-6.      const char *string;
-5. {
-4.   HIST_ENTRY *temp;
-3.   if (history_stifled && (history_length == history_max_entries))
-2.     {
-1.       register int i;

 /*If the history is stifled, and history_length is zer",Useful
"/*If there is something in the slot, then remove it.*/","-2.       if (history_length == 0)
-1. 	return;

 /*If there is something in the slot, then remove it.*/

1.       if (the_history[0])
2. 	(void) free_history_entry (the_history[0]);",Useful
"/*Copy the rest of the entries, moving down one slot.*/","-2.       if (the_history[0])
-1. 	(void) free_history_entry (the_history[0]);

 /*Copy the rest of the entries, moving down one slot.*/

1.       for (i = 0; i < history_length; i++)
2. 	the_history[i] = the_history[i + 1];
3.       history_base++;
4.   ",Useful
"/*Free HIST and return the data so the calling application can free it
   if necessary and desired.*/","-9. void
-8. add_history_time (string)
-7.      const char *string;
-6. {
-5.   HIST_ENTRY *hs;
-4.   hs = the_history[history_length - 1];
-3.   FREE (hs->timestamp);
-2.   hs->timestamp = savestring (string);
-1. }

 /*Free HIST and return the data so t",Useful
"/*Make the history entry at WHICH have LINE and DATA.  This returns
   the old entry so you can dispose of the data.  In the case of an
   invalid WHICH, a NULL pointer is returned.*/","-10.   HIST_ENTRY *ret;
-9.   char *ts;
-8.   if (hist == 0)
-7.     return hist;
-6.   ret = alloc_history_entry (hist->line, (char *)NULL);
-5.   ts = hist->timestamp ? savestring (hist->timestamp) : hist->timestamp;
-4.   ret->timestamp = ts;
-3.   ret",Useful
"/*Replace the DATA in the specified history entries, replacing OLD with
   NEW.  WHICH says which one(s) to replace:  WHICH == -1 means to replace
   all of the history entries where entry->data == OLD; WHICH == -2 means
   to replace the `newest' history entry where entry->data == OLD; and
   WHICH >= 0 means to replace that particular history entry's data, as
   long as it matches OLD.*/","-10.   if (which < 0 || which >= history_length)
-9.     return ((HIST_ENTRY *)NULL);
-8.   temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
-7.   old_value = the_history[which];
-6.   temp->line = savestring (line);
-5.   temp->data = data;
-4.   temp",Useful
/*XXX - we don't check entry->old*/,"-10.       if (entry->data == old)
-9. 	{
-8. 	  last = i;
-7. 	  if (which == -1)
-6. 	    entry->data = new;
-5. 	}
-4.     }
-3.   if (which == -2 && last >= 0)
-2.     {
-1.       entry = the_history[last];

 /*XXX - we don't check entry->old*/

1.   ",Useful
"/*Remove history element WHICH from the history.  The removed
   element is returned to you so you can free the line, data,
   and containing structure.*/","-2.     }
-1. }

 /*Remove history element WHICH from the history.  The removed
   element is returned to you so you can free the line, data,
   and containing structure.*/

1. HIST_ENTRY *
2. remove_history (which)
3.      int which;
4. {
5.   HIST_ENTRY",Useful
/*This loses because we cannot free the data.*/,"-9. void
-8. stifle_history (max)
-7.      int max;
-6. {
-5.   register int i, j;
-4.   if (max < 0)
-3.     max = 0;
-2.   if (history_length > max)
-1.     {

 /*This loses because we cannot free the data.*/

1.       for (i = 0, j = history_length - m",Useful
"/*Stop stifling the history.  This returns the previous maximum
   number of history entries.  The value is positive if the history
   was stifled,  negative if it wasn't.*/","-10. 	free_history_entry (the_history[i]);
-9.       history_base = i;
-8.       for (j = 0, i = history_length - max; j < max; i++, j++)
-7. 	the_history[j] = the_history[i];
-6.       the_history[j] = (HIST_ENTRY *)NULL;
-5.       history_length = j;
-4",Useful
"/************************************************************************
Write-through page write filter.*/","-6. #include <my_global.h>
-5. #include <my_base.h>
-4. #include ""common.h""
-3. #include ""write_filt.h""
-2. #include ""fil_cur.h""
-1. #include ""xtrabackup.h""

 /************************************************************************
Write-through page wri",Useful
"/************************************************************************
Incremental page write filter.*/","-10. Write-through page write filter. */
-9. static my_bool wf_wt_init(xb_write_filt_ctxt_t *ctxt, char *dst_name,
-8. 			  xb_fil_cur_t *cursor, CorruptedPages *corrupted_pages);
-7. static my_bool wf_wt_process(xb_write_filt_ctxt_t *ctxt, ds_file_t *dst",Useful
"/************************************************************************
Initialize incremental page write filter.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
/*allocate buffer for incremental backup (4096 pages)*/,"-10. Initialize incremental page write filter.
-9. @return TRUE on success, FALSE on error. */
-8. static my_bool
-7. wf_incremental_init(xb_write_filt_ctxt_t *ctxt, char *dst_name,
-6. 		    xb_fil_cur_t *cursor, CorruptedPages *corrupted_pages)
-5. {
-4",Useful
"/************************************************************************
Run the next batch of pages through incremental page write filter.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
/*updated page*/,"-10. 	byte				*page;
-9. 	const ulint			page_size = cursor->page_size;
-8. 	xb_wf_incremental_ctxt_t	*cp = &(ctxt->wf_incremental_ctxt);
-7. 	for (i = 0, page = cursor->buf; i < cursor->buf_npages;
-6. 	     i++, page += page_size) {
-5. 		if ((!cp->corru",Useful
/*flush buffer*/,"-1. 		if (cp->npages == page_size / 4) {

 /*flush buffer*/

1. 			if (ds_write(dstfile, cp->delta_buf,
2. 				     cp->npages * page_size)) {
3. 				return(FALSE);
4. 			}",Useful
/*clear buffer*/,"-4. 			if (ds_write(dstfile, cp->delta_buf,
-3. 				     cp->npages * page_size)) {
-2. 				return(FALSE);
-1. 			}

 /*clear buffer*/

1. 			memset(cp->delta_buf, 0, page_size / 4 * page_size);",Useful
"/************************************************************************
Flush the incremental page write filter's buffer.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
/*flush buffer*/,"-1. 		if (cp->npages == page_size / 4) {

 /*flush buffer*/

1. 			if (ds_write(dstfile, cp->delta_buf,
2. 				     cp->npages * page_size)) {
3. 				return(FALSE);
4. 			}",Useful
"/************************************************************************
Free the incremental page write filter's buffer.*/","-5. 	if (ds_write(dstfile, cp->delta_buf, cp->npages * page_size)) {
-4. 		return(FALSE);
-3. 	}
-2. 	return(TRUE);
-1. }

 /************************************************************************
Free the incremental page write filter's buffer.*/

1. st",Useful
"/************************************************************************
Initialize the write-through page write filter.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
"/************************************************************************
Write the next batch of pages to the destination datasink.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
/*HAVE_SYS_FILE_H*/,"-10.    is generally kept in a file called COPYING or LICENSE.  If you do not
-9.    have a copy of the license, write to the Free Software Foundation,
-8.    51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA. */
-7. #define READLINE_LIBRARY
-6",Useful
/*HAVE_UNISTD_H*/,"
#if defined (HAVE_UNISTD_H)



 /*HAVE_UNISTD_H*/

1. #  include <unistd.h>",Useful
/*HAVE_STDLIB_H*/,"
#if defined (HAVE_STDLIB_H)



 /*HAVE_STDLIB_H*/

1. #  include <stdlib.h>
2. #else
3. #  include ""ansi_stdlib.h""",Useful
/*Line editing input utility*/,"-9. static char *readline_internal PARAMS((void));
-8. static void readline_initialize_everything PARAMS((void));
-7. static void bind_arrow_keys_internal PARAMS((Keymap));
-6. static void bind_arrow_keys PARAMS((void));
-5. static void readline_default_b",Useful
/*True if this is `real' readline as opposed to some stub substitute.*/,"-2. const char *rl_library_version = RL_LIBRARY_VERSION;
-1. int rl_readline_version = RL_READLINE_VERSION;

 /*True if this is `real' readline as opposed to some stub substitute.*/

1. int rl_gnu_readline_p = 1;",Useful
"/*A pointer to the keymap that is currently in use.
   By default, it is the standard emacs keymap.*/","-1. int rl_gnu_readline_p = 1;

 /*A pointer to the keymap that is currently in use.
   By default, it is the standard emacs keymap.*/

1. Keymap _rl_keymap = emacs_standard_keymap;",Useful
/*The current insert mode:  input (the default) or overwrite*/,"-1. int rl_editing_mode = emacs_mode;

 /*The current insert mode:  input (the default) or overwrite*/

1. int rl_insert_mode = RL_IM_DEFAULT;",Useful
"/*Non-zero if we called this function from _rl_dispatch().  It's present
   so functions can find out whether they were called from a key binding
   or directly from an application.*/","-1. int rl_insert_mode = RL_IM_DEFAULT;

 /*Non-zero if we called this function from _rl_dispatch().  It's present
   so functions can find out whether they were called from a key binding
   or directly from an application.*/

1. int rl_dispatching;",Useful
/*Non-zero if an argument was typed.*/,"-1. int rl_numeric_arg = 1;

 /*Non-zero if an argument was typed.*/

1. int rl_explicit_arg = 0;",Useful
/*Temporary value used while generating the argument.*/,"-1. int rl_explicit_arg = 0;

 /*Temporary value used while generating the argument.*/

1. int rl_arg_sign = 1;",Useful
"/*If non-zero, this program is running in an EMACS buffer.*/","-2. static int rl_initialized;
-1. #if 0

 /*If non-zero, this program is running in an EMACS buffer.*/

1. static int running_in_emacs;
2. #endif",Useful
/*Flags word encapsulating the current readline state.*/,"-2. static int running_in_emacs;
-1. #endif

 /*Flags word encapsulating the current readline state.*/

1. int rl_readline_state = RL_STATE_NONE;",Useful
/*The current offset in the current input line.*/,"-1. int rl_readline_state = RL_STATE_NONE;

 /*The current offset in the current input line.*/

1. int rl_point;",Useful
/*Mark in the current input line.*/,"-1. int rl_point;

 /*Mark in the current input line.*/

1. int rl_mark;",Useful
/*Length of the current input line.*/,"-1. int rl_mark;

 /*Length of the current input line.*/

1. int rl_end;",Useful
/*Make this non-zero to return the current input_line.*/,"-1. int rl_end;

 /*Make this non-zero to return the current input_line.*/

1. int rl_done;",Useful
/*The last function executed by readline.*/,"-1. int rl_done;

 /*The last function executed by readline.*/

1. rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;",Useful
/*Top level environment for readline_internal ().*/,"-1. rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;

 /*Top level environment for readline_internal ().*/

1. procenv_t readline_top_level;",Useful
/*The names of the streams that we do input and output to.*/,"-1. FILE *_rl_in_stream, *_rl_out_stream;

 /*The names of the streams that we do input and output to.*/

1. FILE *rl_instream = (FILE *)NULL;
2. FILE *rl_outstream = (FILE *)NULL;",Useful
"/*Non-zero means echo characters as they are read.  Defaults to no echo;
   set to 1 if there is a controlling terminal, we can get its attributes,
   and the attributes include `echo'.  Look at rltty.c:prepare_terminal_settings
   for the code that sets it.*/","-2. FILE *rl_instream = (FILE *)NULL;
-1. FILE *rl_outstream = (FILE *)NULL;

 /*Non-zero means echo characters as they are read.  Defaults to no echo;
   set to 1 if there is a controlling terminal, we can get its attributes,
   and the attributes includ",Useful
"/*Set to non-zero by calling application if it has already printed rl_prompt
   and does not want readline to do it the first time.*/","-2. char *rl_prompt = (char *)NULL;
-1. int rl_visible_prompt_length = 0;

 /*Set to non-zero by calling application if it has already printed rl_prompt
   and does not want readline to do it the first time.*/

1. int rl_already_prompted = 0;",Useful
/*The number of characters read in order to type this complete command.*/,"-1. int rl_already_prompted = 0;

 /*The number of characters read in order to type this complete command.*/

1. int rl_key_sequence_length = 0;",Useful
"/*If non-zero, then this is the address of a function to call just
   before readline_internal_setup () prints the first prompt.*/","-1. int rl_key_sequence_length = 0;

 /*If non-zero, then this is the address of a function to call just
   before readline_internal_setup () prints the first prompt.*/

1. rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;",Useful
"/*If non-zero, this is the address of a function to call just before
   readline_internal_setup () returns and readline_internal starts
   reading input characters.*/","-1. rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;

 /*If non-zero, this is the address of a function to call just before
   readline_internal_setup () returns and readline_internal starts
   reading input characters.*/

1. rl_hook_func_t *rl_p",Useful
"/*The character that can generate an EOF.  Really read from
   the terminal driver... just defaulted here.*/","-1. static char *the_line;

 /*The character that can generate an EOF.  Really read from
   the terminal driver... just defaulted here.*/

1. int _rl_eof_char = CTRL ('D');",Useful
/*Non-zero makes this the next keystroke to read.*/,"-1. int _rl_eof_char = CTRL ('D');

 /*Non-zero makes this the next keystroke to read.*/

1. int rl_pending_input = 0;",Useful
/*Pointer to a useful terminal name.*/,"-1. int rl_pending_input = 0;

 /*Pointer to a useful terminal name.*/

1. const char *rl_terminal_name = (const char *)NULL;",Useful
/*Non-zero means to always use horizontal scrolling in line display.*/,"-1. const char *rl_terminal_name = (const char *)NULL;

 /*Non-zero means to always use horizontal scrolling in line display.*/

1. int _rl_horizontal_scroll_mode = 0;",Useful
"/*Non-zero means to display an asterisk at the starts of history lines
   which have been modified.*/","-1. int _rl_horizontal_scroll_mode = 0;

 /*Non-zero means to display an asterisk at the starts of history lines
   which have been modified.*/

1. int _rl_mark_modified_lines = 0;",Useful
"/*The style of `bell' notification preferred.  This can be set to NO_BELL,
   AUDIBLE_BELL, or VISIBLE_BELL.*/","-1. int _rl_mark_modified_lines = 0;

 /*The style of `bell' notification preferred.  This can be set to NO_BELL,
   AUDIBLE_BELL, or VISIBLE_BELL.*/

1. int _rl_bell_preference = AUDIBLE_BELL;",Useful
/*String inserted into the line by rl_insert_comment ().*/,"-1. int _rl_bell_preference = AUDIBLE_BELL;

 /*String inserted into the line by rl_insert_comment ().*/

1. char *_rl_comment_begin;",Useful
/*Line buffer and maintenence.*/,"-1. int rl_num_chars_to_read;

 /*Line buffer and maintenence.*/

1. char *rl_line_buffer = (char *)NULL;
2. int rl_line_buffer_len = 0;",Useful
"/*Forward declarations used by the display, termcap, and history code.*/","-1. _rl_keyseq_cxt *_rl_kscxt = 0;

 /*Forward declarations used by the display, termcap, and history code.*/

111",Useful
"/*Non-zero means to convert characters with the meta bit set to
   escape-prefixed characters so we can indirect through
   emacs_meta_keymap or vi_escape_keymap.*/","-10. _rl_keyseq_cxt *_rl_kscxt = 0;

 /*Non-zero means to convert characters with the meta bit set to
   escape-prefixed characters so we can indirect through
   emacs_meta_keymap or vi_escape_keymap.*/

1. int _rl_convert_meta_chars_to_ascii = 1;",Useful
"/*Non-zero means to output characters with the meta bit set directly
   rather than as a meta-prefixed escape sequence.*/","-1. int _rl_convert_meta_chars_to_ascii = 1;

 /*Non-zero means to output characters with the meta bit set directly
   rather than as a meta-prefixed escape sequence.*/

1. int _rl_output_meta_chars = 0;",Useful
"/*Non-zero means to look at the termios special characters and bind
   them to equivalent readline functions at startup.*/","-1. int _rl_output_meta_chars = 0;

 /*Non-zero means to look at the termios special characters and bind
   them to equivalent readline functions at startup.*/

1. int _rl_bind_stty_chars = 1;",Useful
/*Non-zero means treat 0200 bit in terminal input as Meta bit.*/,"-6. int _rl_bind_stty_chars = 1;

 /*Non-zero means treat 0200 bit in terminal input as Meta bit.*/

111",Useful
"/*Set up the prompt and expand it.  Called from readline() and
   rl_callback_handler_install ().*/","-8. int _rl_bind_stty_chars = 1;

 /*Set up the prompt and expand it.  Called from readline() and
   rl_callback_handler_install ().*/

1. int
2. rl_set_prompt (prompt)
3.      const char *prompt;
4. {
5.   FREE (rl_prompt);
6.   rl_prompt = prompt ? save",Useful
"/*Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
   none.  A return value of NULL means that EOF was encountered.*/","-10. int
-9. rl_set_prompt (prompt)
-8.      const char *prompt;
-7. {
-6.   FREE (rl_prompt);
-5.   rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
-4.   rl_display_prompt = rl_prompt ? rl_prompt : (char*) """";
-3.   rl_visible_prompt_length = rl",Useful
/*If we are at EOF return a NULL string.*/,"-5. char *
-4. readline (prompt)
-3.      const char *prompt;
-2. {
-1.   char *value;

 /*If we are at EOF return a NULL string.*/

1.   if (rl_pending_input == EOF)
2.     {
3.       rl_clear_pending_input ();
4.       return ((char *)NULL);
5.     }
6.",Useful
"/*Restore normal cursor, if available.*/","-2.   if (rl_undo_list)
-1.     rl_free_undo_list ();

 /*Restore normal cursor, if available.*/

1.   _rl_set_insert_mode (RL_IM_INSERT, 0);
2.   return (eof ? (char *)NULL : savestring (the_line));
3. }
4. void
5. _rl_internal_char_cleanup ()
6. {
7. #i",Useful
"/*In vi mode, when you exit insert mode, the cursor moves back
     over the previous character.  We explicitly check for that here.*/","-7.   _rl_set_insert_mode (RL_IM_INSERT, 0);
-6.   return (eof ? (char *)NULL : savestring (the_line));
-5. }
-4. void
-3. _rl_internal_char_cleanup ()
-2. {
-1. #if defined (VI_MODE)

 /*In vi mode, when you exit insert mode, the cursor moves back
     o",Useful
"/*look at input.c:rl_getc() for the circumstances under which this will
	 be returned; punt immediately on read error without converting it to
	 a newline.*/","-6. 	  _rl_reset_argument ();
-5. 	  rl_key_sequence_length = 0;
-4. 	}
-3.       RL_SETSTATE(RL_STATE_READCMD);
-2.       c = rl_read_key ();
-1.       RL_UNSETSTATE(RL_STATE_READCMD);

 /*look at input.c:rl_getc() for the circumstances under which this ",Useful
"/*The character _rl_eof_char typed to blank line, and not as the
	 previous character is interpreted as EOF.*/","-2.       if (c == EOF && rl_end)
-1. 	c = NEWLINE;

 /*The character _rl_eof_char typed to blank line, and not as the
	 previous character is interpreted as EOF.*/

1.       if (((c == _rl_eof_char && lastc != c) || c == EOF) && !rl_end)
2. 	{
3. #if def",Useful
"/*If there was no change in _rl_last_command_was_kill, then no kill
	 has taken place.  Note that if input is pending we are reading
	 a prefix command, so nothing has changed yet.*/","-10. #if defined (READLINE_CALLBACKS)
-9. 	  RL_SETSTATE(RL_STATE_DONE);
-8. 	  return (rl_done = 1);
-7. #else
-6. 	  eof_found = 1;
-5. 	  break;
-4. #endif
-3. 	}
-2.       lastc = c;
-1.       _rl_dispatch ((unsigned char)c, _rl_keymap);

 /*If there ",Useful
"/*Read a line of input from the global rl_instream, doing output on
   the global rl_outstream.
   If rl_prompt is non-null, then that is our prompt.*/","-10. #if defined (READLINE_CALLBACKS)
-9. static int
-8. readline_internal_charloop ()
-7. {
-6.   int eof = 1;
-5.   while (rl_done == 0)
-4.     eof = readline_internal_char ();
-3.   return (eof);
-2. }

 /*Read a line of input from the global rl_instr",Useful
/*sentinel value*/,"-10. }
-9. #if defined (READLINE_CALLBACKS)
-8. _rl_keyseq_cxt *
-7. _rl_keyseq_cxt_alloc ()
-6. {
-5.   _rl_keyseq_cxt *cxt;
-4.   cxt = (_rl_keyseq_cxt *)xmalloc (sizeof (_rl_keyseq_cxt));
-3.   cxt->flags = cxt->subseq_arg = cxt->subseq_retval = 0;
-2.",Useful
"/*The first time this context is used, we want to read input and dispatch
     on it.  When traversing the chain of contexts back `up', we want to use
     the value from the next context down.  We're simulating recursion using
     a chain of contexts.*/","-1. #if 1

 /*The first time this context is used, we want to read input and dispatch
     on it.  When traversing the chain of contexts back `up', we want to use
     the value from the next context down.  We're simulating recursion using
     a chain of",Useful
/*success!*/,"-1.   r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));

 /*success!*/

1.     {
2.       _rl_keyseq_chain_dispose ();
3.       RL_UNSETSTATE (RL_STATE_MULTIKEY);
4.       return r;
5.     }",Useful
/*magic value that says we added to the chain*/,"-5.     {
-4.       _rl_keyseq_chain_dispose ();
-3.       RL_UNSETSTATE (RL_STATE_MULTIKEY);
-2.       return r;
-1.     }

 /*magic value that says we added to the chain*/

1.     _rl_kscxt = cxt->ocxt;
2.   if (_rl_kscxt)
3.     _rl_kscxt->childval = r",Useful
"/*Do the command associated with KEY in MAP.
   If the associated command is really a keymap, then read
   another key, and dispatch into that map.*/","-8.     _rl_kscxt = cxt->ocxt;
-7.   if (_rl_kscxt)
-6.     _rl_kscxt->childval = r;
-5.   if (r != -3)
-4.     _rl_keyseq_cxt_dispose (cxt);
-3.   return r;
-2. }

 /*Do the command associated with KEY in MAP.
   If the associated command is really a key",Useful
/*Special case rl_do_lowercase_version ().*/,"-10.     }
-9.   if (RL_ISSTATE (RL_STATE_MACRODEF))
-8.     _rl_add_macro_char (key);
-7.   r = 0;
-6.   switch (map[key].type)
-5.     {
-4.     case ISFUNC:
-3.       func = map[key].function;
-2.       if (func)
-1. 	{

 /*Special case rl_do_lowercase",Useful
"/*OK, there's no function bound in this map, but there is a
	     shadow function that was overridden when the current keymap
	     was created.  Return -2 to note  that.*/","-5. 	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
-4. 	    rl_last_func = map[key].function;
-3. 	}
-2.       else if (map[ANYOTHERKEY].function)
-1. 	{

 /*OK, there's no function bound in this map, but there is a
	     shadow f",Useful
"/*Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recursion chain and find the last
	     subsequence that is bound to a function.*/","-5. 	  _rl_unget_char  (key);
-4. 	  return -2;
-3. 	}
-2.       else if (got_subseq)
-1. 	{

 /*Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recur",Useful
"/*The only way this test will be true is if a subsequence has been
	     bound starting with ESC, generally the arrow keys.  What we do is
	     check whether there's input in the queue, which there generally
	     will be if an arrow key has been pressed, and, if there's not,
	     just dispatch to (what we assume is) rl_vi_movement_mode right
	     away.  This is essentially an input test with a zero timeout.*/","-10. 	  _rl_keyseq_chain_dispose ();
-9. #endif
-8. 	  _rl_abort_internal ();
-7. 	  return -1;
-6. 	}
-5.       break;
-4.     case ISKMAP:
-3.       if (map[key].function != 0)
-2. 	{
-1. #if defined (VI_MODE)

 /*The only way this test will be true is ",Useful
"/*Allocate new context here.  Use linked contexts (linked through
	     cxt->ocxt) to simulate recursion*/","-10. 	     check whether there's input in the queue, which there generally
-9. 	     will be if an arrow key has been pressed, and, if there's not,
-8. 	     just dispatch to (what we assume is) rl_vi_movement_mode right
-7. 	     away.  This is essential",Useful
"/*Return 0 only the first time, to indicate success to
		 _rl_callback_read_char.  The rest of the time, we're called
		 from _rl_dispatch_callback, so we return 3 to indicate
		 special handling is necessary.*/","-3. #if defined (READLINE_CALLBACKS)
-2. 	  if (RL_ISSTATE (RL_STATE_CALLBACK))
-1. 	    {

 /*Return 0 only the first time, to indicate success to
		 _rl_callback_read_char.  The rest of the time, we're called
		 from _rl_dispatch_callback, so we return ",Useful
/*don't indicate immediate success*/,"-10. 	      r = RL_ISSTATE (RL_STATE_MULTIKEY) ? -3 : 0;
-9. 	      cxt = _rl_keyseq_cxt_alloc ();
-8. 	      if (got_subseq)
-7. 		cxt->flags |= KSEQ_SUBSEQ;
-6. 	      cxt->okey = key;
-5. 	      cxt->oldmap = map;
-4. 	      cxt->dmap = _rl_dispatching",Useful
"/*We didn't match anything, and the keymap we're indexed into
       shadowed a function previously bound to that prefix.  Call
       the function.  The recursive call to _rl_dispatch_subseq has
       already taken care of pushing any necessary input back onto
       the input queue with _rl_unget_char.*/","-10. static int
-9. _rl_subseq_result (r, map, key, got_subseq)
-8.      int r;
-7.      Keymap map;
-6.      int key, got_subseq;
-5. {
-4.   Keymap m;
-3.   int type, nt;
-2.   rl_command_func_t *func, *nf;
-1.   if (r == -2)

 /*We didn't match anythin",Useful
"/*If the function that was shadowed was self-insert, we
	     somehow need a keymap with map[key].func == self-insert.
	     Let's use this one.*/","-10.        already taken care of pushing any necessary input back onto
-9.        the input queue with _rl_unget_char. */
-8.     {
-7.       m = _rl_dispatching_keymap;
-6.       type = m[ANYOTHERKEY].type;
-5.       func = m[ANYOTHERKEY].function;
-4. ",Useful
"/*We didn't match (r is probably -1), so return something to
	 tell the caller that it should try ANYOTHERKEY for an
	 overridden function.*/","-10. 	  m[key].function = func;
-9. 	  r = _rl_dispatch (key, m);
-8. 	  m[key].type = nt;
-7. 	  m[key].function = nf;
-6. 	}
-5.       else
-4. 	r = _rl_dispatch (ANYOTHERKEY, m);
-3.     }
-2.   else if (r && map[ANYOTHERKEY].function)
-1.     {

 /*We",Useful
"/*OK, back up the chain.*/","-6.       _rl_unget_char (key);
-5.       _rl_dispatching_keymap = map;
-4.       return -2;
-3.     }
-2.   else if (r && got_subseq)
-1.     {

 /*OK, back up the chain.*/

1.       _rl_unget_char (key);
2.       _rl_dispatching_keymap = map;
3.       r",Useful
"/*If we have never been called before, initialize the
     terminal and data structures.*/","-3. int
-2. rl_initialize ()
-1. {

 /*If we have never been called before, initialize the
     terminal and data structures.*/

1.   if (!rl_initialized)
2.     {
3.       RL_SETSTATE(RL_STATE_INITIALIZING);
4.       readline_initialize_everything ();
5.",Useful
/*Initalize the current line information.*/,"-8.   if (!rl_initialized)
-7.     {
-6.       RL_SETSTATE(RL_STATE_INITIALIZING);
-5.       readline_initialize_everything ();
-4.       RL_UNSETSTATE(RL_STATE_INITIALIZING);
-3.       rl_initialized++;
-2.       RL_SETSTATE(RL_STATE_INITIALIZED);
-1.   ",Useful
/*Make the display buffer match the state of the line.*/,"-1.   _rl_start_using_history ();

 /*Make the display buffer match the state of the line.*/

1.   rl_reset_line_state ();",Useful
/*Parsing of key-bindings begins in an enabled state.*/,"-1.   rl_last_func = (rl_command_func_t *)NULL;

 /*Parsing of key-bindings begins in an enabled state.*/

1.   _rl_parsing_conditionalized_out = 0;
2. #if defined (VI_MODE)
3.   if (rl_editing_mode == vi_mode)
4.     _rl_vi_initialize_line ();
5. #endif",Useful
/*Initialize the entire state of the world.*/,"-1. #endif

 /*Initialize the entire state of the world.*/

1. static void
2. readline_initialize_everything ()
3. {
4. #if 0
5. #if defined (__EMX__)
6.   if (environ == 0)
7.     _emx_build_environ ();
8. #endif
9. #endif
10. #if 0",Useful
/*Set up input and output if they are not already set up.*/,"-2.   running_in_emacs = sh_get_env_value (""EMACS"") != (char *)0;
-1. #endif

 /*Set up input and output if they are not already set up.*/

1.   if (!rl_instream)
2.     rl_instream = stdin;
3.   if (!rl_outstream)
4.     rl_outstream = stdout;",Useful
"/*Bind _rl_in_stream and _rl_out_stream immediately.  These values
     may change, but they may also be used before readline_internal ()
     is called.*/","-4.   if (!rl_instream)
-3.     rl_instream = stdin;
-2.   if (!rl_outstream)
-1.     rl_outstream = stdout;

 /*Bind _rl_in_stream and _rl_out_stream immediately.  These values
     may change, but they may also be used before readline_internal ()
     i",Useful
/*Allocate data structures.*/,"-2.   _rl_in_stream = rl_instream;
-1.   _rl_out_stream = rl_outstream;

 /*Allocate data structures.*/

1.   if (rl_line_buffer == 0)
2.     rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);",Useful
"/*Override the effect of any `set keymap' assignments in the
     inputrc file.*/","-5.   if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
-4.     {
-3.       _rl_screenwidth--;
-2.       _rl_screenchars -= _rl_screenheight;
-1.     }

 /*Override the effect of any `set keymap' assignments in the
     inputrc file.*/

1.   rl_set_key",Useful
"/*Try to bind a common arrow key prefix, if not already bound.*/","-1.   rl_set_keymap_from_edit_mode ();

 /*Try to bind a common arrow key prefix, if not already bound.*/

1.   bind_arrow_keys ();",Useful
"/*If the completion parser's default word break characters haven't
     been set yet, then do so now.*/","-2.   if (_rl_enable_meta)
-1.     _rl_enable_meta_key ();

 /*If the completion parser's default word break characters haven't
     been set yet, then do so now.*/

1.   if (rl_completer_word_break_characters == (char *)NULL)
2.     rl_completer_word_bre",Useful
"/*If this system allows us to look at the values of the regular
   input editing characters, then bind them to their readline
   equivalents, iff the characters are not bound to keymaps.*/","-3.   if (rl_completer_word_break_characters == (char *)NULL)
-2.     rl_completer_word_break_characters = (char *)rl_basic_word_break_characters;
-1. }

 /*If this system allows us to look at the values of the regular
   input editing characters, then bi",Useful
"/**
Perform read filter context initialization that is common to all read
filters.*/","-10. along with this program; if not, write to the Free Software
-9. Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA
-8. *******************************************************/
-7. /* Data file read filter implementation */",Useful
/*!<in/out: read filter context*/,"-4. static
-3. void
-2. common_init(

 /*!<in/out: read filter context*/

111",Useful
/*!<in: file cursor*/,"-5. static
-4. void
-3. common_init(

 /*!<in: file cursor*/

111",Useful
"/**
Initialize the pass-through read filter.*/","-10. /*========*/
-9. 	xb_read_filt_ctxt_t*	ctxt,	/*!<in/out: read filter context */
-8. 	const xb_fil_cur_t*	cursor)	/*!<in: file cursor */
-7. {
-6. 	ctxt->offset = 0;
-5. 	ctxt->data_file_size = cursor->statinfo.st_size;
-4. 	ctxt->buffer_capacity = cu",Useful
/*!<in/out: read filter context*/,"-4. static
-3. void
-2. common_init(

 /*!<in/out: read filter context*/

111",Useful
/*!<in: file cursor*/,"-5. static
-4. void
-3. common_init(

 /*!<in: file cursor*/

111",Useful
"/**
Get the next batch of pages for the pass-through read filter.*/","-10. rf_pass_through_init(
-9. /*=================*/
-8. 	xb_read_filt_ctxt_t*	ctxt,	/*!<in/out: read filter context */
-7. 	const xb_fil_cur_t*	cursor,	/*!<in: file cursor */
-6. 	ulint			space_id __attribute__((unused)))
-5. 					/*!<in: space id we are",Useful
"/*!<in/out: read filter
							context*/","-4. static
-3. void
-2. rf_pass_through_get_next_batch(

 /*!<in/out: read filter
							context*/

111",Useful
"/*!<out: starting read
							offset in bytes for the
							next batch of pages*/","-6. static
-5. void
-4. rf_pass_through_get_next_batch(

 /*!<out: starting read
							offset in bytes for the
							next batch of pages*/

111",Useful
"/*!<out: length in
							bytes of the next batch
							of pages*/","-10. Get the next batch of pages for the pass-through read filter.  */
-9. static
-8. void
-7. rf_pass_through_get_next_batch(

 /*!<out: length in
							bytes of the next batch
							of pages*/

111",Useful
/*!<in: read filter context*/,"-1. 	xb_read_filt_ctxt_t*	ctxt __attribute__((unused)))

 /*!<in: read filter context*/

111",Useful
/*!<in: read cursor*/,"-6. static
-5. void
-4. rf_bitmap_init(

 /*!<in: read cursor*/

111",Useful
"/*!<out: starting read
							offset in bytes for the
							next batch of pages*/","-6. static
-5. void
-4. rf_pass_through_get_next_batch(

 /*!<out: starting read
							offset in bytes for the
							next batch of pages*/

111",Useful
"/*!<out: length in
							bytes of the next batch
							of pages*/","-10. Get the next batch of pages for the pass-through read filter.  */
-9. static
-8. void
-7. rf_pass_through_get_next_batch(

 /*!<out: length in
							bytes of the next batch
							of pages*/

111",Useful
"/*Used up all the previous bitmap range, get some more*/","-6. {
-5. 	ulint	start_page_id;
-4. 	const ulint	page_size	= ctxt->page_size;
-3. 	start_page_id = (ulint)(ctxt->offset / page_size);
-2. 	xb_a (ctxt->offset % page_size == 0);
-1. 	if (start_page_id == ctxt->filter_batch_end) {

 /*Used up all the previo",Useful
"/*Find the end of the current changed page block by searching
		for the next cleared bitmap bit*/","-7. 		next_page_id = xb_page_bitmap_range_get_next_bit
-6. 			(ctxt->bitmap_range, TRUE);
-5. 		if (next_page_id == ULINT_UNDEFINED) {
-4. 			*read_batch_len = 0;
-3. 			return;
-2. 		}
-1. 		ctxt->offset = next_page_id * page_size;

 /*Find the end of th",Useful
"/*If the page block is larger than the buffer capacity, limit it to
	buffer capacity.  The subsequent invocations will continue returning
	the current block in buffer-sized pieces until ctxt->filter_batch_end
	is reached, trigerring the next bitmap query.*/","-5. 		*read_batch_len = ctxt->data_file_size - ctxt->offset;
-4. 	} else {
-3. 		*read_batch_len = ctxt->filter_batch_end * page_size
-2. 			- ctxt->offset;
-1. 	}

 /*If the page block is larger than the buffer capacity, limit it to
	buffer capacity.  Th",Useful
/*!<in/out: read filter context*/,"-4. static
-3. void
-2. common_init(

 /*!<in/out: read filter context*/

111",Useful
/*The pass-through read filter*/,"-3. {
-2. 	xb_page_bitmap_range_deinit(ctxt->bitmap_range);
-1. }

 /*The pass-through read filter*/

1. xb_read_filt_t rf_pass_through = {
2. 	&rf_pass_through_init,
3. 	&rf_pass_through_get_next_batch,
4. 	&rf_pass_through_deinit
5. };",Useful
"/***********************************************************************
Store Galera checkpoint info in the 'xtrabackup_galera_info' file, if that
information is present in the trx system header. Otherwise, do nothing.*/","-1. #define XB_GALERA_INFO_FILENAME ""xtrabackup_galera_info""

 /***********************************************************************
Store Galera checkpoint info in the 'xtrabackup_galera_info' file, if that
information is present in the trx system hea",Useful
"/*Do not overwrite existing an existing file to be compatible with
	servers with older server versions*/","-6. {
-5. 	FILE*		fp;
-4. 	XID		xid;
-3. 	char		uuid_str[40];
-2. 	long long	seqno;
-1. 	MY_STAT		statinfo;

 /*Do not overwrite existing an existing file to be compatible with
	servers with older server versions*/

1. 	if (!incremental_prepare &&
2. 		my",Useful
/*Calculate size of data without trailing zero bytes.*/,"-10. 	local_file->fd = fd;
-9. 	local_file->init_ibd_done = 0;
-8. 	local_file->is_ibd = (path_len > 5) && !strcmp(fullpath + path_len - 5, "".ibd"");
-7. 	local_file->compressed = 0;
-6. 	local_file->pagesize = 0;
-5. 	file->path = (char *) local_file + si",Useful
"/*Calculate Innodb tablespace specific data, when first page is written.
   We're interested in page compression and page size.*/","-10. 			size_t hole_bytes = n_bytes - datasize;
-9. 			if (my_seek(fd, hole_bytes, MY_SEEK_CUR, MYF(MY_WME | MY_NABP))
-8. 				== MY_FILEPOS_ERROR)
-7. 			 return 1;
-6. 		}
-5. 		written += n_bytes;
-4. 		ptr += n_bytes;
-3. 	}
-2. 	return 0;
-1. }
/* Ca",Useful
"/*Make compressed file sparse, on Windows.
	In 10.1, we do not use sparse files.*/","-9. 		return;
-8. 	}
-7. 	auto flags = mach_read_from_4(&buf[FIL_PAGE_DATA + FSP_SPACE_FLAGS]);
-6. 	auto ssize = FSP_FLAGS_GET_PAGE_SSIZE(flags);
-5. 	local_file->pagesize= ssize == 0 ? UNIV_PAGE_SIZE_ORIG : ((UNIV_ZIP_SIZE_MIN >> 1) << ssize);
-4. 	loca",Useful
"/***********************************************************************
General streaming interface*/","-10. #include ""xbstream.h""
-9. typedef struct {
-8. 	xb_wstream_t	*xbstream;
-7. 	ds_file_t	*dest_file;
-6. 	pthread_mutex_t	mutex;
-5. } ds_stream_ctxt_t;
-4. typedef struct {
-3. 	xb_wstream_file_t	*xbstream_file;
-2. 	ds_stream_ctxt_t	*stream_ctxt;
-1.",Useful
"/*Create a temporary file in tmpdir. The file will be automatically
	removed on close. Code copied from mysql_tmpfile().*/","-10. static ds_file_t *
-9. tmpfile_open(ds_ctxt_t *ctxt, const char *path,
-8. 			       MY_STAT *mystat)
-7. {
-6. 	ds_tmpfile_ctxt_t	*tmpfile_ctxt;
-5. 	char			 tmp_path[FN_REFLEN];
-4. 	ds_tmp_file_t		*tmp_file;
-3. 	ds_file_t		*file;
-2. 	size_t			 p",Useful
/*terminating '\0'*/,"-6. 	fd = create_temp_file(tmp_path,xtrabackup_tmpdir,
-5. 			      ""xbtemp"", O_BINARY | O_SEQUENTIAL,
-4. 			      MYF(MY_WME | MY_TEMPORARY));
-3. 	if (fd < 0) {
-2. 		return NULL;
-1. 	}

 /*terminating '\0'*/

1. 	file = (ds_file_t *) my_malloc(PSI_NO",Useful
/*Store the file object in the list to be piped later*/,"-2. 	file->path = my_strdup(PSI_NOT_INSTRUMENTED, tmp_path, MYF(MY_FAE));
-1. 	file->ptr = tmp_file;

 /*Store the file object in the list to be piped later*/

1. 	tmpfile_ctxt = (ds_tmpfile_ctxt_t *) ctxt->ptr;
2. 	tmp_file->list.data = tmp_file;
3. 	pth",Useful
"/*Do nothing -- we will close (and thus remove) the file after piping
	it to the destination datasink in tmpfile_deinit().*/","-10. 	File fd = ((ds_tmp_file_t *) file->ptr)->fd;
-9. 	if (!my_write(fd, buf, len, MYF(MY_WME | MY_NABP))) {
-8. 		posix_fadvise(fd, 0, 0, POSIX_FADV_DONTNEED);
-7. 		return 0;
-6. 	}
-5. 	return 1;
-4. }
-3. static int
-2. tmpfile_close(ds_file_t *file)",Useful
"/*Stat the file to replace size and mtime on the original
		* mystat struct*/","-3. 	list = list_reverse(list);
-2. 	while (list != NULL) {
-1. 		tmp_file = (ds_tmp_file_t *)list->data;

 /*Stat the file to replace size and mtime on the original
		* mystat struct*/

1. 		if (my_fstat(tmp_file->fd, &mystat, MYF(0))) {
2. 			die(""my_fs",Useful
/*copy to the destination datasink*/,"-10. 			die(""my_fstat() failed."");
-9. 		}
-8. 		tmp_file->mystat.st_size = mystat.st_size;
-7. 		tmp_file->mystat.st_mtime = mystat.st_mtime;
-6. 		dst_file = ds_open(pipe_ctxt, tmp_file->orig_path,
-5. 				   &tmp_file->mystat);
-4. 		if (dst_file == NU",Useful
/*Size of read buffer in pages (640 pages = 10M for 16K sized pages)*/,"-10. #include <fsp0fsp.h>
-9. #include <srv0start.h>
-8. #include <trx0sys.h>
-7. #include ""fil_cur.h""
-6. #include ""fil0crypt.h""
-5. #include ""fil0pagecompress.h""
-4. #include ""common.h""
-3. #include ""read_filt.h""
-2. #include ""xtrabackup.h""
-1. #include",Useful
"/***********************************************************************
Extracts the relative path (""database/table.ibd"") of a tablespace from a
specified possibly absolute path.

For user tablespaces both ""./database/table.ibd"" and
""/remote/dir/database/table.ibd"" result in ""database/table.ibd"".

For system tablepsaces (i.e. When is_system is TRUE) both ""/remote/dir/ibdata1""
and ""./ibdata1"" yield ""ibdata1"" in the output.*/","-1. #define XB_FIL_CUR_PAGES 640

 /***********************************************************************
Extracts the relative path (""database/table.ibd"") of a tablespace from a
specified possibly absolute path.

For user tablespaces both ""./database/t",Useful
"/*!< in: tablespace path (either
			  		relative or absolute)*/","-3. const char *
-2. xb_get_relative_path(

 /*!< in: tablespace path (either
			  		relative or absolute)*/

111",Useful
"/*!< in: TRUE for system tablespaces,
					i.e. when only the filename must be
					returned.*/","-10. specified possibly absolute path.
-9. For user tablespaces both ""./database/table.ibd"" and
-8. ""/remote/dir/database/table.ibd"" result in ""database/table.ibd"".
-7. For system tablepsaces (i.e. When is_system is TRUE) both ""/remote/dir/ibdata1""
-6. an",Useful
"/************************************************************************
Open a source file cursor and initialize the associated read filter.

@return XB_FIL_CUR_SUCCESS on success, XB_FIL_CUR_SKIP if the source file must
be skipped and XB_FIL_CUR_ERROR on error.*/","-10. 	mysql_mutex_lock(&fil_system.mutex);
-9. 	ut_ad(node);
-8. 	ut_a(!node->being_extended);
-7. 	if (node->is_open()) {
-6. 		ret = os_file_close(node->handle);
-5. 		ut_a(ret);
-4. 		node->handle = OS_FILE_CLOSED;
-3. 	}
-2. 	mysql_mutex_unlock(&fil_s",Useful
/*!< out: source file cursor*/,"-3. xb_fil_cur_result_t
-2. xb_fil_cur_open(

 /*!< out: source file cursor*/

111",Useful
/*!< in: source tablespace node*/,"-5. xb_fil_cur_result_t
-4. xb_fil_cur_open(

 /*!< in: source tablespace node*/

111",Useful
/*!< thread number for diagnostics*/,"-6. xb_fil_cur_result_t
-5. xb_fil_cur_open(

 /*!< thread number for diagnostics*/

1. 	ulonglong max_file_size)
2. {
3. 	bool	success;
4. 	int err;",Useful
"/*Initialize these first so xb_fil_cur_close() handles them correctly
	in case of error*/","-4. 	ulonglong max_file_size)
-3. {
-2. 	bool	success;
-1. 	int err;

 /*Initialize these first so xb_fil_cur_close() handles them correctly
	in case of error*/

1. 	cursor->buf = NULL;
2. 	cursor->node = NULL;
3. 	cursor->space_id = node->space->id;
4. 	",Useful
"/*Get the relative path for the destination tablespace name, i.e. the
	one that can be appended to the backup root directory. Non-system
	tablespaces may have absolute paths for DATA DIRECTORY.
	We want to make ""local"" copies for the backup.*/","-5. 	cursor->buf = NULL;
-4. 	cursor->node = NULL;
-3. 	cursor->space_id = node->space->id;
-2. 	strncpy(cursor->abs_path, node->name, (sizeof cursor->abs_path) - 1);
-1. 	cursor->abs_path[(sizeof cursor->abs_path) - 1] = '\0';

 /*Get the relative path f",Useful
"/*In the backup mode we should already have a tablespace handle created
	by fil_ibd_load() unless it is a system
	tablespace. Otherwise we open the file here.*/","-4. 	strncpy(cursor->rel_path,
-3. 		xb_get_relative_path(cursor->abs_path, cursor->is_system()),
-2. 		(sizeof cursor->rel_path) - 1);
-1. 	cursor->rel_path[(sizeof cursor->rel_path) - 1] = '\0';

 /*In the backup mode we should already have a tablespace",Useful
/*The following call prints an error message*/,"-10. 	tablespace. Otherwise we open the file here. */
-9. 	if (!node->is_open()) {
-8. 		ut_ad(cursor->is_system()
-7. 		      || srv_operation == SRV_OPERATION_RESTORE_DELTA
-6. 		      || xb_close_files);
-5. 		node->handle = os_file_create_simple_no_er",Useful
/*Allocate read buffer*/,"-10. 		xb_fil_cur_close(cursor);
-9. 		return(XB_FIL_CUR_SKIP);
-8. 	}
-7. 	if (srv_file_flush_method == SRV_O_DIRECT
-6. 	    || srv_file_flush_method == SRV_O_DIRECT_NO_FSYNC) {
-5. 		os_file_set_nocache(cursor->file, node->name, ""OPEN"");
-4. 	}
-3. 	po",Useful
/*We ignore the doublewrite buffer pages.*/,"-10. 	return(XB_FIL_CUR_SUCCESS);
-9. }
-8. static bool page_is_corrupted(const byte *page, ulint page_no,
-7. 			      const xb_fil_cur_t *cursor,
-6. 			      const fil_space_t *space)
-5. {
-4. 	byte tmp_frame[UNIV_PAGE_SIZE_MAX];
-3. 	byte tmp_page[UN",Useful
"/*On pages that are not all zero, the
		page number must match.

		There may be a mismatch on tablespace ID,
		because files may be renamed during backup.
		We disable the page number check
		on the system tablespace, because it may consist
		of multiple files, and here we count the pages
		from the start of each file.)

		The first 38 and last 8 bytes are never encrypted.*/","-2. 	if (mach_read_from_4(page + FIL_PAGE_OFFSET) != page_no
-1. 	    && cursor->space_id != TRX_SYS_SPACE) {

 /*On pages that are not all zero, the
		page number must match.

		There may be a mismatch on tablespace ID,
		because files may be renamed dur",Useful
/*Whole zero page is valid.*/,"-10. 		from the start of each file.)
-9. 		The first 38 and last 8 bytes are never encrypted. */
-8. 		const ulint* p = reinterpret_cast<const ulint*>(page);
-7. 		const ulint* const end = reinterpret_cast<const ulint*>(
-6. 			page + page_size);
-5. 		do",Useful
"/*Validate encrypted pages. The first page is never encrypted.
	In the system tablespace, the first page would be written with
	FIL_PAGE_FILE_FLUSH_LSN at shutdown, and if the LSN exceeds
	4,294,967,295, the mach_read_from_4() below would wrongly
	interpret the page as encrypted. We prevent that by checking
	page_no first.*/","-5. 		return false;
-4. 	}
-3. 	if (space->full_crc32()) {
-2. 		return buf_page_is_corrupted(true, page, space->flags);
-1. 	}

 /*Validate encrypted pages. The first page is never encrypted.
	In the system tablespace, the first page would be written wit",Useful
"/*Compressed encrypted need to be decrypted
		and decompressed for verification.*/","-10. 	4,294,967,295, the mach_read_from_4() below would wrongly
-9. 	interpret the page as encrypted. We prevent that by checking
-8. 	page_no first. */
-7. 	if (page_no
-6. 	    && mach_read_from_4(page + FIL_PAGE_FILE_FLUSH_LSN_OR_KEY_VERSION)
-5. 	    ",Useful
"/************************************************************************
Reads and verifies the next block of pages from the source
file. Positions the cursor after the last read non-corrupted page.

@return XB_FIL_CUR_SUCCESS if some have been read successfully, XB_FIL_CUR_EOF
if there are no more pages to read and XB_FIL_CUR_ERROR on error.*/","
	ulonglong max_file_size)
{
	bool	success;
	int err;


 /************************************************************************
Reads and verifies the next block of pages from the source
file. Positions the cursor after the last read non-corrupted page.

@return XB_FIL_CUR_SUCCESS if some have been read successfully, XB_FIL_CUR_EOF
if there are no more pages to read and XB_FIL_CUR_ERROR on error.*/

1. xb_fil_cur_result_t xb_fil_cur_read(xb_fil_cur_t*	cursor,
2.                                     CorruptedPages &corrupted_pages)
3. {
4. 	byte*			page;
5. 	unsigned			i;
6. 	ulint			npages;
7. 	ulint			retry_count;
8. 	xb_fil_cur_result_t	ret;
9. 	ib_int64_t		offset;
10. 	ib_int64_t		to_read;",Useful
"/*check pages for corruption and re-read if necessary. i.e. in case of
	partially written pages*/","-10. 	cursor->buf_read = 0;
-9. 	cursor->buf_npages = 0;
-8. 	cursor->buf_offset = offset;
-7. 	cursor->buf_page_no = static_cast<unsigned>(offset / page_size);
-6. 	if (os_file_read(IORequestRead, cursor->file, cursor->buf, offset,
-5. 			  (ulint) to_re",Useful
"/************************************************************************
Close the source file cursor opened with xb_fil_cur_open() and its
associated read filter.*/","-10. 	mysql_mutex_lock(&fil_system.mutex);
-9. 	ut_ad(node);
-8. 	ut_a(!node->being_extended);
-7. 	if (node->is_open()) {
-6. 		ret = os_file_close(node->handle);
-5. 		ut_a(ret);
-4. 		node->handle = OS_FILE_CLOSED;
-3. 	}
-2. 	mysql_mutex_unlock(&fil_s",Useful
/*Allocate 1 MB for the payload buffer initially*/,"-10. GNU General Public License for more details.
-9. You should have received a copy of the GNU General Public License
-8. along with this program; if not, write to the Free Software
-7. Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  0211",Useful
"/*This is the only place where we expect EOF, so read with
	xb_read_full() rather than F_READ()*/","-10. xb_rstream_result_t
-9. xb_stream_read_chunk(xb_rstream_t *stream, xb_rstream_chunk_t *chunk)
-8. {
-7. 	uchar		tmpbuf[16];
-6. 	uchar		*ptr = tmpbuf;
-5. 	uint		pathlen;
-4. 	size_t		tbytes;
-3. 	ulonglong	ullval;
-2. 	File		fd = stream->fd;
-1. 	xb",Useful
/*Payload*/,"-8. 	if (chunk->pathlen > 0) {
-7. 		F_READ((uchar *) chunk->path, pathlen);
-6. 		stream->offset += pathlen;
-5. 	}
-4. 	chunk->path[pathlen] = '\0';
-3. 	if (chunk->type == XB_CHUNK_TYPE_EOF) {
-2. 		return XB_STREAM_READ_CHUNK;
-1. 	}

 /*Payload*/

1.",Useful
"/*Reasonable defaults for tgoto().  Readline currently only uses
         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
         change that later...*/","-10.       _rl_term_cr = ""\r"";
-9.       _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
-8.       _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
-7.       _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_ter",Useful
"/*""An application program can assume that the terminal can do
      character insertion if *any one of* the capabilities `IC',
      `im', `ic' or `ip' is provided.""  But we can't do anything if
      only `ip' is provided, so...*/","-2.   if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-1.     _rl_get_screen_size (tty, 0);

 /*""An application program can assume that the terminal can do
      character insertion if *any one of* the capabilities `IC',
      `im', `ic' or `ip' is pro",Useful
"/*Check to see if this terminal has a meta key and clear the capability
     variables if there is none.*/","-1.   _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);

 /*Check to see if this terminal has a meta key and clear the capability
     variables if there is none.*/

1.   term_has_meta = (tgetflag ((char *)""km"") || tgetflag ((char *)""",Useful
/*A function for the use of tputs ()*/,"-8. int
-7. rl_reset_terminal (terminal_name)
-6.      const char *terminal_name;
-5. {
-4.   _rl_screenwidth = _rl_screenheight = 0;
-3.   _rl_init_terminal_io (terminal_name);
-2.   return 0;
-1. }

 /*A function for the use of tputs ()*/

1. #ifdef _MI",Useful
/*Write COUNT characters from STRING to the output stream.*/,"-7. int
-6. _rl_output_character_function (c)
-5.      int c;
-4. {
-3.   return putc (c, _rl_out_stream);
-2. }

 /*Write COUNT characters from STRING to the output stream.*/

1. void
2. _rl_output_some_chars (string, count)
3.      const char *string;
4",Useful
/*Move the cursor back.*/,"-8. void
-7. _rl_output_some_chars (string, count)
-6.      const char *string;
-5.      int count;
-4. {
-3.   if (fwrite (string, 1, count, _rl_out_stream) != (size_t)count)
-2.     fprintf(stderr, ""Write failed\n"");
-1. }

 /*Move the cursor back.*/

1",Useful
/*Move to the start of the next line.*/,"-10. {
-9.   register int i;
-8.   if (_rl_term_backspace)
-7.     for (i = 0; i < count; i++)
-6.       tputs (_rl_term_backspace, 1, _rl_output_character_function);
-5.   else
-4.     for (i = 0; i < count; i++)
-3.       putc ('\b', _rl_out_stream);
-2",Useful
/*Ring the terminal bell.*/,"-3.   putc ('\n', _rl_out_stream);
-2.   return 0;
-1. }

 /*Ring the terminal bell.*/

1. int
2. rl_ding ()
3. {
4.   if (readline_echoing_p)
5.     {
6.       switch (_rl_bell_preference)
7.         {
8. 	case NO_BELL:
9. 	default:
10. 	  break;",Useful
"/*After initializing the function map, this is the index of the first
   program specific function.*/","-10. #include ""xmalloc.h""
-9. #ifdef __STDC__
-8. typedef int QSFUNC (const void *, const void *);
-7. #else
-6. typedef int QSFUNC ();
-5. #endif
-4. extern int _rl_qsort_string_compare PARAMS((char **, char **));
-3. FUNMAP **funmap;
-2. static int funm",Useful
/*Make the funmap contain all of the default entries.*/,"-10.       funmap_size += 64;
-9.       funmap = (FUNMAP **)xrealloc (funmap, funmap_size * sizeof (FUNMAP *));
-8.     }
-7.   funmap[funmap_entry] = (FUNMAP *)xmalloc (sizeof (FUNMAP));
-6.   funmap[funmap_entry]->name = name;
-5.   funmap[funmap_entry]",Useful
/*Make sure that the function map has been initialized.*/,"-5. const char **
-4. rl_funmap_names ()
-3. {
-2.   const char **result;
-1.   int result_size, result_index;

 /*Make sure that the function map has been initialized.*/

1.   rl_initialize_funmap ();
2.   for (result_index = result_size = 0, result = (c",Useful
/*log0online.h*/,"-6. #include ""changed_page_bitmap.h""
-5. #include ""common.h""
-4. #include ""xtrabackup.h""
-3. #include ""srv0srv.h""

 /*log0online.h*/

111",Useful
/*!< Name with full path*/,"-1. struct log_online_bitmap_file_t {

 /*!< Name with full path*/

111",Useful
/*!< Handle to opened file*/,"-2. struct log_online_bitmap_file_t {

 /*!< Handle to opened file*/

111",Useful
/*!< Dynamically-allocated array of info about individual files*/,"-2. struct log_online_bitmap_file_range_t {

 /*!< Dynamically-allocated array of info about individual files*/

1. 	struct files_t {",Useful
"/*!< Starting LSN of data in this
					file*/","-2. 	struct files_t {

 /*!< Starting LSN of data in this
					file*/

111",Useful
/*!< Sequence number of this file*/,"-4. 	struct files_t {

 /*!< Sequence number of this file*/

1. 	}	*files;
2. };",Useful
/*log0online.c*/,"-2. 	}	*files;
-1. };

 /*log0online.c*/

111",Useful
/** The bitmap file block size in bytes.  All writes will be multiples of this.*/,"-1. static const char* bmp_file_name_stem = ""ib_modified_log_"";
/** The bitmap file block size in bytes.  All writes will be multiples of this.

 /** The bitmap file block size in bytes.  All writes will be multiples of this.*/

1.  */
2. enum {
3. 	MODIF",Useful
"/*1 if last block in the current
					write, 0 otherwise.*/","-1. enum {

 /*1 if last block in the current
					write, 0 otherwise.*/

111",Useful
"/*The starting tracked LSN of this and
					other blocks in the same write*/","-3. enum {

 /*The starting tracked LSN of this and
					other blocks in the same write*/

111",Useful
"/*The ending tracked LSN of this and
					other blocks in the same write*/","-5. enum {

 /*The ending tracked LSN of this and
					other blocks in the same write*/

111",Useful
"/*The space ID of tracked pages in
					this block*/","-7. enum {

 /*The space ID of tracked pages in
					this block*/

111",Useful
"/*The page ID of the first tracked
					page in this block*/","-9. enum {

 /*The page ID of the first tracked
					page in this block*/

111",Useful
"/*Unused in order to align the start
					  of bitmap at 8 byte boundary*/","-10. 	MODIFIED_PAGE_IS_LAST_BLOCK = 0,/* 1 if last block in the current
-9. 					write, 0 otherwise. */
-8. 	MODIFIED_PAGE_START_LSN = 4,	/* The starting tracked LSN of this and
-7. 					other blocks in the same write */
-6. 	MODIFIED_PAGE_END_LSN = 12,	/",Useful
/*Start of the bitmap itself*/,"-10. 	MODIFIED_PAGE_START_LSN = 4,	/* The starting tracked LSN of this and
-9. 					other blocks in the same write */
-8. 	MODIFIED_PAGE_END_LSN = 12,	/* The ending tracked LSN of this and
-7. 					other blocks in the same write */
-6. 	MODIFIED_PAGE_SPAC",Useful
"/*Unused in order to align the end of
					bitmap at 8 byte boundary*/","-1. 	MODIFIED_PAGE_BLOCK_UNUSED_2 = MODIFIED_PAGE_BLOCK_SIZE - 8,

 /*Unused in order to align the end of
					bitmap at 8 byte boundary*/

1. 	MODIFIED_PAGE_BLOCK_CHECKSUM = MODIFIED_PAGE_BLOCK_SIZE - 4",Useful
/** Length of the bitmap data in a block*/,"-1. };

 /** Length of the bitmap data in a block*/

111",Useful
"/**
Calculate a bitmap block checksum.  Algorithm borrowed from
log_block_calc_checksum.
@return checksum*/","-10. };
-9. /** Length of the bitmap data in a block */
-8. enum { MODIFIED_PAGE_BLOCK_BITMAP_LEN
-7.        = MODIFIED_PAGE_BLOCK_UNUSED_2 - MODIFIED_PAGE_BLOCK_BITMAP };
-6. /** Length of the bitmap data in a block in page ids */
-5. enum { MODIFIED_PAG",Useful
/*!<in: bitmap block*/,"-4. UNIV_INLINE
-3. ulint
-2. log_online_calc_checksum(

 /*!<in: bitmap block*/

111",Useful
"/**
Provide a comparisson function for the RB-tree tree (space,
block_start_page) pairs.  Actual implementation does not matter as
long as the ordering is full.
@return -1 if p1 < p2, 0 if p1 == p2, 1 if p1 > p2*/","Provide a comparisson function for the RB-tree tree (space,
block_start_page) pairs.  Actual implementation does not matter as
long as the ordering is full.
@return -1 if p1 < p2, 0 if p1 == p2, 1 if p1 > p2

 /**
Provide a comparisson function for the RB-tree tree (space,
block_start_page) pairs.  Actual implementation does not matter as
long as the ordering is full.
@return -1 if p1 < p2, 0 if p1 == p2, 1 if p1 > p2*/

1. */
2. static
3. int
4. log_online_compare_bmp_keys(",Useful
"/**
Calculate a bitmap block checksum.  Algorithm borrowed from
log_block_calc_checksum.
@return checksum*/","-10. };
-9. /** Length of the bitmap data in a block */
-8. enum { MODIFIED_PAGE_BLOCK_BITMAP_LEN
-7.        = MODIFIED_PAGE_BLOCK_UNUSED_2 - MODIFIED_PAGE_BLOCK_BITMAP };
-6. /** Length of the bitmap data in a block in page ids */
-5. enum { MODIFIED_PAG",Useful
/*!<in: bitmap block*/,"-4. UNIV_INLINE
-3. ulint
-2. log_online_calc_checksum(

 /*!<in: bitmap block*/

111",Useful
"/**
Read one bitmap data page and check it for corruption.

@return TRUE if page read OK, FALSE if I/O error*/","-10. 		sum += b << sh;
-9. 		sh++;
-8. 		if (sh > 24) {
-7. 			sh = 0;
-6. 		}
-5. 	}
-4. 	return sum;
-3. }
-2. /****************************************************************//**
-1. Read one bitmap data page and check it for corruption.
@return TRUE ",Useful
"/*!<out: read page.  Must be at
						least MODIFIED_PAGE_BLOCK_SIZE
						bytes long*/","-6. static
-5. ibool
-4. log_online_read_bitmap_page(

 /*!<out: read page.  Must be at
						least MODIFIED_PAGE_BLOCK_SIZE
						bytes long*/

111",Useful
"/*!<out: TRUE if page
							checksum OK*/","-10. @return TRUE if page read OK, FALSE if I/O error */
-9. static
-8. ibool
-7. log_online_read_bitmap_page(

 /*!<out: TRUE if page
							checksum OK*/

1. {
2. 	ulint	checksum;
3. 	ulint	actual_checksum;
4. 	ibool	success;
5. 	ut_a(bitmap_file->size ",Useful
/*The following call prints an error message*/,"-10. 	ulint	actual_checksum;
-9. 	ibool	success;
-8. 	ut_a(bitmap_file->size >= MODIFIED_PAGE_BLOCK_SIZE);
-7. 	ut_a(bitmap_file->offset
-6. 	     <= bitmap_file->size - MODIFIED_PAGE_BLOCK_SIZE);
-5. 	ut_a(bitmap_file->offset % MODIFIED_PAGE_BLOCK_SIZE =",Useful
"/**
Check the name of a given file if it's a changed page bitmap file and
return file sequence and start LSN name components if it is.  If is not,
the values of output parameters are undefined.

@return TRUE if a given file is a changed page bitmap file.*/","-10. 	ut_ad(bitmap_file->offset <= bitmap_file->size);
-9. 	checksum = mach_read_from_4(page + MODIFIED_PAGE_BLOCK_CHECKSUM);
-8. 	actual_checksum = log_online_calc_checksum(page);
-7. 	*checksum_ok = (checksum == actual_checksum);
-6. 	return TRUE;
-5. }",Useful
"/*!<in: file to
							check*/","-4. static
-3. ibool
-2. log_online_is_bitmap_file(

 /*!<in: file to
							check*/

111",Useful
"/**
List the bitmap files in srv_data_home and setup their range that contains the
specified LSN interval.  This range, if non-empty, will start with a file that
has the greatest LSN equal to or less than the start LSN and will include all
the files up to the one with the greatest LSN less than the end LSN.  Caller
must free bitmap_files->files when done if bitmap_files set to non-NULL and
this function returned TRUE.  Field bitmap_files->count might be set to a
larger value than the actual count of the files, and space for the unused array
slots will be allocated but cleared to zeroes.

@return TRUE if succeeded*/","
List the bitmap files in srv_data_home and setup their range that contains the
specified LSN interval.  This range, if non-empty, will start with a file that
has the greatest LSN equal to or less than the start LSN and will include all
the files up to the one with the greatest LSN less than the end LSN.  Caller
must free bitmap_files->files when done if bitmap_files set to non-NULL and
this function returned TRUE.  Field bitmap_files->count might be set to a
larger value than the actual count of the files, and space for the unused array
slots will be allocated but cleared to zeroes.

@return TRUE if succeeded



 /**
List the bitmap files in srv_data_home and setup their range that contains the
specified LSN interval.  This range, if non-empty, will start with a file that
has the greatest LSN equal to or less than the start LSN and will include all
the files up to the one with the greatest LSN less than the end LSN.  Caller
must free bitmap_files->files when done if bitmap_files set to non-NULL and
this function returned TRUE.  Field bitmap_files->count might be set to a
larger value than the actual count of the files, and space for the unused array
slots will be allocated but cleared to zeroes.

@return TRUE if succeeded*/

1. */
2. static
3. ibool
4. log_online_setup_bitmap_file_range(",Useful
/*1st pass: size the info array*/,"-9. {
-8. 	os_file_dir_t	bitmap_dir;
-7. 	os_file_stat_t	bitmap_dir_file_info;
-6. 	ulong		first_file_seq_num	= ULONG_MAX;
-5. 	ulong		last_file_seq_num	= 0;
-4. 	lsn_t		first_file_start_lsn	= LSN_MAX;
-3. 	xb_ad(range_end >= range_start);
-2. 	bitmap_fil",Useful
"/*A file that has LSN closer to the range start
			but smaller than it, replacing another such file*/","-7. 			if (file_start_lsn < first_file_start_lsn) {
-6. 				first_file_start_lsn = file_start_lsn;
-5. 			}
-4. 			if (file_seq_num < first_file_seq_num) {
-3. 				first_file_seq_num = file_seq_num;
-2. 			}
-1. 		} else if (file_start_lsn > first_file_st",Useful
/*2nd pass: get the file names in the file_seq_num order*/,"-10. 	if (UNIV_UNLIKELY(os_file_closedir_failed(bitmap_dir))) {
-9. 		os_file_get_last_error(TRUE);
-8. 		msg(""InnoDB: Error: cannot close \'%s\'"",srv_data_home);
-7. 		return FALSE;
-6. 	}
-5. 	if (first_file_seq_num == ULONG_MAX && last_file_seq_num == ",Useful
"/**
Open a bitmap file for reading.

@return whether opened successfully*/","-10. 		ut_ad(bitmap_files->files[i].seq_num
-9. 		      > bitmap_files->files[i - 1].seq_num);
-8. 		ut_ad(bitmap_files->files[i].start_lsn
-7. 		      >= bitmap_files->files[i - 1].start_lsn);
-6. 	}
-5. #endif
-4. 	return TRUE;
-3. }
-2. /**************",Useful
"/*!<in: bitmap file
							name without directory,
							which is assumed to be
							srv_data_home*/","-4. static
-3. bool
-2. log_online_open_bitmap_file_read_only(

 /*!<in: bitmap file
							name without directory,
							which is assumed to be
							srv_data_home*/

111",Useful
"/*Here and below assume that bitmap file names do not
		contain apostrophes, thus no need for ut_print_filename().*/","-8. {
-7. 	bool	success	= false;
-6. 	xb_ad(name[0] != '\0');
-5. 	snprintf(bitmap_file->name, FN_REFLEN, ""%s%s"", srv_data_home, name);
-4. 	bitmap_file->file = os_file_create_simple_no_error_handling(
-3. 		0, bitmap_file->name,
-2. 		OS_FILE_OPEN, OS_FI",Useful
"/**
Diagnose one or both of the following situations if we read close to
the end of bitmap file:
1) Warn if the remainder of the file is less than one page.
2) Error if we cannot read any more full pages but the last read page
did not have the last-in-run flag set.

@return FALSE for the error*/","-10. 	posix_fadvise(bitmap_file->file, 0, 0, POSIX_FADV_NOREUSE);
-9. #endif
-8. 	return success;
-7. }
-6. /****************************************************************//**
-5. Diagnose one or both of the following situations if we read close to
-4. ",Useful
/*Check if we are too close to EOF to read a full page*/,"-1. {

 /*Check if we are too close to EOF to read a full page*/

1. 	if ((bitmap_file->size < MODIFIED_PAGE_BLOCK_SIZE)
2. 	    || (bitmap_file->offset
3. 		> bitmap_file->size - MODIFIED_PAGE_BLOCK_SIZE)) {
4. 		if (UNIV_UNLIKELY(bitmap_file->offset != ",Useful
"/*If we are not at EOF and we have less than one page
			to read, it's junk.  This error is not fatal in
			itself.*/","-4. 	if ((bitmap_file->size < MODIFIED_PAGE_BLOCK_SIZE)
-3. 	    || (bitmap_file->offset
-2. 		> bitmap_file->size - MODIFIED_PAGE_BLOCK_SIZE)) {
-1. 		if (UNIV_UNLIKELY(bitmap_file->offset != bitmap_file->size)) {

 /*If we are not at EOF and we have les",Useful
"/*We are at EOF but the last read page did not finish
			a run*/","-4. 			msg(""InnoDB: Warning: junk at the end of changed ""
-3. 			    ""page bitmap file \'%s\'."", bitmap_file->name);
-2. 		}
-1. 		if (UNIV_UNLIKELY(!last_page_in_run)) {

 /*We are at EOF but the last read page did not finish
			a run*/

111",Useful
"/*It's a ""Warning"" here because it's not a fatal error
			for the whole server*/","-6. 			msg(""InnoDB: Warning: junk at the end of changed ""
-5. 			    ""page bitmap file \'%s\'."", bitmap_file->name);
-4. 		}
-3. 		if (UNIV_UNLIKELY(!last_page_in_run)) {

 /*It's a ""Warning"" here because it's not a fatal error
			for the whole server*/

",Useful
/*Bitmap with data*/,"-1. struct xb_page_bitmap_range_struct {

 /*Bitmap with data*/

111",Useful
"/*Space id for this
					        iterator*/","-2. struct xb_page_bitmap_range_struct {

 /*Space id for this
					        iterator*/

111",Useful
/*Current bitmap tree node*/,"-6. struct xb_page_bitmap_range_struct {

 /*Current bitmap tree node*/

111",Useful
/*Current page id*/,"-8. struct xb_page_bitmap_range_struct {

 /*Current page id*/

111",Useful
"/**
Scan a bitmap file until data for a desired LSN or EOF is found and check that
the page before the starting one is not corrupted to ensure that the found page
indeed contains the very start of the desired LSN data.  The caller must check
the page LSN values to determine if the bitmap file was scanned until the data
was found or until EOF.  Page must be at least MODIFIED_PAGE_BLOCK_SIZE big.

@return TRUE if the scan successful without corruption detected*/","
Scan a bitmap file until data for a desired LSN or EOF is found and check that
the page before the starting one is not corrupted to ensure that the found page
indeed contains the very start of the desired LSN data.  The caller must check
the page LSN values to determine if the bitmap file was scanned until the data
was found or until EOF.  Page must be at least MODIFIED_PAGE_BLOCK_SIZE big.

@return TRUE if the scan successful without corruption detected



 /**
Scan a bitmap file until data for a desired LSN or EOF is found and check that
the page before the starting one is not corrupted to ensure that the found page
indeed contains the very start of the desired LSN data.  The caller must check
the page LSN values to determine if the bitmap file was scanned until the data
was found or until EOF.  Page must be at least MODIFIED_PAGE_BLOCK_SIZE big.

@return TRUE if the scan successful without corruption detected*/

1. */
2. static
3. ibool
4. xb_find_lsn_in_bitmap_file(",Useful
"/*!<in/out: last read
							bitmap page*/","-10. the page LSN values to determine if the bitmap file was scanned until the data
-9. was found or until EOF.  Page must be at least MODIFIED_PAGE_BLOCK_SIZE big.
-8. @return TRUE if the scan successful without corruption detected
-7. */
-6. static
-5. ",Useful
"/*!<out: end LSN of the
							last read page*/","-10. @return TRUE if the scan successful without corruption detected
-9. */
-8. static
-7. ibool
-6. xb_find_lsn_in_bitmap_file(

 /*!<out: end LSN of the
							last read page*/

111",Useful
"/*We check two pages here because the last read page already contains
	the required LSN data. If the next to the last one page is corrupted,
	then we have no way of telling if that page contained the required LSN
	range data too*/","-10. 	while ((*page_end_lsn <= lsn)
-9. 	       && (bitmap_file->offset
-8. 		   <= bitmap_file->size - MODIFIED_PAGE_BLOCK_SIZE)) {
-7. 		next_to_last_page_ok = last_page_ok;
-6. 		if (!log_online_read_bitmap_page(bitmap_file, page,
-5. 						 &last_page",Useful
"/**
Read the disk bitmap and build the changed page bitmap tree for the
LSN interval incremental_lsn to checkpoint_lsn_start.

@return the built bitmap tree or NULL if unable to read the full interval for
any reason.*/","-10. 	/* We check two pages here because the last read page already contains
-9. 	the required LSN data. If the next to the last one page is corrupted,
-8. 	then we have no way of telling if that page contained the required LSN
-7. 	range data too */
-6. ",Useful
/*Only accept no bitmap files returned if start LSN == end LSN*/,"-10. 	if (UNIV_UNLIKELY(bmp_start_lsn > bmp_end_lsn)) {
-9. 		msg(""mariabackup: incremental backup LSN "" LSN_PF
-8. 		    "" is larger than than the last checkpoint LSN "" LSN_PF
-7. 		    , bmp_start_lsn, bmp_end_lsn);
-6. 		return NULL;
-5. 	}
-4. 	if (!l",Useful
/*Empty range - empty bitmap*/,"-6. 	if (bitmap_files.count == 0 && bmp_end_lsn != bmp_start_lsn) {
-5. 		return NULL;
-4. 	}
-3. 	result = rbt_create(MODIFIED_PAGE_BLOCK_SIZE,
-2. 			    log_online_compare_bmp_keys);
-1. 	if (bmp_start_lsn == bmp_end_lsn) {

 /*Empty range - empty bitm",Useful
/*Skip any zero-sized files at the start*/,"-6. 		xb_msg_missing_lsn_data(bmp_start_lsn,
-5. 					bitmap_files.files[bmp_i].start_lsn);
-4. 		rbt_free(result);
-3. 		free(bitmap_files.files);
-2. 		return NULL;
-1. 	}

 /*Skip any zero-sized files at the start*/

1. 	while ((bmp_i < bitmap_files.co",Useful
/*TODO: this is not the exact missing range*/,"-1. 	if (UNIV_UNLIKELY(bitmap_files.files[bmp_i].name[0] == '\0')) {

 /*TODO: this is not the exact missing range*/

1. 		xb_msg_missing_lsn_data(bmp_start_lsn, bmp_end_lsn);
2. 		rbt_free(result);
3. 		free(bitmap_files.files);
4. 		return NULL;
5. 	}",Useful
"/*If the 1st file is truncated, no data.  Not merged with the case
	below because zero-length file indicates not a corruption but missing
	subsequent files instead.*/","-7. 	if (UNIV_UNLIKELY(!log_online_open_bitmap_file_read_only(
-6. 				  bitmap_files.files[bmp_i].name,
-5. 				  &bitmap_file))) {
-4. 		rbt_free(result);
-3. 		free(bitmap_files.files);
-2. 		return NULL;
-1. 	}

 /*If the 1st file is truncated, no dat",Useful
"/*1st bitmap page found, add it to the tree.*/","-10. 		os_file_close(bitmap_file.file);
-9. 		return NULL;
-8. 	}
-7. 	if (UNIV_UNLIKELY(current_page_end_lsn < bmp_start_lsn)) {
-6. 		xb_msg_missing_lsn_data(current_page_end_lsn, bmp_start_lsn);
-5. 		rbt_free(result);
-4. 		free(bitmap_files.files);
-",Useful
/*Read next pages/files until all required data is read*/,"-1. 	rbt_insert(result, page, page);

 /*Read next pages/files until all required data is read*/

1. 	while (last_page_ok
2. 	       && (current_page_end_lsn < bmp_end_lsn
3. 		   || (current_page_end_lsn == bmp_end_lsn
4. 		       && !last_page_in_run)))",Useful
"/*Merge the current page with an existing page or insert a new
		page into the tree*/","-10. 			return NULL;
-9. 		}
-8. 		if (UNIV_UNLIKELY(!last_page_ok)) {
-7. 			msg(""mariabackup: warning: changed page bitmap file ""
-6. 			    ""\'%s\' corrupted."", bitmap_file.name);
-5. 			rbt_free(result);
-4. 			free(bitmap_files.files);
-3. 			os_file",Useful
/*Merge the bitmap pages*/,"-1. 		if (!rbt_search(result, &tree_search_pos, page)) {

 /*Merge the bitmap pages*/

1. 			byte	*existing_page
2. 				= rbt_value(byte, tree_search_pos.last);
3. 			bitmap_word_t *bmp_word_1	= (bitmap_word_t *)
4. 				(existing_page + MODIFIED_PAGE_BLOC",Useful
"/**
Free the bitmap tree.*/","-10. 			= mach_read_from_8(page + MODIFIED_PAGE_END_LSN);
-9. 		last_page_in_run
-8. 			= mach_read_from_4(page + MODIFIED_PAGE_IS_LAST_BLOCK);
-7. 	}
-6. 	xb_a (current_page_end_lsn >= bmp_end_lsn);
-5. 	free(bitmap_files.files);
-4. 	os_file_close(bitma",Useful
/*!<in/out: bitmap tree*/,"-3. void
-2. xb_page_bitmap_deinit(

 /*!<in/out: bitmap tree*/

111",Useful
"/**
Advance to the next bitmap page or setup the first bitmap page for the
given bitmap range.  Assumes that bitmap_range->bitmap_page has been
already found/bumped by rbt_search()/rbt_next().

@return FALSE if no more bitmap data for the range space ID*/","-10. 	xb_page_bitmap*	bitmap)	/*!<in/out: bitmap tree */
-9. {
-8. 	if (bitmap) {
-7. 		rbt_free(bitmap);
-6. 	}
-5. }
-4. /****************************************************************//**
-3. Advance to the next bitmap page or setup the first bitmap ",Useful
/*No more data for the current page id.*/,"-10. 	ulint	new_space_id;
-9. 	ulint	new_1st_page_id;
-8. 	if (bitmap_range->bitmap_node == NULL) {
-7. 		bitmap_range->current_page_id = ULINT_UNDEFINED;
-6. 		return FALSE;
-5. 	}
-4. 	bitmap_range->bitmap_page = rbt_value(byte, bitmap_range->bitmap_nod",Useful
"/** Find the node with the smallest key that greater than equal to search key.
@param[in]	tree	red-black tree
@param[in]	key	search key
@return	node with the smallest greater-than-or-equal key
@retval	NULL	if none was found*/","-10. 		return FALSE;
-9. 	}
-8. 	new_1st_page_id = mach_read_from_4(bitmap_range->bitmap_page +
-7. 					   MODIFIED_PAGE_1ST_PAGE_ID);
-6. 	xb_a (new_1st_page_id >= bitmap_range->current_page_id
-5. 	      || bitmap_range->current_page_id == ULINT_UNDEFI",Useful
"/**
Set up a new bitmap range iterator over a given space id changed
pages in a given bitmap.

@return bitmap range iterator*/","-10. 				break;
-9. 			}
-8. 			node = node->left;
-7. 		}
-6. 	}
-5. 	return(ge);
-4. }
-3. /****************************************************************//**
-2. Set up a new bitmap range iterator over a given space id changed
-1. pages in a given bi",Useful
/*!< in: bitmap to iterate over*/,"-3. xb_page_bitmap_range*
-2. xb_page_bitmap_range_init(

 /*!< in: bitmap to iterate over*/

111",Useful
/*Search for the 1st page for the given space id*/,"-8. {
-7. 	byte			search_page[MODIFIED_PAGE_BLOCK_SIZE];
-6. 	xb_page_bitmap_range	*result
-5. 		= static_cast<xb_page_bitmap_range *>(malloc(sizeof(*result)));
-4. 	memset(result, 0, sizeof(*result));
-3. 	result->bitmap = bitmap;
-2. 	result->space_id =",Useful
"/**
Get the value of the bitmap->range->bit_i bitmap bit

@return the current bit value*/","-10. 	/* This also sets MODIFIED_PAGE_1ST_PAGE_ID to 0, which is what we
-9. 	want. */
-8. 	memset(search_page, 0, MODIFIED_PAGE_BLOCK_SIZE);
-7. 	mach_write_to_4(search_page + MODIFIED_PAGE_SPACE_ID, space_id);
-6. 	result->bitmap_node = rbt_lower_bound(",Useful
"/**
Get the next page id that has its bit set or cleared, i.e. equal to
bit_value.

@return page id*/","-10. 							range */
-9. {
-8. 	return ((*(((bitmap_word_t *)(bitmap_range->bitmap_page
-7. 				     + MODIFIED_PAGE_BLOCK_BITMAP))
-6. 		  + (bitmap_range->bit_i >> 6)))
-5. 		& (1ULL << (bitmap_range->bit_i & 0x3F))) ? TRUE : FALSE;
-4. }
-3. /*********",Useful
"/**
Free the bitmap range iterator.*/","-10. 				return result;
-9. 			}
-8. 		}
-7. 		bitmap_range->bitmap_node
-6. 			= rbt_next(bitmap_range->bitmap,
-5. 				   bitmap_range->bitmap_node);
-4. 	} while (xb_page_bitmap_setup_next_page(bitmap_range));
-3. 	return ULINT_UNDEFINED;
-2. }
-1. /**",Useful
/*Group writes smaller than this into a single chunk*/,"-10. GNU General Public License for more details.
-9. You should have received a copy of the GNU General Public License
-8. along with this program; if not, write to the Free Software
-7. Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  0211",Useful
"/*Normalize path on Windows, so we can restore elsewhere.*/","-10. 	size_t			path_len;
-9. 	path_len = strlen(path);
-8. 	if (path_len > FN_REFLEN) {
-7. 		msg(""xb_stream_write_open(): file path is too long."");
-6. 		return NULL;
-5. 	}
-4. 	file = (xb_wstream_file_t *) my_malloc(PSI_NOT_INSTRUMENTED, sizeof(xb_wstr",Useful
/*Write xbstream header*/,"-5. 	uchar		tmpbuf[sizeof(XB_STREAM_CHUNK_MAGIC) - 1 + 1 + 1 + 4 +
-4. 			       FN_REFLEN + 8 + 8 + 4];
-3. 	uchar		*ptr;
-2. 	xb_wstream_t	*stream = file->stream;
-1. 	ulong		checksum;

 /*Write xbstream header*/

1. 	ptr = tmpbuf;",Useful
/*Chunk flags*/,"-2. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-1. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

 /*Chunk flags*/

111",Useful
/*Payload length*/,"-1. 	ptr += file->path_len;

 /*Payload length*/

1. 	ptr += 8;
2. 	checksum = my_checksum(0, buf, len);
3. 	pthread_mutex_lock(&stream->mutex);",Useful
/*Payload*/,"-1. 	ptr += file->path_len;

 /*Payload*/

1. 	ptr += 8;
2. 	checksum = my_checksum(0, buf, len);
3. 	pthread_mutex_lock(&stream->mutex);",Useful
/*Chunk magic + flags + chunk type + path_len + path*/,"-10. 		return 1;
-9. 	}
-8. 	file->chunk_ptr = file->chunk;
-7. 	file->chunk_free = XB_STREAM_MIN_CHUNK_SIZE;
-6. 	return 0;
-5. }
-4. static
-3. int
-2. xb_stream_write_chunk(xb_wstream_file_t *file, const void *buf, size_t len)
-1. {
	/* Chunk magic + f",Useful
/*Write xbstream header*/,"-5. 	uchar		tmpbuf[sizeof(XB_STREAM_CHUNK_MAGIC) - 1 + 1 + 1 + 4 +
-4. 			       FN_REFLEN + 8 + 8 + 4];
-3. 	uchar		*ptr;
-2. 	xb_wstream_t	*stream = file->stream;
-1. 	ulong		checksum;

 /*Write xbstream header*/

1. 	ptr = tmpbuf;",Useful
/*Chunk flags*/,"-2. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-1. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

 /*Chunk flags*/

111",Useful
"/*Does buffered output to a destination datasink set with ds_set_pipe().
Writes to the destination datasink are guaranteed to not be smaller than a
specified buffer size (DS_DEFAULT_BUFFER_SIZE by default), with the only
exception for the last write for a file.*/","-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Useful
"/*We don't have any buffered bytes, just write
				the entire source buffer*/","-10. 				       bytes);
-9. 				if (ds_write(buffer_file->dst_file,
-8. 					     buffer_file->buf,
-7. 					     buffer_file->size)) {
-6. 					return 1;
-5. 				}
-4. 				buffer_file->pos = 0;
-3. 				buf += bytes;
-2. 				len -= bytes;
-1. 			} else {
",Useful
"/************************************************************************
Write to a datasink file.
@return 0 on success, 1 on error.*/","-10. ds_file_t *
-9. ds_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *stat)
-8. {
-7. 	ds_file_t	*file;
-6. 	file = ctxt->datasink->open(ctxt, path, stat);
-5. 	if (file != NULL) {
-4. 		file->datasink = ctxt->datasink;
-3. 	}
-2. 	return file;
-1. }

",Useful
"/************************************************************************
Close a datasink file.
@return 0 on success, 1, on error.*/","-10. Write to a datasink file.
-9. @return 0 on success, 1 on error. */
-8. int
-7. ds_write(ds_file_t *file, const void *buf, size_t len)
-6. {
-5. 	if (len == 0) {
-4. 		return 0;
-3. 	}
-2. 	return file->datasink->write(file, (const uchar *)buf, len);
",Useful
"/************************************************************************
Destroy a datasink handle*/","-5. int
-4. ds_close(ds_file_t *file)
-3. {
-2. 	return file->datasink->close(file);
-1. }

 /************************************************************************
Destroy a datasink handle*/

1. void
2. ds_destroy(ds_ctxt_t *ctxt)
3. {
4. 	ctxt->datas",Useful
/*database*/,"-10. 		mysql_options(connection, MYSQL_OPT_SSL_CRLPATH,
-9. 			      opt_ssl_crlpath);
-8. 	}
-7. 	mysql_options(connection,MYSQL_OPT_SSL_VERIFY_SERVER_CERT,
-6. 		      (char*)&opt_ssl_verify_server_cert);
-5. #endif
-4. 	if (!mysql_real_connect(connecti",Useful
/*store result set on client if there is a result*/,"-10. {
-9. 	MYSQL_RES *mysql_result = NULL;
-8. 	if (mysql_query(connection, query)) {
-7. 		if (die_on_error) {
-6. 			die(""failed to execute query %s: %s"", query, mysql_error(connection));
-5. 		} else {
-4. 			msg(""Error: failed to execute query %s: %s",Useful
"/*bugs.launchpad.net/percona-xtrabackup"",*/","-10. 		|| ((version_number > 100000)
-9. 		    && server_flavor == FLAVOR_MARIADB);
-8. 	if (mysql51 && innodb_version == NULL) {
-7. 		msg(""Error: Built-in InnoDB in MySQL 5.1 is not ""
-6. 		    ""supported in this release. You can either use ""
-5. 		    ",Useful
"/**
Receive options important for XtraBackup from MySQL server.
@return	true on success.*/","-10. 	} else if (!version_supported) {
-9. 		msg(""Error: Unsupported server version: '%s'. Please ""
-8. 		    ""report a bug at ""
-7. 		    ""https://bugs.launchpad.net/percona-xtrabackup"",
-6. 		    version_string);
-5. 	}
-4. 	return(version_supported);
-",Useful
/*get some default values is they are missing from my.cnf*/,"-10.     }
-9.     if (!equal_paths(mysql_data_home, datadir_var))
-8.     {
-7.       msg(""Warning: option 'datadir' has different ""
-6.           ""values:\n""
-5.           ""  '%s' in defaults file\n""
-4.           ""  '%s' in SHOW VARIABLES"",
-3.        ",Useful
"/**
Query the server to find out what backup capabilities it supports.
@return	true on success.*/","-10. 	} else if (!version_supported) {
-9. 		msg(""Error: Unsupported server version: '%s'. Please ""
-8. 		    ""report a bug at ""
-7. 		    ""https://bugs.launchpad.net/percona-xtrabackup"",
-6. 		    version_string);
-5. 	}
-4. 	return(version_supported);
-",Useful
"/*INNODB_CHANGED_PAGES are listed in
		INFORMATION_SCHEMA.PLUGINS in MariaDB, but
		FLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS
		is not supported for versions below 10.1.6
		(see MDEV-7472)*/","-10. 	const char *query = ""SELECT 'INNODB_CHANGED_PAGES', COUNT(*) FROM ""
-9. 				""INFORMATION_SCHEMA.PLUGINS ""
-8. 			    ""WHERE PLUGIN_NAME LIKE 'INNODB_CHANGED_PAGES'"";
-7. 	char *innodb_changed_pages = NULL;
-6. 	mysql_variable vars[] = {
-5. 		{""INNO",Useful
/*do some sanity checks*/,"-10. 		INFORMATION_SCHEMA.PLUGINS in MariaDB, but
-9. 		FLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS
-8. 		is not supported for versions below 10.1.6
-7. 		(see MDEV-7472) */
-6. 		if (server_flavor == FLAVOR_MARIADB &&
-5. 		    mysql_server_version < 1",Useful
"/**
Function acquires either a backup tables lock, if supported
by the server, or a global read lock (FLUSH TABLES WITH READ LOCK)
otherwise.
@returns true if lock acquired*/","-10.   while (kill_query_thread_running);
-9.   mysql_cond_destroy(&kill_query_thread_stop);
-8.   mysql_cond_destroy(&kill_query_thread_stopped);
-7.   mysql_mutex_unlock(&kill_query_thread_mutex);
-6.   mysql_mutex_destroy(&kill_query_thread_mutex);
-5.",Useful
"/**
If backup locks are used, execute LOCK BINLOG FOR BACKUP provided that we are
not in the --no-lock mode and the lock has not been acquired already.
@returns true if lock acquired*/","-10.   while (kill_query_thread_running);
-9.   mysql_cond_destroy(&kill_query_thread_stop);
-8.   mysql_cond_destroy(&kill_query_thread_stopped);
-7.   mysql_mutex_unlock(&kill_query_thread_mutex);
-6.   mysql_mutex_destroy(&kill_query_thread_mutex);
-5.",Useful
"/**
Releases either global read lock acquired with FTWRL and the binlog
lock acquired with LOCK BINLOG FOR BACKUP, depending on
the locking strategy being used*/","-10. 		msg(""Executing LOCK BINLOG FOR BACKUP..."");
-9. 		xb_mysql_query(connection, ""LOCK BINLOG FOR BACKUP"", false);
-8. 		binlog_locked = true;
-7. 		return(true);
-6. 	}
-5. 	return(false);
-4. }
-3. /***************************************************",Useful
"/**
Wait until it's safe to backup a slave.  Returns immediately if
the host isn't a slave.  Currently there's only one check:
Slave_open_temp_tables has to be zero.  Dies on timeout.*/","-10. 	int result = false;
-9. 	read_mysql_variables(connection,
-8. 		""SHOW STATUS LIKE 'slave_open_temp_tables'"", status, true);
-7. 	result = slave_open_temp_tables ? atoi(slave_open_temp_tables) : 0;
-6. 	free_mysql_variables(status);
-5. 	return(resul",Useful
/*we still want to continue the backup*/,"-10. 	mysql_variable variables[] = {
-9. 		{""gtid_slave_pos"", &gtid_slave_pos},
-8. 		{NULL, NULL}
-7. 	};
-6. 	read_mysql_variables(connection, ""SHOW SLAVE STATUS"", status, false);
-5. 	read_mysql_variables(connection, ""SHOW VARIABLES"", variables, true);",Useful
"/*Print slave status to a file.
	If GTID mode is used, construct a CHANGE MASTER statement with
	MASTER_AUTO_POSITION and correct a gtid_purged value.*/","-3. 		result = true;
-2. 		goto cleanup;
-1. 	}

 /*Print slave status to a file.
	If GTID mode is used, construct a CHANGE MASTER statement with
	MASTER_AUTO_POSITION and correct a gtid_purged value.*/

1. 	if (gtid_executed != NULL && *gtid_executed) {",Useful
/*MySQL >= 5.6 with GTID enabled*/,"-1. 	if (gtid_executed != NULL && *gtid_executed) {

 /*MySQL >= 5.6 with GTID enabled*/

1. 		for (ptr = strchr(gtid_executed, '\n');
2. 		     ptr;
3. 		     ptr = strchr(ptr, '\n')) {
4. 			*ptr = ' ';
5. 		}
6. 		result = backup_file_printf(XTRABACKUP",Useful
/*MariaDB >= 10.0 with GTID enabled*/,"-10. 		}
-9. 		result = backup_file_printf(XTRABACKUP_SLAVE_INFO,
-8. 			""SET GLOBAL gtid_purged='%s';\n""
-7. 			""CHANGE MASTER TO MASTER_AUTO_POSITION=1\n"",
-6. 			gtid_executed);
-5. 		ut_a(asprintf(&mysql_slave_position,
-4. 			""master host '%s', purge",Useful
"/*When backup locks are supported by the server, we should skip
	creating xtrabackup_galera_info file on the backup stage, because
	wsrep_local_state_uuid and wsrep_last_committed will be inconsistent
	without blocking commits. The state file will be created on the prepare
	stage using the WSREP recovery procedure.*/","-10. 	char *state_uuid = NULL, *state_uuid55 = NULL;
-9. 	char *last_committed = NULL, *last_committed55 = NULL;
-8. 	bool result;
-7. 	mysql_variable status[] = {
-6. 		{""Wsrep_local_state_uuid"", &state_uuid},
-5. 		{""wsrep_local_state_uuid"", &state_uuid",Useful
/*Default location is MySQL datadir*/,"-5. 			if (log_bin_dir) {
-4. 				free(log_bin_dir);
-3. 			}
-2. 			log_bin_dir = strdup(opt_log_bin);
-1. 		} else if (log_bin_dir == NULL) {

 /*Default location is MySQL datadir*/

1. 			log_bin_dir = static_cast<char*>(malloc(3));
2. 			ut_a(log_bin_",Useful
/*tool_version*/,"-10. 		|| xtrabackup_databases_file
-9. 		|| xtrabackup_tables_exclude
-8. 		|| xtrabackup_databases_exclude
-7. 		);
-6. 	char *buf = NULL;
-5. 	int buf_len = asprintf(&buf,
-4. 		""uuid = %s\n""
-3. 		""name = %s\n""
-2. 		""tool_name = %s\n""
-1. 		""tool_com",Useful
/*ibbackup_version*/,"-10. 		|| xtrabackup_tables_exclude
-9. 		|| xtrabackup_databases_exclude
-8. 		);
-7. 	char *buf = NULL;
-6. 	int buf_len = asprintf(&buf,
-5. 		""uuid = %s\n""
-4. 		""name = %s\n""
-3. 		""tool_name = %s\n""
-2. 		""tool_command = %s\n""
-1. 		""tool_version = ",Useful
/*innodb_from_lsn*/,"-10. 		""name = %s\n""
-9. 		""tool_name = %s\n""
-8. 		""tool_command = %s\n""
-7. 		""tool_version = %s\n""
-6. 		""ibbackup_version = %s\n""
-5. 		""server_version = %s\n""
-4. 		""start_time = %s\n""
-3. 		""end_time = %s\n""
-2. 		""lock_time = %d\n""
-1. 		""binlog_po",Useful
/*innodb_to_lsn*/,"-10. select_incremental_lsn_from_history(lsn_t *incremental_lsn)
-9. {
-8. 	MYSQL_RES *mysql_result;
-7. 	char query[1000];
-6. 	char buf[100];
-5. 	if (opt_incremental_history_name) {
-4. 		mysql_real_escape_string(mysql_connection, buf,
-3. 				opt_incr",Useful
"/**
Deallocate memory, disconnect from MySQL server, etc.
@return	true on success.*/","-10. 	} else if (!version_supported) {
-9. 		msg(""Error: Unsupported server version: '%s'. Please ""
-8. 		    ""report a bug at ""
-7. 		    ""https://bugs.launchpad.net/percona-xtrabackup"",
-6. 		    version_string);
-5. 	}
-4. 	return(version_supported);
-",Useful
/*list of files to sync for --rsync mode*/,"-10. #include ""xtrabackup.h""
-9. #include ""common.h""
-8. #include ""backup_copy.h""
-7. #include ""backup_debug.h""
-6. #include ""backup_mysql.h""
-5. #include <btr0btr.h>
-4. #ifdef _WIN32
-3. #include <aclapi.h>
-2. #endif
-1. #define ROCKSDB_BACKUP_DIR ""#ro",Useful
/*Whether LOCK BINLOG FOR BACKUP has been issued during backup*/,"-1. static std::map<std::string, std::string> tablespace_locations;

 /*Whether LOCK BINLOG FOR BACKUP has been issued during backup*/

1. bool binlog_locked;
2. static void rocksdb_create_checkpoint();
3. static bool has_rocksdb_plugin();
4. static void ",Useful
"/************************************************************************
Holds the state needed to enumerate files in MySQL data directory.*/","-10. Struct represents file or directory. */
-9. struct datadir_node_t {
-8. 	ulint		dbpath_len;
-7. 	char		*filepath;
-6. 	ulint		filepath_len;
-5. 	char		*filepath_rel;
-4. 	ulint		filepath_rel_len;
-3. 	bool		is_empty_dir;
-2. 	bool		is_file;
-1. };

 ",Useful
"/************************************************************************
Retirn true if character if file separator*/","-8. struct datadir_thread_ctxt_t {
-7. 	datadir_iter_t		*it;
-6. 	uint			n_thread;
-5. 	uint			*count;
-4. 	pthread_mutex_t*	count_mutex;
-3. 	bool			ret;
-2. };
-1. static bool backup_files_from_datadir(const char *dir_path);

 /*************************",Useful
"/************************************************************************
Fill the node struct. Memory for node need to be allocated and freed by
the caller. It is caller responsibility to initialize node with
datadir_node_init and cleanup the memory with datadir_node_free.
Node can not be shared between threads.*/","-5. bool
-4. is_path_separator(char c)
-3. {
-2. 	return(c == FN_LIBCHAR || c == FN_LIBCHAR2);
-1. }

 /************************************************************************
Fill the node struct. Memory for node need to be allocated and freed by
the ca",Useful
"/************************************************************************
Create the MySQL data directory iterator. Memory needs to be released
with datadir_iter_free. Position should be advanced with
datadir_iter_next_file. Iterator can be shared between multiple
threads. It is guaranteed that each thread receives unique file from
data directory into its local node struct.*/","-10. 	free(node->filepath);
-9. 	free(node->filepath_rel);
-8. 	memset(node, 0, sizeof(datadir_node_t));
-7. }
-6. static
-5. void
-4. datadir_node_init(datadir_node_t *node)
-3. {
-2. 	memset(node, 0, sizeof(datadir_node_t));
-1. }

 /*******************",Useful
"/*We found a symlink or a directory; try opening it to see
		if a symlink is a directory*/","-10. 		it->dbdir = NULL;
-9. 	}
-8. 	while (os_file_readdir_next_file(it->datadir_path,
-7. 					  it->dir, &it->dbinfo) == 0) {
-6. 		ulint	len;
-5. 		if ((it->dbinfo.type == OS_FILE_TYPE_FILE
-4. 		     && it->skip_first_level)
-3. 		    || it->dbinfo.t",Useful
"/*We want wrong directory permissions to be a fatal error for
		XtraBackup.*/","-10. 		snprintf(it->dbpath, it->dbpath_len, ""%s/%s"",
-9. 			 it->datadir_path, it->dbinfo.name);
-8. 		if (it->dbinfo.type == OS_FILE_TYPE_FILE) {
-7. 			it->is_file = true;
-6. 			return(true);
-5. 		}
-4. 		if (check_if_skip_database_by_path(it->dbpath)",Useful
/*We found a symlink or a file*/,"-10. 		return(true);
-9. 	}
-8. 	if (!it->dbpath || !it->dbdir) {
-7. 		return(false);
-6. 	}
-5. 	while (os_file_readdir_next_file(it->dbpath, it->dbdir,
-4. 					  &it->fileinfo) == 0) {
-3. 		if (it->fileinfo.type == OS_FILE_TYPE_DIR) {
-2. 			continue",Useful
"/************************************************************************
Interface to read MySQL data file sequentially. One should open file
with datafile_open to get cursor and close the cursor with
datafile_close. Cursor can not be shared between multiple
threads.*/","-5. bool
-4. is_path_separator(char c)
-3. {
-2. 	return(c == FN_LIBCHAR || c == FN_LIBCHAR2);
-1. }

 /************************************************************************
Interface to read MySQL data file sequentially. One should open file
with data",Useful
"/*Get the relative path for the destination tablespace name, i.e. the
	one that can be appended to the backup root directory. Non-system
	tablespaces may have absolute paths for remote tablespaces in MySQL
	5.6+. We want to make ""local"" copies for the backup.*/","-10. 		os_file_close(cursor->file);
-9. 	}
-8. 	free(cursor->buf);
-7. }
-6. static
-5. bool
-4. datafile_open(const char *file, datafile_cur_t *cursor, uint thread_n)
-3. {
-2. 	bool		success;
-1. 	new (cursor) datafile_cur_t(file);

 /*Get the relative ",Useful
/*The following call prints an error message*/,"-10. 	tablespaces may have absolute paths for remote tablespaces in MySQL
-9. 	5.6+. We want to make ""local"" copies for the backup. */
-8. 	strncpy(cursor->rel_path,
-7. 		xb_get_relative_path(cursor->abs_path, FALSE),
-6. 		(sizeof cursor->rel_path) - 1)",Useful
"/************************************************************************
Check to see if a file exists.
Takes name of the file to check.
@return true if file exists.*/","-10. 			  cursor->file, cursor->buf, cursor->buf_offset,
-9. 			  to_read) != DB_SUCCESS) {
-8. 		return(XB_FIL_CUR_ERROR);
-7. 	}
-6. 	posix_fadvise(cursor->file, cursor->buf_offset, to_read,
-5. 		      POSIX_FADV_DONTNEED);
-4. 	cursor->buf_read = to_r",Useful
"/************************************************************************
Trim leading slashes from absolute path so it becomes relative*/","-10. @return true if file exists. */
-9. bool
-8. file_exists(const char *filename)
-7. {
-6. 	MY_STAT stat_arg;
-5. 	if (!my_stat(filename, &stat_arg, MYF(0))) {
-4. 		return(false);
-3. 	}
-2. 	return(true);
-1. }

 /************************************",Useful
"/************************************************************************
Check if string ends with given suffix.
@return true if string ends with given suffix.*/","-10. 			continue;
-9. 		}
-8. 		if (*path == '.' && is_path_separator(path[1])) {
-7. 			path += 2;
-6. 			continue;
-5. 		}
-4. 		break;
-3. 	}
-2. 	return(path);
-1. }

 /************************************************************************
Check if ",Useful
"/************************************************************************
Create directories recursively.
@return 0 if directories created successfully.*/","-10. {
-9. 	size_t suffix_len = strlen(suffix);
-8. 	size_t str_len = strlen(str);
-7. 	return(str_len >= suffix_len
-6. 	       && strcmp(str + str_len - suffix_len, suffix) == 0);
-5. }
-4. static bool starts_with(const char *str, const char *prefix)
-3",Useful
/*make a parent directory path*/,"-5. static
-4. int
-3. mkdirp(const char *pathname, int Flags, myf MyFlags)
-2. {
-1. 	char *parent, *p;

 /*make a parent directory path*/

1. 	if (!(parent= strdup(pathname)))
2.           return(-1);
3. 	for (p = parent + strlen(parent);
4. 	    !is_pa",Useful
/*try to make parent directory*/,"-5. 	if (!(parent= strdup(pathname)))
-4.           return(-1);
-3. 	for (p = parent + strlen(parent);
-2. 	    !is_path_separator(*p) && p != parent; p--) ;
-1. 	*p = 0;

 /*try to make parent directory*/

1. 	if (p != parent && mkdirp(parent, Flags, MyF",Useful
/*make this one if parent has been made*/,"-4. 	if (p != parent && mkdirp(parent, Flags, MyFlags) != 0) {
-3. 		free(parent);
-2. 		return(-1);
-1. 	}

 /*make this one if parent has been made*/

1. 	if (my_mkdir(pathname, Flags, MyFlags) == 0) {
2. 		free(parent);
3. 		return(0);
4. 	}",Useful
"/************************************************************************
Return true if first and second arguments are the same path.*/","-7. 	if (errno == EEXIST) {
-6. 		free(parent);
-5. 		return(0);
-4. 	}
-3. 	free(parent);
-2. 	return(-1);
-1. }

 /************************************************************************
Return true if first and second arguments are the same path.*/

1",Useful
"/************************************************************************
Check if directory exists. Optionally create directory if doesn't
exist.
@return true if directory exists and if it was created successfully.*/","-10. 		return false;
-9. 	}
-8. 	result = strcmp(real_first, real_second);
-7. 	free(real_first);
-6. 	free(real_second);
-5. 	return result == 0;
-4. #else
-3. 	return strcmp(first, second) == 0;
-2. #endif
-1. }

 /**************************************",Useful
/*could be symlink*/,"-10. 	if (my_stat(dir, &stat_arg, MYF(0)) == NULL) {
-9. 		if (!create) {
-8. 			return(false);
-7. 		}
-6. 		if (mkdirp(dir, 0777, MYF(0)) < 0) {
-5. 			my_strerror(errbuf, sizeof(errbuf), my_errno);
-4. 			msg(""Can not create directory %s: %s"", dir, err",Useful
"/************************************************************************
Check if file name ends with given set of suffixes.
@return true if it does.*/","-10. 		msg(""%s can not open directory %s"", comment, dir);
-9. 		return(false);
-8. 	}
-7. 	empty = (fil_file_readdir_next_file(&err, dir, os_dir, &info) != 0);
-6. 	os_file_closedir(os_dir);
-5. 	if (!empty) {
-4. 		msg(""%s directory %s is not empty!"", co",Useful
"/************************************************************************
Copy data file for backup. Also check if it is allowed to copy by
comparing its name to the list of known data file types and checking
if passes the rules for partial backup.
@return true if file backed up or skipped successfully.*/","-10. filename_matches(const char *filename, const char **ext_list)
-9. {
-8. 	const char **ext;
-7. 	for (ext = ext_list; *ext; ext++) {
-6. 		if (ends_with(filename, *ext)) {
-5. 			return(true);
-4. 		}
-3. 	}
-2. 	return(false);
-1. }

 /**************",Useful
"/*Get the name and the path for the tablespace. node->name always
	contains the path (which may be absolute for remote tablespaces in
	5.6+). space->name contains the tablespace name in the form
	""./database/table.ibd"" (in 5.5-) or ""database/table"" (in 5.6+). For a
	multi-node shared tablespace, space->name contains the name of the first
	node, but that's irrelevant, since we only need node_name to match them
	against filters, and the shared tablespace is always copied regardless
	of the filters value.*/","-10. comparing its name to the list of known data file types and checking
-9. if passes the rules for partial backup.
-8. @return true if file backed up or skipped successfully. */
-7. static
-6. bool
-5. datafile_copy_backup(const char *filepath, uint th",Useful
"/*Get the name and the path for the tablespace. node->name always
	contains the path (which may be absolute for remote tablespaces in
	5.6+). space->name contains the tablespace name in the form
	""./database/table.ibd"" (in 5.5-) or ""database/table"" (in 5.6+). For a
	multi-node shared tablespace, space->name contains the name of the first
	node, but that's irrelevant, since we only need node_name to match them
	against filters, and the shared tablespace is always copied regardless
	of the filters value.*/","-10. comparing its name to the list of known data file types and checking
-9. if passes the rules for partial backup.
-8. @return true if file backed up or skipped successfully. */
-7. static
-6. bool
-5. datafile_copy_backup(const char *filepath, uint th",Useful
/*Wait for threads to exit*/,"-10. 		malloc(sizeof(datadir_thread_ctxt_t) * n);
-9. 	pthread_mutex_init(&count_mutex, NULL);
-8. 	count = n;
-7. 	for (i = 0; i < n; i++) {
-6. 		data_threads[i].it = it;
-5. 		data_threads[i].n_thread = i + 1;
-4. 		data_threads[i].count = &count;
-3. ",Useful
"/************************************************************************
Copy file for backup/restore.
@return true in case of success.*/","-10. 	ret = true;
-9. 	for (i = 0; i < n; i++) {
-8. 		ret = data_threads[i].ret && ret;
-7. 		if (!data_threads[i].ret) {
-6. 			msg(""Error: thread %u failed."", i);
-5. 		}
-4. 	}
-3. 	free(data_threads);
-2. 	return(ret);
-1. }

 /**********************",Useful
"/************************************************************************
Try to move file by renaming it. If source and destination are on
different devices fall back to copy and unlink.
@return true in case of success.*/","-10. 	ret = true;
-9. 	for (i = 0; i < n; i++) {
-8. 		ret = data_threads[i].ret && ret;
-7. 		if (!data_threads[i].ret) {
-6. 			msg(""Error: thread %u failed."", i);
-5. 		}
-4. 	}
-3. 	free(data_threads);
-2. 	return(ret);
-1. }

 /**********************",Useful
/*Trim whitespace from end of filepath*/,"-10. void
-9. read_link_file(const char *ibd_filepath, const char *link_filepath)
-8. {
-7. 	char *filepath= NULL;
-6. 	FILE *file = fopen(link_filepath, ""r+b"");
-5. 	if (file) {
-4. 		filepath = static_cast<char*>(malloc(OS_FILE_MAX_PATH));
-3. 		os_file",Useful
"/************************************************************************
Return the location of given .ibd if it was previously read
from .isl file.
@return NULL or destination .ibd file path.*/","-9. 			ulint lastch = len - 1;
-8. 			while (lastch > 4 && filepath[lastch] <= 0x20) {
-7. 				filepath[lastch--] = 0x00;
-6. 			}
-5. 		}
-4. 		tablespace_locations[ibd_filepath] = filepath;
-3. 	}
-2. 	free(filepath);
-1. }

 /**************************",Useful
"/************************************************************************
Copy or move file depending on current mode.
@return true in case of success.*/","-10. 	ret = true;
-9. 	for (i = 0; i < n; i++) {
-8. 		ret = data_threads[i].ret && ret;
-7. 		if (!data_threads[i].ret) {
-6. 			msg(""Error: thread %u failed."", i);
-5. 		}
-4. 	}
-3. 	free(data_threads);
-2. 	return(ret);
-1. }

 /**********************",Useful
/*copy to datadir by default*/,"-10. Copy or move file depending on current mode.
-9. @return true in case of success. */
-8. static
-7. bool
-6. copy_or_move_file(const char *src_file_path,
-5. 		  const char *dst_file_path,
-4. 		  const char *dst_dir,
-3. 		  uint thread_n,
-2. 		 bo",Useful
/*read the link from .isl file*/,"-3. 	char filedir[FN_REFLEN];
-2. 	size_t filedir_len;
-1. 	bool ret;

 /*read the link from .isl file*/

1. 	if (ends_with(src_file_path, "".isl"")) {
2. 		char *ibd_filepath;
3. 		ibd_filepath = strdup(src_file_path);
4. 		strcpy(ibd_filepath + strlen(ibd",Useful
"/*Remove files that have been removed between first and
			second passes. Cannot use ""rsync --delete"" because it
			does not work with --files-from.*/","-10. 		if ((err = system(cmd.str().c_str()) && !prep_mode) != 0) {
-9. 			msg(""Error: rsync failed with error code %d"", err);
-8. 			ret = false;
-7. 			goto out;
-6. 		}
-5. 		msg(""rsync finished successfully."");
-4. 		if (!prep_mode && !opt_no_lock) {
-",Useful
"/*There is no need to stop slave thread before coping non-Innodb data when
--no-lock option is used because --no-lock option requires that no DDL or
DML to non-transaction tables can occur.*/","-10. 	}
-9. 	msg(""Waiting for log copy thread to read lsn %llu"", (ulonglong)server_lsn_after_lock);
-8. 	backup_wait_for_lsn(server_lsn_after_lock);
-7. 	DBUG_EXECUTE_FOR_KEY(""sleep_after_waiting_for_lsn"", {},
-6. 		{
-5. 			ulong milliseconds = strtoul(d",Useful
"/*The only reason why Galera/binlog info is written before
	wait_for_ibbackup_log_copy_finish() is that after that call the xtrabackup
	binary will start streamig a temporary copy of REDO log to stdout and
	thus, any streaming from innobackupex would interfere. The only way to
	avoid that is to have a single process, i.e. merge innobackupex and
	xtrabackup.*/","-10. 				return(false);
-9. 			}
-8. 		}
-7. 	}
-6. 	if (opt_slave_info) {
-5. 		lock_binlog_maybe(mysql_connection);
-4. 		if (!write_slave_info(mysql_connection)) {
-3. 			return(false);
-2. 		}
-1. 	}

 /*The only reason why Galera/binlog info is writt",Useful
/** Release resources after backup_start()*/,"-10. 			return(false);
-9. 		}
-8. 	}
-7. 	if (have_flush_engine_logs && !opt_no_lock) {
-6. 		msg(""Executing FLUSH NO_WRITE_TO_BINLOG ENGINE LOGS..."");
-5. 		xb_mysql_query(mysql_connection,
-4. 			""FLUSH NO_WRITE_TO_BINLOG ENGINE LOGS"", false);
-3. 	}
-",Useful
/** Finish after backup_start() and backup_release()*/,"-10. 	const char *dst_name = default_buffer_pool_file;
-9. 	if (!opt_galera_info) {
-8. 		dir_length = dirname_length(buffer_pool_filename);
-7. 		dst_name = buffer_pool_filename + dir_length;
-6. 	}
-5. 	if (length) {
-4. 		*length=dir_length;
-3. 	}
-2.",Useful
/*copy only non-innodb files*/,"-4. 	if (xtrabackup_incremental) {
-3. 		ds_data = ds_create(xtrabackup_target_dir, DS_TYPE_LOCAL);
-2. 		it = datadir_iter_new(xtrabackup_incremental_dir);
-1. 		while (datadir_iter_next(it, &node)) {

 /*copy only non-innodb files*/

1. 			if (node.is_e",Useful
"/*If we are applying an incremental change set, we need to make
	sure non-InnoDB files are cleaned up from full backup dir before
	we copy files from incremental dir.*/","-10. 	return(ret);
-9. }
-8. bool
-7. ibx_cleanup_full_backup()
-6. {
-5. 	const char *ext_list[] = {""delta"", ""meta"", ""ibd"", NULL};
-4. 	datadir_iter_t *it = NULL;
-3. 	datadir_node_t node;
-2. 	bool ret = true;
-1. 	datadir_node_init(&node);

 /*If we ar",Useful
/*cd to backup directory*/,"-10. 			return(false);
-9. 	}
-8. 	if (innobase_data_home_dir && *innobase_data_home_dir
-7. 		&& !directory_exists(innobase_data_home_dir, true)) {
-6. 			return(false);
-5. 	}
-4. 	if (srv_log_group_home_dir && *srv_log_group_home_dir
-3. 		&& !director",Useful
/*copy the rest of tablespaces*/,"-10. 	     end(srv_sys_space.end());
-9. 	     iter != end;
-8. 	     ++iter) {
-7. 		const char *filepath = iter->filepath();
-6. 		if (!(ret = copy_or_move_file(base_name(filepath), filepath,
-5. 					      dst_dir, 1))) {
-4. 			goto cleanup;
-3. 		}
-",Useful
/*copied at later step*/,"-10. 			NULL};
-9. 		const char *filename;
-8. 		char c_tmp;
-7. 		int i_tmp;
-6. 		if (strstr(node.filepath,""/"" ROCKSDB_BACKUP_DIR ""/"")
-5. #ifdef _WIN32
-4. 			|| strstr(node.filepath,""\\"" ROCKSDB_BACKUP_DIR ""\\"")
-3. #endif
-2. 		)
-1. 		{

 /*copied a",Useful
/*skip .qp files*/,"-10. 				my_strerror(errbuf, sizeof(errbuf), my_errno);
-9. 				msg(""Can not create directory %s: %s"",
-8. 					path, errbuf);
-7. 				ret = false;
-6. 				goto cleanup;
-5. 			}
-4. 			msg("" ...done."");
-3. 			continue;
-2. 		}
-1. 		filename = base_name",Useful
/*skip undo tablespaces*/,"-3. 		if (filename_matches(filename, ext_list)) {
-2. 			continue;
-1. 		}

 /*skip undo tablespaces*/

1. 		if (sscanf(filename, ""undo%d%c"", &i_tmp, &c_tmp) == 1) {
2. 			continue;
3. 		}",Useful
/*skip the redo log (it was already copied)*/,"-3. 		if (sscanf(filename, ""undo%d%c"", &i_tmp, &c_tmp) == 1) {
-2. 			continue;
-1. 		}

 /*skip the redo log (it was already copied)*/

1. 		if (!strcmp(filename, LOG_FILE_NAME)) {
2. 			continue;
3. 		}",Useful
/*skip innodb data files*/,"-3. 		if (!strcmp(filename, src_buffer_pool)) {
-2. 			continue;
-1. 		}

 /*skip innodb data files*/

1. 		for (Tablespace::const_iterator iter(srv_sys_space.begin()),
2. 		       end(srv_sys_space.end()); iter != end; ++iter) {
3. 			if (!strcmp(base_na",Useful
/*skip empty directories in backup*/,"-10. 		}
-9. 	 }
-8.  	return(true);
-7. }
-6. static void decrypt_decompress_thread_func(datadir_thread_ctxt_t *ctxt)
-5. {
-4. 	bool ret = true;
-3. 	datadir_node_t node;
-2. 	datadir_node_init(&node);
-1. 	while (datadir_iter_next(ctxt->it, &node)) {

",Useful
/*cd to backup directory*/,"-10. 			return(false);
-9. 	}
-8. 	if (innobase_data_home_dir && *innobase_data_home_dir
-7. 		&& !directory_exists(innobase_data_home_dir, true)) {
-6. 			return(false);
-5. 	}
-4. 	if (srv_log_group_home_dir && *srv_log_group_home_dir
-3. 		&& !director",Useful
/*copy the rest of tablespaces*/,"-10. 	     end(srv_sys_space.end());
-9. 	     iter != end;
-8. 	     ++iter) {
-7. 		const char *filepath = iter->filepath();
-6. 		if (!(ret = copy_or_move_file(base_name(filepath), filepath,
-5. 					      dst_dir, 1))) {
-4. 			goto cleanup;
-3. 		}
-",Useful
"/*Copy some files from top level datadir.
  Do not copy the Innodb files (ibdata1, redo log files),
  as this is done in a separate step.*/","-10. 	if (it != NULL) {
-9. 		datadir_iter_free(it);
-8. 	}
-7. 	if (ds_data != NULL) {
-6. 		ds_destroy(ds_data);
-5. 	}
-4. 	ds_data = NULL;
-3. 	return(ret);
-2. }
-1. /*
  Copy some files from top level datadir.
  Do not copy the Innodb files (ibdata1",Useful
"/*Create a file hardlink.
@return true on success, false on error.*/","-10. 		char c = path[path_len - 1];
-9. 		if (c == '/' IF_WIN(|| c == '\\', ))
-8. 			path_len--;
-7. 		else
-6. 			break;
-5. 	}
-4. 	path[path_len] = 0;
-3. 	return path;
-2. }
-1. /*
Create a file hardlink.
@return true on success, false on error.

 /*",Useful
"/*Copies or moves a directory (non-recursively so far).
 Helper function used to backup rocksdb checkpoint, or copy-back the
 rocksdb files.

 Has optimization that allows to use hardlinks when possible
 (source and destination are directories on the same device)*/","-10. 	{
-9. 		strncpy(to_path_full, to_path, sizeof(to_path_full));
-8. 	}
-7. #ifdef _WIN32
-6. 	return  CreateHardLink(to_path_full, from_path, NULL);
-5. #else
-4. 	return !link(from_path, to_path_full);
-3. #endif
-2. }
-1. /*
 Copies or moves a direc",Useful
"/*Obtain user level lock , to protect the checkpoint directory of the server
  from being  user/overwritten by different backup processes, if backups are
  running in parallel.
  
  This lock will be acquired before rocksdb checkpoint is created,  held
  while all files from it are being copied to their final backup destination,
  and finally released after the checkpoint is removed.*/","-10. 				move_file(ds_data, from_path, node.filepath_rel,
-9. 					to, 1));
-8. 		}
-7. 		if (!rc)
-6. 			die(""copy or move file failed"");
-5. 	}
-4. 	datadir_iter_free(it);
-3. 	datadir_node_free(&node);
-2. }
-1. /*
  Obtain user level lock , to protect",Useful
"/*Copy files from rocksdb temporary checkpoint to final destination.
  remove temp.checkpoint directory (in server's datadir)
  and release user level lock acquired inside rocksdb_create_checkpoint().*/","-10. 	if (!access(rocksdb_checkpoint_dir, 0))
-9. 	{
-8. 		msg(""Removing rocksdb checkpoint from previous backup attempt."");
-7. 		rocksdb_remove_checkpoint_directory();
-6. 	}
-5. 	char query[FN_REFLEN + 32];
-4. 	snprintf(query, sizeof(query), ""SET GLOB",Useful
"/*We are going to create a one-file ""flat"" (i.e. with no
	subdirectories) archive. So strip the directory part from the path and
	remove the '.qp' suffix.*/","-4. 	if (ds_write(dest_file, ""qpress10"", 8) ||
-3. 	    write_uint64_le(dest_file, COMPRESS_CHUNK_SIZE)) {
-2. 		goto err;
-1. 	}

 /*We are going to create a one-file ""flat"" (i.e. with no
	subdirectories) archive. So strip the directory part from the pat",Useful
/*The number of slots to increase the_history by.*/,"-9. #if defined (HAVE_UNISTD_H)
-8. #  ifdef _MINIX
-7. #    include <sys/types.h>
-6. #  endif
-5. #  include <unistd.h>
-4. #endif
-3. #include ""history.h""
-2. #include ""histlib.h""
-1. #include ""xmalloc.h""

 /*The number of slots to increase the_history",Useful
/*An array of HIST_ENTRY.  This is where we store the history.*/,"-7. #define DEFAULT_HISTORY_GROW_SIZE 50
-6. static char *hist_inittime PARAMS((void));

 /*An array of HIST_ENTRY.  This is where we store the history.*/

1. static HIST_ENTRY **the_history = (HIST_ENTRY **)NULL;",Useful
"/*Non-zero means that we have enforced a limit on the amount of
   history that we save.*/","-9. #define DEFAULT_HISTORY_GROW_SIZE 50
-8. static char *hist_inittime PARAMS((void));

 /*Non-zero means that we have enforced a limit on the amount of
   history that we save.*/

1. static int history_stifled;",Useful
/*The current number of slots allocated to the input_history.*/,"-4. static HIST_ENTRY **the_history = (HIST_ENTRY **)NULL;

 /*The current number of slots allocated to the input_history.*/

1. static int history_size;",Useful
"/*If HISTORY_STIFLED is non-zero, then this is the maximum number of
   entries to remember.*/","-1. static int history_size;

 /*If HISTORY_STIFLED is non-zero, then this is the maximum number of
   entries to remember.*/

1. int history_max_entries;",Useful
/*backwards compatibility*/,"-1. int history_max_entries;

 /*backwards compatibility*/

111",Useful
"/*The current location of the interactive history pointer.  Just makes
   life easier for outside callers.*/","-2. int history_max_entries;

 /*The current location of the interactive history pointer.  Just makes
   life easier for outside callers.*/

1. int history_offset;",Useful
/*The number of strings currently stored in the history list.*/,"-1. int history_offset;

 /*The number of strings currently stored in the history list.*/

1. int history_length;",Useful
/*The logical `base' of the history array.  It defaults to 1.*/,"-1. int history_length;

 /*The logical `base' of the history array.  It defaults to 1.*/

1. int history_base = 1;",Useful
/*Return the current HISTORY_STATE of the history.*/,"-1. int history_base = 1;

 /*Return the current HISTORY_STATE of the history.*/

1. HISTORY_STATE *
2. history_get_history_state ()
3. {
4.   HISTORY_STATE *state;
5.   state = (HISTORY_STATE *)xmalloc (sizeof (HISTORY_STATE));
6.   state->entries = the_",Useful
/*Set the state of the current history array to STATE.*/,"-10.   state = (HISTORY_STATE *)xmalloc (sizeof (HISTORY_STATE));
-9.   state->entries = the_history;
-8.   state->offset = history_offset;
-7.   state->length = history_length;
-6.   state->size = history_size;
-5.   state->flags = 0;
-4.   if (history_s",Useful
"/*Begin a session in which the history functions might be used.  This
   initializes interactive variables.*/","-10. history_set_history_state (state)
-9.      HISTORY_STATE *state;
-8. {
-7.   the_history = state->entries;
-6.   history_offset = state->offset;
-5.   history_length = state->length;
-4.   history_size = state->size;
-3.   if (state->flags & HS_STIFL",Useful
"/*Return the number of bytes that the primary history entries are using.
   This just adds up the lengths of the_history->lines and the associated
   timestamps.*/","-5. void
-4. using_history ()
-3. {
-2.   history_offset = history_length;
-1. }

 /*Return the number of bytes that the primary history entries are using.
   This just adds up the lengths of the_history->lines and the associated
   timestamps.*/

1. int
",Useful
"/*Returns the magic number which says what history element we are
   looking at now.  In this implementation, it returns history_offset.*/","-10.    This just adds up the lengths of the_history->lines and the associated
-9.    timestamps. */
-8. int
-7. history_total_bytes ()
-6. {
-5.   register int i, result;
-4.   for (i = result = 0; the_history && the_history[i]; i++)
-3.     result += HI",Useful
"/*Make the current history item be the one at POS, an absolute index.
   Returns zero if POS is out of range, else non-zero.*/","-5. int
-4. where_history ()
-3. {
-2.   return (history_offset);
-1. }

 /*Make the current history item be the one at POS, an absolute index.
   Returns zero if POS is out of range, else non-zero.*/

1. int
2. history_set_pos (pos)
3.      int pos;
4. {",Useful
"/*Return the current history array.  The caller has to be carefull, since this
   is the actual array of data, and could be bashed or made corrupt easily.
   The array is terminated with a NULL pointer.*/","-10.    Returns zero if POS is out of range, else non-zero. */
-9. int
-8. history_set_pos (pos)
-7.      int pos;
-6. {
-5.   if (pos > history_length || pos < 0 || !the_history)
-4.     return (0);
-3.   history_offset = pos;
-2.   return (1);
-1. }

 /",Useful
"/*Return the history entry at the current position, as determined by
   history_offset.  If there is no entry there, return a NULL pointer.*/","-5. HIST_ENTRY **
-4. history_list ()
-3. {
-2.   return (the_history);
-1. }

 /*Return the history entry at the current position, as determined by
   history_offset.  If there is no entry there, return a NULL pointer.*/

1. HIST_ENTRY *
2. current_histo",Useful
"/*Back up history_offset to the previous history entry, and return
   a pointer to that entry.  If there is no previous entry then return
   a NULL pointer.*/","-7. HIST_ENTRY *
-6. current_history ()
-5. {
-4.   return ((history_offset == history_length) || the_history == 0)
-3. 		? (HIST_ENTRY *)NULL
-2. 		: the_history[history_offset];
-1. }

 /*Back up history_offset to the previous history entry, and return
",Useful
"/*Move history_offset forward to the next history entry, and return
   a pointer to that entry.  If there is no next entry then return a
   NULL pointer.*/","-5. HIST_ENTRY *
-4. previous_history ()
-3. {
-2.   return history_offset ? the_history[--history_offset] : (HIST_ENTRY *)NULL;
-1. }

 /*Move history_offset forward to the next history entry, and return
   a pointer to that entry.  If there is no next e",Useful
"/*Return the history entry which is logically at OFFSET in the history array.
   OFFSET is relative to history_base.*/","-5. HIST_ENTRY *
-4. next_history ()
-3. {
-2.   return (history_offset == history_length) ? (HIST_ENTRY *)NULL : the_history[++history_offset];
-1. }

 /*Return the history entry which is logically at OFFSET in the history array.
   OFFSET is relative to",Useful
/*XXX - should use strtol() here*/,"-10. history_get_time (hist)
-9.      HIST_ENTRY *hist;
-8. {
-7.   char *ts;
-6.   time_t t;
-5.   if (hist == 0 || hist->timestamp == 0)
-4.     return 0;
-3.   ts = hist->timestamp;
-2.   if (ts[0] != history_comment_char)
-1.     return 0;

 /*XXX - s",Useful
"/*Place STRING at the end of the history list.  The data field
   is  set to NULL.*/","-8.   snprintf (ts, sizeof (ts) - 1, ""X%lu"", (unsigned long) t);
-7. #else
-6.   sprintf (ts, ""X%lu"", (unsigned long) t);
-5. #endif
-4.   ret = savestring (ts);
-3.   ret[0] = history_comment_char;
-2.   return ret;
-1. }

 /*Place STRING at the end of t",Useful
"/*If the history is stifled, and history_length is zero,
	 and it equals history_max_entries, we don't save items.*/","-8. void
-7. add_history (string)
-6.      const char *string;
-5. {
-4.   HIST_ENTRY *temp;
-3.   if (history_stifled && (history_length == history_max_entries))
-2.     {
-1.       register int i;

 /*If the history is stifled, and history_length is zer",Useful
"/*If there is something in the slot, then remove it.*/","-2.       if (history_length == 0)
-1. 	return;

 /*If there is something in the slot, then remove it.*/

1.       if (the_history[0])
2. 	(void) free_history_entry (the_history[0]);",Useful
"/*Copy the rest of the entries, moving down one slot.*/","-2.       if (the_history[0])
-1. 	(void) free_history_entry (the_history[0]);

 /*Copy the rest of the entries, moving down one slot.*/

1.       for (i = 0; i < history_length; i++)
2. 	the_history[i] = the_history[i + 1];
3.       history_base++;
4.   ",Useful
/*Change the time stamp of the most recent history entry to STRING.*/,"-10. 	      the_history = (HIST_ENTRY **)
-9. 		xrealloc (the_history, history_size * sizeof (HIST_ENTRY *));
-8. 	    }
-7. 	  history_length++;
-6. 	}
-5.     }
-4.   temp = alloc_history_entry ((char*) string, hist_inittime ());
-3.   the_history[histo",Useful
"/*Free HIST and return the data so the calling application can free it
   if necessary and desired.*/","-9. void
-8. add_history_time (string)
-7.      const char *string;
-6. {
-5.   HIST_ENTRY *hs;
-4.   hs = the_history[history_length - 1];
-3.   FREE (hs->timestamp);
-2.   hs->timestamp = savestring (string);
-1. }

 /*Free HIST and return the data so t",Useful
"/*Make the history entry at WHICH have LINE and DATA.  This returns
   the old entry so you can dispose of the data.  In the case of an
   invalid WHICH, a NULL pointer is returned.*/","-10.   HIST_ENTRY *ret;
-9.   char *ts;
-8.   if (hist == 0)
-7.     return hist;
-6.   ret = alloc_history_entry (hist->line, (char *)NULL);
-5.   ts = hist->timestamp ? savestring (hist->timestamp) : hist->timestamp;
-4.   ret->timestamp = ts;
-3.   ret",Useful
"/*Replace the DATA in the specified history entries, replacing OLD with
   NEW.  WHICH says which one(s) to replace:  WHICH == -1 means to replace
   all of the history entries where entry->data == OLD; WHICH == -2 means
   to replace the `newest' history entry where entry->data == OLD; and
   WHICH >= 0 means to replace that particular history entry's data, as
   long as it matches OLD.*/","-10.   if (which < 0 || which >= history_length)
-9.     return ((HIST_ENTRY *)NULL);
-8.   temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
-7.   old_value = the_history[which];
-6.   temp->line = savestring (line);
-5.   temp->data = data;
-4.   temp",Useful
/*XXX - we don't check entry->old*/,"-10.       if (entry->data == old)
-9. 	{
-8. 	  last = i;
-7. 	  if (which == -1)
-6. 	    entry->data = new;
-5. 	}
-4.     }
-3.   if (which == -2 && last >= 0)
-2.     {
-1.       entry = the_history[last];

 /*XXX - we don't check entry->old*/

1.   ",Useful
"/*Remove history element WHICH from the history.  The removed
   element is returned to you so you can free the line, data,
   and containing structure.*/","-2.     }
-1. }

 /*Remove history element WHICH from the history.  The removed
   element is returned to you so you can free the line, data,
   and containing structure.*/

1. HIST_ENTRY *
2. remove_history (which)
3.      int which;
4. {
5.   HIST_ENTRY",Useful
"/*Stifle the history list, remembering only MAX number of lines.*/","-10.   HIST_ENTRY *return_value;
-9.   register int i;
-8.   if (which < 0 || which >= history_length || history_length ==  0 || the_history == 0)
-7.     return ((HIST_ENTRY *)NULL);
-6.   return_value = the_history[which];
-5.   for (i = which; i < hist",Useful
/*This loses because we cannot free the data.*/,"-9. void
-8. stifle_history (max)
-7.      int max;
-6. {
-5.   register int i, j;
-4.   if (max < 0)
-3.     max = 0;
-2.   if (history_length > max)
-1.     {

 /*This loses because we cannot free the data.*/

1.       for (i = 0, j = history_length - m",Useful
"/*Stop stifling the history.  This returns the previous maximum
   number of history entries.  The value is positive if the history
   was stifled,  negative if it wasn't.*/","-10. 	free_history_entry (the_history[i]);
-9.       history_base = i;
-8.       for (j = 0, i = history_length - max; j < max; i++, j++)
-7. 	the_history[j] = the_history[i];
-6.       the_history[j] = (HIST_ENTRY *)NULL;
-5.       history_length = j;
-4",Useful
/*This loses because we cannot free the data.*/,"-9. void
-8. stifle_history (max)
-7.      int max;
-6. {
-5.   register int i, j;
-4.   if (max < 0)
-3.     max = 0;
-2.   if (history_length > max)
-1.     {

 /*This loses because we cannot free the data.*/

1.       for (i = 0, j = history_length - m",Useful
"/************************************************************************
Run the next batch of pages through incremental page write filter.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
"/************************************************************************
Flush the incremental page write filter's buffer.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
"/************************************************************************
Initialize the write-through page write filter.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
"/************************************************************************
Write the next batch of pages to the destination datasink.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
/*The current style of editing.*/,"-1. Keymap _rl_keymap = emacs_standard_keymap;

 /*The current style of editing.*/

1. int rl_editing_mode = emacs_mode;",Useful
/*The current insert mode:  input (the default) or overwrite*/,"-1. int rl_editing_mode = emacs_mode;

 /*The current insert mode:  input (the default) or overwrite*/

1. int rl_insert_mode = RL_IM_DEFAULT;",Useful
"/*Non-zero if we called this function from _rl_dispatch().  It's present
   so functions can find out whether they were called from a key binding
   or directly from an application.*/","-1. int rl_insert_mode = RL_IM_DEFAULT;

 /*Non-zero if we called this function from _rl_dispatch().  It's present
   so functions can find out whether they were called from a key binding
   or directly from an application.*/

1. int rl_dispatching;",Useful
/*Non-zero if the previous command was a kill command.*/,"-1. int rl_dispatching;

 /*Non-zero if the previous command was a kill command.*/

1. int _rl_last_command_was_kill = 0;",Useful
/*The current value of the numeric argument specified by the user.*/,"-1. int _rl_last_command_was_kill = 0;

 /*The current value of the numeric argument specified by the user.*/

1. int rl_numeric_arg = 1;",Useful
/*Non-zero if an argument was typed.*/,"-1. int rl_numeric_arg = 1;

 /*Non-zero if an argument was typed.*/

1. int rl_explicit_arg = 0;",Useful
/*Temporary value used while generating the argument.*/,"-1. int rl_explicit_arg = 0;

 /*Temporary value used while generating the argument.*/

1. int rl_arg_sign = 1;",Useful
/*Non-zero means we have been called at least once before.*/,"-1. int rl_arg_sign = 1;

 /*Non-zero means we have been called at least once before.*/

1. static int rl_initialized;
2. #if 0",Useful
"/*If non-zero, this program is running in an EMACS buffer.*/","-2. static int rl_initialized;
-1. #if 0

 /*If non-zero, this program is running in an EMACS buffer.*/

1. static int running_in_emacs;
2. #endif",Useful
/*Flags word encapsulating the current readline state.*/,"-2. static int running_in_emacs;
-1. #endif

 /*Flags word encapsulating the current readline state.*/

1. int rl_readline_state = RL_STATE_NONE;",Useful
/*The current offset in the current input line.*/,"-1. int rl_readline_state = RL_STATE_NONE;

 /*The current offset in the current input line.*/

1. int rl_point;",Useful
/*Mark in the current input line.*/,"-1. int rl_point;

 /*Mark in the current input line.*/

1. int rl_mark;",Useful
/*Length of the current input line.*/,"-1. int rl_mark;

 /*Length of the current input line.*/

1. int rl_end;",Useful
/*Make this non-zero to return the current input_line.*/,"-1. int rl_end;

 /*Make this non-zero to return the current input_line.*/

1. int rl_done;",Useful
/*The last function executed by readline.*/,"-1. int rl_done;

 /*The last function executed by readline.*/

1. rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;",Useful
/*Top level environment for readline_internal ().*/,"-1. rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;

 /*Top level environment for readline_internal ().*/

1. procenv_t readline_top_level;",Useful
/*The streams we interact with.*/,"-1. procenv_t readline_top_level;

 /*The streams we interact with.*/

1. FILE *_rl_in_stream, *_rl_out_stream;",Useful
/*The names of the streams that we do input and output to.*/,"-1. FILE *_rl_in_stream, *_rl_out_stream;

 /*The names of the streams that we do input and output to.*/

1. FILE *rl_instream = (FILE *)NULL;
2. FILE *rl_outstream = (FILE *)NULL;",Useful
/*Current prompt.*/,"-1. int readline_echoing_p = 0;

 /*Current prompt.*/

1. char *rl_prompt = (char *)NULL;
2. int rl_visible_prompt_length = 0;",Useful
"/*Set to non-zero by calling application if it has already printed rl_prompt
   and does not want readline to do it the first time.*/","-2. char *rl_prompt = (char *)NULL;
-1. int rl_visible_prompt_length = 0;

 /*Set to non-zero by calling application if it has already printed rl_prompt
   and does not want readline to do it the first time.*/

1. int rl_already_prompted = 0;",Useful
/*The number of characters read in order to type this complete command.*/,"-1. int rl_already_prompted = 0;

 /*The number of characters read in order to type this complete command.*/

1. int rl_key_sequence_length = 0;",Useful
"/*If non-zero, then this is the address of a function to call just
   before readline_internal_setup () prints the first prompt.*/","-1. int rl_key_sequence_length = 0;

 /*If non-zero, then this is the address of a function to call just
   before readline_internal_setup () prints the first prompt.*/

1. rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;",Useful
"/*If non-zero, this is the address of a function to call just before
   readline_internal_setup () returns and readline_internal starts
   reading input characters.*/","-1. rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;

 /*If non-zero, this is the address of a function to call just before
   readline_internal_setup () returns and readline_internal starts
   reading input characters.*/

1. rl_hook_func_t *rl_p",Useful
/*What we use internally.  You should always refer to RL_LINE_BUFFER.*/,"-1. rl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;

 /*What we use internally.  You should always refer to RL_LINE_BUFFER.*/

1. static char *the_line;",Useful
"/*The character that can generate an EOF.  Really read from
   the terminal driver... just defaulted here.*/","-1. static char *the_line;

 /*The character that can generate an EOF.  Really read from
   the terminal driver... just defaulted here.*/

1. int _rl_eof_char = CTRL ('D');",Useful
/*Non-zero makes this the next keystroke to read.*/,"-1. int _rl_eof_char = CTRL ('D');

 /*Non-zero makes this the next keystroke to read.*/

1. int rl_pending_input = 0;",Useful
/*Pointer to a useful terminal name.*/,"-1. int rl_pending_input = 0;

 /*Pointer to a useful terminal name.*/

1. const char *rl_terminal_name = (const char *)NULL;",Useful
/*Non-zero means to always use horizontal scrolling in line display.*/,"-1. const char *rl_terminal_name = (const char *)NULL;

 /*Non-zero means to always use horizontal scrolling in line display.*/

1. int _rl_horizontal_scroll_mode = 0;",Useful
"/*Non-zero means to display an asterisk at the starts of history lines
   which have been modified.*/","-1. int _rl_horizontal_scroll_mode = 0;

 /*Non-zero means to display an asterisk at the starts of history lines
   which have been modified.*/

1. int _rl_mark_modified_lines = 0;",Useful
"/*The style of `bell' notification preferred.  This can be set to NO_BELL,
   AUDIBLE_BELL, or VISIBLE_BELL.*/","-1. int _rl_mark_modified_lines = 0;

 /*The style of `bell' notification preferred.  This can be set to NO_BELL,
   AUDIBLE_BELL, or VISIBLE_BELL.*/

1. int _rl_bell_preference = AUDIBLE_BELL;",Useful
/*String inserted into the line by rl_insert_comment ().*/,"-1. int _rl_bell_preference = AUDIBLE_BELL;

 /*String inserted into the line by rl_insert_comment ().*/

1. char *_rl_comment_begin;",Useful
/*Keymap holding the function currently being executed.*/,"-1. char *_rl_comment_begin;

 /*Keymap holding the function currently being executed.*/

1. Keymap rl_executing_keymap;",Useful
/*Keymap we're currently using to dispatch.*/,"-1. Keymap rl_executing_keymap;

 /*Keymap we're currently using to dispatch.*/

1. Keymap _rl_dispatching_keymap;",Useful
"/*Non-zero means to erase entire line, including prompt, on empty input lines.*/","-1. Keymap _rl_dispatching_keymap;

 /*Non-zero means to erase entire line, including prompt, on empty input lines.*/

1. int rl_erase_empty_line = 0;",Useful
"/*Non-zero means to read only this many characters rather than up to a
   character bound to accept-line.*/","-1. int rl_erase_empty_line = 0;

 /*Non-zero means to read only this many characters rather than up to a
   character bound to accept-line.*/

1. int rl_num_chars_to_read;",Useful
/*Line buffer and maintenence.*/,"-1. int rl_num_chars_to_read;

 /*Line buffer and maintenence.*/

1. char *rl_line_buffer = (char *)NULL;
2. int rl_line_buffer_len = 0;",Useful
/*Key sequence `contexts'*/,"-2. char *rl_line_buffer = (char *)NULL;
-1. int rl_line_buffer_len = 0;

 /*Key sequence `contexts'*/

1. _rl_keyseq_cxt *_rl_kscxt = 0;",Useful
"/*Non-zero means do not parse any lines other than comments and
   parser directives.*/","-7. _rl_keyseq_cxt *_rl_kscxt = 0;

 /*Non-zero means do not parse any lines other than comments and
   parser directives.*/

1. unsigned char _rl_parsing_conditionalized_out = 0;",Useful
"/*Non-zero means to convert characters with the meta bit set to
   escape-prefixed characters so we can indirect through
   emacs_meta_keymap or vi_escape_keymap.*/","-10. _rl_keyseq_cxt *_rl_kscxt = 0;

 /*Non-zero means to convert characters with the meta bit set to
   escape-prefixed characters so we can indirect through
   emacs_meta_keymap or vi_escape_keymap.*/

1. int _rl_convert_meta_chars_to_ascii = 1;",Useful
"/*Non-zero means to output characters with the meta bit set directly
   rather than as a meta-prefixed escape sequence.*/","-1. int _rl_convert_meta_chars_to_ascii = 1;

 /*Non-zero means to output characters with the meta bit set directly
   rather than as a meta-prefixed escape sequence.*/

1. int _rl_output_meta_chars = 0;",Useful
"/*Non-zero means to look at the termios special characters and bind
   them to equivalent readline functions at startup.*/","-1. int _rl_output_meta_chars = 0;

 /*Non-zero means to look at the termios special characters and bind
   them to equivalent readline functions at startup.*/

1. int _rl_bind_stty_chars = 1;",Useful
"/*Set up the prompt and expand it.  Called from readline() and
   rl_callback_handler_install ().*/","-8. int _rl_bind_stty_chars = 1;

 /*Set up the prompt and expand it.  Called from readline() and
   rl_callback_handler_install ().*/

1. int
2. rl_set_prompt (prompt)
3.      const char *prompt;
4. {
5.   FREE (rl_prompt);
6.   rl_prompt = prompt ? save",Useful
"/*Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
   none.  A return value of NULL means that EOF was encountered.*/","-10. int
-9. rl_set_prompt (prompt)
-8.      const char *prompt;
-7. {
-6.   FREE (rl_prompt);
-5.   rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
-4.   rl_display_prompt = rl_prompt ? rl_prompt : (char*) """";
-3.   rl_visible_prompt_length = rl",Useful
/*If we are at EOF return a NULL string.*/,"-5. char *
-4. readline (prompt)
-3.      const char *prompt;
-2. {
-1.   char *value;

 /*If we are at EOF return a NULL string.*/

1.   if (rl_pending_input == EOF)
2.     {
3.       rl_clear_pending_input ();
4.       return ((char *)NULL);
5.     }
6.",Useful
"/*If we're not echoing, we still want to at least print a prompt, because
     rl_redisplay will not do it for us.  If the calling application has a
     custom redisplay function, though, let that function handle it.*/","-10. #  define STATIC_CALLBACK static
-9. #endif
-8. STATIC_CALLBACK void
-7. readline_internal_setup ()
-6. {
-5.   char *nprompt;
-4.   _rl_in_stream = rl_instream;
-3.   _rl_out_stream = rl_outstream;
-2.   if (rl_startup_hook)
-1.     (*rl_startup_hoo",Useful
"/*Restore the original of this history line, iff the line that we
     are editing was originally in the history, AND the line has changed.*/","-9.   if (rl_pre_input_hook)
-8.     (*rl_pre_input_hook) ();
-7. }
-6. STATIC_CALLBACK char *
-5. readline_internal_teardown (eof)
-4.      int eof;
-3. {
-2.   char *temp;
-1.   HIST_ENTRY *entry;

 /*Restore the original of this history line, iff the l",Useful
"/*At any rate, it is highly likely that this line has an undo list.  Get
     rid of it now.*/","-10.   entry = current_history ();
-9.   if (entry && rl_undo_list)
-8.     {
-7.       temp = savestring (the_line);
-6.       rl_revert_line (1, 0);
-5.       entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
-4.       _rl_fr",Useful
"/*Restore normal cursor, if available.*/","-2.   if (rl_undo_list)
-1.     rl_free_undo_list ();

 /*Restore normal cursor, if available.*/

1.   _rl_set_insert_mode (RL_IM_INSERT, 0);
2.   return (eof ? (char *)NULL : savestring (the_line));
3. }
4. void
5. _rl_internal_char_cleanup ()
6. {
7. #i",Useful
"/*In vi mode, when you exit insert mode, the cursor moves back
     over the previous character.  We explicitly check for that here.*/","-7.   _rl_set_insert_mode (RL_IM_INSERT, 0);
-6.   return (eof ? (char *)NULL : savestring (the_line));
-5. }
-4. void
-3. _rl_internal_char_cleanup ()
-2. {
-1. #if defined (VI_MODE)

 /*In vi mode, when you exit insert mode, the cursor moves back
     o",Useful
"/*If the application writer has told us to erase the entire line if
     the only character typed was something bound to rl_newline, do so.*/","-10.     {
-9.       (*rl_redisplay_function) ();
-8.       _rl_want_redisplay = 0;
-7.       rl_newline (1, '\n');
-6.     }
-5.   if (rl_done == 0)
-4.     {
-3.       (*rl_redisplay_function) ();
-2.       _rl_want_redisplay = 0;
-1.     }

 /*If the a",Useful
/*Then initialize the argument and number of keys read.*/,"-5. 	  if (RL_ISSTATE (RL_STATE_CALLBACK))
-4. 	    return (0);
-3. 	}
-2.       if (rl_pending_input == 0)
-1. 	{

 /*Then initialize the argument and number of keys read.*/

1. 	  _rl_reset_argument ();
2. 	  rl_key_sequence_length = 0;
3. 	}
4.       R",Useful
"/*look at input.c:rl_getc() for the circumstances under which this will
	 be returned; punt immediately on read error without converting it to
	 a newline.*/","-6. 	  _rl_reset_argument ();
-5. 	  rl_key_sequence_length = 0;
-4. 	}
-3.       RL_SETSTATE(RL_STATE_READCMD);
-2.       c = rl_read_key ();
-1.       RL_UNSETSTATE(RL_STATE_READCMD);

 /*look at input.c:rl_getc() for the circumstances under which this ",Useful
/*EOF typed to a non-blank line is a <NL>.*/,"-10.       if (c == READERR)
-9. 	{
-8. #if defined (READLINE_CALLBACKS)
-7. 	  RL_SETSTATE(RL_STATE_DONE);
-6. 	  return (rl_done = 1);
-5. #else
-4. 	  eof_found = 1;
-3. 	  break;
-2. #endif
-1. 	}

 /*EOF typed to a non-blank line is a <NL>.*/

1.    ",Useful
"/*The character _rl_eof_char typed to blank line, and not as the
	 previous character is interpreted as EOF.*/","-2.       if (c == EOF && rl_end)
-1. 	c = NEWLINE;

 /*The character _rl_eof_char typed to blank line, and not as the
	 previous character is interpreted as EOF.*/

1.       if (((c == _rl_eof_char && lastc != c) || c == EOF) && !rl_end)
2. 	{
3. #if def",Useful
"/*If there was no change in _rl_last_command_was_kill, then no kill
	 has taken place.  Note that if input is pending we are reading
	 a prefix command, so nothing has changed yet.*/","-10. #if defined (READLINE_CALLBACKS)
-9. 	  RL_SETSTATE(RL_STATE_DONE);
-8. 	  return (rl_done = 1);
-7. #else
-6. 	  eof_found = 1;
-5. 	  break;
-4. #endif
-3. 	}
-2.       lastc = c;
-1.       _rl_dispatch ((unsigned char)c, _rl_keymap);

 /*If there ",Useful
"/*OK, there's no function bound in this map, but there is a
	     shadow function that was overridden when the current keymap
	     was created.  Return -2 to note  that.*/","-5. 	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
-4. 	    rl_last_func = map[key].function;
-3. 	}
-2.       else if (map[ANYOTHERKEY].function)
-1. 	{

 /*OK, there's no function bound in this map, but there is a
	     shadow f",Useful
"/*Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recursion chain and find the last
	     subsequence that is bound to a function.*/","-5. 	  _rl_unget_char  (key);
-4. 	  return -2;
-3. 	}
-2.       else if (got_subseq)
-1. 	{

 /*Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recur",Useful
"/*The only way this test will be true is if a subsequence has been
	     bound starting with ESC, generally the arrow keys.  What we do is
	     check whether there's input in the queue, which there generally
	     will be if an arrow key has been pressed, and, if there's not,
	     just dispatch to (what we assume is) rl_vi_movement_mode right
	     away.  This is essentially an input test with a zero timeout.*/","-10. 	  _rl_keyseq_chain_dispose ();
-9. #endif
-8. 	  _rl_abort_internal ();
-7. 	  return -1;
-6. 	}
-5.       break;
-4.     case ISKMAP:
-3.       if (map[key].function != 0)
-2. 	{
-1. #if defined (VI_MODE)

 /*The only way this test will be true is ",Useful
"/*Return 0 only the first time, to indicate success to
		 _rl_callback_read_char.  The rest of the time, we're called
		 from _rl_dispatch_callback, so we return 3 to indicate
		 special handling is necessary.*/","-3. #if defined (READLINE_CALLBACKS)
-2. 	  if (RL_ISSTATE (RL_STATE_CALLBACK))
-1. 	    {

 /*Return 0 only the first time, to indicate success to
		 _rl_callback_read_char.  The rest of the time, we're called
		 from _rl_dispatch_callback, so we return ",Useful
/*don't indicate immediate success*/,"-10. 	      r = RL_ISSTATE (RL_STATE_MULTIKEY) ? -3 : 0;
-9. 	      cxt = _rl_keyseq_cxt_alloc ();
-8. 	      if (got_subseq)
-7. 		cxt->flags |= KSEQ_SUBSEQ;
-6. 	      cxt->okey = key;
-5. 	      cxt->oldmap = map;
-4. 	      cxt->dmap = _rl_dispatching",Useful
"/*We didn't match anything, and the keymap we're indexed into
       shadowed a function previously bound to that prefix.  Call
       the function.  The recursive call to _rl_dispatch_subseq has
       already taken care of pushing any necessary input back onto
       the input queue with _rl_unget_char.*/","-10. static int
-9. _rl_subseq_result (r, map, key, got_subseq)
-8.      int r;
-7.      Keymap map;
-6.      int key, got_subseq;
-5. {
-4.   Keymap m;
-3.   int type, nt;
-2.   rl_command_func_t *func, *nf;
-1.   if (r == -2)

 /*We didn't match anythin",Useful
"/*We didn't match (r is probably -1), so return something to
	 tell the caller that it should try ANYOTHERKEY for an
	 overridden function.*/","-10. 	  m[key].function = func;
-9. 	  r = _rl_dispatch (key, m);
-8. 	  m[key].type = nt;
-7. 	  m[key].function = nf;
-6. 	}
-5.       else
-4. 	r = _rl_dispatch (ANYOTHERKEY, m);
-3.     }
-2.   else if (r && map[ANYOTHERKEY].function)
-1.     {

 /*We",Useful
/*Initialize readline (and terminal if not already).*/,"-10.       _rl_dispatching_keymap = map;
-9.       return -1;
-8.     }
-7.   return r;
-6. }

 /*Initialize readline (and terminal if not already).*/

1. int
2. rl_initialize ()
3. {",Useful
"/*If we have never been called before, initialize the
     terminal and data structures.*/","-3. int
-2. rl_initialize ()
-1. {

 /*If we have never been called before, initialize the
     terminal and data structures.*/

1.   if (!rl_initialized)
2.     {
3.       RL_SETSTATE(RL_STATE_INITIALIZING);
4.       readline_initialize_everything ();
5.",Useful
/*Initalize the current line information.*/,"-8.   if (!rl_initialized)
-7.     {
-6.       RL_SETSTATE(RL_STATE_INITIALIZING);
-5.       readline_initialize_everything ();
-4.       RL_UNSETSTATE(RL_STATE_INITIALIZING);
-3.       rl_initialized++;
-2.       RL_SETSTATE(RL_STATE_INITIALIZED);
-1.   ",Useful
/*We aren't done yet.  We haven't even gotten started yet!*/,"-1.   _rl_init_line_state ();

 /*We aren't done yet.  We haven't even gotten started yet!*/

1.   rl_done = 0;
2.   RL_UNSETSTATE(RL_STATE_DONE);",Useful
/*Tell the history routines what is going on.*/,"-2.   rl_done = 0;
-1.   RL_UNSETSTATE(RL_STATE_DONE);

 /*Tell the history routines what is going on.*/

1.   _rl_start_using_history ();",Useful
/*Make the display buffer match the state of the line.*/,"-1.   _rl_start_using_history ();

 /*Make the display buffer match the state of the line.*/

1.   rl_reset_line_state ();",Useful
/*No such function typed yet.*/,"-1.   rl_reset_line_state ();

 /*No such function typed yet.*/

1.   rl_last_func = (rl_command_func_t *)NULL;",Useful
/*Parsing of key-bindings begins in an enabled state.*/,"-1.   rl_last_func = (rl_command_func_t *)NULL;

 /*Parsing of key-bindings begins in an enabled state.*/

1.   _rl_parsing_conditionalized_out = 0;
2. #if defined (VI_MODE)
3.   if (rl_editing_mode == vi_mode)
4.     _rl_vi_initialize_line ();
5. #endif",Useful
/*Each line starts in insert mode (the default).*/,"-5.   _rl_parsing_conditionalized_out = 0;
-4. #if defined (VI_MODE)
-3.   if (rl_editing_mode == vi_mode)
-2.     _rl_vi_initialize_line ();
-1. #endif

 /*Each line starts in insert mode (the default).*/

1.   _rl_set_insert_mode (RL_IM_DEFAULT, 1);
2. ",Useful
/*Initialize the entire state of the world.*/,"-1. #endif

 /*Initialize the entire state of the world.*/

1. static void
2. readline_initialize_everything ()
3. {
4. #if 0
5. #if defined (__EMX__)
6.   if (environ == 0)
7.     _emx_build_environ ();
8. #endif
9. #endif
10. #if 0",Useful
/*Find out if we are running in Emacs -- UNUSED.*/,"-10. static void
-9. readline_initialize_everything ()
-8. {
-7. #if 0
-6. #if defined (__EMX__)
-5.   if (environ == 0)
-4.     _emx_build_environ ();
-3. #endif
-2. #endif
-1. #if 0

 /*Find out if we are running in Emacs -- UNUSED.*/

1.   running_in_e",Useful
/*Set up input and output if they are not already set up.*/,"-2.   running_in_emacs = sh_get_env_value (""EMACS"") != (char *)0;
-1. #endif

 /*Set up input and output if they are not already set up.*/

1.   if (!rl_instream)
2.     rl_instream = stdin;
3.   if (!rl_outstream)
4.     rl_outstream = stdout;",Useful
"/*Bind _rl_in_stream and _rl_out_stream immediately.  These values
     may change, but they may also be used before readline_internal ()
     is called.*/","-4.   if (!rl_instream)
-3.     rl_instream = stdin;
-2.   if (!rl_outstream)
-1.     rl_outstream = stdout;

 /*Bind _rl_in_stream and _rl_out_stream immediately.  These values
     may change, but they may also be used before readline_internal ()
     i",Useful
/*Allocate data structures.*/,"-2.   _rl_in_stream = rl_instream;
-1.   _rl_out_stream = rl_outstream;

 /*Allocate data structures.*/

1.   if (rl_line_buffer == 0)
2.     rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);",Useful
/*Initialize the terminal interface.*/,"-2.   if (rl_line_buffer == 0)
-1.     rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);

 /*Initialize the terminal interface.*/

1.   if (rl_terminal_name == 0)
2.     rl_terminal_name = sh_get_env_value (""TERM"");
3.   _rl_ini",Useful
/*Bind tty characters to readline functions.*/,"-3.   if (rl_terminal_name == 0)
-2.     rl_terminal_name = sh_get_env_value (""TERM"");
-1.   _rl_init_terminal_io (rl_terminal_name);

 /*Bind tty characters to readline functions.*/

1.   readline_default_bindings ();",Useful
/*Initialize the function names.*/,"-1.   readline_default_bindings ();

 /*Initialize the function names.*/

1.   rl_initialize_funmap ();",Useful
/*Decide whether we should automatically go into eight-bit mode.*/,"-1.   rl_initialize_funmap ();

 /*Decide whether we should automatically go into eight-bit mode.*/

1.   _rl_init_eightbit ();",Useful
/*Read in the init file.*/,"-1.   _rl_init_eightbit ();

 /*Read in the init file.*/

1.   rl_read_init_file ((char *)NULL);",Useful
"/*Override the effect of any `set keymap' assignments in the
     inputrc file.*/","-5.   if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
-4.     {
-3.       _rl_screenwidth--;
-2.       _rl_screenchars -= _rl_screenheight;
-1.     }

 /*Override the effect of any `set keymap' assignments in the
     inputrc file.*/

1.   rl_set_key",Useful
"/*Try to bind a common arrow key prefix, if not already bound.*/","-1.   rl_set_keymap_from_edit_mode ();

 /*Try to bind a common arrow key prefix, if not already bound.*/

1.   bind_arrow_keys ();",Useful
"/*Enable the meta key, if this terminal has one.*/","-1.   bind_arrow_keys ();

 /*Enable the meta key, if this terminal has one.*/

1.   if (_rl_enable_meta)
2.     _rl_enable_meta_key ();",Useful
"/*If the completion parser's default word break characters haven't
     been set yet, then do so now.*/","-2.   if (_rl_enable_meta)
-1.     _rl_enable_meta_key ();

 /*If the completion parser's default word break characters haven't
     been set yet, then do so now.*/

1.   if (rl_completer_word_break_characters == (char *)NULL)
2.     rl_completer_word_bre",Useful
"/*If this system allows us to look at the values of the regular
   input editing characters, then bind them to their readline
   equivalents, iff the characters are not bound to keymaps.*/","-3.   if (rl_completer_word_break_characters == (char *)NULL)
-2.     rl_completer_word_break_characters = (char *)rl_basic_word_break_characters;
-1. }

 /*If this system allows us to look at the values of the regular
   input editing characters, then bi",Useful
"/*Do not overwrite existing an existing file to be compatible with
	servers with older server versions*/","-6. {
-5. 	FILE*		fp;
-4. 	XID		xid;
-3. 	char		uuid_str[40];
-2. 	long long	seqno;
-1. 	MY_STAT		statinfo;

 /*Do not overwrite existing an existing file to be compatible with
	servers with older server versions*/

1. 	if (!incremental_prepare &&
2. 		my",Useful
/*terminating '\0'*/,"-10. 		my_strerror(errbuf, sizeof(errbuf), my_errno);
-9. 		my_error(EE_CANT_MKDIR, MYF(ME_BELL),
-8. 			 dirpath, my_errno, errbuf);
-7. 		return NULL;
-6. 	}
-5. 	fd = my_create(fullpath, 0, O_WRONLY | O_BINARY | O_EXCL | O_NOFOLLOW,
-4. 		     MYF(MY_W",Useful
"/*Weird, bail out.*/","-3. static void init_ibd_data(ds_local_file_t *local_file, const uchar *buf, size_t len)
-2. {
-1. 	if (len < FIL_PAGE_DATA + FSP_SPACE_FLAGS) {

 /*Weird, bail out.*/

1. 		return;
2. 	}
3. 	auto flags = mach_read_from_4(&buf[FIL_PAGE_DATA + FSP_SPACE_FL",Useful
"/*Make compressed file sparse, on Windows.
	In 10.1, we do not use sparse files.*/","-9. 		return;
-8. 	}
-7. 	auto flags = mach_read_from_4(&buf[FIL_PAGE_DATA + FSP_SPACE_FLAGS]);
-6. 	auto ssize = FSP_FLAGS_GET_PAGE_SSIZE(flags);
-5. 	local_file->pagesize= ssize == 0 ? UNIV_PAGE_SIZE_ORIG : ((UNIV_ZIP_SIZE_MIN >> 1) << ssize);
-4. 	loca",Useful
"/*Save a copy of 'path', since it may not be accessible later*/","-5. 	file = (ds_file_t *) my_malloc(PSI_NOT_INSTRUMENTED,
-4.                         sizeof(ds_file_t) + sizeof(ds_tmp_file_t) + path_len, MYF(MY_FAE));
-3. 	tmp_file = (ds_tmp_file_t *) (file + 1);
-2. 	tmp_file->file = file;
-1. 	memcpy(&tmp_file->myst",Useful
/*Store the real temporary file name in file->path*/,"-3. 	tmp_file->orig_path = (char *) tmp_file + sizeof(ds_tmp_file_t);
-2. 	tmp_file->fd = fd;
-1. 	memcpy(tmp_file->orig_path, path, path_len);

 /*Store the real temporary file name in file->path*/

1. 	file->path = my_strdup(PSI_NOT_INSTRUMENTED, tmp_pa",Useful
/*Store the file object in the list to be piped later*/,"-2. 	file->path = my_strdup(PSI_NOT_INSTRUMENTED, tmp_path, MYF(MY_FAE));
-1. 	file->ptr = tmp_file;

 /*Store the file object in the list to be piped later*/

1. 	tmpfile_ctxt = (ds_tmpfile_ctxt_t *) ctxt->ptr;
2. 	tmp_file->list.data = tmp_file;
3. 	pth",Useful
"/*Do nothing -- we will close (and thus remove) the file after piping
	it to the destination datasink in tmpfile_deinit().*/","-10. 	File fd = ((ds_tmp_file_t *) file->ptr)->fd;
-9. 	if (!my_write(fd, buf, len, MYF(MY_WME | MY_NABP))) {
-8. 		posix_fadvise(fd, 0, 0, POSIX_FADV_DONTNEED);
-7. 		return 0;
-6. 	}
-5. 	return 1;
-4. }
-3. static int
-2. tmpfile_close(ds_file_t *file)",Useful
/*Walk the files in the order they have been added*/,"-10. 	ds_ctxt_t		*pipe_ctxt;
-9. 	void			*buf = NULL;
-8. 	const size_t		 buf_size = 10 * 1024 * 1024;
-7. 	size_t			 bytes;
-6. 	size_t			 offset;
-5. 	pipe_ctxt = ctxt->pipe_ctxt;
-4. 	xb_a(pipe_ctxt != NULL);
-3. 	buf = my_malloc(PSI_NOT_INSTRUMENTED, ",Useful
"/*Stat the file to replace size and mtime on the original
		* mystat struct*/","-3. 	list = list_reverse(list);
-2. 	while (list != NULL) {
-1. 		tmp_file = (ds_tmp_file_t *)list->data;

 /*Stat the file to replace size and mtime on the original
		* mystat struct*/

1. 		if (my_fstat(tmp_file->fd, &mystat, MYF(0))) {
2. 			die(""my_fs",Useful
/*copy to the destination datasink*/,"-10. 			die(""my_fstat() failed."");
-9. 		}
-8. 		tmp_file->mystat.st_size = mystat.st_size;
-7. 		tmp_file->mystat.st_mtime = mystat.st_mtime;
-6. 		dst_file = ds_open(pipe_ctxt, tmp_file->orig_path,
-5. 				   &tmp_file->mystat);
-4. 		if (dst_file == NU",Useful
/*Source file cursor implementation*/,"-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Useful
/*!< in: file node*/,"-4. static
-3. void
-2. xb_fil_node_close_file(

 /*!< in: file node*/

1. {
2. 	ibool	ret;
3. 	mysql_mutex_lock(&fil_system.mutex);
4. 	ut_ad(node);
5. 	ut_a(!node->being_extended);
6. 	if (node->is_open()) {
7. 		ret = os_file_close(node->handle);
8. 		",Useful
/*!< in/out: the read filter*/,"-4. xb_fil_cur_result_t
-3. xb_fil_cur_open(

 /*!< in/out: the read filter*/

111",Useful
"/************************************************************************
Reads and verifies the next block of pages from the source
file. Positions the cursor after the last read non-corrupted page.

@return XB_FIL_CUR_SUCCESS if some have been read successfully, XB_FIL_CUR_EOF
if there are no more pages to read and XB_FIL_CUR_ERROR on error.*/","
	ulonglong max_file_size)
{
	bool	success;
	int err;


 /************************************************************************
Reads and verifies the next block of pages from the source
file. Positions the cursor after the last read non-corrupted page.

@return XB_FIL_CUR_SUCCESS if some have been read successfully, XB_FIL_CUR_EOF
if there are no more pages to read and XB_FIL_CUR_ERROR on error.*/

1. xb_fil_cur_result_t xb_fil_cur_read(xb_fil_cur_t*	cursor,
2.                                     CorruptedPages &corrupted_pages)
3. {
4. 	byte*			page;
5. 	unsigned			i;
6. 	ulint			npages;
7. 	ulint			retry_count;
8. 	xb_fil_cur_result_t	ret;
9. 	ib_int64_t		offset;
10. 	ib_int64_t		to_read;",Useful
/*!< in/out: source file cursor*/,"-3. void
-2. xb_fil_cur_close(

 /*!< in/out: source file cursor*/

1. {
2. 	if (cursor->read_filter) {
3. 		cursor->read_filter->deinit(&cursor->read_filter_ctxt);
4. 	}
5. 	aligned_free(cursor->buf);
6. 	cursor->buf = NULL;
7. 	if (cursor->node != NULL)",Useful
/*!< in/out: source file cursor*/,"-3. void
-2. xb_fil_cur_close(

 /*!< in/out: source file cursor*/

1. {
2. 	if (cursor->read_filter) {
3. 		cursor->read_filter->deinit(&cursor->read_filter_ctxt);
4. 	}
5. 	aligned_free(cursor->buf);
6. 	cursor->buf = NULL;
7. 	if (cursor->node != NULL)",Useful
"/*This is the only place where we expect EOF, so read with
	xb_read_full() rather than F_READ()*/","-10. xb_rstream_result_t
-9. xb_stream_read_chunk(xb_rstream_t *stream, xb_rstream_chunk_t *chunk)
-8. {
-7. 	uchar		tmpbuf[16];
-6. 	uchar		*ptr = tmpbuf;
-5. 	uint		pathlen;
-4. 	size_t		tbytes;
-3. 	ulonglong	ullval;
-2. 	File		fd = stream->fd;
-1. 	xb",Useful
"/*Chunk type, ignore unknown ones if ignorable flag is set*/","-2. 	chunk->flags = *ptr++;
-1. 	stream->offset++;

 /*Chunk type, ignore unknown ones if ignorable flag is set*/

1. 	chunk->type = validate_chunk_type(*ptr);
2. 	if (chunk->type == XB_CHUNK_TYPE_UNKNOWN &&
3. 	    !(chunk->flags & XB_STREAM_FLAG_IGNORAB",Useful
"/*Reasonable defaults for tgoto().  Readline currently only uses
         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
         change that later...*/","-10.       _rl_term_cr = ""\r"";
-9.       _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
-8.       _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
-7.       _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_ter",Useful
"/*Set up the variables that the termcap library expects the application
     to provide.*/","-7.       PC = '\0';
-6.       _rl_term_backspace = _rl_term_backspace_default;
-5.       BC = (char*)_rl_term_backspace;
-4.       UP = (char*)_rl_term_up;
-3.       return 0;
-2.     }
-1.   get_term_capabilities (&buffer);

 /*Set up the variables that",Useful
"/*Allow calling application to set default height and width, using
     rl_set_screen_size*/","-6.   PC = _rl_term_pc ? *_rl_term_pc : 0;
-5.   BC = (char*)_rl_term_backspace;
-4.   UP = (char*)_rl_term_up;
-3.   if (!_rl_term_cr)
-2.     _rl_term_cr = ""\r"";
-1.   _rl_term_autowrap = tgetflag ((char *)""am"") && tgetflag ((char *)""xn"");

 /*Allow cal",Useful
"/*""An application program can assume that the terminal can do
      character insertion if *any one of* the capabilities `IC',
      `im', `ic' or `ip' is provided.""  But we can't do anything if
      only `ip' is provided, so...*/","-2.   if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-1.     _rl_get_screen_size (tty, 0);

 /*""An application program can assume that the terminal can do
      character insertion if *any one of* the capabilities `IC',
      `im', `ic' or `ip' is pro",Useful
"/*Check to see if this terminal has a meta key and clear the capability
     variables if there is none.*/","-1.   _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);

 /*Check to see if this terminal has a meta key and clear the capability
     variables if there is none.*/

1.   term_has_meta = (tgetflag ((char *)""km"") || tgetflag ((char *)""",Useful
"/*Attempt to find and bind the arrow keys.  Do not override already
     bound keys in an overzealous attempt, however.*/","-3.   term_has_meta = (tgetflag ((char *)""km"") || tgetflag ((char *)""MT""));
-2.   if (!term_has_meta)
-1.     _rl_term_mm = _rl_term_mo = (char *)NULL;

 /*Attempt to find and bind the arrow keys.  Do not override already
     bound keys in an overzealous",Useful
/*Bind the arrow key sequences from the termcap description in MAP.*/,"-2.   return 0;
-1. }

 /*Bind the arrow key sequences from the termcap description in MAP.*/

1. static void
2. bind_termcap_arrow_keys (map)
3.      Keymap map;
4. {
5.   Keymap xkeymap;
6.   xkeymap = _rl_keymap;
7.   _rl_keymap = map;
8.   rl_bind_key",Useful
"/*Re-initialize the terminal considering that the TERM/TERMCAP variable
   has changed.*/","-10.   register unsigned int i;
-9.   if (tcap_initialized == 0)
-8.     return ((char *)NULL);
-7.   for (i = 0; i < NUM_TC_STRINGS; i++)
-6.     {
-5.       if (tc_strings[i].tc_var[0] == cap[0] && strcmp (tc_strings[i].tc_var, cap) == 0)
-4.         re",Useful
/*Write COUNT characters from STRING to the output stream.*/,"-7. int
-6. _rl_output_character_function (c)
-5.      int c;
-4. {
-3.   return putc (c, _rl_out_stream);
-2. }

 /*Write COUNT characters from STRING to the output stream.*/

1. void
2. _rl_output_some_chars (string, count)
3.      const char *string;
4",Useful
"/*Set the cursor appropriately depending on IM, which is one of the
   insert modes (insert or overwrite).  Insert mode gets the normal
   cursor.  Overwrite mode gets a very visible cursor.  Only does
   anything if we have both capabilities.*/","-10.     tputs (_rl_term_ks, 1, _rl_output_character_function);
-9.   else if (!on && _rl_term_ke)
-8.     tputs (_rl_term_ke, 1, _rl_output_character_function);
-7. #endif
-6. }

 /*Set the cursor appropriately depending on IM, which is one of the
   ins",Useful
"/************************************************************************
Write to a datasink file.
@return 0 on success, 1 on error.*/","-10. ds_file_t *
-9. ds_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *stat)
-8. {
-7. 	ds_file_t	*file;
-6. 	file = ctxt->datasink->open(ctxt, path, stat);
-5. 	if (file != NULL) {
-4. 		file->datasink = ctxt->datasink;
-3. 	}
-2. 	return file;
-1. }

",Useful
"/************************************************************************
Close a datasink file.
@return 0 on success, 1, on error.*/","-10. Write to a datasink file.
-9. @return 0 on success, 1 on error. */
-8. int
-7. ds_write(ds_file_t *file, const void *buf, size_t len)
-6. {
-5. 	if (len == 0) {
-4. 		return 0;
-3. 	}
-2. 	return file->datasink->write(file, (const uchar *)buf, len);
",Useful
"/************************************************************************
Retirn true if character if file separator*/","-8. struct datadir_thread_ctxt_t {
-7. 	datadir_iter_t		*it;
-6. 	uint			n_thread;
-5. 	uint			*count;
-4. 	pthread_mutex_t*	count_mutex;
-3. 	bool			ret;
-2. };
-1. static bool backup_files_from_datadir(const char *dir_path);

 /*************************",Useful
"/*We found a symlink or a directory; try opening it to see
		if a symlink is a directory*/","-10. 		it->dbdir = NULL;
-9. 	}
-8. 	while (os_file_readdir_next_file(it->datadir_path,
-7. 					  it->dir, &it->dbinfo) == 0) {
-6. 		ulint	len;
-5. 		if ((it->dbinfo.type == OS_FILE_TYPE_FILE
-4. 		     && it->skip_first_level)
-3. 		    || it->dbinfo.t",Useful
"/*We want wrong directory permissions to be a fatal error for
		XtraBackup.*/","-10. 		snprintf(it->dbpath, it->dbpath_len, ""%s/%s"",
-9. 			 it->datadir_path, it->dbinfo.name);
-8. 		if (it->dbinfo.type == OS_FILE_TYPE_FILE) {
-7. 			it->is_file = true;
-6. 			return(true);
-5. 		}
-4. 		if (check_if_skip_database_by_path(it->dbpath)",Useful
"/************************************************************************
Check if string ends with given suffix.
@return true if string ends with given suffix.*/","-10. 			continue;
-9. 		}
-8. 		if (*path == '.' && is_path_separator(path[1])) {
-7. 			path += 2;
-6. 			continue;
-5. 		}
-4. 		break;
-3. 	}
-2. 	return(path);
-1. }

 /************************************************************************
Check if ",Useful
"/************************************************************************
Create directories recursively.
@return 0 if directories created successfully.*/","-10. {
-9. 	size_t suffix_len = strlen(suffix);
-8. 	size_t str_len = strlen(str);
-7. 	return(str_len >= suffix_len
-6. 	       && strcmp(str + str_len - suffix_len, suffix) == 0);
-5. }
-4. static bool starts_with(const char *str, const char *prefix)
-3",Useful
"/************************************************************************
Return true if first and second arguments are the same path.*/","-7. 	if (errno == EEXIST) {
-6. 		free(parent);
-5. 		return(0);
-4. 	}
-3. 	free(parent);
-2. 	return(-1);
-1. }

 /************************************************************************
Return true if first and second arguments are the same path.*/

1",Useful
"/************************************************************************
Check if file name ends with given set of suffixes.
@return true if it does.*/","-10. 		msg(""%s can not open directory %s"", comment, dir);
-9. 		return(false);
-8. 	}
-7. 	empty = (fil_file_readdir_next_file(&err, dir, os_dir, &info) != 0);
-6. 	os_file_closedir(os_dir);
-5. 	if (!empty) {
-4. 		msg(""%s directory %s is not empty!"", co",Useful
"/************************************************************************
Copy data file for backup. Also check if it is allowed to copy by
comparing its name to the list of known data file types and checking
if passes the rules for partial backup.
@return true if file backed up or skipped successfully.*/","-10. filename_matches(const char *filename, const char **ext_list)
-9. {
-8. 	const char **ext;
-7. 	for (ext = ext_list; *ext; ext++) {
-6. 		if (ends_with(filename, *ext)) {
-5. 			return(true);
-4. 		}
-3. 	}
-2. 	return(false);
-1. }

 /**************",Useful
"/*Get the name and the path for the tablespace. node->name always
	contains the path (which may be absolute for remote tablespaces in
	5.6+). space->name contains the tablespace name in the form
	""./database/table.ibd"" (in 5.5-) or ""database/table"" (in 5.6+). For a
	multi-node shared tablespace, space->name contains the name of the first
	node, but that's irrelevant, since we only need node_name to match them
	against filters, and the shared tablespace is always copied regardless
	of the filters value.*/","-10. comparing its name to the list of known data file types and checking
-9. if passes the rules for partial backup.
-8. @return true if file backed up or skipped successfully. */
-7. static
-6. bool
-5. datafile_copy_backup(const char *filepath, uint th",Useful
/*ERROR*/,"-10. 	return(NULL);
-9. }
-8. static
-7. bool
-6. datadir_iter_next_database(datadir_iter_t *it)
-5. {
-4. 	if (it->dbdir != NULL) {
-3. 		if (os_file_closedir_failed(it->dbdir)) {
-2. 			msg(""Warning: could not""
-1. 			      "" close database directory %s",Useful
"/************************************************************************
Copy file for backup/restore.
@return true in case of success.*/","-10. 	ret = true;
-9. 	for (i = 0; i < n; i++) {
-8. 		ret = data_threads[i].ret && ret;
-7. 		if (!data_threads[i].ret) {
-6. 			msg(""Error: thread %u failed."", i);
-5. 		}
-4. 	}
-3. 	free(data_threads);
-2. 	return(ret);
-1. }

 /**********************",Useful
"/************************************************************************
Try to move file by renaming it. If source and destination are on
different devices fall back to copy and unlink.
@return true in case of success.*/","-10. 	ret = true;
-9. 	for (i = 0; i < n; i++) {
-8. 		ret = data_threads[i].ret && ret;
-7. 		if (!data_threads[i].ret) {
-6. 			msg(""Error: thread %u failed."", i);
-5. 		}
-4. 	}
-3. 	free(data_threads);
-2. 	return(ret);
-1. }

 /**********************",Useful
"/************************************************************************
Read link from .isl file if any and store it in the global map associated
with given tablespace.*/","-10. 		}
-9. 		my_strerror(errbuf, sizeof(errbuf), my_errno);
-8. 		msg(""Can not move file %s to %s: %s"",
-7. 			src_file_path, dst_file_path_abs,
-6. 			errbuf);
-5. 		return(false);
-4. 	}
-3. 	msg(thread_n,""        ...done"");
-2. 	return(true);
-1. }

",Useful
"/************************************************************************
Return the location of given .ibd if it was previously read
from .isl file.
@return NULL or destination .ibd file path.*/","-9. 			ulint lastch = len - 1;
-8. 			while (lastch > 4 && filepath[lastch] <= 0x20) {
-7. 				filepath[lastch--] = 0x00;
-6. 			}
-5. 		}
-4. 		tablespace_locations[ibd_filepath] = filepath;
-3. 	}
-2. 	free(filepath);
-1. }

 /**************************",Useful
"/************************************************************************
Copy or move file depending on current mode.
@return true in case of success.*/","-10. 	ret = true;
-9. 	for (i = 0; i < n; i++) {
-8. 		ret = data_threads[i].ret && ret;
-7. 		if (!data_threads[i].ret) {
-6. 			msg(""Error: thread %u failed."", i);
-5. 		}
-4. 	}
-3. 	free(data_threads);
-2. 	return(ret);
-1. }

 /**********************",Useful
"/*Create a file hardlink.
@return true on success, false on error.*/","-10. 		char c = path[path_len - 1];
-9. 		if (c == '/' IF_WIN(|| c == '\\', ))
-8. 			path_len--;
-7. 		else
-6. 			break;
-5. 	}
-4. 	path[path_len] = 0;
-3. 	return path;
-2. }
-1. /*
Create a file hardlink.
@return true on success, false on error.

 /*",Useful
/*--- First the classes and functions that describe individual derivatives ---*/,"-10. DEAL_II_NAMESPACE_OPEN
-9. namespace
-8. {
-7.   template <typename T>
-6.   inline T
-5.   sqr(const T t)
-4.   {
-3.     return t * t;
-2.   }

 /*--- First the classes and functions that describe individual derivatives ---*/

1. namespace Derivati",Useful
"/**
       * Declare which data fields have to be updated for the function @p
       * get_projected_derivative to work.*/","-10.      * finite difference approximation to the gradient on a cell. See the
-9.      * general documentation of this class for more information on
-8.      * implementation details.
-7.      */
-6.     template <int dim>
-5.     class Gradient
-4.     ",Useful
"/**
       * Declare the data type which holds the derivative described by this
       * class.*/","-3.       static const UpdateFlags update_flags;
-2.       /**
-1.        * Declare the data type which holds the derivative described by this
       * class.

 /**
       * Declare the data type which holds the derivative described by this
       * class",Useful
"/**
       * Likewise declare the data type that holds the derivative projected to a
       * certain directions.*/","-3.       using Derivative = Tensor<1, dim>;
-2.       /**
-1.        * Likewise declare the data type that holds the derivative projected to a
       * certain directions.

 /**
       * Likewise declare the data type that holds the derivative projected ",Useful
"/**
       * Given an FEValues object initialized to a cell, and a solution vector,
       * extract the desired derivative at the first quadrature point (which is
       * the only one, as we only evaluate the finite element field at the
       * center of each cell).*/","-5.       using ProjectedDerivative = Tensor<0, dim>;
-4.       /**
-3.        * Given an FEValues object initialized to a cell, and a solution vector,
-2.        * extract the desired derivative at the first quadrature point (which is
-1.        * the on",Useful
"/**
       * Return the norm of the derivative object. Here, for the gradient, we
       * choose the Euclidean norm of the gradient vector.*/","-10.        * the only one, as we only evaluate the finite element field at the
-9.        * center of each cell).
-8.        */
-7.       template <class InputVector, int spacedim>
-6.       static ProjectedDerivative
-5.       get_projected_derivative(c",Useful
"/**
       * If for the present derivative order, symmetrization of the derivative
       * tensor is necessary, then do so on the argument.
       *
       * For the first derivatives, no such thing is necessary, so this function
       * is a no-op.*/","-10.        * Return the norm of the derivative object. Here, for the gradient, we
-9.        * choose the Euclidean norm of the gradient vector.
-8.        */
-7.       static double
-6.       derivative_norm(const Derivative &d);
-5.       /**
-4.      ",Useful
"/**
       * Declare which data fields have to be updated for the function @p
       * get_projected_derivative to work.*/","-10.      * finite difference approximation to the gradient on a cell. See the
-9.      * general documentation of this class for more information on
-8.      * implementation details.
-7.      */
-6.     template <int dim>
-5.     class Gradient
-4.     ",Useful
"/**
       * Declare the data type which holds the derivative described by this
       * class.*/","-3.       static const UpdateFlags update_flags;
-2.       /**
-1.        * Declare the data type which holds the derivative described by this
       * class.

 /**
       * Declare the data type which holds the derivative described by this
       * class",Useful
"/**
       * Likewise declare the data type that holds the derivative projected to a
       * certain directions.*/","-3.       using Derivative = Tensor<1, dim>;
-2.       /**
-1.        * Likewise declare the data type that holds the derivative projected to a
       * certain directions.

 /**
       * Likewise declare the data type that holds the derivative projected ",Useful
"/**
       * Given an FEValues object initialized to a cell, and a solution vector,
       * extract the desired derivative at the first quadrature point (which is
       * the only one, as we only evaluate the finite element field at the
       * center of each cell).*/","-5.       using ProjectedDerivative = Tensor<0, dim>;
-4.       /**
-3.        * Given an FEValues object initialized to a cell, and a solution vector,
-2.        * extract the desired derivative at the first quadrature point (which is
-1.        * the on",Useful
"/**
       * Return the norm of the derivative object. Here, for the (symmetric)
       * tensor of second derivatives, we choose the absolute value of the
       * largest eigenvalue, which is the matrix norm associated to the $l_2$
       * norm of vectors. It is also the largest value of the curvature of the
       * solution.*/","-10.       template <class InputVector, int spacedim>
-9.       static ProjectedDerivative
-8.       get_projected_derivative(const FEValues<dim, spacedim> &fe_values,
-7.                                const InputVector &            solution,
-6.        ",Useful
"/**
       * If for the present derivative order, symmetrization of the derivative
       * tensor is necessary, then do so on the argument.
       *
       * For the second derivatives, each entry of the tensor is set to the mean
       * of its value and the value of the transpose element.
       *
       * Note that this function actually modifies its argument.*/","-10.        */
-9.       static double
-8.       derivative_norm(const Derivative &d);
-7.       /**
-6.        * If for the present derivative order, symmetrization of the derivative
-5.        * tensor is necessary, then do so on the argument.
-4.      ",Useful
"/*note that d should be a
symmetric 2x2 tensor, so the
eigenvalues are:

1/2(a+b\pm\sqrt((a-b)^2+4c^2))

if the d_11=a, d_22=b,
d_12=d_21=c*/","-10.     template <>
-9.     inline double
-8.     SecondDerivative<1>::derivative_norm(const Derivative &d)
-7.     {
-6.       return std::fabs(d[0][0]);
-5.     }
-4.     template <>
-3.     inline double
-2.     SecondDerivative<2>::derivative_norm(co",Useful
"/*compute the three eigenvalues of the tensor @p{d} and take the
      largest. one could use the following maple script to generate C
      code:

      with(linalg);
      readlib(C);
      A:=matrix(3,3,[[a00,a01,a02],[a01,a11,a12],[a02,a12,a22]]);
      E:=eigenvals(A);
      EE:=vector(3,[E[1],E[2],E[3]]);
      C(EE);

      Unfortunately, with both optimized and non-optimized output, at some
      places the code `sqrt(-1.0)' is emitted, and I don't know what
      Maple intends to do with it. This happens both with Maple4 and
      Maple5.

      Fortunately, Roger Young provided the following Fortran code, which
      is transcribed below to C. The code uses an algorithm that uses the
      invariants of a symmetric matrix. (The translated algorithm is
      augmented by a test for R>0, since R==0 indicates that all three
      eigenvalues are equal.)


          PROGRAM MAIN

      C FIND EIGENVALUES OF REAL SYMMETRIC MATRIX
      C (ROGER YOUNG, 2001)

          IMPLICIT NONE

          REAL*8 A11, A12, A13, A22, A23, A33
          REAL*8 I1, J2, J3, AM
          REAL*8 S11, S12, S13, S22, S23, S33
          REAL*8 SS12, SS23, SS13
          REAL*8 R,R3, XX,YY, THETA
          REAL*8 A1,A2,A3
          REAL*8 PI
          PARAMETER (PI=3.141592653587932384D0)
          REAL*8 A,B,C, TOL
          PARAMETER (TOL=1.D-14)

      C DEFINE A TEST MATRIX

          A11 = -1.D0
          A12 = 5.D0
          A13 = 3.D0
          A22 = -2.D0
          A23 = 0.5D0
          A33 = 4.D0


          I1 = A11 + A22 + A33
          AM = I1/3.D0

          S11 = A11 - AM
          S22 = A22 - AM
          S33 = A33 - AM
          S12 = A12
          S13 = A13
          S23 = A23

          SS12 = S12*S12
          SS23 = S23*S23
          SS13 = S13*S13

          J2 = S11*S11 + S22*S22 + S33*S33
          J2 = J2 + 2.D0*(SS12 + SS23 + SS13)
          J2 = J2/2.D0

          J3 = S11**3 + S22**3 + S33**3
          J3 = J3 + 3.D0*S11*(SS12 + SS13)
          J3 = J3 + 3.D0*S22*(SS12 + SS23)
          J3 = J3 + 3.D0*S33*(SS13 + SS23)
          J3 = J3 + 6.D0*S12*S23*S13
          J3 = J3/3.D0

          R = SQRT(4.D0*J2/3.D0)
          R3 = R*R*R
          XX = 4.D0*J3/R3

          YY = 1.D0 - DABS(XX)
          IF(YY.LE.0.D0)THEN
             IF(YY.GT.(-TOL))THEN
                WRITE(6,*)'Equal roots: XX= ',XX
                A = -(XX/DABS(XX))*SQRT(J2/3.D0)
                B = AM + A
                C = AM - 2.D0*A
                WRITE(6,*)B,' (twice) ',C
                STOP
             ELSE
                WRITE(6,*)'Error: XX= ',XX
                STOP
             ENDIF
          ENDIF

          THETA = (ACOS(XX))/3.D0

          A1 = AM + R*COS(THETA)
          A2 = AM + R*COS(THETA + 2.D0*PI/3.D0)
          A3 = AM + R*COS(THETA + 4.D0*PI/3.D0)

          WRITE(6,*)A1,A2,A3

          STOP
          END*/","-10.       const double eigenvalues[2] = {
-9.         0.5 * (d[0][0] + d[1][1] + std::sqrt(radicand)),
-8.         0.5 * (d[0][0] + d[1][1] - std::sqrt(radicand))};
-7.       return std::max(std::fabs(eigenvalues[0]), std::fabs(eigenvalues[1]));
-6.     ",Useful
"/*the eigenvalues are away from
@p{am} in the order of R. thus,
if R<<AM, then we have the
degenerate case with three
identical eigenvalues. check
this first*/","-10.       const double J2 = (s[0][0] * s[0][0] + s[1][1] * s[1][1] +
-9.                          s[2][2] * s[2][2] + 2 * (ss01 + ss02 + ss12)) /
-8.                         2.;
-7.       const double J3 =
-6.         (std::pow(s[0][0], 3) + std::pow(s[1",Useful
"/*computing the spectral norm is
not so simple in general. it is
feasible for dim==3 as shown
above, since then there are
still closed form expressions of
the roots of the characteristic
polynomial, and they can easily
be computed using
maple. however, for higher
dimensions, some other method
needs to be employed. maybe some
steps of the power method would
suffice?*/","-10.               EE[2] = am + R * std::cos(theta + 4. / 3. * numbers::PI);
-9.             }
-8.         }
-7.       return std::max(std::fabs(EE[0]),
-6.                       std::max(std::fabs(EE[1]), std::fabs(EE[2])));
-5.     }
-4.     template <i",Useful
"/**
       * Declare which data fields have to be updated for the function @p
       * get_projected_derivative to work.*/","-10.      * finite difference approximation to the gradient on a cell. See the
-9.      * general documentation of this class for more information on
-8.      * implementation details.
-7.      */
-6.     template <int dim>
-5.     class Gradient
-4.     ",Useful
"/**
       * Declare the data type which
       * holds the derivative described
       * by this class.*/","-4.       static const UpdateFlags update_flags;
-3.       /**
-2.        * Declare the data type which
-1.        * holds the derivative described
       * by this class.

 /**
       * Declare the data type which
       * holds the derivative described
",Useful
"/**
       * Likewise declare the data type that holds the derivative projected to a
       * certain directions.*/","-3.       using Derivative = Tensor<1, dim>;
-2.       /**
-1.        * Likewise declare the data type that holds the derivative projected to a
       * certain directions.

 /**
       * Likewise declare the data type that holds the derivative projected ",Useful
"/**
       * Given an FEValues object initialized to a cell, and a solution vector,
       * extract the desired derivative at the first quadrature point (which is
       * the only one, as we only evaluate the finite element field at the
       * center of each cell).*/","-5.       using ProjectedDerivative = Tensor<0, dim>;
-4.       /**
-3.        * Given an FEValues object initialized to a cell, and a solution vector,
-2.        * extract the desired derivative at the first quadrature point (which is
-1.        * the on",Useful
"/**
       * Return the norm of the derivative object. Here, for the (symmetric)
       * tensor of second derivatives, we choose the absolute value of the
       * largest eigenvalue, which is the matrix norm associated to the $l_2$
       * norm of vectors. It is also the largest value of the curvature of the
       * solution.*/","-10.       template <class InputVector, int spacedim>
-9.       static ProjectedDerivative
-8.       get_projected_derivative(const FEValues<dim, spacedim> &fe_values,
-7.                                const InputVector &            solution,
-6.        ",Useful
"/**
       * If for the present derivative order, symmetrization of the derivative
       * tensor is necessary, then do so on the argument.
       *
       * For the second derivatives, each entry of the tensor is set to the mean
       * of its value and the value of the transpose element.
       *
       * Note that this function actually modifies its argument.*/","-10.        */
-9.       static double
-8.       derivative_norm(const Derivative &d);
-7.       /**
-6.        * If for the present derivative order, symmetrization of the derivative
-5.        * tensor is necessary, then do so on the argument.
-4.      ",Useful
"/*return the Frobenius-norm. this is a
member function of Tensor<rank_,dim>*/","-10.     template <>
-9.     inline double
-8.     ThirdDerivative<1>::derivative_norm(const Derivative &d)
-7.     {
-6.       return std::fabs(d[0][0][0]);
-5.     }
-4.     template <int dim>
-3.     inline double
-2.     ThirdDerivative<dim>::derivati",Useful
"/*first do it in the case, that i,j,k are
pairwise different (which can onlky happen
in dim >= 3)*/","-7.       return d.norm();
-6.     }
-5.     template <int dim>
-4.     inline void
-3.     ThirdDerivative<dim>::symmetrize(Derivative &d)
-2.     {

 /*first do it in the case, that i,j,k are
pairwise different (which can onlky happen
in dim >= 3)*/

1.",Useful
"/*now do the case, where two indices are
equal*/","-10.       for (unsigned int i = 0; i < dim; ++i)
-9.         for (unsigned int j = i + 1; j < dim; ++j)
-8.           for (unsigned int k = j + 1; k < dim; ++k)
-7.             {
-6.               const double s = (d[i][j][k] + d[i][k][j] + d[j][i][k] +
",Useful
"/*case 1: index i (lower one) is
double*/","const double t = (d[i][j][j] + d[j][i][j] + d[j][j][i]) / 3;
            d[i][j][j] = d[j][i][j] = d[j][j][i] = t;
          }
    }


    template <int order, int dim>
    class DerivativeSelector
    {
    public:

 /*case 1: index i (lower one) is
double*/

1.   derivative_norm(const Tensor<order, dim> &derivative)
2.   {
3.     return internal::DerivativeSelector<order, dim>::DerivDescr::
4.       derivative_norm(derivative);
5.   }",Useful
"/*case 2: index j (higher one) is
double*/","const double t = (d[i][j][j] + d[j][i][j] + d[j][j][i]) / 3;
            d[i][j][j] = d[j][i][j] = d[j][j][i] = t;
          }
    }


    template <int order, int dim>
    class DerivativeSelector
    {
    public:

 /*case 2: index j (higher one) is
double*/

1.   derivative_norm(const Tensor<order, dim> &derivative)
2.   {
3.     return internal::DerivativeSelector<order, dim>::DerivDescr::
4.       derivative_norm(derivative);
5.   }",Useful
"/**
       * alias to select the DerivativeDescription corresponding to the
       * <tt>order</tt>th derivative. In this general template we set an unvalid
       * alias to void, the real alias have to be specialized.*/","-10.             d[i][j][j] = d[j][i][j] = d[j][j][i] = t;
-9.           }
-8.     }
-7.     template <int order, int dim>
-6.     class DerivativeSelector
-5.     {
-4.     public:
-3.       /**
-2.        * alias to select the DerivativeDescription corr",Useful
/*Dummy structures and dummy function used for WorkStream*/,"-10.       using DerivDescr = SecondDerivative<dim>;
-9.     };
-8.     template <int dim>
-7.     class DerivativeSelector<3, dim>
-6.     {
-5.     public:
-4.       using DerivDescr = ThirdDerivative<dim>;
-3.     };

 /*Dummy structures and dummy func",Useful
/*--------------- now for the functions that do the actual work --------------*/,"-10.       {
-9.         Scratch() = default;
-8.       };
-7.       struct CopyData
-6.       {
-5.         CopyData() = default;
-4.       };

 /*--------------- now for the functions that do the actual work --------------*/

1. namespace DerivativeAppr",Useful
"/**
     * Compute the derivative approximation on one cell. This computes the full
     * derivative tensor.*/","-6. namespace DerivativeApproximation
-5. {
-4.   namespace internal
-3.   {
-2.     /**
-1.      * Compute the derivative approximation on one cell. This computes the full
     * derivative tensor.

 /**
     * Compute the derivative approximation on one",Useful
"/*create collection objects from
single quadratures, mappings,
and finite elements. if we have
an hp DoFHandler,
dof_handler.get_fe() returns a
collection of which we do a
shallow copy instead*/","-10.     void
-9.     approximate_cell(
-8.       const Mapping<dim, spacedim> &   mapping,
-7.       const DoFHandler<dim, spacedim> &dof_handler,
-6.       const InputVector &              solution,
-5.       const unsigned int               component,
",Useful
"/*vector to hold iterators to all
active neighbors of a cell
reserve the maximal number of
active neighbors*/","-1.       Tensor<2, dim> Y;

 /*vector to hold iterators to all
active neighbors of a cell
reserve the maximal number of
active neighbors*/

111",Useful
"/*vector
g=sum_i y_i (f(x+y_i)-f(x))/|y_i|
or related type for higher
derivatives*/","-10. #include <deal.II/lac/block_vector.h>
-9. #include <deal.II/lac/la_parallel_block_vector.h>
-8. #include <deal.II/lac/la_parallel_vector.h>
-7. #include <deal.II/lac/la_vector.h>
-6. #include <deal.II/lac/petsc_block_vector.h>
-5. #include <deal.II/l",Useful
"/*...and get the value of the
projected derivative...*/","-3.       x_fe_midpoint_value.reinit(cell);
-2.       const FEValues<dim> &fe_midpoint_value =
-1.         x_fe_midpoint_value.get_present_fe_values();

 /*...and get the value of the
projected derivative...*/

1.       const typename DerivativeDescriptio",Useful
"/*loop over all neighbors and
accumulate the difference
quotients from them. note
that things get a bit more
complicated if the neighbor
is more refined than the
present one

to make processing simpler,
first collect all neighbor
cells in a vector, and then
collect the data from them*/","-2.       const Point<dim> this_center =

 /*loop over all neighbors and
accumulate the difference
quotients from them. note
that things get a bit more
complicated if the neighbor
is more refined than the
present one

to make processing simpler,
first col",Useful
"/*now loop over all active
neighbors and collect the
data we need*/","-10.       // complicated if the neighbor
-9.       // is more refined than the
-8.       // present one
-7.       //
-6.       // to make processing simpler,
-5.       // first collect all neighbor
-4.       // cells in a vector, and then
-3.       // co",Useful
"/*vector for the
normalized
direction between
the centers of two
cells*/","-2.           const Point<dim> &neighbor_center =
-1.             neighbor_fe_midpoint_value.quadrature_point(0);

 /*vector for the
normalized
direction between
the centers of two
cells*/

1.       AssertIndexRange(component, dof_handler.get_fe(0).n_comp",Useful
"/**** note that unlike in
the docs, y denotes the
normalized vector
connecting the centers
of the two cells, rather
than the normal
difference! ****/","-1.           y /= distance;

 /**** note that unlike in
the docs, y denotes the
normalized vector
connecting the centers
of the two cells, rather
than the normal
difference! ****/

111",Useful
"/*then update the sum
of difference
quotients*/","-10.           // connecting the centers
-9.           // of the two cells, rather
-8.           // than the normal
-7.           // difference! ***
-6.           // add up the
-5.           // contribution of
-4.           // this cell to Y
-3.          ",Useful
"/*can we determine an
approximation of the
gradient for the present
cell? if so, then we need to
have passed over vectors y_i
which span the whole space,
otherwise we would not have
all components of the
gradient*/","-6.           typename DerivativeDescription::ProjectedDerivative
-5.             projected_finite_difference =
-4.               (neighbor_midpoint_value - this_midpoint_value);
-3.           projected_finite_difference /= distance;
-2.           project",Useful
"/**
     * Compute the derivative approximation on a given cell.  Fill the @p
     * derivative_norm vector with the norm of the computed derivative tensors
     * on the cell.*/","-5.       DerivativeDescription::symmetrize(derivative);
-4.     }
-3.     /**
-2.      * Compute the derivative approximation on a given cell.  Fill the @p
-1.      * derivative_norm vector with the norm of the computed derivative tensors
     * on the c",Useful
"/*if the cell is not locally owned, then there is nothing to do*/","-10.     void
-9.     approximate(
-8.       SynchronousIterators<
-7.         std::tuple<typename DoFHandler<dim, spacedim>::active_cell_iterator,
-6.                    Vector<float>::iterator>> const &cell,
-5.       const Mapping<dim, spacedim> &     ",Useful
"/*call the function doing the actual
work on this cell*/","-5.       if (std::get<0>(*cell)->is_locally_owned() == false)
-4.         *std::get<1>(*cell) = 0;
-3.       else
-2.         {
-1.           typename DerivativeDescription::Derivative derivative;

 /*call the function doing the actual
work on this cell*",Useful
"/**
     * Kind of the main function of this class. It is called by the public entry
     * points to this class with the correct template first argument and then
     * simply calls the @p approximate function, after setting up several
     * threads and doing some administration that is independent of the actual
     * derivative to be computed.
     *
     * The @p component argument denotes which component of the solution vector
     * we are to work on.*/","-10.         }
-9.     }
-8.     /**
-7.      * Kind of the main function of this class. It is called by the public entry
-6.      * points to this class with the correct template first argument and then
-5.      * simply calls the @p approximate function",Useful
"/*There is no need for a copier because there is no conflict between
threads to write in derivative_norm. Scratch and CopyData are also
useless.*/","-10.              ExcVectorLengthVsNActiveCells(
-9.                derivative_norm.size(),
-8.                dof_handler.get_triangulation().n_active_cells()));
-7.       AssertIndexRange(component, dof_handler.get_fe(0).n_components());
-6.       using",Useful
/*------------------------ finally for the public interface of this namespace*/,"-10.           Assembler::CopyData &) {
-9.           approximate<DerivativeDescription, dim, InputVector, spacedim>(
-8.             cell, mapping, dof_handler, solution, component);
-7.         },
-6.         std::function<void(internal::Assembler::Copy",Useful
"/*This file compiles the second quarter of the instantiations from
solution_transfer.cc to reduce the compilation unit (and memory consumption)*/","-10. // This file is part of the deal.II library.
-9. //
-8. // The deal.II library is free software; you can use it, redistribute
-7. // it, and/or modify it under the terms of the GNU Lesser General
-6. // Public License as published by the Free Softwar",Useful
"/*delete previous content and
clean the sub_objects array
completely*/","-10.     }
-9.   catch (...)
-8.     {}
-7. }
-6. template <class SparsityPatternBase>
-5. void
-4. BlockSparsityPatternBase<SparsityPatternBase>::reinit(
-3.   const size_type n_block_rows,
-2.   const size_type n_block_columns)
-1. {

 /*delete previous",Useful
/*then set new sizes*/,"-8.   for (size_type i = 0; i < rows; ++i)
-7.     for (size_type j = 0; j < columns; ++j)
-6.       {
-5.         SparsityPatternBase *sp = sub_objects[i][j];
-4.         sub_objects[i][j]       = nullptr;
-3.         delete sp;
-2.       }
-1.   sub_obj",Useful
/*allocate new objects*/,"-3.   rows    = n_block_rows;
-2.   columns = n_block_columns;
-1.   sub_objects.reinit(rows, columns);

 /*allocate new objects*/

1.   for (size_type i = 0; i < rows; ++i)
2.     for (size_type j = 0; j < columns; ++j)
3.       {
4.         SparsityPatt",Useful
/*update index objects*/,"-3.   for (size_type i = 0; i < rows; ++i)
-2.     for (size_type j = 0; j < columns; ++j)
-1.       *sub_objects[i][j] = *bsp.sub_objects[i][j];

 /*update index objects*/

1.   collect_sizes();
2.   return *this;
3. }
4. template <class SparsityPatternB",Useful
"/*first find out the row sizes
from the first block column*/","-9.   collect_sizes();
-8.   return *this;
-7. }
-6. template <class SparsityPatternBase>
-5. void
-4. BlockSparsityPatternBase<SparsityPatternBase>::collect_sizes()
-3. {
-2.   std::vector<size_type> row_sizes(rows);
-1.   std::vector<size_type> col_size",Useful
"/*then check that the following
block columns have the same
sizes*/","for (size_type c = 1; c < columns; ++c)
    for (size_type r = 0; r < rows; ++r)
      Assert(row_sizes[r] == sub_objects[r][c]->n_rows(),
             ExcIncompatibleRowNumbers(r, 0, r, c));

 /*then check that the following
block columns have the same
sizes*/

1.   }",Useful
"/*finally initialize the row
indices with this array*/","-4.   for (size_type c = 1; c < columns; ++c)
-3.     for (size_type r = 0; r < rows; ++r)
-2.       Assert(row_sizes[r] == sub_objects[r][c]->n_rows(),
-1.              ExcIncompatibleRowNumbers(r, 0, r, c));

 /*finally initialize the row
indices with t",Useful
"/*finally initialize the row
indices with this array*/","-4.   for (size_type c = 1; c < columns; ++c)
-3.     for (size_type r = 0; r < rows; ++r)
-2.       Assert(row_sizes[r] == sub_objects[r][c]->n_rows(),
-1.              ExcIncompatibleRowNumbers(r, 0, r, c));

 /*finally initialize the row
indices with t",Useful
"/*only count in first column, since
all rows should be equivalent*/","-10.         this_row += sub_objects[block_row][c]->max_entries_per_row();
-9.       if (this_row > max_entries)
-8.         max_entries = this_row;
-7.     }
-6.   return max_entries;
-5. }
-4. template <class SparsityPatternBase>
-3. typename BlockSpars",Useful
"/*only count in first row, since
all rows should be equivalent*/","-9.   size_type count = 0;
-8.   for (size_type r = 0; r < rows; ++r)
-7.     count += sub_objects[r][0]->n_rows();
-6.   return count;
-5. }
-4. template <class SparsityPatternBase>
-3. typename BlockSparsityPatternBase<SparsityPatternBase>::size_type
-2",Useful
"/*delete old content, set block
sizes anew*/","-10.           MemoryConsumption::memory_consumption(row_indices) +
-9.           MemoryConsumption::memory_consumption(column_indices));
-8.   for (size_type r = 0; r < rows; ++r)
-7.     for (size_type c = 0; c < columns; ++c)
-6.       mem += MemoryCon",Useful
"/*and finally enquire their new
sizes*/","collect_sizes();
}



BlockDynamicSparsityPattern::BlockDynamicSparsityPattern(
  const size_type n_rows,
  const size_type n_columns)
  : BlockSparsityPatternBase<DynamicSparsityPattern>(n_rows, n_columns)
{}



BlockDynamicSparsityPattern::BlockDynamicSparsityPattern(
  const std::vector<size_type> &row_indices,
  const std::vector<size_type> &col_indices)
  : BlockSparsityPatternBase<DynamicSparsityPattern>(row_indices.size(),
                                                     col_indices.size())
{
  for (size_type i = 0; i < row_indices.size(); ++i)
    for (size_type j = 0; j < col_indices.size(); ++j)
      this->block(i, j).reinit(row_indices[i], col_indices[j]);
  this->collect_sizes();
}



BlockDynamicSparsityPattern::BlockDynamicSparsityPattern(
  const std::vector<IndexSet> &partitioning)
  : BlockSparsityPatternBase<DynamicSparsityPattern>(partitioning.size(),
                                                     partitioning.size())
{
  for (size_type i = 0; i < partitioning.size(); ++i)
    for (size_type j = 0; j < partitioning.size(); ++j)
      this->block(i, j).reinit(partitioning[i].size(),
                               partitioning[j].size(),
                               partitioning[i]);
  this->collect_sizes();
}



BlockDynamicSparsityPattern::BlockDynamicSparsityPattern(
  const BlockIndices &row_indices,
  const BlockIndices &col_indices)
{
  reinit(row_indices, col_indices);
}



void
BlockDynamicSparsityPattern::reinit(
  const std::vector<size_type> &row_block_sizes,
  const std::vector<size_type> &col_block_sizes)
{
  BlockSparsityPatternBase<DynamicSparsityPattern>::reinit(
    row_block_sizes.size(), col_block_sizes.size());
  for (size_type i = 0; i < row_block_sizes.size(); ++i)
    for (size_type j = 0; j < col_block_sizes.size(); ++j)
      this->block(i, j).reinit(row_block_sizes[i], col_block_sizes[j]);
  this->collect_sizes();
}



void
BlockDynamicSparsityPattern::reinit(const std::vector<IndexSet> &partitioning)
{
  BlockSparsityPatternBase<DynamicSparsityPattern>::reinit(partitioning.size(),
                                                           partitioning.size());
  for (size_type i = 0; i < partitioning.size(); ++i)
    for (size_type j = 0; j < partitioning.size(); ++j)
      this->block(i, j).reinit(partitioning[i].size(),
                               partitioning[j].size(),
                               partitioning[i]);
  this->collect_sizes();
}



void
BlockDynamicSparsityPattern::reinit(const BlockIndices &row_indices,
                                    const BlockIndices &col_indices)
{
  BlockSparsityPatternBase<DynamicSparsityPattern>::reinit(row_indices.size(),
                                                           col_indices.size());
  for (size_type i = 0; i < row_indices.size(); ++i)
    for (size_type j = 0; j < col_indices.size(); ++j)
      this->block(i, j).reinit(row_indices.block_size(i),
                               col_indices.block_size(j));
  this->collect_sizes();
}


#ifdef DEAL_II_WITH_TRILINOS
namespace TrilinosWrappers
{
  BlockSparsityPattern::BlockSparsityPattern(const size_type n_rows,
                                             const size_type n_columns)
    : dealii::BlockSparsityPatternBase<SparsityPattern>(n_rows, n_columns)
  {}



  BlockSparsityPattern::BlockSparsityPattern(
    const std::vector<size_type> &row_indices,
    const std::vector<size_type> &col_indices)
    : BlockSparsityPatternBase<SparsityPattern>(row_indices.size(),
                                                col_indices.size())
  {
    for (size_type i = 0; i < row_indices.size(); ++i)
      for (size_type j = 0; j < col_indices.size(); ++j)
        this->block(i, j).reinit(row_indices[i], col_indices[j]);
    this->collect_sizes();
  }



  BlockSparsityPattern::BlockSparsityPattern(
    const std::vector<IndexSet> &parallel_partitioning,
    const MPI_Comm &             communicator)
    : BlockSparsityPatternBase<SparsityPattern>(parallel_partitioning.size(),
                                                parallel_partitioning.size())
  {
    for (size_type i = 0; i < parallel_partitioning.size(); ++i)
      for (size_type j = 0; j < parallel_partitioning.size(); ++j)
        this->block(i, j).reinit(parallel_partitioning[i],
                                 parallel_partitioning[j],
                                 communicator);
    this->collect_sizes();
  }



  BlockSparsityPattern::BlockSparsityPattern(
    const std::vector<IndexSet> &row_parallel_partitioning,
    const std::vector<IndexSet> &col_parallel_partitioning,
    const std::vector<IndexSet> &writable_rows,
    const MPI_Comm &             communicator)
    : BlockSparsityPatternBase<SparsityPattern>(
        row_parallel_partitioning.size(),
        col_parallel_partitioning.size())
  {
    for (size_type i = 0; i < row_parallel_partitioning.size(); ++i)
      for (size_type j = 0; j < col_parallel_partitioning.size(); ++j)
        this->block(i, j).reinit(row_parallel_partitioning[i],
                                 col_parallel_partitioning[j],
                                 writable_rows[i],
                                 communicator);
    this->collect_sizes();
  }



  void
  BlockSparsityPattern::reinit(const std::vector<size_type> &row_block_sizes,
                               const std::vector<size_type> &col_block_sizes)
  {
    dealii::BlockSparsityPatternBase<SparsityPattern>::reinit(
      row_block_sizes.size(), col_block_sizes.size());
    for (size_type i = 0; i < row_block_sizes.size(); ++i)
      for (size_type j = 0; j < col_block_sizes.size(); ++j)
        this->block(i, j).reinit(row_block_sizes[i], col_block_sizes[j]);
    this->collect_sizes();
  }



  void
  BlockSparsityPattern::reinit(
    const std::vector<IndexSet> &parallel_partitioning,
    const MPI_Comm &             communicator)
  {
    dealii::BlockSparsityPatternBase<SparsityPattern>::reinit(
      parallel_partitioning.size(), parallel_partitioning.size());
    for (size_type i = 0; i < parallel_partitioning.size(); ++i)
      for (size_type j = 0; j < parallel_partitioning.size(); ++j)
        this->block(i, j).reinit(parallel_partitioning[i],
                                 parallel_partitioning[j],
                                 communicator);
    this->collect_sizes();
  }



  void
  BlockSparsityPattern::reinit(
    const std::vector<IndexSet> &row_parallel_partitioning,
    const std::vector<IndexSet> &col_parallel_partitioning,
    const MPI_Comm &             communicator)
  {
    dealii::BlockSparsityPatternBase<SparsityPattern>::reinit(
      row_parallel_partitioning.size(), col_parallel_partitioning.size());
    for (size_type i = 0; i < row_parallel_partitioning.size(); ++i)
      for (size_type j = 0; j < col_parallel_partitioning.size(); ++j)
        this->block(i, j).reinit(row_parallel_partitioning[i],
                                 col_parallel_partitioning[j],
                                 communicator);
    this->collect_sizes();
  }



  void
  BlockSparsityPattern::reinit(
    const std::vector<IndexSet> &row_parallel_partitioning,
    const std::vector<IndexSet> &col_parallel_partitioning,
    const std::vector<IndexSet> &writable_rows,
    const MPI_Comm &             communicator)
  {
    AssertDimension(writable_rows.size(), row_parallel_partitioning.size());
    dealii::BlockSparsityPatternBase<SparsityPattern>::reinit(
      row_parallel_partitioning.size(), col_parallel_partitioning.size());
    for (size_type i = 0; i < row_parallel_partitioning.size(); ++i)
      for (size_type j = 0; j < col_parallel_partitioning.size(); ++j)
        this->block(i, j).reinit(row_parallel_partitioning[i],
                                 col_parallel_partitioning[j],
                                 writable_rows[i],
                                 communicator);
    this->collect_sizes();

 /*and finally enquire their new
sizes*/

1.   }",Useful
"/*This file compiles a part of the instantiations from matrix_creator.cc
to reduce the compilation unit (and memory consumption)*/","-10. // This file is part of the deal.II library.
-9. //
-8. // The deal.II library is free software; you can use it, redistribute
-7. // it, and/or modify it under the terms of the GNU Lesser General
-6. // Public License as published by the Free Softwar",Useful
"/*First, initialize the
generalized support points and
quadrature weights, since they
are required for interpolation.*/","-10.                                               degree + 1,
-9.                                               FiniteElementData<dim>::Hdiv),
-8.                        std::vector<bool>(1, false),
-7.                        std::vector<ComponentMask>(
",Useful
"/*note that this->degree is the maximal
polynomial degree and is thus one higher
than the argument given to the
constructor*/","return ""FE_RaviartThomasNodal<"" + std::to_string(dim) + "">("" +
         std::to_string(this->degree - 1) + "")"";
}


template <int dim>
std::unique_ptr<FiniteElement<dim, dim>>
FE_RaviartThomasNodal<dim>::clone() const
{
  return std::make_unique<FE_RaviartThomasNodal<dim>>(*this);
}

 /*note that this->degree is the maximal
polynomial degree and is thus one higher
than the argument given to the
constructor*/

1.       const unsigned int p = this->degree - 1;
2.       const unsigned int q = fe_q_other->degree - 1;
3.       std::vector<std::pair<unsigned int, unsigned int>> identities;
4.       if (p == q)
5.         for (unsigned int i = 0; i < p + 1; ++i)
6.           identities.emplace_back(i, i);
7.       else if (p % 2 == 0 && q % 2 == 0)
8.         identities.emplace_back(p / 2, q / 2);
9.       return identities;
10.     }",Useful
"/*The only thing we know for sure
is that shape functions with
support on one face are zero on
the opposite face.*/","-1.   const unsigned int support_face = shape_index / this->n_dofs_per_face();

 /*The only thing we know for sure
is that shape functions with
support on one face are zero on
the opposite face.*/

1.   if (support_face < GeometryInfo<dim>::faces_per_cell",Useful
"/*In all other cases, return true,
which is safe*/","-2.   if (support_face < GeometryInfo<dim>::faces_per_cell)
-1.     return (face_index != GeometryInfo<dim>::opposite_face[support_face]);

 /*In all other cases, return true,
which is safe*/

1.   return true;
2. }
3. template <int dim>
4. void
5. FE_Rav",Useful
"/*First do interpolation on
faces. There, the component
evaluated depends on the face
direction and orientation.*/","-10.     std::vector<double> &              nodal_values) const
-9. {
-8.   Assert(support_point_values.size() == this->generalized_support_points.size(),
-7.          ExcDimensionMismatch(support_point_values.size(),
-6.                               thi",Useful
"/*TODO: There are tests that check that the following few functions don't
produce assertion failures, but none that actually check whether they do the
right thing. one example for such a test would be to project a function onto
an hp space and make sure that the convergence order is correct with regard
to the lowest used polynomial degree*/","-10.     {
-9.       for (unsigned int i = 0; i < istep; ++i)
-8.         {
-7.           nodal_values[fbase + i] = support_point_values[fbase + i](f);
-6.         }
-5.       fbase += istep;
-4.       ++f;
-3.     }
-2.   Assert(fbase == this->n_dofs_per",Useful
"/*we can presently only compute these
identities if both FEs are
FE_RaviartThomasNodals or the other is FE_Nothing.
In either case, no dofs are assigned on the vertex,
so we shouldn't be getting here at all.*/","-10. bool
-9. FE_RaviartThomasNodal<dim>::hp_constraints_are_implemented() const
-8. {
-7.   return true;
-6. }
-5. template <int dim>
-4. std::vector<std::pair<unsigned int, unsigned int>>
-3. FE_RaviartThomasNodal<dim>::hp_vertex_dof_identities(
-2.   c",Useful
"/*we can presently only compute
these identities if both FEs are
FE_RaviartThomasNodals or if the other
one is FE_Nothing*/","-10.     {
-9.       Assert(false, ExcNotImplemented());
-8.       return std::vector<std::pair<unsigned int, unsigned int>>();
-7.     }
-6. }
-5. template <int dim>
-4. std::vector<std::pair<unsigned int, unsigned int>>
-3. FE_RaviartThomasNodal<dim>::h",Useful
"/*dofs are located along lines, so two
dofs are identical only if in the
following two cases (remember that
the face support points are Gauss
points):
1. this->degree = fe_q_other->degree,
in the case, all the dofs on
the line are identical
2. this->degree-1 and fe_q_other->degree-1
are both even, i.e. this->dof_per_line
and fe_q_other->dof_per_line are both odd,
there exists only one point (the middle one)
such that dofs are identical on this point

to understand this, note that
this->degree is the *maximal*
polynomial degree, and is thus one
higher than the argument given to
the constructor*/","-2.       if (dim != 2)
-1.         return std::vector<std::pair<unsigned int, unsigned int>>();

 /*dofs are located along lines, so two
dofs are identical only if in the
following two cases (remember that
the face support points are Gauss
points):
1. th",Useful
"/*we can presently only compute
these identities if both FEs are
FE_RaviartThomasNodals or if the other
one is FE_Nothing*/","-10.     {
-9.       Assert(false, ExcNotImplemented());
-8.       return std::vector<std::pair<unsigned int, unsigned int>>();
-7.     }
-6. }
-5. template <int dim>
-4. std::vector<std::pair<unsigned int, unsigned int>>
-3. FE_RaviartThomasNodal<dim>::h",Useful
"/*the FE_Nothing has no degrees of freedom and it is typically used
in a context where we don't require any continuity along the
interface*/","-10.         return FiniteElementDomination::either_element_can_dominate;
-9.       else
-8.         return FiniteElementDomination::other_element_dominates;
-7.     }
-6.   else if (const FE_Nothing<dim> *fe_nothing =
-5.              dynamic_cast<const ",Useful
"/*Rule of thumb for FP accuracy,
that can be expected for a
given polynomial degree.
This value is used to cut
off values close to zero.*/","-2.   Quadrature<dim - 1> quad_face_support(
-1.     source_fe.generalized_face_support_points[face_no]);

 /*Rule of thumb for FP accuracy,
that can be expected for a
given polynomial degree.
This value is used to cut
off values close to zero.*/

1.   do",Useful
"/*Correct the interpolated
value. I.e. if it is close
to 1 or 0, make it exactly
1 or 0. Unfortunately, this
is required to avoid problems
with higher order elements.*/","-10.     QProjector<dim>::project_to_face(this->reference_cell(),
-9.                                      quad_face_support,
-8.                                      0);
-7.   for (unsigned int i = 0; i < source_fe.n_dofs_per_face(face_no); ++i)
-6.     ",Useful
"/*make sure that the row sum of
each of the matrices is 1 at
this point. this must be so
since the shape functions sum up
to 1*/","-8.           if (std::fabs(matrix_entry - 1.0) < eps)
-7.             matrix_entry = 1.0;
-6.           if (std::fabs(matrix_entry) < eps)
-5.             matrix_entry = 0.0;
-4.           interpolation_matrix(i, j) = matrix_entry;
-3.         }
-2.     ",Useful
"/*Rule of thumb for FP accuracy,
that can be expected for a
given polynomial degree.
This value is used to cut
off values close to zero.*/","-2.   Quadrature<dim - 1> quad_face_support(
-1.     source_fe.generalized_face_support_points[face_no]);

 /*Rule of thumb for FP accuracy,
that can be expected for a
given polynomial degree.
This value is used to cut
off values close to zero.*/

1.   do",Useful
"/*Correct the interpolated
value. I.e. if it is close
to 1 or 0, make it exactly
1 or 0. Unfortunately, this
is required to avoid problems
with higher order elements.*/","-10.     QProjector<dim>::project_to_face(this->reference_cell(),
-9.                                      quad_face_support,
-8.                                      0);
-7.   for (unsigned int i = 0; i < source_fe.n_dofs_per_face(face_no); ++i)
-6.     ",Useful
"/*make sure that the row sum of
each of the matrices is 1 at
this point. this must be so
since the shape functions sum up
to 1*/","-8.           if (std::fabs(matrix_entry - 1.0) < eps)
-7.             matrix_entry = 1.0;
-6.           if (std::fabs(matrix_entry) < eps)
-5.             matrix_entry = 0.0;
-4.           interpolation_matrix(i, j) = matrix_entry;
-3.         }
-2.     ",Useful
"/*First, initialize the
generalized support points and
quadrature weights, since they
are required for interpolation.*/","-10.                              deg + 2,
-9.                              FiniteElementData<dim>::Hdiv),
-8.       std::vector<bool>(PolynomialsABF<dim>::n_polynomials(deg), true),
-7.       std::vector<ComponentMask>(PolynomialsABF<dim>::n_polynomials(",Useful
"/*Now compute the inverse node matrix, generating the correct
basis functions from the raw ones. For a discussion of what
exactly happens here, see FETools::compute_node_matrix.*/","-1.   initialize_support_points(deg);

 /*Now compute the inverse node matrix, generating the correct
basis functions from the raw ones. For a discussion of what
exactly happens here, see FETools::compute_node_matrix.*/

1.   const FullMatrix<double> M = ",Useful
"/*From now on, the shape functions provided by FiniteElement::shape_value
and similar functions will be the correct ones, not
the raw shape functions from the polynomial space anymore.*/","-3.   const FullMatrix<double> M = FETools::compute_node_matrix(*this);
-2.   this->inverse_node_matrix.reinit(n_dofs, n_dofs);
-1.   this->inverse_node_matrix.invert(M);

 /*From now on, the shape functions provided by FiniteElement::shape_value
and simi",Useful
"/*Reinit the vectors of
restriction and prolongation
matrices to the right sizes.
Restriction only for isotropic
refinement*/","-6.   const FullMatrix<double> M = FETools::compute_node_matrix(*this);
-5.   this->inverse_node_matrix.reinit(n_dofs, n_dofs);
-4.   this->inverse_node_matrix.invert(M);

 /*Reinit the vectors of
restriction and prolongation
matrices to the right sizes.
",Useful
"/*TODO[TL]: for anisotropic refinement we will probably need a table of
submatrices with an array for each refine case*/","-2.   AssertDimension(this->n_unique_faces(), 1);
-1.   const unsigned int face_no = 0;

 /*TODO[TL]: for anisotropic refinement we will probably need a table of
submatrices with an array for each refine case*/

1.   std::vector<FullMatrix<double>> face_e",Useful
"/*TODO: Something goes wrong there. The error of the least squares fit
is to large ...
FETools::compute_face_embedding_matrices(*this, face_embeddings.data(), 0,
0);*/","-4.   std::vector<FullMatrix<double>> face_embeddings(
-3.     1 << (dim - 1),
-2.     FullMatrix<double>(this->n_dofs_per_face(face_no),
-1.                        this->n_dofs_per_face(face_no)));

 /*TODO: Something goes wrong there. The error of the l",Useful
"/*note that the
FETools::get_fe_by_name
function depends on the
particular format of the string
this function returns, so they
have to be kept in synch*/","-6.   return;
-5. }
-4. template <int dim>
-3. std::string
-2. FE_ABF<dim>::get_name() const
-1. {

 /*note that the
FETools::get_fe_by_name
function depends on the
particular format of the string
this function returns, so they
have to be kept in synch*/
",Useful
"/*These might be required when the faces contribution is computed
Therefore they will be initialized at this point.*/","-5.   for (unsigned int d = 1; d < dim; ++d)
-4.     n_face_points *= deg + 1;
-3.   this->generalized_support_points.resize(
-2.     GeometryInfo<dim>::faces_per_cell * n_face_points + n_interior_points);
-1.   this->generalized_face_support_points[face_",Useful
"/*Compute its quadrature
contribution for each
moment.*/","-4.       for (unsigned int k = 0; k < n_face_points; ++k)
-3.         {
-2.           this->generalized_face_support_points[face_no][k] =
-1.             face_points.point(k);

 /*Compute its quadrature
contribution for each
moment.*/

1.           for (",Useful
"/*Now initialize edge interior weights for the ABF elements.
These are completely independent from the usual edge moments. They
stem from applying the Gauss theorem to the nodal values, which
was necessary to cast the ABF elements into the deal.II framework
for vector valued elements.*/","-2.           this->generalized_support_points[current] = faces.point(current);
-1.         }

 /*Now initialize edge interior weights for the ABF elements.
These are completely independent from the usual edge moments. They
stem from applying the Gauss th",Useful
"/*Create Legendre basis for the
space D_xi Q_k*/","-10.         {
-9.           for (unsigned int i = 0; i < polynomials_abf[0]->n() * dim; ++i)
-8.             {
-7.               boundary_weights_abf(k, i) =
-6.                 polynomials_abf[i % dim]->compute_value(i / dim,
-5.                        ",Useful
"/*Decouple the creation of the generalized support points
from computation of interior weights.*/","-10.         TableIndices<3>(n_interior_points, polynomials[0]->n(), dim));
-9.       for (unsigned int k = 0; k < cell_quadrature.size(); ++k)
-8.         {
-7.           for (unsigned int i = 0; i < polynomials[0]->n(); ++i)
-6.             for (unsigne",Useful
"/*Additional functionality for the ABF elements
TODO: Here the canonical extension of the principle
behind the ABF elements is implemented. It is unclear,
if this really leads to the ABF spaces in 3D!*/","-2.   for (unsigned int k = 0; k < cell_quadrature.size(); ++k)
-1.     this->generalized_support_points[current++] = cell_quadrature.point(k);

 /*Additional functionality for the ABF elements
TODO: Here the canonical extension of the principle
behind th",Useful
"/*This function is the same Raviart-Thomas interpolation performed by
interpolate. Still, we cannot use interpolate, since it was written
for smooth functions. The functions interpolated here are not
smooth, maybe even not continuous. Therefore, we must double the
number of quadrature points in each direction in order to integrate
only smooth functions.*/","-7.           for (unsigned int d = 0; d < dim; ++d)
-6.             interior_weights_abf(k, i, d) = -poly_grad[d];
-5.         }
-4.     }
-3.   Assert(current == this->generalized_support_points.size(),
-2.          ExcInternalError());
-1. }

 /*This f",Useful
"/*Then again, the interpolated function is chosen such that the
moments coincide with the function to be interpolated.*/","-10.     }
-9.   Assert(current == this->generalized_support_points.size(),
-8.          ExcInternalError());
-7. }

 /*Then again, the interpolated function is chosen such that the
moments coincide with the function to be interpolated.*/

1. template <in",Useful
"/*First, compute interpolation on
subfaces*/","-10.     {
-9.       unsigned int iso = RefinementCase<dim>::isotropic_refinement - 1;
-8.       for (unsigned int i = 0; i < GeometryInfo<dim>::max_children_per_cell;
-7.            ++i)
-6.         this->restriction[iso][i].reinit(0, 0);
-5.       retur",Useful
"/*The shape functions of the
child cell are evaluated
in the quadrature points
of a full face.*/","-2.   for (unsigned int face : GeometryInfo<dim>::face_indices())
-1.     {

 /*The shape functions of the
child cell are evaluated
in the quadrature points
of a full face.*/

1.       Quadrature<dim> q_face =
2.         QProjector<dim>::project_to_face(t",Useful
"/*Store shape values, since the
evaluation suffers if not
ordered by point*/","-2.       Quadrature<dim> q_face =
-1.         QProjector<dim>::project_to_face(this->reference_cell(), q_base, face);

 /*Store shape values, since the
evaluation suffers if not
ordered by point*/

1.       Table<2, double> cached_values_face(this->n_dof",Useful
"/*The weight functions for
the coarse face are
evaluated on the subface
only.*/","-9.       Table<2, double> cached_values_face(this->n_dofs_per_cell(),
-8.                                           q_face.size());
-7.       for (unsigned int k = 0; k < q_face.size(); ++k)
-6.         for (unsigned int i = 0; i < this->n_dofs_per_cell(",Useful
"/*On a certain face, we must
compute the moments of ALL
fine level functions with
the coarse level weight
functions belonging to
that face. Due to the
orthogonalization process
when building the shape
functions, these weights
are equal to the
corresponding shape
functions.*/","-4.           Quadrature<dim> q_sub = QProjector<dim>::project_to_subface(
-3.             this->reference_cell(), q_base, face, sub);
-2.           const unsigned int child = GeometryInfo<dim>::child_cell_on_face(
-1.             RefinementCase<dim>::iso",Useful
"/*Create Legendre basis for the
space D_xi Q_k. Here, we cannot
use the shape functions*/","-10.                     cached_values_face(i_child, k) *
-9.                     this->shape_value_component(
-8.                       face * this->n_dofs_per_face(face) + i_face,
-7.                       q_sub.point(k),
-6.                       Geome",Useful
"/*Store shape values, since the
evaluation suffers if not
ordered by point*/","-2.       Quadrature<dim> q_face =
-1.         QProjector<dim>::project_to_face(this->reference_cell(), q_base, face);

 /*Store shape values, since the
evaluation suffers if not
ordered by point*/

1.       Table<2, double> cached_values_face(this->n_dof",Useful
"/*the element is face-based (not
to be confused with George
W. Bush's Faith Based
Initiative...), and we have
(rt_order+1)^(dim-1) DoFs per face*/","-10. }
-9. template <int dim>
-8. std::vector<unsigned int>
-7. FE_ABF<dim>::get_dpo_vector(const unsigned int rt_order)
-6. {
-5.   if (dim == 1)
-4.     {
-3.       Assert(false, ExcImpossibleInDim(1));
-2.       return std::vector<unsigned int>();
-1. ",Useful
"/*Return computed values if we
know them easily. Otherwise, it
is always safe to return true.*/","-7. template <int dim>
-6. bool
-5. FE_ABF<dim>::has_support_on_face(const unsigned int shape_index,
-4.                                  const unsigned int face_index) const
-3. {
-2.   AssertIndexRange(shape_index, this->n_dofs_per_cell());
-1.   Assert",Useful
"/*TODO: Check if this ""correction"" can be removed.*/","-9.           unsigned int k = QProjector<dim>::DataSetDescriptor::face(
-8.             this->reference_cell(), face, false, false, false, n_face_points);
-7.           for (unsigned int i = 0; i < boundary_weights_abf.size(1); ++i)
-6.             nodal",Useful
"/*We require the cell to be active since we can only then get nodal
values for the shifts*/","-2.   typename DoFHandler<dim, spacedim>::cell_iterator dof_cell(
-1.     *cell, shiftmap_dof_handler);

 /*We require the cell to be active since we can only then get nodal
values for the shifts*/

1.   Assert(dof_cell->is_active() == true, ExcInactiveCe",Useful
/*now get the values of the shift vectors at the vertices*/,"-1.   Assert(dof_cell->is_active() == true, ExcInactiveCell());

 /*now get the values of the shift vectors at the vertices*/

1.   Vector<typename VectorType::value_type> mapping_values(
2.     shiftmap_dof_handler->get_fe().n_dofs_per_cell());
3.   dof_",Useful
"/*pick out the value of the shift vector at the present
vertex. since vertex dofs are always numbered first, we can
access them easily*/","-6.   Vector<typename VectorType::value_type> mapping_values(
-5.     shiftmap_dof_handler->get_fe().n_dofs_per_cell());
-4.   dof_cell->get_dof_values(*euler_transform_vectors, mapping_values);
-3.   for (const unsigned int i : GeometryInfo<dim>::vertex_",Useful
"/*compute new support point by old (reference) value and added
shift*/","
      vertices[i] = cell->vertex(i) + shift_vector;



 /*compute new support point by old (reference) value and added
shift*/

1.     }
2.   return vertices;
3. }
4. template <int dim, class VectorType, int spacedim>
5. std::vector<Point<spacedim>>
6. MappingQ1Eulerian<dim, VectorType, spacedim>::compute_mapping_support_points(
7.   const typename Triangulation<dim, spacedim>::cell_iterator &cell) const
8. {
9.   const auto vertices = this->get_vertices(cell);
10.   std::vector<Point<spacedim>> a(GeometryInfo<dim>::vertices_per_cell);",Useful
"/*call the function of the base class, but ignoring
any potentially detected cell similarity between
the current and the previous cell*/","-10. template <int dim, class VectorType, int spacedim>
-9. CellSimilarity::Similarity
-8. MappingQ1Eulerian<dim, VectorType, spacedim>::fill_fe_values(
-7.   const typename Triangulation<dim, spacedim>::cell_iterator &cell,
-6.   const CellSimilarity::Si",Useful
"/*also return the updated flag since any detected
similarity wasn't based on the mapped field, but
the original vertices which are meaningless*/","-5.   MappingQ<dim, spacedim>::fill_fe_values(cell,
-4.                                           CellSimilarity::invalid_next_cell,
-3.                                           quadrature,
-2.                                           internal_data,
-1.",Useful
"/*we transform our tria iterator into a dof iterator so we can access
data not associated with triangulations*/","-10.                     Utilities::to_string(reference_cell.get_dimension()) +
-9.                     "" ) do not agree.""));
-8.   return this->reference_cell == reference_cell;
-7. }
-6. template <int dim, int spacedim, typename VectorType>
-5. boost::c",Useful
"/*add flags if the respective quantities are necessary to compute
what we need. note that some flags appear in both conditions and
in subsequent set operations. this leads to some circular
logic. the only way to treat this is to iterate. since there are
5 if-clauses in the loop, it will take at most 4 iterations to
converge. do them:*/","-10.         for (unsigned int i = 0; i < data.n_shape_functions; ++i)
-9.           data.fourth_derivative(point, i) =
-8.             fe->shape_4th_derivative(i, unit_points[point]);
-7.     }
-6. }
-5. template <int dim, int spacedim, typename VectorTy",Useful
"/*The following is a little incorrect:
If not applied on a face,
update_boundary_forms does not
make sense. On the other hand,
it is necessary on a
face. Currently,
update_boundary_forms is simply
ignored for the interior of a
cell.*/","-3.   UpdateFlags out = in;
-2.   for (unsigned int i = 0; i < 5; ++i)
-1.     {

 /*The following is a little incorrect:
If not applied on a face,
update_boundary_forms does not
make sense. On the other hand,
it is necessary on a
face. Currently,
update_",Useful
"/*store the flags in the internal data object so we can access them
in fill_fe_*_values(). use the transitive hull of the required
flags*/","if (data.update_each & update_quadrature_points)
    data.shape_values.resize(data.n_shape_functions * n_q_points);

  if (data.update_each &
      (update_covariant_transformation | update_contravariant_transformation |
       update_JxW_values | update_boundary_forms | update_normal_vectors |
       update_jacobians | update_jacobian_grads | update_inverse_jacobians))
    data.shape_derivatives.resize(data.n_shape_functions * n_q_points);

  if (data.update_each & update_covariant_transformation)
    data.covariant.resize(n_original_q_points);

  if (data.update_each & update_contravariant_transformation)
    data.contravariant.resize(n_original_q_points);

  if (data.update_each & update_volume_elements)
    data.volume_elements.resize(n_original_q_points);

  if (data.update_each &
      (update_jacobian_grads | update_jacobian_pushed_forward_grads))
    data.shape_second_derivatives.resize(data.n_shape_functions * n_q_points);

  if (data.update_each & (update_jacobian_2nd_derivatives |
                          update_jacobian_pushed_forward_2nd_derivatives))
    data.shape_third_derivatives.resize(data.n_shape_functions * n_q_points);

  if (data.update_each & (update_jacobian_3rd_derivatives |
                          update_jacobian_pushed_forward_3rd_derivatives))
    data.shape_fourth_derivatives.resize(data.n_shape_functions * n_q_points);

  compute_shapes_virtual(q.get_points(), data);

 /*store the flags in the internal data object so we can access them
in fill_fe_*_values(). use the transitive hull of the required
flags*/

1.   Assert(dynamic_cast<InternalData *>(mdata.get()) != nullptr,
2.          ExcInternalError());
3.   update_internal_dofs(cell, dynamic_cast<InternalData &>(*mdata));
4.   return do_transform_real_to_unit_cell(cell,
5.                                         p,
6.                                         initial_p_unit,
7.                                         dynamic_cast<InternalData &>(*mdata));
8. }
9. template <int dim, int spacedim, typename VectorType>
10. Point<dim>",Useful
"/*see if we need the (transformation) shape function values
and/or gradients and resize the necessary arrays*/","-2.   data.update_each = requires_update_flags(update_flags);
-1.   const unsigned int n_q_points = q.size();

 /*see if we need the (transformation) shape function values
and/or gradients and resize the necessary arrays*/

1.   if (data.update_each & upd",Useful
"/**
       * Compute the locations of quadrature points on the object described by
       * the first argument (and the cell for which the mapping support points
       * have already been set), but only if the update_flags of the @p data
       * argument indicate so.*/","-10. namespace internal
-9. {
-8.   namespace MappingFEFieldImplementation
-7.   {
-6.     namespace
-5.     {
-4.       /**
-3.        * Compute the locations of quadrature points on the object described by
-2.        * the first argument (and the cell f",Useful
/*write result into contravariant data*/,"-10.                   &data.derivative(point + data_set, 0);
-9.                 Tensor<1, dim> result[spacedim];
-8.                 for (unsigned int k = 0; k < data.n_shape_functions; ++k)
-7.                   {
-6.                     const unsigned",Useful
"/*never touch any data for j=dim in case dim<spacedim, so
it will always be zero as it was initialized*/","-10.                 for (unsigned int k = 0; k < data.n_shape_functions; ++k)
-9.                   {
-8.                     const unsigned int comp_k =
-7.                       fe.system_to_component_index(k).first;
-6.                     if (fe_mask",Useful
"/*never touch any data for j=dim in case dim<spacedim, so
it will always be zero as it was initialized*/","-10.                 for (unsigned int k = 0; k < data.n_shape_functions; ++k)
-9.                   {
-8.                     const unsigned int comp_k =
-7.                       fe.system_to_component_index(k).first;
-6.                     if (fe_mask",Useful
"/*never touch any data for j,l,m,n=dim in case
dim<spacedim, so it will always be zero as it was
initialized*/","for (unsigned int i = 0; i < spacedim; ++i)
                  for (unsigned int j = 0; j < spacedim; ++j)
                    for (unsigned int l = 0; l < spacedim; ++l)
                      for (unsigned int m = 0; m < dim; ++m)
                        for (unsigned int n = 0; n < dim; ++n)
                          {
                            jacobian_pushed_forward_3rd_derivatives
                              [point][i][j][l][m][n] =
                                tmp[i][j][0][m][n] *
                                data.covariant[point][l][0];
                            for (unsigned int lr = 1; lr < dim; ++lr)
                              jacobian_pushed_forward_3rd_derivatives[point][i]
                                                                     [j][l][m]
                                                                     [n] +=
                                tmp[i][j][lr][m][n] *
                                data.covariant[point][l][lr];
                          }

 /*never touch any data for j,l,m,n=dim in case
dim<spacedim, so it will always be zero as it was
initialized*/

1.                    ""update_covariant_transformation""));
2.           for (unsigned int q = 0; q < output.size(); ++q)
3.             for (unsigned int i = 0; i < spacedim; ++i)
4.               for (unsigned int j = 0; j < spacedim; ++j)
5.                 for (unsigned int k = 0; k < spacedim; ++k)
6.                   {
7.                     output[q][i][j][k] = data.covariant[q][j][0] *
8.                                          data.covariant[q][k][0] *
9.                                          input[q][i][0][0];
10.                     for (unsigned int J = 0; J < dim; ++J)",Useful
"/**
       * Depending on what information is called for in the update flags of the
       * @p data object, compute the various pieces of information that is
       * required by the fill_fe_face_values() and fill_fe_subface_values()
       * functions.  This function simply unifies the work that would be done by
       * those two functions.
       *
       * The resulting data is put into the @p output_data argument.*/","-10.               }
-9.           }
-8.       }
-7.       /**
-6.        * Depending on what information is called for in the update flags of the
-5.        * @p data object, compute the various pieces of information that is
-4.        * required by the ",Useful
"/*map the unit tangentials to the real cell. checking for d!=dim-1
eliminates compiler warnings regarding unsigned int expressions <
0.*/","-10.           &output_data)
-9.       {
-8.         const UpdateFlags update_flags = data.update_each;
-7.         if (update_flags & update_boundary_forms)
-6.           {
-5.             const unsigned int n_q_points = output_data.boundary_forms.size()",Useful
"/*if dim==spacedim, we can use the unit tangentials to compute the
boundary form by simply taking the cross product*/","-10.                   data.aux[d].size() <=
-9.                     data.unit_tangentials[face_no + cell->n_faces() * d].size(),
-8.                   ExcInternalError());
-7.                 mapping.transform(
-6.                   make_array_view(
-5. ",Useful
"/*in 1d, we don't have access to any of the data.aux
fields (because it has only dim-1 components), but we
can still compute the boundary form by simply looking
at the number of the face*/","-6.             if (dim == spacedim)
-5.               {
-4.                 for (unsigned int i = 0; i < n_q_points; ++i)
-3.                   switch (dim)
-2.                     {
-1.                       case 1:

 /*in 1d, we don't have access to an",Useful
"/*in the codim-one case, the boundary form results from the
cross product of all the face tangential vectors and the cell
normal vector

to compute the cell normal, use the same method used in
fill_fe_values for cells above*/","-1.               {

 /*in the codim-one case, the boundary form results from the
cross product of all the face tangential vectors and the cell
normal vector

to compute the cell normal, use the same method used in
fill_fe_values for cells above*/

1.    ",Useful
/*J is a tangent vector*/,"-5.                 AssertDimension(data.contravariant.size(), n_q_points);
-4.                 for (unsigned int point = 0; point < n_q_points; ++point)
-3.                   {
-2.                     if (dim == 1)
-1.                       {

 /*J is a ",Useful
"/*then compute the face normal from the face tangent
and the cell normal:*/","-10.                           (face_no == 0 ? -1. : +1.) *
-9.                           output_data.boundary_forms[point].norm();
-8.                       }
-7.                     if (dim == 2)
-6.                       {
-5.                         c",Useful
"/**
       * Do the work of MappingFEField::fill_fe_face_values() and
       * MappingFEField::fill_fe_subface_values() in a generic way, using the
       * 'data_set' to differentiate whether we will work on a face (and if so,
       * which one) or subface.*/","-10.             if (update_flags & update_inverse_jacobians)
-9.               for (unsigned int point = 0; point < n_q_points; ++point)
-8.                 output_data.inverse_jacobians[point] =
-7.                   data.covariant[point].transpose();
-",Useful
"/*convert data object to internal data for this class. fails with an
exception if that is not possible*/","-10. template <int dim, int spacedim, typename VectorType>
-9. CellSimilarity::Similarity
-8. MappingFEField<dim, spacedim, VectorType, void>::fill_fe_values(
-7.   const typename Triangulation<dim, spacedim>::cell_iterator &cell,
-6.   const CellSimilari",Useful
"/*if dim==spacedim, then there is no cell normal to
compute. since this is for FEValues (and not FEFaceValues),
there are also no face normals to compute*/","-6.               Assert(det > 1e-12 * Utilities::fixed_power<dim>(
-5.                                      cell->diameter() / std::sqrt(double(dim))),
-4.                      (typename Mapping<dim, spacedim>::ExcDistortedMappedCell(
-3.                ",Useful
/*copy values from InternalData to vector given by reference*/,"-2.         }
-1.     }

 /*copy values from InternalData to vector given by reference*/

1.   if (update_flags & update_jacobians)
2.     {
3.       AssertDimension(output_data.jacobians.size(), n_q_points);
4.       for (unsigned int point = 0; point < ",Useful
/*copy values from InternalData to vector given by reference*/,"-2.         }
-1.     }

 /*copy values from InternalData to vector given by reference*/

1.   if (update_flags & update_jacobians)
2.     {
3.       AssertDimension(output_data.jacobians.size(), n_q_points);
4.       for (unsigned int point = 0; point < ",Useful
"/*calculate derivatives of the Jacobians pushed forward to real cell
coordinates*/","internal::MappingFEFieldImplementation::
    maybe_update_jacobian_3rd_derivatives<dim, spacedim, VectorType>(
      QProjector<dim>::DataSetDescriptor::cell(),
      data,
      euler_dof_handler->get_fe(),
      fe_mask,
      fe_to_real,
      output_data.jacobian_3rd_derivatives);

 /*calculate derivatives of the Jacobians pushed forward to real cell
coordinates*/

1.   internal::MappingFEFieldImplementation::
2.     maybe_update_jacobian_pushed_forward_3rd_derivatives<dim,
3.                                                          spacedim,
4.                                                          VectorType>(
5.       QProjector<dim>::DataSetDescriptor::cell(),
6.       data,
7.       euler_dof_handler->get_fe(),
8.       fe_mask,
9.       fe_to_real,
10.       output_data.jacobian_pushed_forward_3rd_derivatives);",Useful
"/*convert data object to internal data for this class. fails with an
exception if that is not possible*/","-10. template <int dim, int spacedim, typename VectorType>
-9. CellSimilarity::Similarity
-8. MappingFEField<dim, spacedim, VectorType, void>::fill_fe_values(
-7.   const typename Triangulation<dim, spacedim>::cell_iterator &cell,
-6.   const CellSimilari",Useful
"/*convert data object to internal data for this class. fails with an
exception if that is not possible*/","-10. template <int dim, int spacedim, typename VectorType>
-9. CellSimilarity::Similarity
-8. MappingFEField<dim, spacedim, VectorType, void>::fill_fe_values(
-7.   const typename Triangulation<dim, spacedim>::cell_iterator &cell,
-6.   const CellSimilari",Useful
"/*We still allow this operation as in the
reference cell Derivatives are Tensor
rather than DerivativeForm*/","-10.                     ""update_volume_elements""));
-9.                 Assert(rank == 1, ExcMessage(""Only for rank 1""));
-8.                 for (unsigned int i = 0; i < output.size(); ++i)
-7.                   {
-6.                     output[i] =
-5.",Useful
"/*Use the get_data function to create an InternalData with data vectors of
the right size and transformation shape values already computed at point
p.*/","-10.   (void)mapping_data;
-9.   AssertDimension(input.size(), output.size());
-8.   AssertThrow(false, ExcNotImplemented());
-7. }
-6. template <int dim, int spacedim, typename VectorType>
-5. Point<spacedim>
-4. MappingFEField<dim, spacedim, VectorType,",Useful
"/*first a Newton iteration based on the real mapping. It uses the center
point of the cell as a starting point*/","-10.           data.local_dof_values[i] * data.shape(0, i);
-9.     }
-8.   return p_real;
-7. }
-6. template <int dim, int spacedim, typename VectorType>
-5. Point<dim>
-4. MappingFEField<dim, spacedim, VectorType, void>::transform_real_to_unit_cell(
-3.",Useful
"/*mirror the conditions of the code below to determine if we need to
use an arbitrary starting point or if we just need to rethrow the
exception*/","
  initial_p_unit = GeometryInfo<dim>::project_to_unit_cell(initial_p_unit);



 /*mirror the conditions of the code below to determine if we need to
use an arbitrary starting point or if we just need to rethrow the
exception*/

111",Useful
"/*for (unsigned int d=0; d<dim; ++d)
initial_p_unit[d] = 0.;*/","-1.   initial_p_unit = GeometryInfo<dim>::project_to_unit_cell(initial_p_unit);

 /*for (unsigned int d=0; d<dim; ++d)
initial_p_unit[d] = 0.;*/

1.   const Quadrature<dim> point_quadrature(initial_p_unit);
2.   UpdateFlags update_flags = update_quadratur",Useful
"/*Newton iteration to solve
f(x)=p(x)-p=0
x_{n+1}=x_n-[f'(x)]^{-1}f(x)
The start value was set to be the
linear approximation to the cell
The shape values and derivatives
of the mapping at this point are
previously computed.
f(x)*/","-10. MappingFEField<dim, spacedim, VectorType, void>::do_transform_real_to_unit_cell(
-9.   const typename Triangulation<dim, spacedim>::cell_iterator &cell,
-8.   const Point<spacedim> &                                     p,
-7.   const Point<dim> &    ",Useful
/*do a line search*/,"-2.       const Tensor<1, dim> delta =
-1.         invert(df) * static_cast<const Tensor<1, dim> &>(f);

 /*do a line search*/

1.       double step_length = 1;
2.       do
3.         {",Useful
"/*update of p_unit. The
spacedimth component of
transformed point is simply
ignored in codimension one
case. When this component is
not zero, then we are
projecting the point to the
surface or curve identified
by the cell.*/","-3.       double step_length = 1;
-2.       do
-1.         {

 /*update of p_unit. The
spacedimth component of
transformed point is simply
ignored in codimension one
case. When this component is
not zero, then we are
projecting the point to the
surface or",Useful
"/*shape values and derivatives
at new p_unit point*/","-10.           // transformed point is simply
-9.           // ignored in codimension one
-8.           // case. When this component is
-7.           // not zero, then we are
-6.           // projecting the point to the
-5.           // surface or curve i",Useful
"/*see if we are making progress with the current step length
and if not, reduce it by a factor of two and try again*/","-2.           Point<spacedim> p_real_trial = do_transform_unit_to_real_cell(mdata);
-1.           const Tensor<1, spacedim> f_trial = p - p_real_trial;

 /*see if we are making progress with the current step length
and if not, reduce it by a factor of two",Useful
"/*if we get to the following label, then we have either run out
of Newton iterations, or the line search has not converged.
in either case, we need to give up, so throw an exception that
can then be caught*/","-10.             step_length /= 2;
-9.           else
-8.             goto failure;
-7.         }
-6.       while (true);
-5.       ++newton_iteration;
-4.       if (newton_iteration > newton_iteration_limit)
-3.         goto failure;
-2.     }
-1.   retu",Useful
"/*...the compiler wants us to return something, though we can
of course never get here...*/","-3. failure:
-2.   AssertThrow(false,
-1.               (typename Mapping<dim, spacedim>::ExcTransformationFailed()));

 /*...the compiler wants us to return something, though we can
of course never get here...*/

1.   return {};
2. }
3. template <int dim",Useful
/*adjust unit support point for discontinuous node*/,"-10.                              FiniteElementData<dim>(get_dpo_vector(degree),
-9.                                                     1,
-8.                                                     degree,
-7.                                                ",Useful
/*adjust unit support point for discontinuous node*/,"-10.                              FiniteElementData<dim>(get_dpo_vector(degree),
-9.                                                     1,
-8.                                                     degree,
-7.                                                ",Useful
"/*note that the FETools::get_fe_by_name function depends on the
particular format of the string this function returns, so they have to be
kept in synch*/","-10.   Point<dim> point;
-9.   for (unsigned int d = 0; d < dim; ++d)
-8.     point[d] = 0.5;
-7.   this->unit_support_points.push_back(point);
-6.   AssertDimension(this->n_dofs_per_cell(), this->unit_support_points.size());
-5. }
-4. template <int dim, ",Useful
/*Decode the support points in one coordinate direction.*/,"-8.   std::ostringstream             namebuf;
-7.   bool                           type     = true;
-6.   const unsigned int             n_points = this->degree + 1;
-5.   std::vector<double>            points(n_points);
-4.   const unsigned int          ",Useful
/*Do not consider the discontinuous node for dimension 1*/,"-10.         {
-9.           if (index == 0)
-8.             points[index] = unit_support_points[j](0);
-7.           else if (index == 1)
-6.             points[n_points - 1] = unit_support_points[j](0);
-5.           else
-4.             points[index - ",Useful
/*We don't need the discontinuous function for local interpolation*/,"-10.          ExcDimensionMismatch(nodal_dofs.size(), this->n_dofs_per_cell()));
-9.   Assert(support_point_values[0].size() == this->n_components(),
-8.          ExcDimensionMismatch(support_point_values[0].size(),
-7.                               this-",Useful
/*we need an additional DG0-node for a dim-dimensional object*/,"-10.   riaf.back() = true;
-9.   return riaf;
-8. }
-7. template <int dim, int spacedim>
-6. std::vector<unsigned int>
-5. FE_Q_DG0<dim, spacedim>::get_dpo_vector(const unsigned int deg)
-4. {
-3.   std::vector<unsigned int> dpo(dim + 1, 1U);
-2.   for (u",Useful
"/*vertex/line/face domination
(if fe_other is derived from FE_DGQ)
------------------------------------*/","-1.       return FiniteElementDomination::no_requirements;

 /*vertex/line/face domination
(if fe_other is derived from FE_DGQ)
------------------------------------*/

1.   if (const FE_Q_DG0<dim, spacedim> *fe_dg0_other =
2.         dynamic_cast<const FE",Useful
/*there are no requirements between continuous and discontinuous elements*/,"-2.   if (codim > 0)
-1.     if (dynamic_cast<const FE_DGQ<dim, spacedim> *>(&fe_other) != nullptr)

 /*there are no requirements between continuous and discontinuous elements*/

1.       return FiniteElementDomination::no_requirements;",Useful
"/*vertex/line/face domination
(if fe_other is not derived from FE_DGQ)
& cell domination
----------------------------------------*/","-1.       return FiniteElementDomination::no_requirements;

 /*vertex/line/face domination
(if fe_other is not derived from FE_DGQ)
& cell domination
----------------------------------------*/

1.   if (const FE_Q_DG0<dim, spacedim> *fe_dg0_other =
2.    ",Useful
"/*the FE_Nothing has no degrees of freedom and it is typically used
in a context where we don't require any continuity along the
interface*/","-10.         return FiniteElementDomination::either_element_can_dominate;
-9.       else
-8.         return FiniteElementDomination::other_element_dominates;
-7.     }
-6.   else if (const FE_Nothing<dim> *fe_nothing =
-5.              dynamic_cast<const ",Useful
"/*now convert from the map to the linear vector. make sure every
entry really appeared in the map*/","-5.         std::map<types::global_dof_index, Point<spacedim>> x_support_points;
-4.         map_dofs_to_support_points(mapping,
-3.                                    dof_handler,
-2.                                    x_support_points,
-1.              ",Useful
"/*Let the internal function do all the work, just make sure that it
gets a MappingCollection*/","-10.                              std::vector<Point<spacedim>> &   support_points,
-9.                              const ComponentMask &            mask)
-8.   {
-7.     AssertDimension(support_points.size(), dof_handler.n_dofs());
-6.     Assert((dynami",Useful
"/*Let the internal function do all the work, just make sure that it
gets a MappingCollection*/","-10.                              std::vector<Point<spacedim>> &   support_points,
-9.                              const ComponentMask &            mask)
-8.   {
-7.     AssertDimension(support_points.size(), dof_handler.n_dofs());
-6.     Assert((dynami",Useful
"/*Let the internal function do all the work, just make sure that it
gets a MappingCollection*/","-10.                              std::vector<Point<spacedim>> &   support_points,
-9.                              const ComponentMask &            mask)
-8.   {
-7.     AssertDimension(support_points.size(), dof_handler.n_dofs());
-6.     Assert((dynami",Useful
"/*Let the internal function do all the work, just make sure that it
gets a MappingCollection*/","-10.                              std::vector<Point<spacedim>> &   support_points,
-9.                              const ComponentMask &            mask)
-8.   {
-7.     AssertDimension(support_points.size(), dof_handler.n_dofs());
-6.     Assert((dynami",Useful
/*convert to map point -> list of DoFs*/,"-10.   void
-9.   write_gnuplot_dof_support_point_info(
-8.     std::ostream &                                            out,
-7.     const std::map<types::global_dof_index, Point<spacedim>> &support_points)
-6.   {
-5.     AssertThrow(out.fail() == fals",Useful
/*print the newly created map:*/,"-5.     for (const auto &it : support_points)
-4.       {
-3.         std::vector<types::global_dof_index> &v = point_map[it.second];
-2.         v.push_back(it.first);
-1.       }

 /*print the newly created map:*/

1.     for (const auto &it : point_map",Useful
/*Exclude degrees of freedom on faces opposite to the vertex*/,"-10.     const FiniteElement<dim> &fe = dof_handler.get_fe();
-9.     block_list.reinit(1, dof_handler.n_dofs(level), dof_handler.n_dofs(level));
-8.     std::vector<types::global_dof_index> indices;
-7.     std::vector<bool>                    exclude;
-",Useful
"/*For hp, only this line here would have to be replaced.*/","-10.     std::vector<types::global_dof_index> indices;
-9.     std::vector<bool>                    exclude;
-8.     unsigned int block = 0;
-7.     for (const auto &pcell : dof_handler.cell_iterators_on_level(level - 1))
-6.       {
-5.         if (pcell",Useful
"/*Eliminate dofs on faces of the child which are on faces
of the parent*/","-8.             const FiniteElement<dim> &fe     = dof_handler.get_fe();
-7.             const unsigned int        n_dofs = fe.n_dofs_per_cell();
-6.             indices.resize(n_dofs);
-5.             exclude.resize(n_dofs);
-4.             std::fill(exc",Useful
"/*Now remove all degrees of freedom on the domain boundary
from the exclusion list*/","-7.                 for (unsigned int d = 0; d < dim; ++d)
-6.                   {
-5.                     const unsigned int face =
-4.                       GeometryInfo<dim>::vertex_to_face[child][d];
-3.                     for (unsigned int i = 0; i ",Useful
"/*Vector mapping from vertex index in the triangulation to consecutive
block indices on this level The number of cells at a vertex*/","-10.   std::vector<unsigned int>
-9.   make_vertex_patches(SparsityPattern &                block_list,
-8.                       const DoFHandler<dim, spacedim> &dof_handler,
-7.                       const unsigned int               level,
-6.          ",Useful
/*Estimate for the number of dofs at this point*/,"-5.     std::vector<bool> vertex_boundary(
-4.       dof_handler.get_triangulation().n_vertices(), false);
-3.     std::vector<unsigned int> vertex_mapping(
-2.       dof_handler.get_triangulation().n_vertices(),
-1.       numbers::invalid_unsigned_int);
",Useful
"/*Identify all vertices active on this level and remember some data
about them*/","-2.     std::vector<unsigned int> vertex_dof_count(
-1.       dof_handler.get_triangulation().n_vertices(), 0);

 /*Identify all vertices active on this level and remember some data
about them*/

1.     for (const auto &cell : dof_handler.cell_iterators_o",Useful
/*Create a mapping from all vertices to the ones used here*/,"-4.     for (unsigned int vg = 0; vg < vertex_dof_count.size(); ++vg)
-3.       if ((!single_cell_patches && vertex_cell_count[vg] < 2) ||
-2.           (!boundary_patches && vertex_boundary[vg]))
-1.         vertex_dof_count[vg] = 0;

 /*Create a mapping",Useful
"/*Now that we have all the data, we reduce it to the part we actually
want*/","
    block_list.reinit(vertex_dof_count.size(),
                      dof_handler.n_dofs(level),
                      vertex_dof_count);

    std::vector<types::global_dof_index> indices;
    std::vector<bool>                    exclude;

    for (const auto &cell : dof_handler.cell_iterators_on_level(level))
      {
        const FiniteElement<dim> &fe = cell->get_fe();
        indices.resize(fe.n_dofs_per_cell());
        cell->get_mg_dof_indices(indices);

        for (const unsigned int v : cell->vertex_indices())
          {
            const unsigned int vg    = cell->vertex_index(v);
            const unsigned int block = vertex_mapping[vg];
            if (block == numbers::invalid_unsigned_int)
              continue;



 /*Now that we have all the data, we reduce it to the part we actually
want*/

1.         vertex_mapping.resize(n_vertex_count);
2.       }
3.     return vertex_mapping;
4.   }
5.   template <int dim, int spacedim>
6.   unsigned int
7.   count_dofs_on_patch(
8.     const std::vector<typename DoFHandler<dim, spacedim>::active_cell_iterator>
9.       &patch)
10.   {",Useful
"/*At this point, the list of patches is ready. Now we enter the dofs
into the sparsity pattern.*/","-1.     vertex_dof_count.resize(n_vertex_count);

 /*At this point, the list of patches is ready. Now we enter the dofs
into the sparsity pattern.*/

1.     block_list.reinit(vertex_dof_count.size(),
2.                       dof_handler.n_dofs(level),
3. ",Useful
"/*Collect excluded dofs for some block(s) if boundary dofs
for a block are decided to be excluded*/","-10.       {
-9.         const FiniteElement<dim> &fe = cell->get_fe();
-8.         indices.resize(fe.n_dofs_per_cell());
-7.         cell->get_mg_dof_indices(indices);
-6.         for (const unsigned int v : cell->vertex_indices())
-5.           {
-4.   ",Useful
"/*Exclude degrees of freedom on faces opposite to the
vertex*/","if (exclude_boundary_dofs[fe.system_to_block_index(
                                                      fe.face_to_cell_index(
                                                        i, face))
                                                    .first] == true)
                          exclude[fe.face_to_cell_index(i, face)] = true;
                      }
                  }
                for (unsigned int j = 0; j < indices.size(); ++j)
                  if (!exclude[j])
                    block_list.add(block, indices[j]);
              }
            else
              {
                for (const auto index : indices)
                  block_list.add(block, index);
              }
          }
      }

    if (invert_vertex_mapping)
      {

 /*Exclude degrees of freedom on faces opposite to the
vertex*/

1.   }
2.   template <int dim, int spacedim>
3.   unsigned int
4.   count_dofs_on_patch(
5.     const std::vector<typename DoFHandler<dim, spacedim>::active_cell_iterator>
6.       &patch)
7.   {
8.     std::set<types::global_dof_index>    dofs_on_patch;
9.     std::vector<types::global_dof_index> local_dof_indices;",Useful
"/*For each dof, get the block it is in and decide to
exclude it or not*/","-10.                 exclude.resize(fe.n_dofs_per_cell());
-9.                 std::fill(exclude.begin(), exclude.end(), false);
-8.                 for (unsigned int d = 0; d < dim; ++d)
-7.                   {
-6.                     const unsigned int ",Useful
"/*loop over the cells in the patch and get the DoFs on each.
add all of them to a std::set which automatically makes sure
all duplicates are ignored*/","-10.     return vertex_mapping;
-9.   }
-8.   template <int dim, int spacedim>
-7.   unsigned int
-6.   count_dofs_on_patch(
-5.     const std::vector<typename DoFHandler<dim, spacedim>::active_cell_iterator>
-4.       &patch)
-3.   {
-2.     std::set<typ",Useful
"/*loop over the cells in the patch and get the DoFs on each.
add all of them to a std::set which automatically makes sure
all duplicates are ignored*/","-10.     return vertex_mapping;
-9.   }
-8.   template <int dim, int spacedim>
-7.   unsigned int
-6.   count_dofs_on_patch(
-5.     const std::vector<typename DoFHandler<dim, spacedim>::active_cell_iterator>
-4.       &patch)
-3.   {
-2.     std::set<typ",Useful
"/*return a vector with the content of the set above. copying
also ensures that we retain sortedness as promised in the
documentation and as necessary to retain the block structure
also on the local system*/","-10.         Assert(cell->is_artificial() == false,
-9.                ExcMessage(""This function can not be called with cells that are ""
-8.                           ""not either locally owned or ghost cells.""));
-7.         local_dof_indices.resize(cell-",Useful
"/*Following command-line options are actually handled by xtrabackup.
	We put them here with only purpose for them to showup in
	innobackupex --help output*/","-10. 	 ""--ftwrl-wait-timeout is 0. Default value is 60 seconds."",
-9. 	 (uchar*) &opt_ibx_lock_wait_threshold,
-8. 	 (uchar*) &opt_ibx_lock_wait_threshold, 0, GET_UINT,
-7. 	 REQUIRED_ARG, 60, 0, 0, 0, 0, 0},
-6. 	{""safe-slave-backup-timeout"", OPT_SAFE_SL",Useful
/*find and save position argument*/,"-10. 		ibx_mode = IBX_MODE_APPLY_LOG;
-9. 	} else if (opt_ibx_copy_back) {
-8. 		ibx_mode = IBX_MODE_COPY_BACK;
-7. 	} else if (opt_ibx_move_back) {
-6. 		ibx_mode = IBX_MODE_MOVE_BACK;
-5. 	} else if (opt_ibx_decompress) {
-4. 		ibx_mode = IBX_MODE_DECRY",Useful
"/**
Parse command-line options, connect to MySQL server,
detect server capabilities, etc.
@return	true on success.*/","-10. 		return(false);
-9. 	}
-8. 	/* set argv[0] to be the program name */
-7. 	--(*argv);
-6. 	++(*argc);
-5. 	return(true);
-4. }
-3. /*********************************************************************//**
-2. Parse command-line options, connect to M",Useful
"/*Need the following definitions to avoid linking with ds_*.o and their link
dependencies*/","-10. #include ""xbstream.h""
-9. #include ""datasink.h""
-8. #define XBSTREAM_VERSION ""1.0""
-7. #define XBSTREAM_BUFFER_SIZE (10 * 1024 * 1024UL)
-6. #define START_FILE_HASH_SIZE 16
-5. typedef enum {
-4. 	RUN_MODE_NONE,
-3. 	RUN_MODE_CREATE,
-2. 	RUN_MODE_EX",Useful
/*Change the current directory if -C is specified*/,"-10. main(int argc, char **argv)
-9. {
-8. 	MY_INIT(argv[0]);
-7. 	if (get_options(&argc, &argv)) {
-6. 		goto err;
-5. 	}
-4. 	if (opt_mode == RUN_MODE_NONE) {
-3. 		msg(""%s: either -c or -x must be specified."", my_progname);
-2. 		goto err;
-1. 	}

 /*C",Useful
/*Create and initialize the worker threads*/,"-10. static comp_thread_ctxt_t *create_worker_threads(uint n);
-9. static void destroy_worker_threads(comp_thread_ctxt_t *threads, uint n);
-8. static void *compress_worker_thread_func(void *arg);
-7. static
-6. ds_ctxt_t *
-5. compress_init(const char *r",Useful
"/*We are going to create a one-file ""flat"" (i.e. with no
	subdirectories) archive. So strip the directory part from the path and
	remove the '.qp' suffix.*/","-4. 	if (ds_write(dest_file, ""qpress10"", 8) ||
-3. 	    write_uint64_le(dest_file, COMPRESS_CHUNK_SIZE)) {
-2. 		goto err;
-1. 	}

 /*We are going to create a one-file ""flat"" (i.e. with no
	subdirectories) archive. So strip the directory part from the pat",Useful
/*Send data to worker threads for compression*/,"-10. 	const char		*ptr;
-9. 	ds_file_t		*dest_file;
-8. 	comp_file = (ds_compress_file_t *) file->ptr;
-7. 	comp_ctxt = comp_file->comp_ctxt;
-6. 	dest_file = comp_file->dest_file;
-5. 	threads = comp_ctxt->threads;
-4. 	nthreads = comp_ctxt->nthreads;
-3",Useful
"/*Supposedly the number of written bytes should be written as a
	""recovery information"" in the file trailer, but in reality qpress
	always writes 8 zeros here. Let's do the same*/","-1. 	ds_write(dest_file, ""ENDSENDS"", 8);

 /*Supposedly the number of written bytes should be written as a
	""recovery information"" in the file trailer, but in reality qpress
	always writes 8 zeros here. Let's do the same*/

1. 	write_uint64_le(dest_file, ",Useful
"/*qpress uses 0x00010000 as the initial value, but its own
		Adler-32 implementation treats the value differently:
		  1. higher order bits are the sum of all bytes in the sequence
		  2. lower order bits are the sum of resulting values at every
		     step.
		So it's the other way around as compared to zlib's adler32().
		That's why  0x00000001 is being passed here to be compatible
		with qpress implementation.*/","-10. 	while (1) {
-9. 		thd->data_avail = FALSE;
-8. 		pthread_cond_signal(&thd->data_cond);
-7. 		while (!thd->data_avail && !thd->cancelled) {
-6. 			pthread_cond_wait(&thd->data_cond, &thd->data_mutex);
-5. 		}
-4. 		if (thd->cancelled)
-3. 			break;
-",Useful
"/*The goal is to make the implementation transparent, so that you
   don't have to know what data types are used, just what functions
   you can call.  I think I have done that.*/","-10.    the Free Software Foundation; either version 2, or (at your option)
-9.    any later version.
-8.    The Library is distributed in the hope that it will be useful, but
-7.    WITHOUT ANY WARRANTY; without even the implied warranty of
-6.    MERCHA",Useful
/*The current number of slots allocated to the input_history.*/,"-4. static HIST_ENTRY **the_history = (HIST_ENTRY **)NULL;

 /*The current number of slots allocated to the input_history.*/

1. static int history_size;",Useful
"/*If HISTORY_STIFLED is non-zero, then this is the maximum number of
   entries to remember.*/","-1. static int history_size;

 /*If HISTORY_STIFLED is non-zero, then this is the maximum number of
   entries to remember.*/

1. int history_max_entries;",Useful
"/*The current location of the interactive history pointer.  Just makes
   life easier for outside callers.*/","-2. int history_max_entries;

 /*The current location of the interactive history pointer.  Just makes
   life easier for outside callers.*/

1. int history_offset;",Useful
/*The number of strings currently stored in the history list.*/,"-1. int history_offset;

 /*The number of strings currently stored in the history list.*/

1. int history_length;",Useful
/*The logical `base' of the history array.  It defaults to 1.*/,"-1. int history_length;

 /*The logical `base' of the history array.  It defaults to 1.*/

1. int history_base = 1;",Useful
/*Set the state of the current history array to STATE.*/,"-10.   state = (HISTORY_STATE *)xmalloc (sizeof (HISTORY_STATE));
-9.   state->entries = the_history;
-8.   state->offset = history_offset;
-7.   state->length = history_length;
-6.   state->size = history_size;
-5.   state->flags = 0;
-4.   if (history_s",Useful
"/*Begin a session in which the history functions might be used.  This
   initializes interactive variables.*/","-10. history_set_history_state (state)
-9.      HISTORY_STATE *state;
-8. {
-7.   the_history = state->entries;
-6.   history_offset = state->offset;
-5.   history_length = state->length;
-4.   history_size = state->size;
-3.   if (state->flags & HS_STIFL",Useful
"/*Return the number of bytes that the primary history entries are using.
   This just adds up the lengths of the_history->lines and the associated
   timestamps.*/","-5. void
-4. using_history ()
-3. {
-2.   history_offset = history_length;
-1. }

 /*Return the number of bytes that the primary history entries are using.
   This just adds up the lengths of the_history->lines and the associated
   timestamps.*/

1. int
",Useful
"/*Returns the magic number which says what history element we are
   looking at now.  In this implementation, it returns history_offset.*/","-10.    This just adds up the lengths of the_history->lines and the associated
-9.    timestamps. */
-8. int
-7. history_total_bytes ()
-6. {
-5.   register int i, result;
-4.   for (i = result = 0; the_history && the_history[i]; i++)
-3.     result += HI",Useful
"/*Make the current history item be the one at POS, an absolute index.
   Returns zero if POS is out of range, else non-zero.*/","-5. int
-4. where_history ()
-3. {
-2.   return (history_offset);
-1. }

 /*Make the current history item be the one at POS, an absolute index.
   Returns zero if POS is out of range, else non-zero.*/

1. int
2. history_set_pos (pos)
3.      int pos;
4. {",Useful
"/*Return the current history array.  The caller has to be carefull, since this
   is the actual array of data, and could be bashed or made corrupt easily.
   The array is terminated with a NULL pointer.*/","-10.    Returns zero if POS is out of range, else non-zero. */
-9. int
-8. history_set_pos (pos)
-7.      int pos;
-6. {
-5.   if (pos > history_length || pos < 0 || !the_history)
-4.     return (0);
-3.   history_offset = pos;
-2.   return (1);
-1. }

 /",Useful
"/*Return the history entry at the current position, as determined by
   history_offset.  If there is no entry there, return a NULL pointer.*/","-5. HIST_ENTRY **
-4. history_list ()
-3. {
-2.   return (the_history);
-1. }

 /*Return the history entry at the current position, as determined by
   history_offset.  If there is no entry there, return a NULL pointer.*/

1. HIST_ENTRY *
2. current_histo",Useful
"/*Back up history_offset to the previous history entry, and return
   a pointer to that entry.  If there is no previous entry then return
   a NULL pointer.*/","-7. HIST_ENTRY *
-6. current_history ()
-5. {
-4.   return ((history_offset == history_length) || the_history == 0)
-3. 		? (HIST_ENTRY *)NULL
-2. 		: the_history[history_offset];
-1. }

 /*Back up history_offset to the previous history entry, and return
",Useful
"/*Move history_offset forward to the next history entry, and return
   a pointer to that entry.  If there is no next entry then return a
   NULL pointer.*/","-5. HIST_ENTRY *
-4. previous_history ()
-3. {
-2.   return history_offset ? the_history[--history_offset] : (HIST_ENTRY *)NULL;
-1. }

 /*Move history_offset forward to the next history entry, and return
   a pointer to that entry.  If there is no next e",Useful
"/*Return the history entry which is logically at OFFSET in the history array.
   OFFSET is relative to history_base.*/","-5. HIST_ENTRY *
-4. next_history ()
-3. {
-2.   return (history_offset == history_length) ? (HIST_ENTRY *)NULL : the_history[++history_offset];
-1. }

 /*Return the history entry which is logically at OFFSET in the history array.
   OFFSET is relative to",Useful
"/*Place STRING at the end of the history list.  The data field
   is  set to NULL.*/","-8.   snprintf (ts, sizeof (ts) - 1, ""X%lu"", (unsigned long) t);
-7. #else
-6.   sprintf (ts, ""X%lu"", (unsigned long) t);
-5. #endif
-4.   ret = savestring (ts);
-3.   ret[0] = history_comment_char;
-2.   return ret;
-1. }

 /*Place STRING at the end of t",Useful
"/*If the history is stifled, and history_length is zero,
	 and it equals history_max_entries, we don't save items.*/","-8. void
-7. add_history (string)
-6.      const char *string;
-5. {
-4.   HIST_ENTRY *temp;
-3.   if (history_stifled && (history_length == history_max_entries))
-2.     {
-1.       register int i;

 /*If the history is stifled, and history_length is zer",Useful
"/*If there is something in the slot, then remove it.*/","-2.       if (history_length == 0)
-1. 	return;

 /*If there is something in the slot, then remove it.*/

1.       if (the_history[0])
2. 	(void) free_history_entry (the_history[0]);",Useful
/*Change the time stamp of the most recent history entry to STRING.*/,"-10. 	      the_history = (HIST_ENTRY **)
-9. 		xrealloc (the_history, history_size * sizeof (HIST_ENTRY *));
-8. 	    }
-7. 	  history_length++;
-6. 	}
-5.     }
-4.   temp = alloc_history_entry ((char*) string, hist_inittime ());
-3.   the_history[histo",Useful
"/*Free HIST and return the data so the calling application can free it
   if necessary and desired.*/","-9. void
-8. add_history_time (string)
-7.      const char *string;
-6. {
-5.   HIST_ENTRY *hs;
-4.   hs = the_history[history_length - 1];
-3.   FREE (hs->timestamp);
-2.   hs->timestamp = savestring (string);
-1. }

 /*Free HIST and return the data so t",Useful
"/*Make the history entry at WHICH have LINE and DATA.  This returns
   the old entry so you can dispose of the data.  In the case of an
   invalid WHICH, a NULL pointer is returned.*/","-10.   HIST_ENTRY *ret;
-9.   char *ts;
-8.   if (hist == 0)
-7.     return hist;
-6.   ret = alloc_history_entry (hist->line, (char *)NULL);
-5.   ts = hist->timestamp ? savestring (hist->timestamp) : hist->timestamp;
-4.   ret->timestamp = ts;
-3.   ret",Useful
"/*Replace the DATA in the specified history entries, replacing OLD with
   NEW.  WHICH says which one(s) to replace:  WHICH == -1 means to replace
   all of the history entries where entry->data == OLD; WHICH == -2 means
   to replace the `newest' history entry where entry->data == OLD; and
   WHICH >= 0 means to replace that particular history entry's data, as
   long as it matches OLD.*/","-10.   if (which < 0 || which >= history_length)
-9.     return ((HIST_ENTRY *)NULL);
-8.   temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
-7.   old_value = the_history[which];
-6.   temp->line = savestring (line);
-5.   temp->data = data;
-4.   temp",Useful
"/*Remove history element WHICH from the history.  The removed
   element is returned to you so you can free the line, data,
   and containing structure.*/","-2.     }
-1. }

 /*Remove history element WHICH from the history.  The removed
   element is returned to you so you can free the line, data,
   and containing structure.*/

1. HIST_ENTRY *
2. remove_history (which)
3.      int which;
4. {
5.   HIST_ENTRY",Useful
"/*Stifle the history list, remembering only MAX number of lines.*/","-10.   HIST_ENTRY *return_value;
-9.   register int i;
-8.   if (which < 0 || which >= history_length || history_length ==  0 || the_history == 0)
-7.     return ((HIST_ENTRY *)NULL);
-6.   return_value = the_history[which];
-5.   for (i = which; i < hist",Useful
"/*Stop stifling the history.  This returns the previous maximum
   number of history entries.  The value is positive if the history
   was stifled,  negative if it wasn't.*/","-10. 	free_history_entry (the_history[i]);
-9.       history_base = i;
-8.       for (j = 0, i = history_length - max; j < max; i++, j++)
-7. 	the_history[j] = the_history[i];
-6.       the_history[j] = (HIST_ENTRY *)NULL;
-5.       history_length = j;
-4",Useful
"/*Backwards compatibility, now that savestring has been removed from
   all `public' readline header files.*/","-10.    The GNU General Public License is often shipped with GNU software, and
-9.    is generally kept in a file called COPYING or LICENSE.  If you do not
-8.    have a copy of the license, write to the Free Software Foundation,
-7.    51 Franklin Street",Useful
"/*The list of alternate characters that can delimit a history search
   string.*/","-8. #if defined (HAVE_UNISTD_H)
-7. #  ifdef _MINIX
-6. #    include <sys/types.h>
-5. #  endif
-4. #  include <unistd.h>
-3. #endif
-2. #include ""history.h""
-1. #include ""histlib.h""

 /*The list of alternate characters that can delimit a history search
 ",Useful
"/*Search the history for STRING, starting at history_offset.
   If DIRECTION < 0, then the search is through previous entries, else
   through subsequent.  If ANCHORED is non-zero, the string must
   appear at the beginning of a history line, otherwise, the string
   may appear anywhere in the line.  If the string is found, then
   current_history () is the history entry, and the value of this
   function is the offset in the line of that history entry that the
   string was found in.  Otherwise, nothing is changed, and a -1 is
   returned.*/","-2. char *history_search_delimiter_chars = (char *)NULL;
-1. static int history_search_internal PARAMS((const char *, int, int));

 /*Search the history for STRING, starting at history_offset.
   If DIRECTION < 0, then the search is through previous entri",Useful
/*Take care of trivial cases first.*/,"-2.   i = history_offset;
-1.   reverse = (direction < 0);

 /*Take care of trivial cases first.*/

1.   if (string == 0 || *string == '\0')
2.     return (-1);
3.   if (!history_length || ((i >= history_length) && !reverse))
4.     return (-1);
5.   if (",Useful
/*Search each line in the history list for STRING.*/,"-10.     return (-1);
-9.   if (!history_length || ((i >= history_length) && !reverse))
-8.     return (-1);
-7.   if (reverse && (i >= history_length))
-6.     i = history_length - 1;
-5. #define NEXT_LINE() do { if (reverse) i--; else i++; } while (0)
-",Useful
"/*If STRING is longer than line, no match.*/","-4.       if ((reverse && i < 0) || (!reverse && i == history_length))
-3. 	return (-1);
-2.       line = the_history[i]->line;
-1.       line_index = strlen (line);

 /*If STRING is longer than line, no match.*/

1.       if (string_len > line_index)
2. ",Useful
/*Handle anchored searches first.*/,"-5.       if (string_len > line_index)
-4. 	{
-3. 	  NEXT_LINE ();
-2. 	  continue;
-1. 	}

 /*Handle anchored searches first.*/

1.       if (anchored == ANCHORED_SEARCH)
2. 	{
3. 	  if (STREQN (string, line, string_len))
4. 	    {
5. 	      history_offs",Useful
/*Do substring search.*/,"-10.       if (anchored == ANCHORED_SEARCH)
-9. 	{
-8. 	  if (STREQN (string, line, string_len))
-7. 	    {
-6. 	      history_offset = i;
-5. 	      return (0);
-4. 	    }
-3. 	  NEXT_LINE ();
-2. 	  continue;
-1. 	}

 /*Do substring search.*/

1.       ",Useful
/*Do a non-anchored search for STRING through the history in DIRECTION.*/,"-10. 		{
-9. 		  history_offset = i;
-8. 		  return (line_index);
-7. 		}
-6. 	      line_index++;
-5. 	    }
-4. 	}
-3.       NEXT_LINE ();
-2.     }
-1. }

 /*Do a non-anchored search for STRING through the history in DIRECTION.*/

1. int
2. history_sea",Useful
/*Do an anchored search for string through the history in DIRECTION.*/,"-7. int
-6. history_search (string, direction)
-5.      const char *string;
-4.      int direction;
-3. {
-2.   return (history_search_internal (string, direction, NON_ANCHORED_SEARCH));
-1. }

 /*Do an anchored search for string through the history in DI",Useful
"/*Search for STRING in the history list.  DIR is < 0 for searching
   backwards.  POS is an absolute index into the history list at
   which point to begin searching.*/","-7. int
-6. history_search_prefix (string, direction)
-5.      const char *string;
-4.      int direction;
-3. {
-2.   return (history_search_internal (string, direction, ANCHORED_SEARCH));
-1. }

 /*Search for STRING in the history list.  DIR is < 0 for ",Useful
"/*The default value of tilde_additional_prefixes.  This is set to
   whitespace preceding a tilde so that simple programs which do not
   perform any word separation get desired behaviour.*/","-2. extern char *sh_get_home_dir PARAMS((void));
-1. extern char *sh_get_env_value PARAMS((const char *));

 /*The default value of tilde_additional_prefixes.  This is set to
   whitespace preceding a tilde so that simple programs which do not
   perform ",Useful
"/*The default value of tilde_additional_suffixes.  This is set to
   whitespace or newline so that simple programs which do not
   perform any word separation get desired behaviour.*/","-2. static const char *default_prefixes[] =
-1.   { "" ~"", ""\t~"", (const char *)NULL };

 /*The default value of tilde_additional_suffixes.  This is set to
   whitespace or newline so that simple programs which do not
   perform any word separation get des",Useful
"/*If non-null, this contains the address of a function that the application
   wants called before trying the standard tilde expansions.  The function
   is called with the text sans tilde, and returns a malloc()'ed string
   which is the expansion, or a NULL pointer if the expansion fails.*/","-2. static const char *default_suffixes[] =
-1.   { "" "", ""\n"", (const char *)NULL };

 /*If non-null, this contains the address of a function that the application
   wants called before trying the standard tilde expansions.  The function
   is called with",Useful
"/*If non-null, this contains the address of a function to call if the
   standard meaning for expanding a tilde fails.  The function is called
   with the text (sans tilde, as in ""foo""), and returns a malloc()'ed string
   which is the expansion, or a NULL pointer if there is no expansion.*/","-1. tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;

 /*If non-null, this contains the address of a function to call if the
   standard meaning for expanding a tilde fails.  The function is called
   with the text (sans t",Useful
"/*When non-null, this is a NULL terminated array of strings which
   are duplicates for a tilde prefix.  Bash uses this to expand
   `=~' and `:~'.*/","-1. tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;

 /*When non-null, this is a NULL terminated array of strings which
   are duplicates for a tilde prefix.  Bash uses this to expand
   `=~' and `:~'.*/

1. char **tilde_addit",Useful
"/*When non-null, this is a NULL terminated array of strings which match
   the end of a username, instead of just ""/"".  Bash sets this to
   `:' and `=~'.*/","-1. char **tilde_additional_prefixes = (char **)default_prefixes;

 /*When non-null, this is a NULL terminated array of strings which match
   the end of a username, instead of just ""/"".  Bash sets this to
   `:' and `=~'.*/

1. char **tilde_additional_su",Useful
"/*Find the start of a tilde expansion in STRING, and return the index of
   the tilde which starts the expansion.  Place the length of the text
   which identified this tilde starter in LEN, excluding the tilde itself.*/","-5. char **tilde_additional_suffixes = (char **)default_suffixes;
-4. static int tilde_find_prefix PARAMS((const char *, int *));
-3. static int tilde_find_suffix PARAMS((const char *));
-2. static char *isolate_tilde_prefix PARAMS((const char *, int *));",Useful
"/*Find the end of a tilde expansion in STRING, and return the index of
   the character which ends the tilde definition.*/","-10. 	      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
-9. 		{
-8. 		  *len = strlen (prefixes[j]) - 1;
-7. 		  return (i + *len);
-6. 		}
-5. 	    }
-4. 	}
-3.     }
-2.   return (string_len);
-1. }

 /*Find the end of a tilde expa",Useful
/*Return a new string which is the result of tilde expanding STRING.*/,"-10. #endif
-9. 	break;
-8.       for (j = 0; suffixes && suffixes[j]; j++)
-7. 	{
-6. 	  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
-5. 	    return (i);
-4. 	}
-3.     }
-2.   return (i);
-1. }

 /*Return a new string which is the ",Useful
/*Make START point to the tilde which starts the expansion.*/,"-5.   while (1)
-4.     {
-3.       register int start, end;
-2.       char *tilde_word, *expansion;
-1.       int len;

 /*Make START point to the tilde which starts the expansion.*/

1.       start = tilde_find_prefix (string, &len);",Useful
/*Copy the skipped text into the result.*/,"-1.       start = tilde_find_prefix (string, &len);

 /*Copy the skipped text into the result.*/

1.       if ((result_index + start + 1) > result_size)
2. 	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));
3.       strncpy (result + ",Useful
"/*Make END be the index of one after the last character of the
	 username.*/","-1.       string += start;

 /*Make END be the index of one after the last character of the
	 username.*/

1.       end = tilde_find_suffix (string);",Useful
"/*If both START and END are zero, we are all done.*/","-1.       end = tilde_find_suffix (string);

 /*If both START and END are zero, we are all done.*/

1.       if (!start && !end)
2. 	break;",Useful
"/*Expand the entire tilde word, and copy it into RESULT.*/","-2.       if (!start && !end)
-1. 	break;

 /*Expand the entire tilde word, and copy it into RESULT.*/

1.       tilde_word = (char *)xmalloc (1 + end);
2.       strncpy (tilde_word, string, end);
3.       tilde_word[end] = '\0';
4.       string += end;
5",Useful
"/*Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
	 $HOME for `user' is /.  On cygwin, // denotes a network drive.*/","-8.       tilde_word = (char *)xmalloc (1 + end);
-7.       strncpy (tilde_word, string, end);
-6.       tilde_word[end] = '\0';
-5.       string += end;
-4.       expansion = tilde_expand_word (tilde_word);
-3.       free (tilde_word);
-2.       len = st",Useful
"/*Take FNAME and return the tilde prefix we want expanded.  If LENP is
   non-null, the index of the end of the prefix into FNAME is returned in
   the location it points to.*/","-10. 	  if ((result_index + len + 1) > result_size)
-9. 	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));
-8. 	  strcpy (result + result_index, expansion);
-7. 	  result_index += len;
-6. 	}
-5.       free (expansion);
-4.     }
-3",Useful
"/*Public function to scan a string (FNAME) beginning with a tilde and find
   the portion of the string that should be passed to the tilde expansion
   function.  Right now, it just calls tilde_find_suffix and allocates new
   memory, but it can be expanded to do different things later.*/","-10. #else
-9.   for (i = 1; fname[i] && fname[i] != '/'; i++)
-8. #endif
-7.     ret[i - 1] = fname[i];
-6.   ret[i - 1] = '\0';
-5.   if (lenp)
-4.     *lenp = i;
-3.   return ret;
-2. }
-1. #if 0

 /*Public function to scan a string (FNAME) beginning w",Useful
"/*Return a string that is PREFIX concatenated with SUFFIX starting at
   SUFFIND.*/","-10.     {
-9.       r = (char *)xmalloc (1 + x);
-8.       strncpy (r, fname, x);
-7.       r[x] = '\0';
-6.       if (lenp)
-5. 	*lenp = x;
-4.     }
-3.   return r;
-2. }
-1. #endif

 /*Return a string that is PREFIX concatenated with SUFFIX starting a",Useful
"/*Do the work of tilde expansion on FILENAME.  FILENAME starts with a
   tilde.  If there is no expansion, call tilde_expansion_failure_hook.
   This always returns a newly-allocated string, never static storage.*/","-10.   char *ret;
-9.   int plen, slen;
-8.   plen = (prefix && *prefix) ? strlen (prefix) : 0;
-7.   slen = strlen (suffix + suffind);
-6.   ret = (char *)xmalloc (plen + slen + 1);
-5.   if (plen)
-4.     strcpy (ret, prefix);
-3.   strcpy (ret + plen, ",Useful
"/*A leading `~/' or a bare `~' is *always* translated to the value of
     $HOME or the home directory of the current user, regardless of any
     preexpansion hook.*/","-10. tilde_expand_word (filename)
-9.      const char *filename;
-8. {
-7.   char *dirname, *expansion, *username;
-6.   int user_len;
-5.   struct passwd *user_entry;
-4.   if (filename == 0)
-3.     return ((char *)NULL);
-2.   if (*filename != '~')
-1.",Useful
"/*If the calling program has a special syntax for expanding tildes,
	 and we couldn't find a standard expansion, then let them try.*/","-8.   dirname = (char *)NULL;
-7. #if defined (HAVE_GETPWNAM)
-6.   user_entry = getpwnam (username);
-5. #else
-4.   user_entry = 0;
-3. #endif
-2.   if (user_entry == 0)
-1.     {

 /*If the calling program has a special syntax for expanding tildes,
	 a",Useful
"/*If we don't have a failure hook, or if the failure hook did not
	 expand the tilde, return a copy of what we were passed.*/","-10. 	 and we couldn't find a standard expansion, then let them try. */
-9.       if (tilde_expansion_failure_hook)
-8. 	{
-7. 	  expansion = (*tilde_expansion_failure_hook) (username);
-6. 	  if (expansion)
-5. 	    {
-4. 	      dirname = glue_prefix_and",Useful
"/** Local variables:
 * compile-command: ""gcc -g -DTEST -o tilde tilde.c""
 * end:*/","-10.     memory_error_and_abort ();
-9.   return (temp);
-8. }
-7. static void
-6. memory_error_and_abort ()
-5. {
-4.   fprintf (stderr, ""readline: out of virtual memory\n"");
-3.   abort ();
-2. }
-1. /*
 * Local variables:
 * compile-command: ""gcc -g -D",Useful
"/************************************************************************
Initialize incremental page write filter.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
/*allocate buffer for incremental backup (4096 pages)*/,"-10. Initialize incremental page write filter.
-9. @return TRUE on success, FALSE on error. */
-8. static my_bool
-7. wf_incremental_init(xb_write_filt_ctxt_t *ctxt, char *dst_name,
-6. 		    xb_fil_cur_t *cursor, CorruptedPages *corrupted_pages)
-5. {
-4",Useful
"/*change the target file name, since we are only going to write
	delta pages*/","-10. 	snprintf(meta_name, sizeof(meta_name), ""%s%s"", dst_name,
-9. 		 XB_DELTA_INFO_SUFFIX);
-8. 	const xb_delta_info_t	info(cursor->page_size, cursor->zip_size,
-7. 				     cursor->space_id);
-6. 	if (!xb_write_delta_metadata(meta_name, &info)) {
-5. 		",Useful
"/************************************************************************
Run the next batch of pages through incremental page write filter.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
"/************************************************************************
Flush the incremental page write filter's buffer.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
"/************************************************************************
Free the incremental page write filter's buffer.*/","-5. 	if (ds_write(dstfile, cp->delta_buf, cp->npages * page_size)) {
-4. 		return(FALSE);
-3. 	}
-2. 	return(TRUE);
-1. }

 /************************************************************************
Free the incremental page write filter's buffer.*/

1. st",Useful
"/************************************************************************
Initialize the write-through page write filter.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
"/************************************************************************
Write the next batch of pages to the destination datasink.

@return TRUE on success, FALSE on error.*/","-10. 				      ds_file_t *dstfile);
-9. static my_bool wf_incremental_finalize(xb_write_filt_ctxt_t *ctxt,
-8. 				       ds_file_t *dstfile);
-7. static void wf_incremental_deinit(xb_write_filt_ctxt_t *ctxt);
-6. xb_write_filt_t wf_incremental = {
-5. 	&",Useful
"/*readline.c -- a general facility for reading lines of input
   with emacs style editing and completion.*/","
/* readline.c -- a general facility for reading lines of input
   with emacs style editing and completion. */


 /*readline.c -- a general facility for reading lines of input
   with emacs style editing and completion.*/

1. /* Copyright (C) 1987-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
/*True if this is `real' readline as opposed to some stub substitute.*/,"-2. const char *rl_library_version = RL_LIBRARY_VERSION;
-1. int rl_readline_version = RL_READLINE_VERSION;

 /*True if this is `real' readline as opposed to some stub substitute.*/

1. int rl_gnu_readline_p = 1;",Useful
"/*A pointer to the keymap that is currently in use.
   By default, it is the standard emacs keymap.*/","-1. int rl_gnu_readline_p = 1;

 /*A pointer to the keymap that is currently in use.
   By default, it is the standard emacs keymap.*/

1. Keymap _rl_keymap = emacs_standard_keymap;",Useful
/*The current insert mode:  input (the default) or overwrite*/,"-1. int rl_editing_mode = emacs_mode;

 /*The current insert mode:  input (the default) or overwrite*/

1. int rl_insert_mode = RL_IM_DEFAULT;",Useful
"/*Non-zero if we called this function from _rl_dispatch().  It's present
   so functions can find out whether they were called from a key binding
   or directly from an application.*/","-1. int rl_insert_mode = RL_IM_DEFAULT;

 /*Non-zero if we called this function from _rl_dispatch().  It's present
   so functions can find out whether they were called from a key binding
   or directly from an application.*/

1. int rl_dispatching;",Useful
/*Non-zero if the previous command was a kill command.*/,"-1. int rl_dispatching;

 /*Non-zero if the previous command was a kill command.*/

1. int _rl_last_command_was_kill = 0;",Useful
/*The current value of the numeric argument specified by the user.*/,"-1. int _rl_last_command_was_kill = 0;

 /*The current value of the numeric argument specified by the user.*/

1. int rl_numeric_arg = 1;",Useful
/*Non-zero if an argument was typed.*/,"-1. int rl_numeric_arg = 1;

 /*Non-zero if an argument was typed.*/

1. int rl_explicit_arg = 0;",Useful
/*Temporary value used while generating the argument.*/,"-1. int rl_explicit_arg = 0;

 /*Temporary value used while generating the argument.*/

1. int rl_arg_sign = 1;",Useful
"/*If non-zero, this program is running in an EMACS buffer.*/","-2. static int rl_initialized;
-1. #if 0

 /*If non-zero, this program is running in an EMACS buffer.*/

1. static int running_in_emacs;
2. #endif",Useful
/*Flags word encapsulating the current readline state.*/,"-2. static int running_in_emacs;
-1. #endif

 /*Flags word encapsulating the current readline state.*/

1. int rl_readline_state = RL_STATE_NONE;",Useful
/*The current offset in the current input line.*/,"-1. int rl_readline_state = RL_STATE_NONE;

 /*The current offset in the current input line.*/

1. int rl_point;",Useful
/*Length of the current input line.*/,"-1. int rl_mark;

 /*Length of the current input line.*/

1. int rl_end;",Useful
/*Make this non-zero to return the current input_line.*/,"-1. int rl_end;

 /*Make this non-zero to return the current input_line.*/

1. int rl_done;",Useful
/*Top level environment for readline_internal ().*/,"-1. rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;

 /*Top level environment for readline_internal ().*/

1. procenv_t readline_top_level;",Useful
/*The names of the streams that we do input and output to.*/,"-1. FILE *_rl_in_stream, *_rl_out_stream;

 /*The names of the streams that we do input and output to.*/

1. FILE *rl_instream = (FILE *)NULL;
2. FILE *rl_outstream = (FILE *)NULL;",Useful
"/*Non-zero means echo characters as they are read.  Defaults to no echo;
   set to 1 if there is a controlling terminal, we can get its attributes,
   and the attributes include `echo'.  Look at rltty.c:prepare_terminal_settings
   for the code that sets it.*/","-2. FILE *rl_instream = (FILE *)NULL;
-1. FILE *rl_outstream = (FILE *)NULL;

 /*Non-zero means echo characters as they are read.  Defaults to no echo;
   set to 1 if there is a controlling terminal, we can get its attributes,
   and the attributes includ",Useful
"/*Set to non-zero by calling application if it has already printed rl_prompt
   and does not want readline to do it the first time.*/","-2. char *rl_prompt = (char *)NULL;
-1. int rl_visible_prompt_length = 0;

 /*Set to non-zero by calling application if it has already printed rl_prompt
   and does not want readline to do it the first time.*/

1. int rl_already_prompted = 0;",Useful
/*The number of characters read in order to type this complete command.*/,"-1. int rl_already_prompted = 0;

 /*The number of characters read in order to type this complete command.*/

1. int rl_key_sequence_length = 0;",Useful
"/*If non-zero, then this is the address of a function to call just
   before readline_internal_setup () prints the first prompt.*/","-1. int rl_key_sequence_length = 0;

 /*If non-zero, then this is the address of a function to call just
   before readline_internal_setup () prints the first prompt.*/

1. rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;",Useful
"/*If non-zero, this is the address of a function to call just before
   readline_internal_setup () returns and readline_internal starts
   reading input characters.*/","-1. rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;

 /*If non-zero, this is the address of a function to call just before
   readline_internal_setup () returns and readline_internal starts
   reading input characters.*/

1. rl_hook_func_t *rl_p",Useful
"/*The character that can generate an EOF.  Really read from
   the terminal driver... just defaulted here.*/","-1. static char *the_line;

 /*The character that can generate an EOF.  Really read from
   the terminal driver... just defaulted here.*/

1. int _rl_eof_char = CTRL ('D');",Useful
/*Non-zero makes this the next keystroke to read.*/,"-1. int _rl_eof_char = CTRL ('D');

 /*Non-zero makes this the next keystroke to read.*/

1. int rl_pending_input = 0;",Useful
/*Pointer to a useful terminal name.*/,"-1. int rl_pending_input = 0;

 /*Pointer to a useful terminal name.*/

1. const char *rl_terminal_name = (const char *)NULL;",Useful
/*Non-zero means to always use horizontal scrolling in line display.*/,"-1. const char *rl_terminal_name = (const char *)NULL;

 /*Non-zero means to always use horizontal scrolling in line display.*/

1. int _rl_horizontal_scroll_mode = 0;",Useful
"/*Non-zero means to display an asterisk at the starts of history lines
   which have been modified.*/","-1. int _rl_horizontal_scroll_mode = 0;

 /*Non-zero means to display an asterisk at the starts of history lines
   which have been modified.*/

1. int _rl_mark_modified_lines = 0;",Useful
"/*The style of `bell' notification preferred.  This can be set to NO_BELL,
   AUDIBLE_BELL, or VISIBLE_BELL.*/","-1. int _rl_mark_modified_lines = 0;

 /*The style of `bell' notification preferred.  This can be set to NO_BELL,
   AUDIBLE_BELL, or VISIBLE_BELL.*/

1. int _rl_bell_preference = AUDIBLE_BELL;",Useful
"/*Non-zero means to erase entire line, including prompt, on empty input lines.*/","-1. Keymap _rl_dispatching_keymap;

 /*Non-zero means to erase entire line, including prompt, on empty input lines.*/

1. int rl_erase_empty_line = 0;",Useful
"/*Non-zero means to read only this many characters rather than up to a
   character bound to accept-line.*/","-1. int rl_erase_empty_line = 0;

 /*Non-zero means to read only this many characters rather than up to a
   character bound to accept-line.*/

1. int rl_num_chars_to_read;",Useful
"/*Forward declarations used by the display, termcap, and history code.*/","-1. _rl_keyseq_cxt *_rl_kscxt = 0;

 /*Forward declarations used by the display, termcap, and history code.*/

111",Useful
"/*Non-zero means do not parse any lines other than comments and
   parser directives.*/","-7. _rl_keyseq_cxt *_rl_kscxt = 0;

 /*Non-zero means do not parse any lines other than comments and
   parser directives.*/

1. unsigned char _rl_parsing_conditionalized_out = 0;",Useful
"/*Non-zero means to convert characters with the meta bit set to
   escape-prefixed characters so we can indirect through
   emacs_meta_keymap or vi_escape_keymap.*/","-10. _rl_keyseq_cxt *_rl_kscxt = 0;

 /*Non-zero means to convert characters with the meta bit set to
   escape-prefixed characters so we can indirect through
   emacs_meta_keymap or vi_escape_keymap.*/

1. int _rl_convert_meta_chars_to_ascii = 1;",Useful
"/*Non-zero means to output characters with the meta bit set directly
   rather than as a meta-prefixed escape sequence.*/","-1. int _rl_convert_meta_chars_to_ascii = 1;

 /*Non-zero means to output characters with the meta bit set directly
   rather than as a meta-prefixed escape sequence.*/

1. int _rl_output_meta_chars = 0;",Useful
"/*Non-zero means to look at the termios special characters and bind
   them to equivalent readline functions at startup.*/","-1. int _rl_output_meta_chars = 0;

 /*Non-zero means to look at the termios special characters and bind
   them to equivalent readline functions at startup.*/

1. int _rl_bind_stty_chars = 1;",Useful
/*Top Level Functions*/,"-3. int _rl_bind_stty_chars = 1;

 /*Top Level Functions*/

111",Useful
/*Non-zero means treat 0200 bit in terminal input as Meta bit.*/,"-6. int _rl_bind_stty_chars = 1;

 /*Non-zero means treat 0200 bit in terminal input as Meta bit.*/

111",Useful
"/*Set up the prompt and expand it.  Called from readline() and
   rl_callback_handler_install ().*/","-8. int _rl_bind_stty_chars = 1;

 /*Set up the prompt and expand it.  Called from readline() and
   rl_callback_handler_install ().*/

1. int
2. rl_set_prompt (prompt)
3.      const char *prompt;
4. {
5.   FREE (rl_prompt);
6.   rl_prompt = prompt ? save",Useful
"/*Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
   none.  A return value of NULL means that EOF was encountered.*/","-10. int
-9. rl_set_prompt (prompt)
-8.      const char *prompt;
-7. {
-6.   FREE (rl_prompt);
-5.   rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
-4.   rl_display_prompt = rl_prompt ? rl_prompt : (char*) """";
-3.   rl_visible_prompt_length = rl",Useful
/*If we are at EOF return a NULL string.*/,"-5. char *
-4. readline (prompt)
-3.      const char *prompt;
-2. {
-1.   char *value;

 /*If we are at EOF return a NULL string.*/

1.   if (rl_pending_input == EOF)
2.     {
3.       rl_clear_pending_input ();
4.       return ((char *)NULL);
5.     }
6.",Useful
"/*If we're not echoing, we still want to at least print a prompt, because
     rl_redisplay will not do it for us.  If the calling application has a
     custom redisplay function, though, let that function handle it.*/","-10. #  define STATIC_CALLBACK static
-9. #endif
-8. STATIC_CALLBACK void
-7. readline_internal_setup ()
-6. {
-5.   char *nprompt;
-4.   _rl_in_stream = rl_instream;
-3.   _rl_out_stream = rl_outstream;
-2.   if (rl_startup_hook)
-1.     (*rl_startup_hoo",Useful
"/*Restore normal cursor, if available.*/","-2.   if (rl_undo_list)
-1.     rl_free_undo_list ();

 /*Restore normal cursor, if available.*/

1.   _rl_set_insert_mode (RL_IM_INSERT, 0);
2.   return (eof ? (char *)NULL : savestring (the_line));
3. }
4. void
5. _rl_internal_char_cleanup ()
6. {
7. #i",Useful
"/*In vi mode, when you exit insert mode, the cursor moves back
     over the previous character.  We explicitly check for that here.*/","-7.   _rl_set_insert_mode (RL_IM_INSERT, 0);
-6.   return (eof ? (char *)NULL : savestring (the_line));
-5. }
-4. void
-3. _rl_internal_char_cleanup ()
-2. {
-1. #if defined (VI_MODE)

 /*In vi mode, when you exit insert mode, the cursor moves back
     o",Useful
"/*If the application writer has told us to erase the entire line if
     the only character typed was something bound to rl_newline, do so.*/","-10.     {
-9.       (*rl_redisplay_function) ();
-8.       _rl_want_redisplay = 0;
-7.       rl_newline (1, '\n');
-6.     }
-5.   if (rl_done == 0)
-4.     {
-3.       (*rl_redisplay_function) ();
-2.       _rl_want_redisplay = 0;
-1.     }

 /*If the a",Useful
"/*If we get here, we're not being called from something dispatched
	     from _rl_callback_read_char(), which sets up its own value of
	     readline_top_level (saving and restoring the old, of course), so
	     we can just return here.*/","-10. #if !defined (READLINE_CALLBACKS)
-9.   while (rl_done == 0)
-8.     {
-7. #endif
-6.       lk = _rl_last_command_was_kill;
-5.       code = setjmp (readline_top_level);
-4.       if (code)
-3. 	{
-2. 	  (*rl_redisplay_function) ();
-1. 	  _rl_want_r",Useful
/*Then initialize the argument and number of keys read.*/,"-5. 	  if (RL_ISSTATE (RL_STATE_CALLBACK))
-4. 	    return (0);
-3. 	}
-2.       if (rl_pending_input == 0)
-1. 	{

 /*Then initialize the argument and number of keys read.*/

1. 	  _rl_reset_argument ();
2. 	  rl_key_sequence_length = 0;
3. 	}
4.       R",Useful
"/*If there was no change in _rl_last_command_was_kill, then no kill
	 has taken place.  Note that if input is pending we are reading
	 a prefix command, so nothing has changed yet.*/","-10. #if defined (READLINE_CALLBACKS)
-9. 	  RL_SETSTATE(RL_STATE_DONE);
-8. 	  return (rl_done = 1);
-7. #else
-6. 	  eof_found = 1;
-5. 	  break;
-4. #endif
-3. 	}
-2.       lastc = c;
-1.       _rl_dispatch ((unsigned char)c, _rl_keymap);

 /*If there ",Useful
"/*Read a line of input from the global rl_instream, doing output on
   the global rl_outstream.
   If rl_prompt is non-null, then that is our prompt.*/","-10. #if defined (READLINE_CALLBACKS)
-9. static int
-8. readline_internal_charloop ()
-7. {
-6.   int eof = 1;
-5.   while (rl_done == 0)
-4.     eof = readline_internal_char ();
-3.   return (eof);
-2. }

 /*Read a line of input from the global rl_instr",Useful
"/*The first time this context is used, we want to read input and dispatch
     on it.  When traversing the chain of contexts back `up', we want to use
     the value from the next context down.  We're simulating recursion using
     a chain of contexts.*/","-1. #if 1

 /*The first time this context is used, we want to read input and dispatch
     on it.  When traversing the chain of contexts back `up', we want to use
     the value from the next context down.  We're simulating recursion using
     a chain of",Useful
/*magic value that says we added to the chain*/,"-5.     {
-4.       _rl_keyseq_chain_dispose ();
-3.       RL_UNSETSTATE (RL_STATE_MULTIKEY);
-2.       return r;
-1.     }

 /*magic value that says we added to the chain*/

1.     _rl_kscxt = cxt->ocxt;
2.   if (_rl_kscxt)
3.     _rl_kscxt->childval = r",Useful
"/*Do the command associated with KEY in MAP.
   If the associated command is really a keymap, then read
   another key, and dispatch into that map.*/","-8.     _rl_kscxt = cxt->ocxt;
-7.   if (_rl_kscxt)
-6.     _rl_kscxt->childval = r;
-5.   if (r != -3)
-4.     _rl_keyseq_cxt_dispose (cxt);
-3.   return r;
-2. }

 /*Do the command associated with KEY in MAP.
   If the associated command is really a key",Useful
"/*If we have input pending, then the last command was a prefix
	     command.  Don't change the state of rl_last_func.  Otherwise,
	     remember the last command executed in this variable.*/","-8. 	  if (func == rl_do_lowercase_version)
-7. 	    return (_rl_dispatch (_rl_to_lower (key), map));
-6. 	  rl_executing_keymap = map;
-5. 	  rl_dispatching = 1;
-4. 	  RL_SETSTATE(RL_STATE_DISPATCHING);
-3. 	  (*map[key].function)(rl_numeric_arg * rl_ar",Useful
"/*OK, there's no function bound in this map, but there is a
	     shadow function that was overridden when the current keymap
	     was created.  Return -2 to note  that.*/","-5. 	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
-4. 	    rl_last_func = map[key].function;
-3. 	}
-2.       else if (map[ANYOTHERKEY].function)
-1. 	{

 /*OK, there's no function bound in this map, but there is a
	     shadow f",Useful
"/*Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recursion chain and find the last
	     subsequence that is bound to a function.*/","-5. 	  _rl_unget_char  (key);
-4. 	  return -2;
-3. 	}
-2.       else if (got_subseq)
-1. 	{

 /*Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recur",Useful
"/*The only way this test will be true is if a subsequence has been
	     bound starting with ESC, generally the arrow keys.  What we do is
	     check whether there's input in the queue, which there generally
	     will be if an arrow key has been pressed, and, if there's not,
	     just dispatch to (what we assume is) rl_vi_movement_mode right
	     away.  This is essentially an input test with a zero timeout.*/","-10. 	  _rl_keyseq_chain_dispose ();
-9. #endif
-8. 	  _rl_abort_internal ();
-7. 	  return -1;
-6. 	}
-5.       break;
-4.     case ISKMAP:
-3.       if (map[key].function != 0)
-2. 	{
-1. #if defined (VI_MODE)

 /*The only way this test will be true is ",Useful
"/*Allocate new context here.  Use linked contexts (linked through
	     cxt->ocxt) to simulate recursion*/","-10. 	     check whether there's input in the queue, which there generally
-9. 	     will be if an arrow key has been pressed, and, if there's not,
-8. 	     just dispatch to (what we assume is) rl_vi_movement_mode right
-7. 	     away.  This is essential",Useful
"/*Return 0 only the first time, to indicate success to
		 _rl_callback_read_char.  The rest of the time, we're called
		 from _rl_dispatch_callback, so we return 3 to indicate
		 special handling is necessary.*/","-3. #if defined (READLINE_CALLBACKS)
-2. 	  if (RL_ISSTATE (RL_STATE_CALLBACK))
-1. 	    {

 /*Return 0 only the first time, to indicate success to
		 _rl_callback_read_char.  The rest of the time, we're called
		 from _rl_dispatch_callback, so we return ",Useful
"/*We didn't match anything, and the keymap we're indexed into
       shadowed a function previously bound to that prefix.  Call
       the function.  The recursive call to _rl_dispatch_subseq has
       already taken care of pushing any necessary input back onto
       the input queue with _rl_unget_char.*/","-10. static int
-9. _rl_subseq_result (r, map, key, got_subseq)
-8.      int r;
-7.      Keymap map;
-6.      int key, got_subseq;
-5. {
-4.   Keymap m;
-3.   int type, nt;
-2.   rl_command_func_t *func, *nf;
-1.   if (r == -2)

 /*We didn't match anythin",Useful
"/*We didn't match (r is probably -1), so return something to
	 tell the caller that it should try ANYOTHERKEY for an
	 overridden function.*/","-10. 	  m[key].function = func;
-9. 	  r = _rl_dispatch (key, m);
-8. 	  m[key].type = nt;
-7. 	  m[key].function = nf;
-6. 	}
-5.       else
-4. 	r = _rl_dispatch (ANYOTHERKEY, m);
-3.     }
-2.   else if (r && map[ANYOTHERKEY].function)
-1.     {

 /*We",Useful
"/*OK, back up the chain.*/","-6.       _rl_unget_char (key);
-5.       _rl_dispatching_keymap = map;
-4.       return -2;
-3.     }
-2.   else if (r && got_subseq)
-1.     {

 /*OK, back up the chain.*/

1.       _rl_unget_char (key);
2.       _rl_dispatching_keymap = map;
3.       r",Useful
/*Initialize readline (and terminal if not already).*/,"-10.       _rl_dispatching_keymap = map;
-9.       return -1;
-8.     }
-7.   return r;
-6. }

 /*Initialize readline (and terminal if not already).*/

1. int
2. rl_initialize ()
3. {",Useful
"/*If we have never been called before, initialize the
     terminal and data structures.*/","-3. int
-2. rl_initialize ()
-1. {

 /*If we have never been called before, initialize the
     terminal and data structures.*/

1.   if (!rl_initialized)
2.     {
3.       RL_SETSTATE(RL_STATE_INITIALIZING);
4.       readline_initialize_everything ();
5.",Useful
/*Make the display buffer match the state of the line.*/,"-1.   _rl_start_using_history ();

 /*Make the display buffer match the state of the line.*/

1.   rl_reset_line_state ();",Useful
/*Each line starts in insert mode (the default).*/,"-5.   _rl_parsing_conditionalized_out = 0;
-4. #if defined (VI_MODE)
-3.   if (rl_editing_mode == vi_mode)
-2.     _rl_vi_initialize_line ();
-1. #endif

 /*Each line starts in insert mode (the default).*/

1.   _rl_set_insert_mode (RL_IM_DEFAULT, 1);
2. ",Useful
/*Find out if we are running in Emacs -- UNUSED.*/,"-10. static void
-9. readline_initialize_everything ()
-8. {
-7. #if 0
-6. #if defined (__EMX__)
-5.   if (environ == 0)
-4.     _emx_build_environ ();
-3. #endif
-2. #endif
-1. #if 0

 /*Find out if we are running in Emacs -- UNUSED.*/

1.   running_in_e",Useful
/*Set up input and output if they are not already set up.*/,"-2.   running_in_emacs = sh_get_env_value (""EMACS"") != (char *)0;
-1. #endif

 /*Set up input and output if they are not already set up.*/

1.   if (!rl_instream)
2.     rl_instream = stdin;
3.   if (!rl_outstream)
4.     rl_outstream = stdout;",Useful
/*Allocate data structures.*/,"-2.   _rl_in_stream = rl_instream;
-1.   _rl_out_stream = rl_outstream;

 /*Allocate data structures.*/

1.   if (rl_line_buffer == 0)
2.     rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);",Useful
/*Decide whether we should automatically go into eight-bit mode.*/,"-1.   rl_initialize_funmap ();

 /*Decide whether we should automatically go into eight-bit mode.*/

1.   _rl_init_eightbit ();",Useful
"/*Try to bind a common arrow key prefix, if not already bound.*/","-1.   rl_set_keymap_from_edit_mode ();

 /*Try to bind a common arrow key prefix, if not already bound.*/

1.   bind_arrow_keys ();",Useful
"/*If the completion parser's default word break characters haven't
     been set yet, then do so now.*/","-2.   if (_rl_enable_meta)
-1.     _rl_enable_meta_key ();

 /*If the completion parser's default word break characters haven't
     been set yet, then do so now.*/

1.   if (rl_completer_word_break_characters == (char *)NULL)
2.     rl_completer_word_bre",Useful
"/*If this system allows us to look at the values of the regular
   input editing characters, then bind them to their readline
   equivalents, iff the characters are not bound to keymaps.*/","-3.   if (rl_completer_word_break_characters == (char *)NULL)
-2.     rl_completer_word_break_characters = (char *)rl_basic_word_break_characters;
-1. }

 /*If this system allows us to look at the values of the regular
   input editing characters, then bi",Useful
"/*Try and bind the common arrow key prefixes after giving termcap and
   the inputrc file a chance to bind them and create `real' keymaps
   for the arrow key prefix.*/","-10.   rl_bind_keyseq_if_unbound (""\033OH"", rl_beg_of_line);
-9.   rl_bind_keyseq_if_unbound (""\033OF"", rl_end_of_line);
-8. #if defined (__MINGW32__)
-7.   rl_bind_keyseq_if_unbound (""\340H"", rl_get_previous_history);
-6.   rl_bind_keyseq_if_unbound (""\3",Useful
"/*Insert a string of text into the line at point.  This is the only
   way that you should do insertion.  _rl_insert_char () calls this
   function.  Returns the number of characters inserted.*/","-10. static int _rl_char_search PARAMS((int, int, int));
-9. #if defined (READLINE_CALLBACKS)
-8. static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-7. static int _rl_char_search_callback PARAMS((_rl_callback_generic_arg *));
-6. #",Useful
/*Remember how to undo this if we aren't undoing something.*/,"-10. {
-9.   register int i, l;
-8.   l = (string && *string) ? strlen (string) : 0;
-7.   if (l == 0)
-6.     return 0;
-5.   if (rl_end + l >= rl_line_buffer_len)
-4.     rl_extend_line_buffer (rl_end + l);
-3.   for (i = rl_end; i >= rl_point; i--)
-2.",Useful
"/*Delete the string between FROM and TO.  FROM is inclusive, TO is not.
   Returns the number of characters deleted.*/","-10. 	  (rl_undo_list->end - rl_undo_list->start < 20))
-9. 	rl_undo_list->end++;
-8.       else
-7. 	rl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);
-6.     }
-5.   rl_point += l;
-4.   rl_end += l;
-3.   rl_line_buffer[rl_end] = '\0';
-",Useful
/*Some versions of strncpy() can't handle overlapping arguments.*/,"-9.   if (to > rl_end)
-8.     {
-7.       to = rl_end;
-6.       if (from > to)
-5. 	from = to;
-4.     }
-3.   if (from < 0)
-2.     from = 0;
-1.   text = rl_copy_text (from, to);

 /*Some versions of strncpy() can't handle overlapping arguments.*/

1.",Useful
"/*Fix up point so that it is within the line boundaries after killing
   text.  If FIX_MARK_TOO is non-zero, the mark is forced within line
   boundaries also.*/","-8.   if (_rl_doing_an_undo == 0)
-7.     rl_add_undo (UNDO_DELETE, from, to, text);
-6.   else
-5.     free (text);
-4.   rl_end -= diff;
-3.   rl_line_buffer[rl_end] = '\0';
-2.   return (diff);
-1. }

 /*Fix up point so that it is within the line bound",Useful
"/*Replace the contents of the line buffer between START and END with
   TEXT.  The operation is undoable.  To replace the entire line in an
   undoable mode, use _rl_replace_text(text, 0, rl_end);*/","-10. 	} while (0)
-9. void
-8. _rl_fix_point (fix_mark_too)
-7.      int fix_mark_too;
-6. {
-5.   _RL_FIX_POINT (rl_point);
-4.   if (fix_mark_too)
-3.     _RL_FIX_POINT (rl_mark);
-2. }
-1. #undef _RL_FIX_POINT

 /*Replace the contents of the line buffe",Useful
"/*Replace the current line buffer contents with TEXT.  If CLEAR_UNDO is
   non-zero, we free the current undo list.*/","-10.      int start, end;
-9. {
-8.   int n;
-7.   rl_begin_undo_group ();
-6.   rl_delete_text (start, end + 1);
-5.   rl_point = start;
-4.   n = rl_insert_text (text);
-3.   rl_end_undo_group ();
-2.   return n;
-1. }

 /*Replace the current line buffe",Useful
"/*Note that:

   rl_end is the place in the string that we would place '\0';
   i.e., it is always safe to place '\0' there.

   rl_point is the place in the string where the cursor is.  Sometimes
   this is the same as rl_end.

   Any command that is called interactively receives two arguments.
   The first is a count: the numeric arg pased to this command.
   The second is the key which invoked this command.*/","/* Note that:

   rl_end is the place in the string that we would place '\0';
   i.e., it is always safe to place '\0' there.

   rl_point is the place in the string where the cursor is.  Sometimes
   this is the same as rl_end.

   Any command that is called interactively receives two arguments.
   The first is a count: the numeric arg pased to this command.
   The second is the key which invoked this command.

 /*Note that:

   rl_end is the place in the string that we would place '\0';
   i.e., it is always safe to place '\0' there.

   rl_point is the place in the string where the cursor is.  Sometimes
   this is the same as rl_end.

   Any command that is called interactively receives two arguments.
   The first is a count: the numeric arg pased to this command.
   The second is the key which invoked this command.*/

1. */",Useful
"/*Note that if you `optimize' the display for these functions, you cannot
   use said functions in other functions which do not do optimizing display.
   I.e., you will have to update the data base for rl_redisplay, and you
   might as well let rl_redisplay do that job.*/","-10.    this is the same as rl_end.
-9.    Any command that is called interactively receives two arguments.
-8.    The first is a count: the numeric arg pased to this command.
-7.    The second is the key which invoked this command.
-6. */

 /*Note that i",Useful
/*Move forward COUNT bytes.*/,"-10. */

 /*Move forward COUNT bytes.*/

1. int
2. rl_forward_byte (count, key)
3.      int count, key;
4. {
5.   if (count < 0)
6.     return (rl_backward_byte (-count, key));
7.   if (count > 0)
8.     {
9.       int end = rl_point + count;
10. #if defi",Useful
/*Move forward COUNT characters.*/,"-10. 	  rl_ding ();
-9. 	}
-8.       else
-7. 	rl_point = end;
-6.     }
-5.   if (rl_end < 0)
-4.     rl_end = 0;
-3.   return 0;
-2. }
-1. #if defined (HANDLE_MULTIBYTE)

 /*Move forward COUNT characters.*/

1. int
2. rl_forward_char (count, key)
3.    ",Useful
/*Move backward COUNT bytes.*/,"-6. int
-5. rl_forward (count, key)
-4.      int count, key;
-3. {
-2.   return (rl_forward_char (count, key));
-1. }

 /*Move backward COUNT bytes.*/

1. int
2. rl_backward_byte (count, key)
3.      int count, key;
4. {
5.   if (count < 0)
6.     return ",Useful
/*Move backward COUNT characters.*/,"-10. 	  rl_ding ();
-9. 	}
-8.       else
-7. 	rl_point -= count;
-6.     }
-5.   if (rl_point < 0)
-4.     rl_point = 0;
-3.   return 0;
-2. }
-1. #if defined (HANDLE_MULTIBYTE)

 /*Move backward COUNT characters.*/

1. int
2. rl_backward_char (count, ke",Useful
/*Move forward a word.  We do what Emacs does.  Handles multibyte chars.*/,"-7. int
-6. rl_end_of_line (count, key)
-5.      int count __attribute__((unused)), key __attribute__((unused));
-4. {
-3.   rl_point = rl_end;
-2.   return 0;
-1. }

 /*Move forward a word.  We do what Emacs does.  Handles multibyte chars.*/

1. int
2. r",Useful
"/*If we are not in a word, move forward until we are in one.
	 Then, move forward until we hit a non-alphabetic character.*/","-10. rl_forward_word (count, key)
-9.      int count, key;
-8. {
-7.   int c;
-6.   if (count < 0)
-5.     return (rl_backward_word (-count, key));
-4.   while (count)
-3.     {
-2.       if (rl_point == rl_end)
-1. 	return 0;

 /*If we are not in a word,",Useful
/*Move backward a word.  We do what Emacs does.  Handles multibyte chars.*/,"-10. 	{
-9. 	  c = _rl_char_value (rl_line_buffer, rl_point);
-8. 	  if (_rl_walphabetic (c) == 0)
-7. 	    break;
-6. 	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
-5. 	}
-4.       --count;
-3.     }
-2.   return 0;
-1. }

 /*",Useful
/*Clear the current line.  Numeric argument to C-l does this.*/,"-10. 	  c = _rl_char_value (rl_line_buffer, p);	  
-9. 	  if (_rl_walphabetic (c) == 0)
-8. 	    break;
-7. 	  else
-6. 	    rl_point = p;
-5. 	}
-4.       --count;
-3.     }
-2.   return 0;
-1. }

 /*Clear the current line.  Numeric argument to C-l does ",Useful
/*arg of 0 means to not use spaces*/,"-8. int
-7. rl_refresh_line (ignore1, ignore2)
-6.      int ignore1 __attribute__((unused)), ignore2 __attribute__((unused));
-5. {
-4.   int curr_line;
-3.   curr_line = _rl_current_display_line ();
-2.   _rl_move_vert (curr_line);

 /*arg of 0 means to ",Useful
"/*C-l typed to a line without quoting clears the screen, and then reprints
   the prompt and the current input line.  Given a numeric arg, redraw only
   the current line.*/","-4.   rl_forced_update_display ();
-3.   rl_display_fixed = 1;
-2.   return 0;
-1. }

 /*C-l typed to a line without quoting clears the screen, and then reprints
   the prompt and the current input line.  Given a numeric arg, redraw only
   the current li",Useful
/*calls termcap function to clear screen*/,"-10.    the current line. */
-9. int
-8. rl_clear_screen (count, key)
-7.      int count, key;
-6. {
-5.   if (rl_explicit_arg)
-4.     {
-3.       rl_refresh_line (count, key);
-2.       return 0;
-1.     }

 /*calls termcap function to clear screen*/

1",Useful
"/*Insert the character C at the current location, moving point forward.
   If C introduces a multibyte sequence, we read the whole sequence and
   then insert the multibyte char into the line buffer.*/","-5. #ifdef HANDLE_MULTIBYTE
-4. static char pending_bytes[MB_LEN_MAX];
-3. static int pending_bytes_length = 0;
-2. static mbstate_t ps;
-1. #endif

 /*Insert the character C at the current location, moving point forward.
   If C introduces a multibyte se",Useful
"/*Bytes too short to compose character, try to wait for next byte.
	     Restore the state of the byte sequence, because in this case the
	     effect of mbstate is undefined.*/","-10.       size_t ret;
-9.       if (stored_count <= 0)
-8. 	stored_count = count;
-7.       else
-6. 	count = stored_count;
-5.       ps_back = ps;
-4.       pending_bytes[pending_bytes_length++] = c;
-3.       ret = mbrtowc (&wc, pending_bytes, pending_",Useful
"/*Invalid byte sequence for the current locale.  Treat first byte
	     as a single character.*/","-5. 	  ps = ps_back;
-4. 	  return 1;
-3. 	}
-2.       else if (ret == (size_t)-1)
-1. 	{

 /*Invalid byte sequence for the current locale.  Treat first byte
	     as a single character.*/

1. 	  incoming[0] = pending_bytes[0];
2. 	  incoming[1] = '\0';
3",Useful
"/*Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined.*/","-7. 	  memset (&ps, 0, sizeof (mbstate_t));
-6. 	}
-5.       else if (ret == (size_t)0)
-4. 	{
-3. 	  incoming[0] = '\0';
-2. 	  incoming_length = 0;
-1. 	  pending_bytes_length--;

 /*Clear the state of the byte sequence, because in this case the
	     e",Useful
"/*Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined.*/","-7. 	  memset (&ps, 0, sizeof (mbstate_t));
-6. 	}
-5.       else if (ret == (size_t)0)
-4. 	{
-3. 	  incoming[0] = '\0';
-2. 	  incoming_length = 0;
-1. 	  pending_bytes_length--;

 /*Clear the state of the byte sequence, because in this case the
	     e",Useful
/*We successfully read a single multibyte character.*/,"-4. 	  memset (&ps, 0, sizeof (mbstate_t));
-3. 	}
-2.       else
-1. 	{

 /*We successfully read a single multibyte character.*/

1. 	  memcpy (incoming, pending_bytes, pending_bytes_length);
2. 	  incoming[pending_bytes_length] = '\0';
3. 	  incoming_le",Useful
"/*If we can optimize, then do it.  But don't let people crash
     readline because of extra large arguments.*/","-7. 	  memcpy (incoming, pending_bytes, pending_bytes_length);
-6. 	  incoming[pending_bytes_length] = '\0';
-5. 	  incoming_length = pending_bytes_length;
-4. 	  pending_bytes_length = 0;
-3. 	}
-2.     }

 /*If we can optimize, then do it.  But don't le",Useful
"/*We are inserting a single character.
	 If there is pending input, then make a string of all of the
	 pending characters that are bound to rl_insert, and insert
	 them all.*/","-4.       return 0;
-3.     }
-2.   if (MB_CUR_MAX == 1 || rl_byte_oriented)
-1.     {

 /*We are inserting a single character.
	 If there is pending input, then make a string of all of the
	 pending characters that are bound to rl_insert, and insert
	 th",Useful
/*Inserting a single character.*/,"-4.       if (_rl_any_typein ())
-3. 	_rl_insert_typein (c);
-2.       else
-1. 	{

 /*Inserting a single character.*/

1. 	  char str[2];
2. 	  str[1] = '\0';
3. 	  str[0] = c;
4. 	  rl_insert_text (str);
5. 	}
6.     }
7. #if defined (HANDLE_MULTIBYTE)
",Useful
"/*Overwrite the character at point (or next COUNT characters) with C.
   If C introduces a multibyte character sequence, read the entire sequence
   before starting the overwrite loop.*/","-10.     }
-9. #if defined (HANDLE_MULTIBYTE)
-8.   else
-7.     {
-6.       rl_insert_text (incoming);
-5.       stored_count = 0;
-4.     }
-3. #endif
-2.   return 0;
-1. }

 /*Overwrite the character at point (or next COUNT characters) with C.
   If C ",Useful
/*Read an entire multibyte character sequence to insert COUNT times.*/,"-7. int
-6. _rl_overwrite_char (count, c)
-5.      int count, c;
-4. {
-3.   int i;
-2. #if defined (HANDLE_MULTIBYTE)
-1.   char mbkey[MB_LEN_MAX];

 /*Read an entire multibyte character sequence to insert COUNT times.*/

1.   if (count > 0 && MB_CUR_MAX",Useful
/*Insert the next typed character verbatim.*/,"-10.   rl_end_undo_group ();
-9.   return 0;
-8. }
-7. int
-6. rl_insert (count, c)
-5.      int count, c;
-4. {
-3.   return (rl_insert_mode == RL_IM_INSERT ? _rl_insert_char (count, c)
-2.   					 : _rl_overwrite_char (count, c));
-1. }

 /*Insert the n",Useful
"/*Deregister function, let rl_callback_read_char deallocate data*/","-10. #endif
-9.   return (_rl_insert_char (count, c));  
-8. }
-7. #if defined (READLINE_CALLBACKS)
-6. static int
-5. _rl_insert_next_callback (data)
-4.      _rl_callback_generic_arg *data;
-3. {
-2.   int count;
-1.   count = data->count;

 /*Deregiste",Useful
/*Insert a tab character.*/,"-10. #if defined (READLINE_CALLBACKS)
-9.   if (RL_ISSTATE (RL_STATE_CALLBACK))
-8.     {
-7.       _rl_callback_data = _rl_callback_data_alloc (count);
-6.       _rl_callback_func = _rl_insert_next_callback;
-5.       return (0);
-4.     }
-3. #endif
-2.",Useful
"/*What to do when a NEWLINE is pressed.  We accept the whole line.
   KEY is the key that invoked this command.  I guess it could have
   meaning in the future.*/","-6. int
-5. rl_tab_insert (count, key)
-4.      int count, key __attribute__((unused));
-3. {
-2.   return (_rl_insert_char (count, '\t'));
-1. }

 /*What to do when a NEWLINE is pressed.  We accept the whole line.
   KEY is the key that invoked this comm",Useful
"/*If we've been asked to erase empty lines, suppress the final update,
     since _rl_update_final calls rl_crlf().*/","-3. 	_rl_vi_reset_last ();
-2.     }

 /*If we've been asked to erase empty lines, suppress the final update,
     since _rl_update_final calls rl_crlf().*/

1.   if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
2.     return 0;
3.   if (readline_",Useful
"/*What to do for some uppercase characters, like meta characters,
   and some characters appearing in emacs_ctlx_keymap.  This function
   is just a stub, you bind keys to it and the code in _rl_dispatch ()
   is special cased.*/","-6.   if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
-5.     return 0;
-4.   if (readline_echoing_p)
-3.     _rl_update_final ();
-2.   return 0;
-1. }

 /*What to do for some uppercase characters, like meta characters,
   and some characters ap",Useful
"/*This is different from what vi does, so the code's not shared.  Emacs
   rubout in overwrite mode has one oddity:  it replaces a control
   character that's displayed as two characters (^X) with two spaces.*/","-6. int
-5. rl_do_lowercase_version (ignore1, ignore2)
-4.      int ignore1 __attribute__((unused)), ignore2 __attribute__((unused));
-3. {
-2.   return 0;
-1. }

 /*This is different from what vi does, so the code's not shared.  Emacs
   rubout in overwr",Useful
/*L == number of spaces to insert*/,"-10.      int count, key;
-9. {
-8.   int opoint;
-7.   int i, l;
-6.   if (rl_point == 0)
-5.     {
-4.       rl_ding ();
-3.       return 1;
-2.     }
-1.   opoint = rl_point;

 /*L == number of spaces to insert*/

1.   for (i = l = 0; i < count; i++)
2",Useful
/*Emacs puts point at the beginning of the sequence of spaces.*/,"-6.     }
-5.   rl_begin_undo_group ();
-4.   if (count > 1 || rl_explicit_arg)
-3.     rl_kill_text (opoint, rl_point);
-2.   else
-1.     rl_delete_text (opoint, rl_point);

 /*Emacs puts point at the beginning of the sequence of spaces.*/

1.   if (rl_",Useful
"/*Delete the character under the cursor.  Given a numeric argument,
   kill that many characters instead.*/","-10. 	  _rl_erase_at_end_of_line (l);
-9. 	}
-8.     }
-7.   else
-6.     {
-5.       rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
-4.       rl_delete_text (rl_point, orig_point);
-3.     }
-2.   return 0;
-1. }

 /*Delete ",Useful
"/*Delete the character under the cursor, unless the insertion
   point is at the end of the line, in which case the character
   behind the cursor is deleted.  COUNT is obeyed and may be used
   to delete forward or backward that many characters.*/","-10.       rl_kill_text (xpoint, rl_point);
-9.       rl_point = xpoint;
-8.     }
-7.   else
-6.     {
-5.       xpoint = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
-4.       rl_delete_text (rl_point, xpoint);
-3.     }
-2.   return 0;
-",Useful
/*Delete all spaces and tabs around point.*/,"-10.    to delete forward or backward that many characters. */      
-9. int
-8. rl_rubout_or_delete (count, key)
-7.      int count, key;
-6. {
-5.   if (rl_end != 0 && rl_point == rl_end)
-4.     return (_rl_rubout_char (count, key));
-3.   else
-2.    ",Useful
"/*Like the tcsh editing function delete-char-or-list.  The eof character
   is caught before this is invoked, so this really does the same thing as
   delete-char-or-list-or-eof, as long as it's bound to the eof character.*/","-10.     rl_point++;
-9.   if (start != rl_point)
-8.     {
-7.       rl_delete_text (start, rl_point);
-6.       rl_point = start;
-5.     }
-4.   if (rl_point < 0)
-3.     rl_point = 0;
-2.   return 0;
-1. }

 /*Like the tcsh editing function delete-cha",Useful
"/*Upcase the first letter, downcase the rest.*/","-6. int
-5. rl_downcase_word (count, key)
-4.      int count, key __attribute__((unused));
-3. {
-2.   return (rl_change_case (count, DownCase));
-1. }

 /*Upcase the first letter, downcase the rest.*/

1. int
2. rl_capitalize_word (count, key)
3.      in",Useful
"/*The meaty function.
   Change the case of COUNT words, performing OP on them.
   OP is one of UpCase, DownCase, or CapCase.
   If a negative argument is given, leave point where it started,
   otherwise, leave it where it moves to.*/","-6. int
-5. rl_capitalize_word (count, key)
-4.      int count, key __attribute__((unused));
-3. {
-2.  return (rl_change_case (count, CapCase));
-1. }

 /*The meaty function.
   Change the case of COUNT words, performing OP on them.
   OP is one of UpCas",Useful
"/*Transpose the words at point.  If point is at the end of the line,
   transpose the two words before point.*/","-10.       start = next;
-9.     }
-8.   rl_point = end;
-7.   return 0;
-6. }

 /*Transpose the words at point.  If point is at the end of the line,
   transpose the two words before point.*/

1. int
2. rl_transpose_words (count, key)
3.      int count, ",Useful
/*Do some check to make sure that there really are two words.*/,"-8.   rl_forward_word (count, key);
-7.   w2_end = rl_point;
-6.   rl_backward_word (1, key);
-5.   w2_beg = rl_point;
-4.   rl_backward_word (count, key);
-3.   w1_beg = rl_point;
-2.   rl_forward_word (1, key);
-1.   w1_end = rl_point;

 /*Do some check",Useful
/*Get the text of the words.*/,"-6.   if ((w1_beg == w2_beg) || (w2_beg < w1_end))
-5.     {
-4.       rl_ding ();
-3.       rl_point = orig_point;
-2.       return -1;
-1.     }

 /*Get the text of the words.*/

1.   word1 = rl_copy_text (w1_beg, w1_end);
2.   word2 = rl_copy_text (w2_",Useful
"/*We are about to do many insertions and deletions.  Remember them
     as one operation.*/","-2.   word1 = rl_copy_text (w1_beg, w1_end);
-1.   word2 = rl_copy_text (w2_beg, w2_end);

 /*We are about to do many insertions and deletions.  Remember them
     as one operation.*/

1.   rl_begin_undo_group ();",Useful
"/*Do the stuff at word2 first, so that we don't have to worry
     about word1 moving.*/","-1.   rl_begin_undo_group ();

 /*Do the stuff at word2 first, so that we don't have to worry
     about word1 moving.*/

1.   rl_point = w2_beg;
2.   rl_delete_text (w2_beg, w2_end);
3.   rl_insert_text (word1);
4.   rl_point = w1_beg;
5.   rl_delete_tex",Useful
"/*This is exactly correct since the text before this point has not
     changed in length.*/","-6.   rl_point = w2_beg;
-5.   rl_delete_text (w2_beg, w2_end);
-4.   rl_insert_text (word1);
-3.   rl_point = w1_beg;
-2.   rl_delete_text (w1_beg, w1_end);
-1.   rl_insert_text (word2);

 /*This is exactly correct since the text before this point has no",Useful
"/*Transpose the characters at point.  If point is at the end of the line,
   then transpose the characters before point.*/","-5.   rl_end_undo_group ();
-4.   free (word1);
-3.   free (word2);
-2.   return 0;
-1. }

 /*Transpose the characters at point.  If point is at the end of the line,
   then transpose the characters before point.*/

1. int
2. rl_transpose_chars (count, ke",Useful
"/*Search COUNT times for a character read from the current input stream.
   FDIR is the direction to search if COUNT is non-negative; otherwise
   the search goes in BDIR.  So much is dependent on HANDLE_MULTIBYTE
   that there are two separate versions of this function.*/","-10. 	}
-9. #if defined (HANDLE_MULTIBYTE)
-8.       while ((dir < 0) ? (pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY)) != prepos
-7. 		       : (pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)) != prepos);
-6. #else
-5.  ",Useful
/*A bindable command to set the mark.*/,"-9. int
-8. _rl_set_mark_at_pos (position)
-7.      int position;
-6. {
-5.   if (position > rl_end)
-4.     return -1;
-3.   rl_mark = position;
-2.   return 0;
-1. }

 /*A bindable command to set the mark.*/

1. int
2. rl_set_mark (count, key)
3.      i",Useful
/*Exchange the position of mark and point.*/,"-6. int
-5. rl_set_mark (count, key)
-4.      int count, key __attribute__((unused));
-3. {
-2.   return (_rl_set_mark_at_pos (rl_explicit_arg ? count : rl_point));
-1. }

 /*Exchange the position of mark and point.*/

1. int
2. rl_exchange_point_and_mark",Useful
"/*shell.c -- readline utility functions that are normally provided by
	      bash when readline is linked as part of the shell.*/","
/* shell.c -- readline utility functions that are normally provided by
	      bash when readline is linked as part of the shell. */


 /*shell.c -- readline utility functions that are normally provided by
	      bash when readline is linked as part of the shell.*/

1. /* Copyright (C) 1997 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
/*Nonzero if the integer type T is signed.*/,"-6. #ifndef NULL
-5. #  define NULL 0
-4. #endif
-3. #ifndef CHAR_BIT
-2. #  define CHAR_BIT 8
-1. #endif

 /*Nonzero if the integer type T is signed.*/

1. #define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))",Useful
"/*All of these functions are resolved from bash if we are linking readline
   as part of bash.*/","-3. #define INT_STRLEN_BOUND(t) \
-2.   ((sizeof (t) * CHAR_BIT - TYPE_SIGNED (t)) * 302 / 1000 \
-1.    + 1 + TYPE_SIGNED (t))

 /*All of these functions are resolved from bash if we are linking readline
   as part of bash.*/

111",Useful
/*start new quoted string*/,"-1. 	  *r++ = '\'';

 /*start new quoted string*/

1. 	}
2.     }
3.   *r++ = '\'';
4.   *r = '\0';
5.   return (result);
6. }",Useful
/*Data file read filter implementation*/,"-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Useful
"/**
Perform read filter context initialization that is common to all read
filters.*/","-10. along with this program; if not, write to the Free Software
-9. Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA
-8. *******************************************************/
-7. /* Data file read filter implementation */",Useful
/*!<in/out: read filter context*/,"-4. static
-3. void
-2. common_init(

 /*!<in/out: read filter context*/

111",Useful
"/**
Initialize the pass-through read filter.*/","-10. /*========*/
-9. 	xb_read_filt_ctxt_t*	ctxt,	/*!<in/out: read filter context */
-8. 	const xb_fil_cur_t*	cursor)	/*!<in: file cursor */
-7. {
-6. 	ctxt->offset = 0;
-5. 	ctxt->data_file_size = cursor->statinfo.st_size;
-4. 	ctxt->buffer_capacity = cu",Useful
/*!<in/out: read filter context*/,"-4. static
-3. void
-2. common_init(

 /*!<in/out: read filter context*/

111",Useful
"/**
Get the next batch of pages for the pass-through read filter.*/","-10. rf_pass_through_init(
-9. /*=================*/
-8. 	xb_read_filt_ctxt_t*	ctxt,	/*!<in/out: read filter context */
-7. 	const xb_fil_cur_t*	cursor,	/*!<in: file cursor */
-6. 	ulint			space_id __attribute__((unused)))
-5. 					/*!<in: space id we are",Useful
"/*!<in/out: read filter
							context*/","-4. static
-3. void
-2. rf_pass_through_get_next_batch(

 /*!<in/out: read filter
							context*/

111",Useful
"/*!<out: starting read
							offset in bytes for the
							next batch of pages*/","-6. static
-5. void
-4. rf_pass_through_get_next_batch(

 /*!<out: starting read
							offset in bytes for the
							next batch of pages*/

111",Useful
"/*!<out: length in
							bytes of the next batch
							of pages*/","-10. Get the next batch of pages for the pass-through read filter.  */
-9. static
-8. void
-7. rf_pass_through_get_next_batch(

 /*!<out: length in
							bytes of the next batch
							of pages*/

111",Useful
/*!<in: read filter context*/,"-1. 	xb_read_filt_ctxt_t*	ctxt __attribute__((unused)))

 /*!<in: read filter context*/

111",Useful
"/**
Initialize the changed page bitmap-based read filter.  Assumes that
the bitmap is already set up in changed_page_bitmap.*/","-10. static
-9. void
-8. rf_pass_through_deinit(
-7. /*===================*/
-6. 	xb_read_filt_ctxt_t*	ctxt __attribute__((unused)))
-5. 					/*!<in: read filter context */
-4. {
-3. }
-2. /****************************************************************/",Useful
"/*!<in/out: read filter
						context*/","-4. static
-3. void
-2. rf_pass_through_get_next_batch(

 /*!<in/out: read filter
						context*/

111",Useful
"/**
Get the next batch of pages for the bitmap read filter.*/","-10. 						context */
-9. 	const xb_fil_cur_t*	cursor,		/*!<in: read cursor */
-8. 	ulint			space_id)	/*!<in: space id  */
-7. {
-6. 	common_init(ctxt, cursor);
-5. 	ctxt->bitmap_range = xb_page_bitmap_range_init(changed_page_bitmap,
-4. 						       spac",Useful
"/*!<in/out: read filter
							context*/","-4. static
-3. void
-2. rf_pass_through_get_next_batch(

 /*!<in/out: read filter
							context*/

111",Useful
"/*!<out: starting read
							offset in bytes for the
							next batch of pages*/","-6. static
-5. void
-4. rf_pass_through_get_next_batch(

 /*!<out: starting read
							offset in bytes for the
							next batch of pages*/

111",Useful
"/*!<out: length in
							bytes of the next batch
							of pages*/","-10. Get the next batch of pages for the pass-through read filter.  */
-9. static
-8. void
-7. rf_pass_through_get_next_batch(

 /*!<out: length in
							bytes of the next batch
							of pages*/

111",Useful
"/*Used up all the previous bitmap range, get some more*/","-6. {
-5. 	ulint	start_page_id;
-4. 	const ulint	page_size	= ctxt->page_size;
-3. 	start_page_id = (ulint)(ctxt->offset / page_size);
-2. 	xb_a (ctxt->offset % page_size == 0);
-1. 	if (start_page_id == ctxt->filter_batch_end) {

 /*Used up all the previo",Useful
"/*Find the end of the current changed page block by searching
		for the next cleared bitmap bit*/","-7. 		next_page_id = xb_page_bitmap_range_get_next_bit
-6. 			(ctxt->bitmap_range, TRUE);
-5. 		if (next_page_id == ULINT_UNDEFINED) {
-4. 			*read_batch_len = 0;
-3. 			return;
-2. 		}
-1. 		ctxt->offset = next_page_id * page_size;

 /*Find the end of th",Useful
"/*No more cleared bits in the bitmap, need to copy all the
		remaining pages.*/","-7. 		ctxt->filter_batch_end
-6. 			= xb_page_bitmap_range_get_next_bit(ctxt->bitmap_range,
-5. 							    FALSE);
-4. 		xb_a(next_page_id < ctxt->filter_batch_end);
-3. 	}
-2. 	*read_batch_start = ctxt->offset;
-1. 	if (ctxt->filter_batch_end == ULINT_UN",Useful
"/*If the page block is larger than the buffer capacity, limit it to
	buffer capacity.  The subsequent invocations will continue returning
	the current block in buffer-sized pieces until ctxt->filter_batch_end
	is reached, trigerring the next bitmap query.*/","-5. 		*read_batch_len = ctxt->data_file_size - ctxt->offset;
-4. 	} else {
-3. 		*read_batch_len = ctxt->filter_batch_end * page_size
-2. 			- ctxt->offset;
-1. 	}

 /*If the page block is larger than the buffer capacity, limit it to
	buffer capacity.  Th",Useful
"/**
Deinitialize the changed page bitmap-based read filter.*/","-10. 	is reached, trigerring the next bitmap query.  */
-9. 	if (*read_batch_len > (ib_int64_t)ctxt->buffer_capacity) {
-8. 		*read_batch_len = ctxt->buffer_capacity;
-7. 	}
-6. 	ctxt->offset += *read_batch_len;
-5. 	xb_a (ctxt->offset % page_size == 0);
",Useful
/*!<in/out: read filter context*/,"-4. static
-3. void
-2. common_init(

 /*!<in/out: read filter context*/

111",Useful
/*The changed page bitmap-based read filter*/,"-5. xb_read_filt_t rf_pass_through = {
-4. 	&rf_pass_through_init,
-3. 	&rf_pass_through_get_next_batch,
-2. 	&rf_pass_through_deinit
-1. };

 /*The changed page bitmap-based read filter*/

1. xb_read_filt_t rf_bitmap = {
2. 	&rf_bitmap_init,
3. 	&rf_bitm",Useful
"/***********************************************************************
Store Galera checkpoint info in the 'xtrabackup_galera_info' file, if that
information is present in the trx system header. Otherwise, do nothing.*/","-1. #define XB_GALERA_INFO_FILENAME ""xtrabackup_galera_info""

 /***********************************************************************
Store Galera checkpoint info in the 'xtrabackup_galera_info' file, if that
information is present in the trx system hea",Useful
"/*Do not overwrite existing an existing file to be compatible with
	servers with older server versions*/","-6. {
-5. 	FILE*		fp;
-4. 	XID		xid;
-3. 	char		uuid_str[40];
-2. 	long long	seqno;
-1. 	MY_STAT		statinfo;

 /*Do not overwrite existing an existing file to be compatible with
	servers with older server versions*/

1. 	if (!incremental_prepare &&
2. 		my",Useful
"/*Read ""plugin-load"" value (encryption plugin) from backup-my.cnf during
  prepare phase.
  The value is stored during backup phase.*/","nan


 /*Read ""plugin-load"" value (encryption plugin) from backup-my.cnf during
  prepare phase.
  The value is stored during backup phase.*/

nan
",Useful
/*remote \n at the end of string*/,"nan


 /*remote \n at the end of string*/

nan
",Useful
"/*Remove shared library suffixes, in case we'll prepare on different OS.*/","nan


 /*Remove shared library suffixes, in case we'll prepare on different OS.*/

nan
",Useful
/*Required  to load the plugin later.*/,"nan


 /*Required  to load the plugin later.*/

nan
",Useful
/*Check whether to encrypt logs.*/,"nan


 /*Check whether to encrypt logs.*/

nan
",Useful
"/*Patch optional and mandatory plugins, we only need to load the one in xb_plugin_load.*/","nan


 /*Patch optional and mandatory plugins, we only need to load the one in xb_plugin_load.*/

nan
",Useful
"/*Private data for callback registration functions.  See comments in
   rl_callback_read_char for more details.*/","-4. #include ""rldefs.h""
-3. #include ""readline.h""
-2. #include ""rlprivate.h""
-1. #include ""xmalloc.h""

 /*Private data for callback registration functions.  See comments in
   rl_callback_read_char for more details.*/

1. _rl_callback_func_t *_rl_callback",Useful
"/*Allow using readline in situations where a program may have multiple
   things to handle at once, and dispatches them via select().  Call
   rl_callback_handler_install() with the prompt and a function to call
   whenever a complete line of input is ready.  The user must then
   call rl_callback_read_char() every time some input is available, and 
   rl_callback_read_char() will call the user's function with the complete
   text read in at each end of line.  The terminal is kept prepped and
   signals handled all the time, except during calls to the user's function.*/","-7. _rl_callback_func_t *_rl_callback_func = 0;
-6. _rl_callback_generic_arg *_rl_callback_data = 0;

 /*Allow using readline in situations where a program may have multiple
   things to handle at once, and dispatches them via select().  Call
   rl_callba",Useful
"/*Make sure the terminal is set up, initialize readline, and prompt.*/","-10. /* Allow using readline in situations where a program may have multiple
-9.    things to handle at once, and dispatches them via select().  Call
-8.    rl_callback_handler_install() with the prompt and a function to call
-7.    whenever a complete li",Useful
"/*Install a readline handler, set up the terminal, and issue the prompt.*/","-10.     {
-9.       in_handler = 1;
-8.       if (rl_prep_term_function)
-7. 	(*rl_prep_term_function) (_rl_meta_flag);
-6. #if defined (HANDLE_SIGNALS)
-5.       rl_set_signals ();
-4. #endif
-3.     }
-2.   readline_internal_setup ();
-1. }

 /*Install",Useful
"/*Read one character, and dispatch to the handler if it ends the line.*/","-10. void
-9. rl_callback_handler_install (prompt, linefunc)
-8.      const char *prompt;
-7.      rl_vcpfunc_t *linefunc;
-6. {
-5.   rl_set_prompt (prompt);
-4.   RL_SETSTATE (RL_STATE_CALLBACK);
-3.   rl_linefunc = linefunc;
-2.   _rl_callback_newline ",Useful
"/*This allows functions that simply need to read an additional
	     character (like quoted-insert) to register a function to be
	     called when input is available.  _rl_callback_data is simply a
	     pointer to a struct that has the argument count originally
	     passed to the registering function and space for any additional
	     parameters.*/","-10. 	  while ((eof == -1 || eof == -2) && RL_ISSTATE (RL_STATE_MULTIKEY) && _rl_kscxt && (_rl_kscxt->flags & KSEQ_DISPATCHED))
-9. 	    eof = _rl_dispatch_callback (_rl_kscxt);
-8. 	  if (RL_ISSTATE (RL_STATE_MULTIKEY) == 0)
-7. 	    {
-6. 	      _rl_int",Useful
"/*If the function `deregisters' itself, make sure the data is
	     cleaned up.*/","-1. 	  eof = (*_rl_callback_func) (_rl_callback_data);

 /*If the function `deregisters' itself, make sure the data is
	     cleaned up.*/

1. 	  if (_rl_callback_func == 0)
2. 	    {
3. 	      if (_rl_callback_data) 	
4. 		{
5. 		  _rl_callback_data_disp",Useful
"/*If the user did not clear out the line, do it for him.*/","-10.       if (rl_done)
-9. 	{
-8. 	  line = readline_internal_teardown (eof);
-7. 	  if (rl_deprep_term_function)
-6. 	    (*rl_deprep_term_function) ();
-5. #if defined (HANDLE_SIGNALS)
-4. 	  rl_clear_signals ();
-3. #endif
-2. 	  in_handler = 0;
-1. 	",Useful
"/*Redisplay the prompt if readline_handler_{install,remove}
	     not called.*/","-2. 	  if (rl_line_buffer[0])
-1. 	    _rl_init_line_state ();

 /*Redisplay the prompt if readline_handler_{install,remove}
	     not called.*/

1. 	  if (in_handler == 0 && rl_linefunc)
2. 	    _rl_callback_newline ();
3. 	}
4.     }
5.   while (rl_pend",Useful
"/*Remove the handler, and make sure the terminal is in its normal state.*/","-6. 	  if (in_handler == 0 && rl_linefunc)
-5. 	    _rl_callback_newline ();
-4. 	}
-3.     }
-2.   while (rl_pending_input || _rl_pushed_input_available () || RL_ISSTATE (RL_STATE_MACROINPUT));
-1. }

 /*Remove the handler, and make sure the terminal is ",Useful
/*Calculate size of data without trailing zero bytes.*/,"-10. 	local_file->fd = fd;
-9. 	local_file->init_ibd_done = 0;
-8. 	local_file->is_ibd = (path_len > 5) && !strcmp(fullpath + path_len - 5, "".ibd"");
-7. 	local_file->compressed = 0;
-6. 	local_file->pagesize = 0;
-5. 	file->path = (char *) local_file + si",Useful
"/*Write data to the output file, and punch ""holes"" if needed.*/","-6. static size_t trim_binary_zeros(uchar *buf, size_t pagesize)
-5. {
-4. 	size_t i;
-3. 	for (i = pagesize; (i > 0) && (buf[i - 1] == 0); i--) {};
-2. 	return i;
-1. }

 /*Write data to the output file, and punch ""holes"" if needed.*/

1. static int writ",Useful
"/*Calculate Innodb tablespace specific data, when first page is written.
   We're interested in page compression and page size.*/","-10. 			size_t hole_bytes = n_bytes - datasize;
-9. 			if (my_seek(fd, hole_bytes, MY_SEEK_CUR, MYF(MY_WME | MY_NABP))
-8. 				== MY_FILEPOS_ERROR)
-7. 			 return 1;
-6. 		}
-5. 		written += n_bytes;
-4. 		ptr += n_bytes;
-3. 	}
-2. 	return 0;
-1. }
/* Ca",Useful
"/*Make compressed file sparse, on Windows.
	In 10.1, we do not use sparse files.*/","-9. 		return;
-8. 	}
-7. 	auto flags = mach_read_from_4(&buf[FIL_PAGE_DATA + FSP_SPACE_FLAGS]);
-6. 	auto ssize = FSP_FLAGS_GET_PAGE_SSIZE(flags);
-5. 	local_file->pagesize= ssize == 0 ? UNIV_PAGE_SIZE_ORIG : ((UNIV_ZIP_SIZE_MIN >> 1) << ssize);
-4. 	loca",Useful
/*Set EOF at file's current position.*/,"-10. 	}
-9. 	if (local_file->compressed) {
-8. 		return write_compressed(fd, b, len, local_file->pagesize);
-7. 	}
-6. 	if (!my_write(fd, b , len, MYF(MY_WME | MY_NABP))) {
-5. 		posix_fadvise(fd, 0, 0, POSIX_FADV_DONTNEED);
-4. 		return 0;
-3. 	}
-2. 	re",Useful
"/*Do all writes to temporary files first, then pipe them to the specified
datasink in a serialized way in deinit().*/","-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Useful
"/*Create a temporary file in tmpdir. The file will be automatically
	removed on close. Code copied from mysql_tmpfile().*/","-10. static ds_file_t *
-9. tmpfile_open(ds_ctxt_t *ctxt, const char *path,
-8. 			       MY_STAT *mystat)
-7. {
-6. 	ds_tmpfile_ctxt_t	*tmpfile_ctxt;
-5. 	char			 tmp_path[FN_REFLEN];
-4. 	ds_tmp_file_t		*tmp_file;
-3. 	ds_file_t		*file;
-2. 	size_t			 p",Useful
"/*Save a copy of 'path', since it may not be accessible later*/","-5. 	file = (ds_file_t *) my_malloc(PSI_NOT_INSTRUMENTED,
-4.                         sizeof(ds_file_t) + sizeof(ds_tmp_file_t) + path_len, MYF(MY_FAE));
-3. 	tmp_file = (ds_tmp_file_t *) (file + 1);
-2. 	tmp_file->file = file;
-1. 	memcpy(&tmp_file->myst",Useful
/*Store the real temporary file name in file->path*/,"-3. 	tmp_file->orig_path = (char *) tmp_file + sizeof(ds_tmp_file_t);
-2. 	tmp_file->fd = fd;
-1. 	memcpy(tmp_file->orig_path, path, path_len);

 /*Store the real temporary file name in file->path*/

1. 	file->path = my_strdup(PSI_NOT_INSTRUMENTED, tmp_pa",Useful
/*Store the file object in the list to be piped later*/,"-2. 	file->path = my_strdup(PSI_NOT_INSTRUMENTED, tmp_path, MYF(MY_FAE));
-1. 	file->ptr = tmp_file;

 /*Store the file object in the list to be piped later*/

1. 	tmpfile_ctxt = (ds_tmpfile_ctxt_t *) ctxt->ptr;
2. 	tmp_file->list.data = tmp_file;
3. 	pth",Useful
"/*Do nothing -- we will close (and thus remove) the file after piping
	it to the destination datasink in tmpfile_deinit().*/","-10. 	File fd = ((ds_tmp_file_t *) file->ptr)->fd;
-9. 	if (!my_write(fd, buf, len, MYF(MY_WME | MY_NABP))) {
-8. 		posix_fadvise(fd, 0, 0, POSIX_FADV_DONTNEED);
-7. 		return 0;
-6. 	}
-5. 	return 1;
-4. }
-3. static int
-2. tmpfile_close(ds_file_t *file)",Useful
"/*Stat the file to replace size and mtime on the original
		* mystat struct*/","-3. 	list = list_reverse(list);
-2. 	while (list != NULL) {
-1. 		tmp_file = (ds_tmp_file_t *)list->data;

 /*Stat the file to replace size and mtime on the original
		* mystat struct*/

1. 		if (my_fstat(tmp_file->fd, &mystat, MYF(0))) {
2. 			die(""my_fs",Useful
/*Size of read buffer in pages (640 pages = 10M for 16K sized pages)*/,"-10. #include <fsp0fsp.h>
-9. #include <srv0start.h>
-8. #include <trx0sys.h>
-7. #include ""fil_cur.h""
-6. #include ""fil0crypt.h""
-5. #include ""fil0pagecompress.h""
-4. #include ""common.h""
-3. #include ""read_filt.h""
-2. #include ""xtrabackup.h""
-1. #include",Useful
"/***********************************************************************
Extracts the relative path (""database/table.ibd"") of a tablespace from a
specified possibly absolute path.

For user tablespaces both ""./database/table.ibd"" and
""/remote/dir/database/table.ibd"" result in ""database/table.ibd"".

For system tablepsaces (i.e. When is_system is TRUE) both ""/remote/dir/ibdata1""
and ""./ibdata1"" yield ""ibdata1"" in the output.*/","-1. #define XB_FIL_CUR_PAGES 640

 /***********************************************************************
Extracts the relative path (""database/table.ibd"") of a tablespace from a
specified possibly absolute path.

For user tablespaces both ""./database/t",Useful
"/*!< in: tablespace path (either
			  		relative or absolute)*/","-3. const char *
-2. xb_get_relative_path(

 /*!< in: tablespace path (either
			  		relative or absolute)*/

111",Useful
"/*!< in: TRUE for system tablespaces,
					i.e. when only the filename must be
					returned.*/","-10. specified possibly absolute path.
-9. For user tablespaces both ""./database/table.ibd"" and
-8. ""/remote/dir/database/table.ibd"" result in ""database/table.ibd"".
-7. For system tablepsaces (i.e. When is_system is TRUE) both ""/remote/dir/ibdata1""
-6. an",Useful
"/*The node is in the LRU list, remove it*/","nan


 /*The node is in the LRU list, remove it*/

nan
",Useful
"/************************************************************************
Open a source file cursor and initialize the associated read filter.

@return XB_FIL_CUR_SUCCESS on success, XB_FIL_CUR_SKIP if the source file must
be skipped and XB_FIL_CUR_ERROR on error.*/","-10. 	mysql_mutex_lock(&fil_system.mutex);
-9. 	ut_ad(node);
-8. 	ut_a(!node->being_extended);
-7. 	if (node->is_open()) {
-6. 		ret = os_file_close(node->handle);
-5. 		ut_a(ret);
-4. 		node->handle = OS_FILE_CLOSED;
-3. 	}
-2. 	mysql_mutex_unlock(&fil_s",Useful
/*!< thread number for diagnostics*/,"-6. xb_fil_cur_result_t
-5. xb_fil_cur_open(

 /*!< thread number for diagnostics*/

1. 	ulonglong max_file_size)
2. {
3. 	bool	success;
4. 	int err;",Useful
"/*Initialize these first so xb_fil_cur_close() handles them correctly
	in case of error*/","-4. 	ulonglong max_file_size)
-3. {
-2. 	bool	success;
-1. 	int err;

 /*Initialize these first so xb_fil_cur_close() handles them correctly
	in case of error*/

1. 	cursor->buf = NULL;
2. 	cursor->node = NULL;
3. 	cursor->space_id = node->space->id;
4. 	",Useful
"/*Get the relative path for the destination tablespace name, i.e. the
	one that can be appended to the backup root directory. Non-system
	tablespaces may have absolute paths for DATA DIRECTORY.
	We want to make ""local"" copies for the backup.*/","-5. 	cursor->buf = NULL;
-4. 	cursor->node = NULL;
-3. 	cursor->space_id = node->space->id;
-2. 	strncpy(cursor->abs_path, node->name, (sizeof cursor->abs_path) - 1);
-1. 	cursor->abs_path[(sizeof cursor->abs_path) - 1] = '\0';

 /*Get the relative path f",Useful
"/*In the backup mode we should already have a tablespace handle created
	by fil_ibd_load() unless it is a system
	tablespace. Otherwise we open the file here.*/","-4. 	strncpy(cursor->rel_path,
-3. 		xb_get_relative_path(cursor->abs_path, cursor->is_system()),
-2. 		(sizeof cursor->rel_path) - 1);
-1. 	cursor->rel_path[(sizeof cursor->rel_path) - 1] = '\0';

 /*In the backup mode we should already have a tablespace",Useful
/*Put the node to the LRU list*/,"nan


 /*Put the node to the LRU list*/

nan
",Useful
/*Allocate read buffer*/,"-10. 		xb_fil_cur_close(cursor);
-9. 		return(XB_FIL_CUR_SKIP);
-8. 	}
-7. 	if (srv_file_flush_method == SRV_O_DIRECT
-6. 	    || srv_file_flush_method == SRV_O_DIRECT_NO_FSYNC) {
-5. 		os_file_set_nocache(cursor->file, node->name, ""OPEN"");
-4. 	}
-3. 	po",Useful
/*We ignore the doublewrite buffer pages.*/,"-10. 	return(XB_FIL_CUR_SUCCESS);
-9. }
-8. static bool page_is_corrupted(const byte *page, ulint page_no,
-7. 			      const xb_fil_cur_t *cursor,
-6. 			      const fil_space_t *space)
-5. {
-4. 	byte tmp_frame[UNIV_PAGE_SIZE_MAX];
-3. 	byte tmp_page[UN",Useful
/*Validate page number.*/,"-5. 	if (cursor->space_id == TRX_SYS_SPACE
-4. 	    && page_no >= FSP_EXTENT_SIZE
-3. 	    && page_no < FSP_EXTENT_SIZE * 3) {
-2. 		return false;
-1. 	}

 /*Validate page number.*/

1. 	if (mach_read_from_4(page + FIL_PAGE_OFFSET) != page_no
2. 	    && c",Useful
"/*On pages that are not all zero, the
		page number must match.

		There may be a mismatch on tablespace ID,
		because files may be renamed during backup.
		We disable the page number check
		on the system tablespace, because it may consist
		of multiple files, and here we count the pages
		from the start of each file.)

		The first 38 and last 8 bytes are never encrypted.*/","-2. 	if (mach_read_from_4(page + FIL_PAGE_OFFSET) != page_no
-1. 	    && cursor->space_id != TRX_SYS_SPACE) {

 /*On pages that are not all zero, the
		page number must match.

		There may be a mismatch on tablespace ID,
		because files may be renamed dur",Useful
/*Whole zero page is valid.*/,"-10. 		from the start of each file.)
-9. 		The first 38 and last 8 bytes are never encrypted. */
-8. 		const ulint* p = reinterpret_cast<const ulint*>(page);
-7. 		const ulint* const end = reinterpret_cast<const ulint*>(
-6. 			page + page_size);
-5. 		do",Useful
"/*Validate encrypted pages. The first page is never encrypted.
	In the system tablespace, the first page would be written with
	FIL_PAGE_FILE_FLUSH_LSN at shutdown, and if the LSN exceeds
	4,294,967,295, the mach_read_from_4() below would wrongly
	interpret the page as encrypted. We prevent that by checking
	page_no first.*/","-5. 		return false;
-4. 	}
-3. 	if (space->full_crc32()) {
-2. 		return buf_page_is_corrupted(true, page, space->flags);
-1. 	}

 /*Validate encrypted pages. The first page is never encrypted.
	In the system tablespace, the first page would be written wit",Useful
"/*Compressed encrypted need to be decrypted
		and decompressed for verification.*/","-10. 	4,294,967,295, the mach_read_from_4() below would wrongly
-9. 	interpret the page as encrypted. We prevent that by checking
-8. 	page_no first. */
-7. 	if (page_no
-6. 	    && mach_read_from_4(page + FIL_PAGE_FILE_FLUSH_LSN_OR_KEY_VERSION)
-5. 	    ",Useful
"/************************************************************************
Reads and verifies the next block of pages from the source
file. Positions the cursor after the last read non-corrupted page.

@return XB_FIL_CUR_SUCCESS if some have been read successfully, XB_FIL_CUR_EOF
if there are no more pages to read and XB_FIL_CUR_ERROR on error.*/","
	ulonglong max_file_size)
{
	bool	success;
	int err;


 /************************************************************************
Reads and verifies the next block of pages from the source
file. Positions the cursor after the last read non-corrupted page.

@return XB_FIL_CUR_SUCCESS if some have been read successfully, XB_FIL_CUR_EOF
if there are no more pages to read and XB_FIL_CUR_ERROR on error.*/

1. xb_fil_cur_result_t xb_fil_cur_read(xb_fil_cur_t*	cursor,
2.                                     CorruptedPages &corrupted_pages)
3. {
4. 	byte*			page;
5. 	unsigned			i;
6. 	ulint			npages;
7. 	ulint			retry_count;
8. 	xb_fil_cur_result_t	ret;
9. 	ib_int64_t		offset;
10. 	ib_int64_t		to_read;",Useful
"/*check pages for corruption and re-read if necessary. i.e. in case of
	partially written pages*/","-10. 	cursor->buf_read = 0;
-9. 	cursor->buf_npages = 0;
-8. 	cursor->buf_offset = offset;
-7. 	cursor->buf_page_no = static_cast<unsigned>(offset / page_size);
-6. 	if (os_file_read(IORequestRead, cursor->file, cursor->buf, offset,
-5. 			  (ulint) to_re",Useful
"/*Last line found by the current incremental search, so we don't `find'
   identical lines many times in a row.  Now part of isearch context.*/","-5. extern HIST_ENTRY *_rl_saved_line_for_history;
-4. static int rl_search_history PARAMS((int, int));
-3. static _rl_search_cxt *_rl_isearch_init PARAMS((int));
-2. static void _rl_isearch_fini PARAMS((_rl_search_cxt *));
-1. static int _rl_isearch_clea",Useful
/*Last search string and its length.*/,"-8. extern HIST_ENTRY *_rl_saved_line_for_history;
-7. static int rl_search_history PARAMS((int, int));
-6. static _rl_search_cxt *_rl_isearch_init PARAMS((int));
-5. static void _rl_isearch_fini PARAMS((_rl_search_cxt *));
-4. static int _rl_isearch_clea",Useful
"/*Search backwards through the history looking for a string which is typed
   interactively.  Start with the current line.*/","-10. void
-9. _rl_scxt_dispose (cxt, flags)
-8.      _rl_search_cxt *cxt;
-7.      int flags __attribute__((unused));
-6. {
-5.   FREE (cxt->search_string);
-4.   FREE (cxt->allocated_line);
-3.   FREE (cxt->lines);
-2.   free (cxt);
-1. }

 /*Search back",Useful
"/*Search forwards through the history looking for a string which is typed
   interactively.  Start with the current line.*/","-6. int
-5. rl_reverse_search_history (sign, key)
-4.      int sign, key;
-3. {
-2.   return (rl_search_history (-sign, key));
-1. }

 /*Search forwards through the history looking for a string which is typed
   interactively.  Start with the current line",Useful
"/*Display the current state of the search in the echo-area.
   SEARCH_STRING contains the string that is being searched for,
   DIRECTION is zero for forward, or non-zero for reverse,
   WHERE is the history list number of the current line.  If it is
   -1, then this line is the starting one.*/","-6. int
-5. rl_forward_search_history (sign, key)
-4.      int sign, key;
-3. {
-2.   return (rl_search_history (sign, key));
-1. }

 /*Display the current state of the search in the echo-area.
   SEARCH_STRING contains the string that is being searched f",Useful
/*Create an arrary of pointers to the lines that we want to search.*/,"-10.      int direction;
-9. {
-8.   _rl_search_cxt *cxt;
-7.   register int i;
-6.   HIST_ENTRY **hlist;
-5.   cxt = _rl_scxt_alloc (RL_SEARCH_ISEARCH, 0);
-4.   if (direction < 0)
-3.     cxt->sflags |= SF_REVERSE;
-2.   cxt->search_terminators = _rl_is",Useful
"/*Allocate space for this many lines, +1 for the current input line,
     and remember those lines.*/","-5.   hlist = history_list ();
-4.   rl_maybe_replace_line ();
-3.   i = 0;
-2.   if (hlist)
-1.     for (i = 0; hlist[i]; i++);

 /*Allocate space for this many lines, +1 for the current input line,
     and remember those lines.*/

1.   cxt->lines = (ch",Useful
/*The line where we start the search.*/,"-5.       cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
-4.       strcpy (cxt->allocated_line, &rl_line_buffer[0]);
-3.       cxt->lines[i] = cxt->allocated_line;
-2.     }
-1.   cxt->hlen++;

 /*The line where we start the search.*",Useful
/*Initialize search parameters.*/,"-2.   cxt->history_pos = cxt->save_line;
-1.   rl_save_prompt ();

 /*Initialize search parameters.*/

1.   cxt->search_string = (char *)xmalloc (cxt->search_string_size = 128);
2.   cxt->search_string[cxt->search_string_index = 0] = '\0';",Useful
/*First put back the original state.*/,"-6.   return cxt;
-5. }
-4. static void
-3. _rl_isearch_fini (cxt)
-2.      _rl_search_cxt *cxt;
-1. {

 /*First put back the original state.*/

1.   strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
2.   rl_restore_prompt ();",Useful
/*Save the search string for possible later use.*/,"-2.   strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
-1.   rl_restore_prompt ();

 /*Save the search string for possible later use.*/

1.   FREE (last_isearch_string);
2.   last_isearch_string = cxt->search_string;
3.   last_isearch_string_len = cxt",Useful
"/*If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position.*/","-8.   FREE (last_isearch_string);
-7.   last_isearch_string = cxt->search_string;
-6.   last_isearch_string_len = cxt->search_string_index;
-5.   cxt->search_string = 0;
-4.   if (cxt->last_found_line < cxt->save_line)
-3.     rl_get_previous_history (cxt",Useful
/*Read a key and decide how to proceed.*/,"-7.   rl_clear_message ();
-6. }
-5. int
-4. _rl_search_getchar (cxt)
-3.      _rl_search_cxt *cxt;
-2. {
-1.   int c;

 /*Read a key and decide how to proceed.*/

1.   RL_SETSTATE(RL_STATE_MOREINPUT);
2.   c = cxt->lastc = rl_read_key ();
3.   RL_UNSETST",Useful
"/*Process just-read character C according to isearch context CXT.  Return
   -1 if the caller should just free the context and return, 0 if we should
   break out of the loop, and 1 if we should continue to read characters.*/","-9.   RL_SETSTATE(RL_STATE_MOREINPUT);
-8.   c = cxt->lastc = rl_read_key ();
-7.   RL_UNSETSTATE(RL_STATE_MOREINPUT);
-6. #if defined (HANDLE_MULTIBYTE)
-5.   if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
-4.     c = cxt->lastc = _rl_read_mbstring (cxt->l",Useful
"/*The characters in isearch_terminators (set from the user-settable
     variable isearch-terminators) are used to terminate the search but
     not subsequently execute the character as a command.  The default
     value is ""\033\012"" (ESC and C-J).*/","-2. 	cxt->lastc = -6;
-1.     }

 /*The characters in isearch_terminators (set from the user-settable
     variable isearch-terminators) are used to terminate the search but
     not subsequently execute the character as a command.  The default
     value",Useful
"/*ESC still terminates the search, but if there is pending
	 input or if input arrives within 0.1 seconds (on systems
	 with select(2)) it is used as a prefix character
	 with rl_execute_next.  WATCH OUT FOR THIS!  This is intended
	 to allow the arrow keys to be used like ^F and ^B are used
	 to terminate the search and execute the movement command.
	 XXX - since _rl_input_available depends on the application-
	 settable keyboard timeout value, this could alternatively
	 use _rl_input_queued(100000)*/","-2.   if (strchr (cxt->search_terminators, cxt->lastc))
-1.     {

 /*ESC still terminates the search, but if there is pending
	 input or if input arrives within 0.1 seconds (on systems
	 with select(2)) it is used as a prefix character
	 with rl_execute_",Useful
"/*This sets rl_pending_input to c; it will be picked up the next
	     time rl_read_key is called.*/","-10. 	rl_execute_next (ESC);
-9.       return (0);
-8.     }
-7. #define ENDSRCH_CHAR(c) \
-6.   ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))
-5. #if defined (HANDLE_MULTIBYTE)
-4.   if (MB_CUR_MAX > 1 && rl_byte_oriented == ",Useful
"/*Now dispatch on the character.  `Opcodes' affect the search string or
     state.  Other characters are added to the string.*/","-3. 	rl_execute_next (cxt->lastc);
-2. 	return (0);
-1.       }

 /*Now dispatch on the character.  `Opcodes' affect the search string or
     state.  Other characters are added to the string.*/

1.   switch (cxt->lastc)
2.     {",Useful
/*delete character from search string.*/,"-7.     case -2:
-6.       cxt->direction = -cxt->direction;
-5.       if (cxt->direction < 0)
-4. 	cxt->sflags |= SF_REVERSE;
-3.       else
-2. 	cxt->sflags &= ~SF_REVERSE;
-1.       break;

 /*delete character from search string.*/

111",Useful
"/*This is tricky.  To do this right, we need to keep a
	 stack of search positions for the current search, with
	 sentinels marking the beginning and end.  But this will
	 do until we have a real isearch-undo.*/","-9.     case -2:
-8.       cxt->direction = -cxt->direction;
-7.       if (cxt->direction < 0)
-6. 	cxt->sflags |= SF_REVERSE;
-5.       else
-4. 	cxt->sflags &= ~SF_REVERSE;
-3.       break;

 /*This is tricky.  To do this right, we need to keep a
	 stac",Useful
"/*if not in a word, move to one.*/","-6.       wstart = rl_point + cxt->search_string_index;
-5.       if (wstart >= rl_end)
-4. 	{
-3. 	  rl_ding ();
-2. 	  break;
-1. 	}

 /*if not in a word, move to one.*/

1.       cval = _rl_char_value (rl_line_buffer, wstart);
2.       if (_rl_walphabe",Useful
/*Add character to search string and continue search.*/,"-10.       n = rl_end - wstart + 1;
-9.       if (cxt->search_string_index + n + 1 >= cxt->search_string_size)
-8. 	{
-7. 	  cxt->search_string_size += n + 1;
-6. 	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
-5. ",Useful
"/*Move to the next line, but skip new copies of the line
	 we just found and lines shorter than the string we're
	 searching for.*/","-10. 	  if (STREQN (cxt->search_string, cxt->sline + cxt->sline_index, cxt->search_string_index))
-9. 	    {
-8. 	      cxt->sflags |= SF_FOUND;
-7. 	      break;
-6. 	    }
-5. 	  else
-4. 	    cxt->sline_index += cxt->direction;
-3. 	}
-2.       if (cxt",Useful
/*Now set up the line for searching...*/,"-7. 	  cxt->sline = cxt->lines[cxt->history_pos];
-6. 	  cxt->sline_len = strlen (cxt->sline);
-5. 	}
-4.       while ((cxt->prev_line_found && STREQ (cxt->prev_line_found, cxt->lines[cxt->history_pos])) ||
-3. 	     (cxt->search_string_index > cxt->sline",Useful
/*We cannot find the search string.  Ding the bell.*/,"-4.       cxt->sline_index = (cxt->sflags & SF_REVERSE) ? cxt->sline_len - cxt->search_string_index : 0;
-3.     }
-2.   if (cxt->sflags & SF_FAILED)
-1.     {

 /*We cannot find the search string.  Ding the bell.*/

1.       rl_ding ();
2.       cxt->his",Useful
"/*We have found the search string.  Just display it.  But don't
     actually move there in the history list until the user accepts
     the location.*/","-4.       rl_ding ();
-3.       cxt->history_pos = cxt->last_found_line;
-2.       return 1;
-1.     }

 /*We have found the search string.  Just display it.  But don't
     actually move there in the history list until the user accepts
     the location.",Useful
"/*If we are using the callback interface, all we do is set up here and
      return.  The key is that we leave RL_STATE_ISEARCH set.*/","-4.   int r;
-3.   RL_SETSTATE(RL_STATE_ISEARCH);
-2.   cxt = _rl_isearch_init (direction);
-1.   rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);

 /*If we are using the callback interface, all we do is set up here and
      return",Useful
"/*The searching is over.  The user may have found the string that she
     was looking for, or else she may have exited a failing search.  If
     LINE_INDEX is -1, then that shows that the string searched for was
     not found.  We use this to determine where to place rl_point.*/","-4.       r = _rl_isearch_dispatch (cxt, cxt->lastc);
-3.       if (r <= 0)
-2.         break;
-1.     }

 /*The searching is over.  The user may have found the string that she
     was looking for, or else she may have exited a failing search.  If
     L",Useful
"/*Called from the callback functions when we are ready to read a key.  The
   callback functions know to call this because RL_ISSTATE(RL_STATE_ISEARCH).
   If _rl_isearch_dispatch finishes searching, this function is responsible
   for turning off RL_STATE_ISEARCH, which it does using _rl_isearch_cleanup.*/","-3.   return (_rl_isearch_cleanup (cxt, r));
-2. }
-1. #if defined (READLINE_CALLBACKS)

 /*Called from the callback functions when we are ready to read a key.  The
   callback functions know to call this because RL_ISSTATE(RL_STATE_ISEARCH).
   If _rl_is",Useful
/*complete.c -- filename completion for readline.*/,"
/* complete.c -- filename completion for readline. */


 /*complete.c -- filename completion for readline.*/

1. /* Copyright (C) 1987-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
"/*If non-zero, then this is the address of a function to call when
   completing a word would normally display the list of possible matches.
   This function is called instead of actually doing the display.
   It takes three arguments: (char **matches, int num_matches, int max_length)
   where MATCHES is the array of strings that matched, NUM_MATCHES is the
   number of strings in that array, and MAX_LENGTH is the length of the
   longest string in that array.*/","-3. #if defined (HAVE_GETPWENT) && (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))
-2. extern struct passwd *getpwent PARAMS((void));

 /*If non-zero, then this is the address of a function to call when
   completing a word would normally display",Useful
"/*If non-zero, non-unique completions always show the list of matches.*/","-10. static void display_matches PARAMS((char **));
-9. static int compute_lcd_of_matches PARAMS((char **, int, const char *));
-8. static int postprocess_matches PARAMS((char ***, int));
-7. static char *make_quoted_replacement PARAMS((char *, int, char ",Useful
"/*If non-zero, non-unique completions show the list of matches, unless it
   is not possible to do partial completion and modify the line.*/","-10. static int postprocess_matches PARAMS((char ***, int));
-9. static char *make_quoted_replacement PARAMS((char *, int, char *));

 /*If non-zero, non-unique completions show the list of matches, unless it
   is not possible to do partial completion an",Useful
"/*If non-zero, completed directory names have a slash appended.*/","-4. int _rl_complete_show_all = 0;

 /*If non-zero, completed directory names have a slash appended.*/

1. int _rl_complete_mark_directories = 1;",Useful
"/*If non-zero, the symlinked directory completion behavior introduced in
   readline-4.2a is disabled, and symlinks that point to directories have
   a slash appended (subject to the value of _rl_complete_mark_directories).
   This is user-settable via the mark-symlinked-directories variable.*/","-1. int _rl_complete_mark_directories = 1;

 /*If non-zero, the symlinked directory completion behavior introduced in
   readline-4.2a is disabled, and symlinks that point to directories have
   a slash appended (subject to the value of _rl_complete_mark_",Useful
"/*If non-zero, completions are printed horizontally in alphabetical order,
   like `ls -x'.*/","-1. int _rl_complete_mark_symlink_dirs = 0;

 /*If non-zero, completions are printed horizontally in alphabetical order,
   like `ls -x'.*/

1. int _rl_print_completions_horizontally;",Useful
/*Non-zero means that case is not significant in filename completion.*/,"-1. int _rl_print_completions_horizontally;

 /*Non-zero means that case is not significant in filename completion.*/

1. #if defined (__MSDOS__) && !defined (__DJGPP__)
2. int _rl_completion_case_fold = 1;
3. #else
4. int _rl_completion_case_fold;
5. #en",Useful
"/*If non-zero, don't match hidden files (filenames beginning with a `.' on
   Unix) when doing filename completion.*/","-5. #if defined (__MSDOS__) && !defined (__DJGPP__)
-4. int _rl_completion_case_fold = 1;
-3. #else
-2. int _rl_completion_case_fold;
-1. #endif

 /*If non-zero, don't match hidden files (filenames beginning with a `.' on
   Unix) when doing filename comp",Useful
"/*Non-zero means add an additional character to each filename displayed
   during listing completion iff rl_filename_completion_desired which helps
   to indicate the type of file being listed.*/","-1. #if defined (VISIBLE_STATS)

 /*Non-zero means add an additional character to each filename displayed
   during listing completion iff rl_filename_completion_desired which helps
   to indicate the type of file being listed.*/

1. int rl_visible_stats ",Useful
"/*If non-zero, then this is the address of a function to call when
   completing on a directory name.  The function is called with
   the address of a string (the current directory name) as an arg.*/","-2. int rl_visible_stats = 0;

 /*If non-zero, then this is the address of a function to call when
   completing on a directory name.  The function is called with
   the address of a string (the current directory name) as an arg.*/

1. rl_icppfunc_t *rl_d",Useful
/*Non-zero means readline completion functions perform tilde expansion.*/,"-2. rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;
-1. rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;

 /*Non-zero means readline completion functions perform tilde expansion.*/

1. int rl_complete_with_tilde_expan",Useful
"/*Pointer to the generator function for completion_matches ().
   NULL means to use rl_filename_completion_function (), the default filename
   completer.*/","-1. int rl_complete_with_tilde_expansion = 0;

 /*Pointer to the generator function for completion_matches ().
   NULL means to use rl_filename_completion_function (), the default filename
   completer.*/

1. rl_compentry_func_t *rl_completion_entry_funct",Useful
"/*Pointer to alternative function to create matches.
   Function is called with TEXT, START, and END.
   START and END are indices in RL_LINE_BUFFER saying what the boundaries
   of TEXT are.
   If this function exists and returns NULL then call the value of
   rl_completion_entry_function to try to match, otherwise use the
   array of strings returned.*/","-1. rl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;

 /*Pointer to alternative function to create matches.
   Function is called with TEXT, START, and END.
   START and END are indices in RL_LINE_BUFFER saying what the bou",Useful
"/*Non-zero means to suppress normal filename completion after the
   user-specified completion function has been called.*/","-1. rl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;

 /*Non-zero means to suppress normal filename completion after the
   user-specified completion function has been called.*/

1. int rl_attempted_completion_over = ",Useful
"/*Set to a character indicating the type of completion being performed
   by rl_complete_internal, available for use by application completion
   functions.*/","-1. int rl_attempted_completion_over = 0;

 /*Set to a character indicating the type of completion being performed
   by rl_complete_internal, available for use by application completion
   functions.*/

1. int rl_completion_type = 0;",Useful
"/*Up to this many items will be displayed in response to a
   possible-completions call.  After that, we ask the user if
   she is sure she wants to see them all.  A negative value means
   don't ask.*/","-1. int rl_completion_type = 0;

 /*Up to this many items will be displayed in response to a
   possible-completions call.  After that, we ask the user if
   she is sure she wants to see them all.  A negative value means
   don't ask.*/

1. int rl_complet",Useful
"/*The basic list of characters that signal a break between words for the
   completer routine.  The contents of this variable is what breaks words
   in the shell, i.e. "" \t\n\""\\'`@$><=""*/","-2. int rl_completion_query_items = 100;
-1. int _rl_page_completions = 1;

 /*The basic list of characters that signal a break between words for the
   completer routine.  The contents of this variable is what breaks words
   in the shell, i.e. "" \t\n\""\",Useful
/*List of basic quoting characters.*/,"-6. int rl_completion_query_items = 100;
-5. int _rl_page_completions = 1;

 /*List of basic quoting characters.*/

111",Useful
"/*The list of characters that signal a break between words for
   rl_complete_internal.  The default list is the contents of
   rl_basic_word_break_characters.*/","-1. const char *rl_basic_quote_characters = ""\""'"";

 /*The list of characters that signal a break between words for
   rl_complete_internal.  The default list is the contents of
   rl_basic_word_break_characters.*/

111",Useful
"/*Hook function to allow an application to set the completion word
   break characters before readline breaks up the line.  Allows
   position-dependent word break characters.*/","-5. const char *rl_basic_quote_characters = ""\""'"";

 /*Hook function to allow an application to set the completion word
   break characters before readline breaks up the line.  Allows
   position-dependent word break characters.*/

1. rl_cpvfunc_t *rl_com",Useful
"/*List of characters which can be used to quote a substring of the line.
   Completion occurs on the entire substring, and within the substring
   rl_completer_word_break_characters are treated as any other character,
   unless they also appear within this list.*/","-1. rl_cpvfunc_t *rl_completion_word_break_hook = (rl_cpvfunc_t *)NULL;

 /*List of characters which can be used to quote a substring of the line.
   Completion occurs on the entire substring, and within the substring
   rl_completer_word_break_characters",Useful
/*List of characters that should be quoted in filenames by the completer.*/,"-1. const char *rl_completer_quote_characters = (const char *)NULL;

 /*List of characters that should be quoted in filenames by the completer.*/

1. const char *rl_filename_quote_characters = (const char *)NULL;",Useful
"/*List of characters that are word break characters, but should be left
   in TEXT when it is passed to the completion function.  The shell uses
   this to help determine what kind of completing to do.*/","-1. const char *rl_filename_quote_characters = (const char *)NULL;

 /*List of characters that are word break characters, but should be left
   in TEXT when it is passed to the completion function.  The shell uses
   this to help determine what kind of co",Useful
"/*Non-zero means that the results of the matches are to be treated
   as filenames.  This is ALWAYS zero on entry, and can only be changed
   within a completion entry finder function.*/","-1. int rl_ignore_completion_duplicates = 1;

 /*Non-zero means that the results of the matches are to be treated
   as filenames.  This is ALWAYS zero on entry, and can only be changed
   within a completion entry finder function.*/

1. int rl_filename_c",Useful
"/*Non-zero means that the results of the matches are to be quoted using
   double quotes (or an application-specific quoting mechanism) if the
   filename contains any characters in rl_filename_quote_chars.  This is
   ALWAYS non-zero on entry, and can only be changed within a completion
   entry finder function.*/","-1. int rl_filename_completion_desired = 0;

 /*Non-zero means that the results of the matches are to be quoted using
   double quotes (or an application-specific quoting mechanism) if the
   filename contains any characters in rl_filename_quote_chars.  T",Useful
"/*This function, if defined, is called by the completer when real
   filename completion is done, after all the matching names have been
   generated. It is passed a (char**) known as matches in the code below.
   It consists of a NULL-terminated array of pointers to potential
   matching strings.  The 1st element (matches[0]) is the maximal
   substring that is common to all matches. This function can re-arrange
   the list of matches as required, but all elements of the array must be
   free()'d if they are deleted. The main intent of this function is
   to implement FIGNORE a la SunOS csh.*/","-1. int rl_filename_quoting_desired = 1;

 /*This function, if defined, is called by the completer when real
   filename completion is done, after all the matching names have been
   generated. It is passed a (char**) known as matches in the code below.
 ",Useful
"/*Set to a function to quote a filename in an application-specific fashion.
   Called with the text to quote, the type of match found (single or multiple)
   and a pointer to the quoting character to be used, which the function can
   reset if desired.*/","-1. rl_compignore_func_t *rl_ignore_some_completions_function = (rl_compignore_func_t *)NULL;

 /*Set to a function to quote a filename in an application-specific fashion.
   Called with the text to quote, the type of match found (single or multiple)
   a",Useful
"/*Function to call to remove quoting characters from a filename.  Called
   before completion is attempted, so the embedded quotes do not interfere
   with matching names in the file system.  Readline doesn't do anything
   with this; it's set only by applications.*/","-1. rl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;

 /*Function to call to remove quoting characters from a filename.  Called
   before completion is attempted, so the embedded quotes do not interfere
   with matching names in the file",Useful
"/*Function to call to decide whether or not a word break character is
   quoted.  If a character is quoted, it does not break words for the
   completer.*/","-1. rl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;

 /*Function to call to decide whether or not a word break character is
   quoted.  If a character is quoted, it does not break words for the
   completer.*/

1. rl_linebuf",Useful
"/*If non-zero, the completion functions don't append anything except a
   possible closing quote.  This is set to 0 by rl_complete_internal and
   may be changed by an application-specific completion function.*/","-1. rl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;

 /*If non-zero, the completion functions don't append anything except a
   possible closing quote.  This is set to 0 by rl_complete_internal and
   may be changed by an application-s",Useful
"/*Character appended to completed words when at the end of the line.  The
   default is a space.*/","-1. int rl_completion_suppress_append = 0;

 /*Character appended to completed words when at the end of the line.  The
   default is a space.*/

1. int rl_completion_append_character = ' ';",Useful
"/*If non-zero, the completion functions don't append any closing quote.
   This is set to 0 by rl_complete_internal and may be changed by an
   application-specific completion function.*/","-1. int rl_completion_append_character = ' ';

 /*If non-zero, the completion functions don't append any closing quote.
   This is set to 0 by rl_complete_internal and may be changed by an
   application-specific completion function.*/

1. int rl_completi",Useful
"/*Set to any quote character readline thinks it finds before any application
   completion function is called.*/","-1. int rl_completion_suppress_quote = 0;

 /*Set to any quote character readline thinks it finds before any application
   completion function is called.*/

1. int rl_completion_quote_character;",Useful
"/*If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that application completion functions can override the user's preference
   (set via the mark-symlinked-directories variable) if appropriate.
   It's set to the value of _rl_complete_mark_symlink_dirs in
   rl_complete_internal before any application-specific completion
   function is called, so without that function doing anything, the user's
   preferences are honored.*/","-1. int rl_completion_found_quote;

 /*If non-zero, a slash will be appended to completed filenames that are
   symbolic links to directory names, subject to the value of the
   mark-directories variable (which is user-settable).  This exists so
   that a",Useful
/*Local variable states what happened during the last completion attempt.*/,"-2. int rl_inhibit_completion;

 /*Local variable states what happened during the last completion attempt.*/

1. static int completion_changed_buffer;",Useful
"/*Complete the word at or before point.  You have supplied the function
   that does the initial simple matching selection algorithm (see
   rl_completion_matches ()).  The default is to do filename completion.*/","-6. static int completion_changed_buffer;

 /*Complete the word at or before point.  You have supplied the function
   that does the initial simple matching selection algorithm (see
   rl_completion_matches ()).  The default is to do filename completion.*",Useful
"/*Return the correct value to pass to rl_complete_internal performing
   the same tests as rl_complete.  This allows consecutive calls to an
   application's completion function to list possible completions and for
   an application-specific completion function to honor the
   show-all-if-ambiguous readline variable.*/","-10.      int ignore __attribute__((unused)), invoking_key __attribute__((unused));
-9. {
-8.   return (rl_complete_internal ('?'));
-7. }
-6. int
-5. rl_insert_completions (ignore, invoking_key)
-4.      int ignore __attribute__((unused)), invoking_key _",Useful
/*Completion utility functions*/,"-10.     return '?';
-9.   else if (_rl_complete_show_all)
-8.     return '!';
-7.   else if (_rl_complete_show_unmodified)
-6.     return '@';
-5.   else
-4.     return TAB;
-3. }

 /*Completion utility functions*/

111",Useful
"/*Set default values for readline word completion.  These are the variables
   that application completion functions can change or inspect.*/","-10.   else if (_rl_complete_show_unmodified)
-9.     return '@';
-8.   else
-7.     return TAB;
-6. }

 /*Set default values for readline word completion.  These are the variables
   that application completion functions can change or inspect.*/

1. stat",Useful
/*Only the completion entry function can change these.*/,"-4. static void
-3. set_completion_defaults (what_to_do)
-2.      int what_to_do;
-1. {

 /*Only the completion entry function can change these.*/

1.   rl_filename_completion_desired = 0;
2.   rl_filename_quoting_desired = 1;
3.   rl_completion_type = wh",Useful
/*The completion entry function may optionally change this.*/,"-4.   rl_filename_completion_desired = 0;
-3.   rl_filename_quoting_desired = 1;
-2.   rl_completion_type = what_to_do;
-1.   rl_completion_suppress_append = rl_completion_suppress_quote = 0;

 /*The completion entry function may optionally change this.*/",Useful
"/*Return the character which best describes FILENAME.
     `@' for symbolic links
     `/' for directories
     `*' for executables
     `=' for sockets
     `|' for FIFOs
     `%' for character special devices
     `#' for block special devices*/","-10.     return 0;
-9. }
-8. static int
-7. path_isdir (filename)
-6.      const char *filename;
-5. {
-4.   struct stat finfo;
-3.   return (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode));
-2. }
-1. #if defined (VISIBLE_STATS)

 /*Return the ch",Useful
"/*Return the portion of PATHNAME that should be output when listing
   possible completions.  If we are hacking filename completion, we
   are only interested in the basename, the portion following the
   final slash.  Otherwise, we return what we were passed.  Since
   printing empty strings is not very informative, if we're doing
   filename completion, and the basename is the empty string, we look
   for the previous slash and return the portion following that.  If
   there's no previous slash, we just return what we were passed.*/","-10.     character = '|';
-9. #endif
-8.   else if (S_ISREG (finfo.st_mode))
-7.     {
-6.       if (access (filename, X_OK) == 0)
-5. 	character = '*';
-4.     }
-3.   return (character);
-2. }

 /*Return the portion of PATHNAME that should be output whe",Useful
"/*If the basename is NULL, we might have a pathname like '/usr/src/'.
     Look for a previous slash and, if one is found, return the portion
     following that slash.  If there's no previous slash, just return the
     pathname we were passed.*/","-8.     return (pathname);
-7.   temp = strrchr (pathname, '/');
-6. #if defined (__MSDOS__)
-5.   if (temp == 0 && ISALPHA ((unsigned char)pathname[0]) && pathname[1] == ':')
-4.     temp = pathname + 1;
-3. #endif
-2.   if (temp == 0 || *temp == '\0')
-",Useful
/*Compute width of STRING when displayed on screen by print_filename*/,"-10.   else if (temp[1] == '\0')
-9.     {
-8.       for (x = temp - 1; x > pathname; x--)
-7.         if (*x == '/')
-6.           break;
-5.       return ((*x == '/') ? x + 1 : pathname);
-4.     }
-3.   else
-2.     return ++temp;
-1. }

 /*Compute wid",Useful
"/*Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
   are using it, check for and output a single character for `special'
   filenames.  Return the number of characters we output.*/","-10. 	  printed_len += width;
-9. #else
-8. 	  putc (*s, rl_outstream);
-7. 	  s++;
-6. 	  printed_len++;
-5. #endif
-4. 	}
-3.     }
-2.   return printed_len;
-1. }

 /*Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
   are using it,",Useful
"/*If to_print != full_pathname, to_print is the basename of the
	 path passed.  In this case, we try to expand the directory
	 name before checking for the stat character.*/","-10.   char *s, c, *new_full_pathname;
-9.   const char *dn;
-8.   extension_char = 0;
-7.   printed_len = fnprint (to_print);
-6. #if defined (VISIBLE_STATS)
-5.  if (rl_filename_completion_desired && (rl_visible_stats || _rl_complete_mark_directories))
",Useful
"/*If setting the last slash in full_pathname to a NUL results in
	     full_pathname being the empty string, we are trying to complete
	     files in the root directory.  If we pass a null string to the
	     bash directory completion hook, for example, it will expand it
	     to the current directory.  We just want the `/'.*/","-2. 	  c = to_print[-1];
-1. 	  to_print[-1] = '\0';

 /*If setting the last slash in full_pathname to a NUL results in
	     full_pathname being the empty string, we are trying to complete
	     files in the root directory.  If we pass a null string to t",Useful
"/*Find the bounds of the current word for completion purposes, and leave
   rl_point set to the end of the word.  This function skips quoted
   substrings (characters between matched pairs of characters in
   rl_completer_quote_characters).  First we try to find an unclosed
   quoted substring on which to do matching.  If one is not found, we use
   the word break characters to find the boundaries of the current word.
   We call an application-specific function to decide whether or not a
   particular word break character is quoted; if that function returns a
   non-zero result, the character does not break a word.  This function
   returns the opening quote character if we found an unclosed quoted
   substring, '\0' otherwise.  FP, if non-null, is set to a value saying
   which (shell-like) quote characters we found (single quote, double
   quote, or backslash) anywhere in the string.  DP, if non-null, is set to
   the value of the delimiter character that caused a word break.*/","-10.      char *qcp;
-9. {
-8.   char *r;
-7.   r = (char *)xmalloc (strlen (s) + 2);
-6.   *r = *rl_completer_quote_characters;
-5.   strcpy (r + 1, s);
-4.   if (qcp)
-3.     *qcp = *rl_completer_quote_characters;
-2.   return r;
-1. }

 /*Find the boun",Useful
"/*We have a list of characters which can be used in pairs to
	 quote substrings for the completer.  Try to find the start
	 of an unclosed quoted substring.*/","-10.   end = rl_point;
-9.   found_quote = delimiter = 0;
-8.   quote_char = '\0';
-7.   brkchars = 0;
-6.   if (rl_completion_word_break_hook)
-5.     brkchars = (*rl_completion_word_break_hook) ();
-4.   if (brkchars == 0)
-3.     brkchars = rl_complete",Useful
/*FOUND_QUOTE is set so we know what kind of quotes we found.*/,"-10.   brkchars = 0;
-9.   if (rl_completion_word_break_hook)
-8.     brkchars = (*rl_completion_word_break_hook) ();
-7.   if (brkchars == 0)
-6.     brkchars = rl_completer_word_break_characters;
-5.   if (rl_completer_quote_characters)
-4.     {

 /*FO",Useful
"/*Shell-like semantics for single quotes -- don't allow backslash
	     to quote anything in single quotes, especially not the closing
	     quote.  If you don't like this, take out the check on the value
	     of quote_char.*/","-7.       for (scan = pass_next = 0; scan < end; scan = MB_NEXTCHAR (rl_line_buffer, scan, 1, MB_FIND_ANY))
-6. 	{
-5. 	  if (pass_next)
-4. 	    {
-3. 	      pass_next = 0;
-2. 	      continue;
-1. 	    }

 /*Shell-like semantics for single quotes -- don",Useful
/*Found start of a quoted substring.*/,"-6. 		  quote_char = '\0';
-5. 		  rl_point = end;
-4. 		}
-3. 	    }
-2. 	  else if (strchr (rl_completer_quote_characters, rl_line_buffer[scan]))
-1. 	    {

 /*Found start of a quoted substring.*/

1. 	      quote_char = rl_line_buffer[scan];
2. 	     ",Useful
"/*We didn't find an unclosed quoted substring upon which to do
         completion, so use the word break characters to find the
         substring on which to complete.*/","-10. 		found_quote |= RL_QF_SINGLE_QUOTE;
-9. 	      else if (quote_char == '""')
-8. 		found_quote |= RL_QF_DOUBLE_QUOTE;
-7. 	      else
-6. 		found_quote |= RL_QF_OTHER_QUOTE;      
-5. 	    }
-4. 	}
-3.     }
-2.   if (rl_point == end && quote_char == ",Useful
"/*Call the application-specific function to tell us whether
	     this word break character is quoted and should be skipped.*/","-5.       while ((rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_ANY)))
-4. 	{
-3. 	  scan = rl_line_buffer[rl_point];
-2. 	  if (strchr (brkchars, scan) == 0)
-1. 	    continue;

 /*Call the application-specific function to tell us whether
	  ",Useful
"/*If we are at an unquoted word break, then advance past it.*/","-3. 	  break;
-2. 	}
-1.     }

 /*If we are at an unquoted word break, then advance past it.*/

1.   scan = rl_line_buffer[rl_point];",Useful
"/*If there is an application-specific function to say whether or not
     a character is quoted and we found a quote character, let that
     function decide whether or not a character is a word break, even
     if it is found in rl_completer_word_break_characters.  Don't bother
     if we're at the end of the line, though.*/","-1.   scan = rl_line_buffer[rl_point];

 /*If there is an application-specific function to say whether or not
     a character is quoted and we found a quote character, let that
     function decide whether or not a character is a word break, even
     if",Useful
"/*If the character that caused the word break was a quoting
	     character, then remember it as the delimiter.*/","-10.   if (scan)
-9.     {
-8.       if (rl_char_is_quoted_p)
-7. 	isbrk = (found_quote == 0 ||
-6. 		(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&
-5. 		strchr (brkchars, scan) != 0;
-4.       else
-3. 	isbrk = strchr (brkchars, scan) != 0;
",Useful
"/*If the character isn't needed to determine something special
	     about what kind of completion to perform, then advance past it.*/","-4. 	  if (rl_basic_quote_characters &&
-3. 	      strchr (rl_basic_quote_characters, scan) &&
-2. 	      (end - rl_point) > 1)
-1. 	    delimiter = scan;

 /*If the character isn't needed to determine something special
	     about what kind of completion",Useful
"/*If the user wants to TRY to complete, but then wants to give
     up and use the default completion function, they set the
     variable rl_attempted_completion_function.*/","-10. static char **
-9. gen_completion_matches (text, start, end, our_func, found_quote, quote_char)
-8.      char *text;
-7.      int start, end;
-6.      rl_compentry_func_t *our_func;
-5.      int found_quote, quote_char;
-4. {
-3.   char **matches;
-2",Useful
"/*Filter out duplicates in MATCHES.  This frees up the strings in
   MATCHES.*/","-3.   matches = rl_completion_matches (text, our_func);
-2.   return matches;  
-1. }

 /*Filter out duplicates in MATCHES.  This frees up the strings in
   MATCHES.*/

1. static char **
2. remove_duplicate_matches (matches)
3.      char **matches;
4. {
5",Useful
/*Sort the items.*/,"-8. static char **
-7. remove_duplicate_matches (matches)
-6.      char **matches;
-5. {
-4.   char *lowest_common;
-3.   int i, j, newlen;
-2.   char dead_slot;
-1.   char **temp_array;

 /*Sort the items.*/

1.   for (i = 0; matches[i]; i++)
2.     ;",Useful
/*Remember the lowest common denominator for it may be unique.*/,"-2.   if (i)
-1.     qsort (matches+1, i-1, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);

 /*Remember the lowest common denominator for it may be unique.*/

1.   lowest_common = savestring (matches[0]);
2.   for (i = newlen = 0; matches[i + 1]; i",Useful
"/*We have marked all the dead slots with (char *)&dead_slot.
     Copy all the non-dead entries into a new array.*/","-10.   for (i = newlen = 0; matches[i + 1]; i++)
-9.     {
-8.       if (strcmp (matches[i], matches[i + 1]) == 0)
-7. 	{
-6. 	  free (matches[i]);
-5. 	  matches[i] = (char *)&dead_slot;
-4. 	}
-3.       else
-2. 	newlen++;
-1.     }

 /*We have marked a",Useful
"/*If there is one string left, and it is identical to the
     lowest common denominator, then the LCD is the string to
     insert.*/","-1.   temp_array[0] = lowest_common;

 /*If there is one string left, and it is identical to the
     lowest common denominator, then the LCD is the string to
     insert.*/

1.   if (j == 2 && strcmp (temp_array[0], temp_array[1]) == 0)
2.     {
3.      ",Useful
"/*Find the common prefix of the list of matches, and put it into
   matches[0].*/","-7.   if (j == 2 && strcmp (temp_array[0], temp_array[1]) == 0)
-6.     {
-5.       free (temp_array[1]);
-4.       temp_array[1] = (char *)NULL;
-3.     }
-2.   return (temp_array);
-1. }

 /*Find the common prefix of the list of matches, and put it into",Useful
/*Count of max-matched characters.*/,"-7. static int
-6. compute_lcd_of_matches (match_list, matches, text)
-5.      char **match_list;
-4.      int matches;
-3.      const char *text;
-2. {
-1.   register int i, c1, c2, si;

 /*Count of max-matched characters.*/

111",Useful
"/*If only one match, just use that.  Otherwise, compare each
     member of the list with the next, finding out where they
     stop matching.*/","-5. #if defined (HANDLE_MULTIBYTE)
-4.   int v;
-3.   mbstate_t ps1, ps2;
-2.   wchar_t wc1, wc2;
-1. #endif

 /*If only one match, just use that.  Otherwise, compare each
     member of the list with the next, finding out where they
     stop matching.*/",Useful
"/*If there were multiple matches, but none matched up to even the
     first character, and the user typed something, use that as the
     value of matches[0].*/","-10. 		  si += v - 1;
-9. 	      }
-8. 	    else
-7. #endif
-6. 	    if (c1 != c2)
-5. 	      break;
-4. 	}
-3.       if (low > si)
-2. 	low = si;
-1.     }

 /*If there were multiple matches, but none matched up to even the
     first character, and the ",Useful
"/*If we are ignoring case, try to preserve the case of the string
	 the user typed in the face of multiple matches differing in case.*/","-10.      value of matches[0]. */
-9.   if (low == 0 && text && *text)
-8.     {
-7.       match_list[0] = (char *)xmalloc (strlen (text) + 1);
-6.       strcpy (match_list[0], text);
-5.     }
-4.   else
-3.     {
-2.       match_list[0] = (char *)xmallo",Useful
"/*We're making an assumption here:
		IF we're completing filenames AND
		   the application has defined a filename dequoting function AND
		   we found a quote character AND
		   the application has requested filename quoting
		THEN
		   we assume that TEXT was dequoted before checking against
		   the file system and needs to be dequoted here before we
		   check against the list of matches
		FI*/","-2.       if (_rl_completion_case_fold)
-1. 	{

 /*We're making an assumption here:
		IF we're completing filenames AND
		   the application has defined a filename dequoting function AND
		   we found a quote character AND
		   the application has request",Useful
/*sort the list to get consistent answers.*/,"-10. 		FI */
-9. 	  dtext = (char *)NULL;
-8. 	  if (rl_filename_completion_desired &&
-7. 	      rl_filename_dequoting_function &&
-6. 	      rl_completion_found_quote &&
-5. 	      rl_filename_quoting_desired)
-4. 	    {
-3. 	      dtext = (*rl_filename",Useful
"/*It seems to me that in all the cases we handle we would like
     to ignore duplicate possiblilities.  Scan for the text to
     insert being identical to the other completions.*/","-10. static int
-9. postprocess_matches (matchesp, matching_filenames)
-8.      char ***matchesp;
-7.      int matching_filenames;
-6. {
-5.   char *t, **matches, **temp_matches;
-4.   int nmatch, i;
-3.   matches = *matchesp;
-2.   if (matches == 0)
-1. ",Useful
"/*If we are matching filenames, then here is our chance to
     do clever processing by re-examining the list.  Call the
     ignore function with the array as a parameter.  It can
     munge the array, deleting matches as it desires.*/","-6.   if (rl_ignore_completion_duplicates)
-5.     {
-4.       temp_matches = remove_duplicate_matches (matches);
-3.       free (matches);
-2.       matches = temp_matches;
-1.     }

 /*If we are matching filenames, then here is our chance to
     do cl",Useful
"/*If we removed some matches, recompute the common prefix.*/","-10. 	;
-9.       (void)(*rl_ignore_some_completions_function) (matches);
-8.       if (matches == 0 || matches[0] == 0)
-7. 	{
-6. 	  FREE (matches);
-5. 	  *matchesp = (char **)0;
-4. 	  return 0;
-3.         }
-2.       else
-1. 	{

 /*If we removed so",Useful
"/*A convenience function for displaying a list of strings in
   columnar format on readline's output stream.  MATCHES is the list
   of strings, in argv format, LEN is the number of strings in MATCHES,
   and MAX is the length of the longest string in MATCHES.*/","-10. 	    {
-9. 	      t = matches[0];
-8. 	      compute_lcd_of_matches (matches, i - 1, t);
-7. 	      FREE (t);
-6. 	    }
-5. 	}
-4.     }
-3.   *matchesp = matches;
-2.   return (1);
-1. }

 /*A convenience function for displaying a list of strings i",Useful
/*How many items of MAX length can we fit in the screen window?*/,"-10.    of strings, in argv format, LEN is the number of strings in MATCHES,
-9.    and MAX is the length of the longest string in MATCHES. */
-8. void
-7. rl_display_match_list (matches, len, max)
-6.      char **matches;
-5.      int len, max;
-4. {
-3.",Useful
"/*Avoid a possible floating exception.  If max > _rl_screenwidth,
     limit will be 0 and a divide-by-zero fault will result.*/","-4.   max += 2;
-3.   limit = _rl_screenwidth / max;
-2.   if (limit != 1 && (limit * max == _rl_screenwidth))
-1.     limit--;

 /*Avoid a possible floating exception.  If max > _rl_screenwidth,
     limit will be 0 and a divide-by-zero fault will result",Useful
"/*Watch out for special case.  If LEN is less than LIMIT, then
     just do the inner printing loop.
	   0 < len <= limit  implies  count = 1.*/","-1.   count = (len + (limit - 1)) / limit;

 /*Watch out for special case.  If LEN is less than LIMIT, then
     just do the inner printing loop.
	   0 < len <= limit  implies  count = 1.*/

111",Useful
/*Sort the items if they are not already sorted.*/,"-4.   count = (len + (limit - 1)) / limit;

 /*Sort the items if they are not already sorted.*/

1.   if (rl_ignore_completion_duplicates == 0)
2.     qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
3.   rl_crlf ();
4.   lin",Useful
"/*Print the sorted items, up-and-down alphabetically, like ls.*/","-6.   if (rl_ignore_completion_duplicates == 0)
-5.     qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
-4.   rl_crlf ();
-3.   lines = 0;
-2.   if (_rl_print_completions_horizontally == 0)
-1.     {

 /*Print the sorted ite",Useful
"/*Print the sorted items, across alphabetically, like ls -x.*/","-10. 	  if (_rl_page_completions && lines >= (_rl_screenheight - 1) && i < count)
-9. 	    {
-8. 	      lines = _rl_internal_pager (lines);
-7. 	      if (lines < 0)
-6. 		return;
-5. 	    }
-4. 	}
-3.     }
-2.   else
-1.     {

 /*Print the sorted items",Useful
"/*Display MATCHES, a list of matching filenames in argv format.  This
   handles the simple case -- a single match -- first.  If there is more
   than one match, we compute the number of strings in the list and the
   length of the longest string, which will be needed by the display
   function.  If the application wants to handle displaying the list of
   matches itself, it sets RL_COMPLETION_DISPLAY_MATCHES_HOOK to the
   address of a function, and we just call it.  If we're handling the
   display ourselves, we just call rl_display_match_list.  We also check
   that the list of matches doesn't exceed the user-settable threshold,
   and ask the user if he wants to see the list if there are more matches
   than RL_COMPLETION_QUERY_ITEMS.*/","-10. 		    }
-9. 		}
-8. 	      else
-7. 		for (k = 0; k < max - printed_len; k++)
-6. 		  putc (' ', rl_outstream);
-5. 	    }
-4. 	}
-3.       rl_crlf ();
-2.     }
-1. }

 /*Display MATCHES, a list of matching filenames in argv format.  This
   handles",Useful
/*Move to the last visible line of a possibly-multiple-line command.*/,"-10.    display ourselves, we just call rl_display_match_list.  We also check
-9.    that the list of matches doesn't exceed the user-settable threshold,
-8.    and ask the user if he wants to see the list if there are more matches
-7.    than RL_COMPLETI",Useful
/*Handle simple case first.  What if there is only one answer?*/,"-1.   _rl_move_vert (_rl_vis_botlin);

 /*Handle simple case first.  What if there is only one answer?*/

1.   if (matches[1] == 0)
2.     {
3.       temp = printable_part (matches[0]);
4.       rl_crlf ();
5.       print_filename (temp, matches[0]);
6.  ",Useful
"/*There is more than one answer.  Find out how many there are,
     and find the maximum printed length of a single entry.*/","-10.   if (matches[1] == 0)
-9.     {
-8.       temp = printable_part (matches[0]);
-7.       rl_crlf ();
-6.       print_filename (temp, matches[0]);
-5.       rl_crlf ();
-4.       rl_forced_update_display ();
-3.       rl_display_fixed = 1;
-2.       r",Useful
"/*If the caller has defined a display hook, then call that now.*/","-8.   for (max = 0, i = 1; matches[i]; i++)
-7.     {
-6.       temp = printable_part (matches[i]);
-5.       len = fnwidth (temp);
-4.       if (len > max)
-3. 	max = len;
-2.     }
-1.   len = i - 1;

 /*If the caller has defined a display hook, then ca",Useful
"/*If there are many items, then ask the user if she really wants to
     see them all.*/","-5.   if (rl_completion_display_matches_hook)
-4.     {
-3.       (*rl_completion_display_matches_hook) (matches, len, max);
-2.       return;
-1.     }

 /*If there are many items, then ask the user if she really wants to
     see them all.*/

1.   if (r",Useful
"/*Pointer to quoting character, if any*/","-10. 	}
-9.     }
-8.   rl_display_match_list (matches, len, max);
-7.   rl_forced_update_display ();
-6.   rl_display_fixed = 1;
-5. }
-4. static char *
-3. make_quoted_replacement (match, mtype, qc)
-2.      char *match;
-1.      int mtype;

 /*Pointer ",Useful
"/*If we are doing completion on quoted substrings, and any matches
     contain any of the completer_word_break_characters, then auto-
     matically prepend the substring with a quote character (just pick
     the first one from the list of such) if it does not already begin
     with a quote string.  FIXME: Need to remove any such automatically
     inserted quote character when it no longer is necessary, such as
     if we change the string we are completing on and the new set of
     matches don't require a quoted substring.*/","-3. {
-2.   int should_quote, do_replace;
-1.   char *replacement;

 /*If we are doing completion on quoted substrings, and any matches
     contain any of the completer_word_break_characters, then auto-
     matically prepend the substring with a quote c",Useful
"/*If there is a single match, see if we need to quote it.
         This also checks whether the common prefix of several
	 matches needs to be quoted.*/","-10.      matches don't require a quoted substring. */
-9.   replacement = match;
-8.   should_quote = match && rl_completer_quote_characters &&
-7. 			rl_filename_completion_desired &&
-6. 			rl_filename_quoting_desired;
-5.   if (should_quote)
-4.     s",Useful
"/*Quote the replacement, since we found an embedded
	 word break character in a potential match.*/","-4.       should_quote = rl_filename_quote_characters
-3. 			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
-2. 			: 0;
-1.       do_replace = should_quote ? mtype : NO_MATCH;

 /*Quote the replacement, since we found an embedded
	 word break ",Useful
/*Don't double an opening quote character.*/,"-2.   if (replacement)
-1.     {

 /*Don't double an opening quote character.*/

1.       if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&
2. 	    replacement[0] == *qc)
3. 	start--;",Useful
"/*If make_quoted_replacement changed the quoting character, remove
	 the opening quote and insert the (fully-quoted) replacement.*/","-3.       if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&
-2. 	    replacement[0] == *qc)
-1. 	start--;

 /*If make_quoted_replacement changed the quoting character, remove
	 the opening quote and insert the (fully-quoted) replacement.*/

1.",Useful
"/*Append any necessary closing quote and a separator character to the
   just-inserted match.  If the user has specified that directories
   should be marked by a trailing `/', append one of those instead.  The
   default trailing character is a space.  Returns the number of characters
   appended.  If NONTRIVIAL_MATCH is set, we test for a symlink (if the OS
   has them) and don't add a suffix for a symlink to a directory.  A
   nontrivial match is one that actually adds to the word being completed.
   The variable rl_completion_mark_symlink_dirs controls this behavior
   (it's initially set to the what the user has chosen, indicated by the
   value of _rl_complete_mark_symlink_dirs, but may be modified by an
   application's completion function).*/","-8.       else if (qc && (*qc != oqc) && start && rl_line_buffer[start - 1] == oqc &&
-7. 	    replacement[0] != oqc)
-6. 	start--;
-5.       _rl_replace_text (replacement, start, rl_point - 1);
-4.       if (replacement != match)
-3.         free (replac",Useful
"/*This is clumsy.  Avoid putting in a double slash if point
		 is at the end of the line and the previous character is a
		 slash.*/","-1. 	    {

 /*This is clumsy.  Avoid putting in a double slash if point
		 is at the end of the line and the previous character is a
		 slash.*/

1. 	      if (rl_point && rl_line_buffer[rl_point] == '\0' && rl_line_buffer[rl_point - 1] == '/')
2. 		;
3.",Useful
"/*Don't add anything if the filename is a symlink and resolves to a
	 directory.*/","-7. 	      if (rl_point && rl_line_buffer[rl_point] == '\0' && rl_line_buffer[rl_point - 1] == '/')
-6. 		;
-5. 	      else if (rl_line_buffer[rl_point] != '/')
-4. 		rl_insert_text (""/"");
-3. 	    }
-2. 	}
-1. #ifdef S_ISLNK

 /*Don't add anything if the",Useful
"/*Complete the word at or before point.
   WHAT_TO_DO says what to do with the completion.
   `?' means list the possible completions.
   TAB means do standard completion.
   `*' means insert all of the possible completions.
   `!' means to do standard completion, and list all possible completions if
   there is more than one.
   `@' means to do standard completion, and list all possible completions if
   there is more than one and partial completion is not possible.*/","-10. _rl_free_match_list (matches)
-9.      char **matches;
-8. {
-7.   register int i;
-6.   if (matches == 0)
-5.     return;
-4.   for (i = 0; matches[i]; i++)
-3.     free (matches[i]);
-2.   free (matches);
-1. }

 /*Complete the word at or before po",Useful
/*We now look backwards for the start of a filename/variable word.*/,"-10.   rl_compentry_func_t *our_func;
-9.   int start, end, delimiter, found_quote, i, nontrivial_lcd;
-8.   char *text, *saved_line_buffer;
-7.   char quote_char;
-6.   RL_SETSTATE(RL_STATE_COMPLETING);
-5.   set_completion_defaults (what_to_do);
-4.   s",Useful
"/*This (possibly) changes rl_point.  If it returns a non-zero char,
       we know we have an open quote.*/","-4.   end = rl_point;
-3.   found_quote = delimiter = 0;
-2.   quote_char = '\0';
-1.   if (rl_point)

 /*This (possibly) changes rl_point.  If it returns a non-zero char,
       we know we have an open quote.*/

1.     quote_char = _rl_find_completion_wo",Useful
"/*nontrivial_lcd is set if the common prefix adds something to the word
     being completed.*/","-5.     quote_char = _rl_find_completion_word (&found_quote, &delimiter);
-4.   start = rl_point;
-3.   rl_point = end;
-2.   text = rl_copy_text (start, end);
-1.   matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);

",Useful
"/*If we are matching filenames, the attempted completion function will
     have set rl_filename_completion_desired to a non-zero value.  The basic
     rl_filename_completion_function does this.*/","-10.   nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
-9.   free (text);
-8.   if (matches == 0)
-7.     {
-6.       rl_ding ();
-5.       FREE (saved_line_buffer);
-4.       completion_changed_buffer = 0;
-3.       RL_UNSETSTATE(RL_STATE_COM",Useful
/*Insert the first match with proper quoting.*/,"-10.       FREE (saved_line_buffer);
-9.       completion_changed_buffer = 0;
-8.       RL_UNSETSTATE(RL_STATE_COMPLETING);
-7.       return (0);
-6.     }
-5.   switch (what_to_do)
-4.     {
-3.     case TAB:
-2.     case '!':
-1.     case '@':

 /*Inser",Useful
"/*If there are more matches, ring the bell to indicate.
	 If we are in vi mode, Posix.2 says to not ring the bell.
	 If the `show-all-if-ambiguous' variable is set, display
	 all the matches immediately.  Otherwise, if this was the
	 only match, and we are hacking files, check the file to
	 see if it was a directory.  If so, and the `mark-directories'
	 variable is set, add a '/' to the name.  If not, and we
	 are at the end of the line, then add a space.*/","-2.       if (*matches[0])
-1. 	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);

 /*If there are more matches, ring the bell to indicate.
	 If we are in vi mode, Posix.2 says to not ring the bell.
	 If the `show-all-",Useful
/*Check to see if the line has changed through all of this manipulation.*/,"-10.       display_matches (matches);
-9.       break;
-8.     default:
-7.       fprintf (stderr, ""\r\nreadline: bad value %d for what_to_do in rl_complete\n"", what_to_do);
-6.       rl_ding ();
-5.       FREE (saved_line_buffer);
-4.       RL_UNSETSTATE",Useful
/*Application-callable completion match generator functions*/,"-10.   if (saved_line_buffer)
-9.     {
-8.       completion_changed_buffer = strcmp (rl_line_buffer, saved_line_buffer) != 0;
-7.       free (saved_line_buffer);
-6.     }
-5.   RL_UNSETSTATE(RL_STATE_COMPLETING);
-4.   return 0;
-3. }

 /*Application-ca",Useful
"/*If there were any matches, then look through them finding out the
     lowest common denominator.  That then becomes match_list[0].*/","-10.   match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
-9.   match_list[1] = (char *)NULL;
-8.   while ((string = (*entry_function) (text, matches)))
-7.     {
-6.       if (matches + 1 == match_list_size)
-5. 	match_list = (char ",Useful
"/*A completion function for usernames.
   TEXT contains a partial username preceded by a random
   character (usually `~').*/","-6.     {
-5.       free (match_list);
-4.       match_list = (char **)NULL;
-3.     }
-2.   return (match_list);
-1. }

 /*A completion function for usernames.
   TEXT contains a partial username preceded by a random
   character (usually `~').*/

1. cha",Useful
/*Null usernames should result in all users as possible completions.*/,"-10.       first_char_loc = first_char == '~';
-9.       username = savestring (&text[first_char_loc]);
-8. #if defined (HAVE_GETPWENT)
-7.       namelen = strlen (username);
-6. #endif
-5.       setpwent ();
-4.     }
-3. #if defined (HAVE_GETPWENT)
-2. ",Useful
"/*Okay, now we write the entry_function for filename completion.  In the
   general case.  Note that completion in the shell is a little different
   because of all the pathnames that must be followed when looking up the
   completion for a command.*/","-1. }

 /*Okay, now we write the entry_function for filename completion.  In the
   general case.  Note that completion in the shell is a little different
   because of all the pathnames that must be followed when looking up the
   completion for a comman",Useful
"/*If we don't have any state, then do some initialization.*/","-10.      int state;
-9. {
-8.   static DIR *directory = (DIR *)NULL;
-7.   static char *filename = (char *)NULL;
-6.   static char *dirname = (char *)NULL;
-5.   static char *users_dirname = (char *)NULL;
-4.   static int filename_len;
-3.   char *temp;
",Useful
"/*If we were interrupted before closing the directory or reading
	 all of its contents, close it.*/","-2.   if (state == 0)
-1.     {

 /*If we were interrupted before closing the directory or reading
	 all of its contents, close it.*/

1.       if (directory)
2. 	{
3. 	  closedir (directory);
4. 	  directory = (DIR *)NULL;
5. 	}
6.       FREE (dirname);
",Useful
/*delete single and double quotes*/,"-7.       if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
-6. 	{
-5. 	  free (users_dirname);
-4. 	  users_dirname = savestring (dirname);
-3. 	}
-2.       else if (rl_completion_found_quote && rl_filename_dequoting_functio",Useful
/*delete single and double quotes*/,"-7.       if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
-6. 	{
-5. 	  free (users_dirname);
-4. 	  users_dirname = savestring (dirname);
-3. 	}
-2.       else if (rl_completion_found_quote && rl_filename_dequoting_functio",Useful
"/*At this point we should entertain the possibility of hacking wildcarded
     filenames, like /usr/man/man<WILD>/te<TAB>.  If the directory name
     contains globbing characters, then build an array of directories, and
     then map over that list while completing.*/","-7. 	  temp = (*rl_filename_dequoting_function) (filename, rl_completion_quote_character);
-6. 	  free (filename);
-5. 	  filename = temp;
-4. 	}
-3.       filename_len = strlen (filename);
-2.       rl_filename_completion_desired = 1;
-1.     }

 /*At th",Useful
"/*Special case for no filename.  If the user has disabled the
         `match-hidden-files' variable, skip filenames beginning with `.'.
	 All other entries except ""."" and "".."" match.*/","-3.   entry = (struct dirent *)NULL;
-2.   while (directory && (entry = readdir (directory)))
-1.     {

 /*Special case for no filename.  If the user has disabled the
         `match-hidden-files' variable, skip filenames beginning with `.'.
	 All other ",Useful
"/*Otherwise, if these match up to the length of filename, then
	     it is a match.*/","-10. 	{
-9. 	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (entry->d_name))
-8. 	    continue;
-7. 	  if (entry->d_name[0] != '.' ||
-6. 	       (entry->d_name[1] &&
-5. 		 (entry->d_name[1] != '.' || entry->d_name[2])))
-4. 	    break;
-3. 	}
-2.     ",Useful
"/*Canonicalization cuts off any final slash present.  We
		 may need to add it back.*/","-7.       if (dirname && (dirname[0] != '.' || dirname[1]))
-6. 	{
-5. 	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
-4. 	    {
-3. 	      dirlen = strlen (dirname);
-2. 	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
-1",Useful
"/*An initial implementation of a menu completion function a la tcsh.  The
   first time (if the last readline command was not rl_menu_complete), we
   generate the list of matches.  This code is very similar to the code in
   rl_complete_internal -- there should be a way to combine the two.  Then,
   for each item in the list of matches, we insert the match in an undoable
   fashion, with the appropriate character appended (this happens on the
   second and subsequent consecutive calls to rl_menu_complete).  When we
   hit the end of the match list, we restore the original unmatched text,
   ring the bell, and reset the counter to zero.*/","-10. 	      if (users_dirname[dirlen - 1] != '/')
-9. 		temp[dirlen++] = '/';
-8. 	    }
-7. 	  strcpy (temp + dirlen, entry->d_name);
-6. 	}
-5.       else
-4. 	temp = savestring (entry->d_name);
-3.       return (temp);
-2.     }
-1. }

 /*An initial im",Useful
"/*The first time through, we generate the list of matches and set things
     up to insert them.*/","-10. {
-9.   rl_compentry_func_t *our_func;
-8.   int matching_filenames, found_quote;
-7.   static char *orig_text;
-6.   static char **matches = (char **)0;
-5.   static int match_list_index = 0;
-4.   static int match_list_size = 0;
-3.   static int or",Useful
/*Only the completion entry function can change these.*/,"-4. static void
-3. set_completion_defaults (what_to_do)
-2.      int what_to_do;
-1. {

 /*Only the completion entry function can change these.*/

1.   rl_filename_completion_desired = 0;
2.   rl_filename_quoting_desired = 1;
3.   rl_completion_type = wh",Useful
/*We now look backwards for the start of a filename/variable word.*/,"-10.   rl_compentry_func_t *our_func;
-9.   int start, end, delimiter, found_quote, i, nontrivial_lcd;
-8.   char *text, *saved_line_buffer;
-7.   char quote_char;
-6.   RL_SETSTATE(RL_STATE_COMPLETING);
-5.   set_completion_defaults (what_to_do);
-4.   s",Useful
"/*This (possibly) changes rl_point.  If it returns a non-zero char,
	   we know we have an open quote.*/","-4.       orig_end = rl_point;
-3.       found_quote = delimiter = 0;
-2.       quote_char = '\0';
-1.       if (rl_point)

 /*This (possibly) changes rl_point.  If it returns a non-zero char,
	   we know we have an open quote.*/

1. 	quote_char = _rl_fin",Useful
"/*If we are matching filenames, the attempted completion function will
	 have set rl_filename_completion_desired to a non-zero value.  The basic
	 rl_filename_completion_function does this.*/","-6. 	quote_char = _rl_find_completion_word (&found_quote, &delimiter);
-5.       orig_start = rl_point;
-4.       rl_point = orig_end;
-3.       orig_text = rl_copy_text (orig_start, orig_end);
-2.       matches = gen_completion_matches (orig_text, orig_s",Useful
"/*matches[0] is lcd if match_list_size > 1, but the circular buffer
	 code below should take care of it.*/","-10.     	  rl_ding ();
-9. 	  FREE (matches);
-8. 	  matches = (char **)0;
-7. 	  FREE (orig_text);
-6. 	  orig_text = (char *)0;
-5.     	  completion_changed_buffer = 0;
-4.           return (0);
-3. 	}
-2.       for (match_list_size = 0; matches[match",Useful
"/*Now we have the list of matches.  Replace the text between
     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
     matches[match_list_index], and add any necessary closing char.*/","-1.     }

 /*Now we have the list of matches.  Replace the text between
     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
     matches[match_list_index], and add any necessary closing char.*/

1.   if (matches == 0 || match_list_size == 0",Useful
/*macro.c -- keyboard macros for readline.*/,"
/* macro.c -- keyboard macros for readline. */


 /*macro.c -- keyboard macros for readline.*/

1. /* Copyright (C) 1994 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
"/*The currently executing macro string.  If this is non-zero,
   then it is a malloc ()'ed string where input is coming from.*/","-9. #include ""readline.h""
-8. #include ""history.h""
-7. #include ""rlprivate.h""
-6. #include ""xmalloc.h""

 /*The currently executing macro string.  If this is non-zero,
   then it is a malloc ()'ed string where input is coming from.*/

1. char *rl_executing",Useful
/*The offset in the above string to the next character to be read.*/,"-1. char *rl_executing_macro = (char *)NULL;

 /*The offset in the above string to the next character to be read.*/

1. static int executing_macro_index;",Useful
"/*The current macro string being built.  Characters get stuffed
   in here by add_macro_char ().*/","-3. char *rl_executing_macro = (char *)NULL;

 /*The current macro string being built.  Characters get stuffed
   in here by add_macro_char ().*/

1. static char *current_macro = (char *)NULL;",Useful
/*The size of the buffer allocated to current_macro.*/,"-1. static char *current_macro = (char *)NULL;

 /*The size of the buffer allocated to current_macro.*/

1. static int current_macro_size;",Useful
/*The index at which characters are being added to current_macro.*/,"-1. static int current_macro_size;

 /*The index at which characters are being added to current_macro.*/

1. static int current_macro_index;",Useful
"/*A structure used to save nested macro strings.
   It is a linked list of string/index for each saved macro.*/","-1. static int current_macro_index;

 /*A structure used to save nested macro strings.
   It is a linked list of string/index for each saved macro.*/

1. struct saved_macro {
2.   struct saved_macro *next;
3.   char *string;
4.   int sindex;
5. };",Useful
/*The list of saved macros.*/,"-5. struct saved_macro {
-4.   struct saved_macro *next;
-3.   char *string;
-2.   int sindex;
-1. };

 /*The list of saved macros.*/

1. static struct saved_macro *macro_list = (struct saved_macro *)NULL;",Useful
"/*Set up to read subsequent input from STRING.
   STRING is free ()'ed when we are done with it.*/","-1. static struct saved_macro *macro_list = (struct saved_macro *)NULL;

 /*Set up to read subsequent input from STRING.
   STRING is free ()'ed when we are done with it.*/

1. void
2. _rl_with_macro_input (string)
3.      char *string;
4. {
5.   _rl_push",Useful
"/*Return the next character available from a macro, or 0 if
   there are no macro characters.*/","-10.    STRING is free ()'ed when we are done with it. */
-9. void
-8. _rl_with_macro_input (string)
-7.      char *string;
-6. {
-5.   _rl_push_executing_macro ();
-4.   rl_executing_macro = string;
-3.   executing_macro_index = 0;
-2.   RL_SETSTATE(RL_S",Useful
/*Save the currently executing macro on a stack of saved macros.*/,"-10.     }
-9. #if defined (READLINE_CALLBACKS)
-8.   c = rl_executing_macro[executing_macro_index++];
-7.   if (RL_ISSTATE (RL_STATE_CALLBACK) && RL_ISSTATE (RL_STATE_READCMD|RL_STATE_MOREINPUT) && rl_executing_macro[executing_macro_index] == 0)
-6.     ",Useful
"/*Discard the current macro, replacing it with the one
   on the top of the stack of saved macros.*/","-10. void
-9. _rl_push_executing_macro ()
-8. {
-7.   struct saved_macro *saver;
-6.   saver = (struct saved_macro *)xmalloc (sizeof (struct saved_macro));
-5.   saver->next = macro_list;
-4.   saver->sindex = executing_macro_index;
-3.   saver->string = ",Useful
/*Add a character to the macro being built.*/,"-10.     {
-9.       macro = macro_list;
-8.       rl_executing_macro = macro_list->string;
-7.       executing_macro_index = macro_list->sindex;
-6.       macro_list = macro_list->next;
-5.       free (macro);
-4.     }
-3.   if (rl_executing_macro == 0)",Useful
"/*Begin defining a keyboard macro.
   Keystrokes are recorded as they are executed.
   End the definition with rl_end_kbd_macro ().
   If a numeric argument was explicitly typed, then append this
   definition to the end of the existing macro, and start by
   re-executing the existing macro.*/","-10.     {
-9.       free (current_macro);
-8.       current_macro = (char *) NULL;
-7.     }
-6.   current_macro_size = current_macro_index = 0;
-5.   FREE (rl_executing_macro);
-4.   rl_executing_macro = (char *) NULL;
-3.   executing_macro_index = 0;
-",Useful
"/*Stop defining a keyboard macro.
   A numeric argument says to execute the macro right now,
   that many times, counting the definition as the first time.*/","-10.   if (rl_explicit_arg)
-9.     {
-8.       if (current_macro)
-7. 	_rl_with_macro_input (savestring (current_macro));
-6.     }
-5.   else
-4.     current_macro_index = 0;
-3.   RL_SETSTATE(RL_STATE_MACRODEF);
-2.   return 0;
-1. }

 /*Stop defining ",Useful
"/*Execute the most recently defined keyboard macro.
   COUNT says how many times to execute it.*/","-10.   if (RL_ISSTATE (RL_STATE_MACRODEF) == 0)
-9.     {
-8.       _rl_abort_internal ();
-7.       return -1;
-6.     }
-5.   current_macro_index -= rl_key_sequence_length - 1;
-4.   current_macro[current_macro_index] = '\0';
-3.   RL_UNSETSTATE(RL_STAT",Useful
/*Allocate 1 MB for the payload buffer initially*/,"-10. GNU General Public License for more details.
-9. You should have received a copy of the GNU General Public License
-8. along with this program; if not, write to the Free Software
-7. Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  0211",Useful
"/*Chunk type, ignore unknown ones if ignorable flag is set*/","-2. 	chunk->flags = *ptr++;
-1. 	stream->offset++;

 /*Chunk type, ignore unknown ones if ignorable flag is set*/

1. 	chunk->type = validate_chunk_type(*ptr);
2. 	if (chunk->type == XB_CHUNK_TYPE_UNKNOWN &&
3. 	    !(chunk->flags & XB_STREAM_FLAG_IGNORAB",Useful
/*Path length*/,"-10. 	chunk->type = validate_chunk_type(*ptr);
-9. 	if (chunk->type == XB_CHUNK_TYPE_UNKNOWN &&
-8. 	    !(chunk->flags & XB_STREAM_FLAG_IGNORABLE)) {
-7. 		msg(""xb_stream_read_chunk(): unknown chunk type 0x%lu at ""
-6. 		    ""offset 0x%llx."", (ulong) *pt",Useful
/*Path*/,"-10. 	chunk->type = validate_chunk_type(*ptr);
-9. 	if (chunk->type == XB_CHUNK_TYPE_UNKNOWN &&
-8. 	    !(chunk->flags & XB_STREAM_FLAG_IGNORABLE)) {
-7. 		msg(""xb_stream_read_chunk(): unknown chunk type 0x%lu at ""
-6. 		    ""offset 0x%llx."", (ulong) *pt",Useful
/*Reallocate the buffer if needed*/,"-9. 	ullval = uint8korr(tmpbuf + 8);
-8. 	if (ullval > (ulonglong) MY_OFF_T_MAX) {
-7. 		msg(""xb_stream_read_chunk(): chunk offset is too large at ""
-6. 		    ""offset 0x%llx: 0x%llx."", (ulonglong) stream->offset,
-5. 		    ullval);
-4. 		goto err;
-3. 	}
",Useful
/*What we assume for a max number of kills.*/,"-9. #include ""readline.h""
-8. #include ""history.h""
-7. #include ""rlprivate.h""
-6. #include ""xmalloc.h""

 /*What we assume for a max number of kills.*/

1. #define DEFAULT_MAX_KILLS 10",Useful
/*The real variable to look at to find out when to flush kills.*/,"-1. #define DEFAULT_MAX_KILLS 10

 /*The real variable to look at to find out when to flush kills.*/

1. static int rl_max_kills =  DEFAULT_MAX_KILLS;",Useful
"/*Add TEXT to the kill ring, allocating a new kill ring slot as necessary.
   This uses TEXT directly, so the caller must not free it.  If APPEND is
   non-zero, and the last command was a kill, the text is appended to the
   current kill ring slot, otherwise prepended.*/","-6. int
-5. rl_set_retained_kills (num)
-4.      int num __attribute__((unused));
-3. {
-2.   return 0;
-1. }

 /*Add TEXT to the kill ring, allocating a new kill ring slot as necessary.
   This uses TEXT directly, so the caller must not free it.  If APPE",Useful
"/*If we don't have any defined, then make one.*/","-2.       if (rl_kill_ring == 0)
-1. 	{

 /*If we don't have any defined, then make one.*/

1. 	  rl_kill_ring = (char **)
2. 	    xmalloc (((rl_kill_ring_length = 1) + 1) * sizeof (char *));
3. 	  rl_kill_ring[slot = 0] = (char *)NULL;
4. 	}
5.       els",Useful
"/*We have to add a new slot on the end, unless we have
	     exceeded the max limit for remembering kills.*/","-6. 	  rl_kill_ring = (char **)
-5. 	    xmalloc (((rl_kill_ring_length = 1) + 1) * sizeof (char *));
-4. 	  rl_kill_ring[slot = 0] = (char *)NULL;
-3. 	}
-2.       else
-1. 	{

 /*We have to add a new slot on the end, unless we have
	     exceeded the ma",Useful
"/*If the last command was a kill, prepend or append.*/","-10. 	  else
-9. 	    {
-8. 	      slot = rl_kill_ring_length += 1;
-7. 	      rl_kill_ring = (char **)xrealloc (rl_kill_ring, slot * sizeof (char *));
-6. 	    }
-5. 	  rl_kill_ring[--slot] = (char *)NULL;
-4. 	}
-3.     }
-2.   else
-1.     slot = rl_ki",Useful
"/*The way to kill something.  This appends or prepends to the last
   kill, if the last command was a kill command.  if FROM is less
   than TO, then the text is appended, otherwise prepended.  If the
   last command was not a kill command, then a new slot is made for
   this kill.*/","-10. 	}
-9.       free (old);
-8.       free (text);
-7.       rl_kill_ring[slot] = new;
-6.     }
-5.   else
-4.     rl_kill_ring[slot] = text;
-3.   rl_kill_index = slot;
-2.   return 0;
-1. }

 /*The way to kill something.  This appends or prepends to ",Useful
"/*Now REMEMBER!  In order to do prepending or appending correctly, kill
   commands always make rl_point's original position be the FROM argument,
   and rl_point's extent be the TO argument.*/","-5.   rl_delete_text (from, to);
-4.   _rl_copy_to_kill_ring (text, from < to);
-3.   _rl_last_command_was_kill++;
-2.   return 0;
-1. }

 /*Now REMEMBER!  In order to do prepending or appending correctly, kill
   commands always make rl_point's original ",Useful
"/*Delete the word at point, saving the text in the kill ring.*/","-10.   return 0;
-9. }

 /*Delete the word at point, saving the text in the kill ring.*/

1. int
2. rl_kill_word (count, key)
3.      int count, key;
4. {
5.   int orig_point;
6.   if (count < 0)
7.     return (rl_backward_kill_word (-count, key));
8.   e",Useful
"/*Rubout the word before point, placing it on the kill ring.*/","-10.       orig_point = rl_point;
-9.       rl_forward_word (count, key);
-8.       if (rl_point != orig_point)
-7. 	rl_kill_text (orig_point, rl_point);
-6.       rl_point = orig_point;
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point",Useful
"/*Kill from here to the end of the line.  If DIRECTION is negative, kill
   back to the line start instead.*/","-10.     {
-9.       orig_point = rl_point;
-8.       rl_backward_word (count, ignore);
-7.       if (rl_point != orig_point)
-6. 	rl_kill_text (orig_point, rl_point);
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point;
-3.     }
-2.   r",Useful
"/*Kill backwards to the start of the line.  If DIRECTION is negative, kill
   forwards to the line end instead.*/","-10.       orig_point = rl_point;
-9.       rl_end_of_line (1, ignore);
-8.       if (orig_point != rl_point)
-7. 	rl_kill_text (orig_point, rl_point);
-6.       rl_point = orig_point;
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point;
",Useful
"/*The next two functions mimic unix line editing behaviour, except they
   save the deleted text on the kill ring.  This is safer than not saving
   it, and since we have a ring, nobody should get screwed.*/","-10. rl_kill_full_line (count, ignore)
-9.      int count __attribute__((unused)), ignore __attribute__((unused));
-8. {
-7.   rl_begin_undo_group ();
-6.   rl_point = 0;
-5.   rl_kill_text (rl_point, rl_end);
-4.   rl_mark = 0;
-3.   rl_end_undo_group ()",Useful
"/*This deletes one filename component in a Unix pathname.  That is, it
   deletes backward to directory separator (`/') or whitespace.*/","-10. 	    rl_point--;
-9. 	  while (rl_point && (whitespace (rl_line_buffer[rl_point - 1]) == 0))
-8. 	    rl_point--;
-7. 	}
-6.       rl_kill_text (orig_point, rl_point);
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point;
-3.     }
-2",Useful
"/*Here is C-u doing what Unix does.  You don't *have* to use these
   key-bindings.  We have a choice of killing the entire line, or
   killing from where we are to the start of the line.  We choose the
   latter, because if you are a Unix weenie, then you haven't backspaced
   into the line at all, and if you aren't, then you know what you are
   doing.*/","-10. 	      rl_point--;
-9. 	      c = rl_line_buffer[rl_point - 1];
-8. 	    }
-7. 	}
-6.       rl_kill_text (orig_point, rl_point);
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point;
-3.     }
-2.   return 0;
-1. }

 /*Here is C-u doi",Useful
"/*Copy the text in the `region' to the kill ring.  If DELETE is non-zero,
   delete the text from the line as well.*/","-10.     rl_ding ();
-9.   else
-8.     {
-7.       rl_kill_text (rl_point, 0);
-6.       rl_point = 0;
-5.       if (rl_editing_mode == emacs_mode)
-4. 	rl_mark = rl_point;
-3.     }
-2.   return 0;
-1. }

 /*Copy the text in the `region' to the kill rin",Useful
"/*Copy COUNT words to the kill ring.  DIR says which direction we look
   to find the words.*/","-10. rl_kill_region (count, ignore)
-9.      int count __attribute__((unused)), ignore __attribute__((unused));
-8. {
-7.   int r, npoint;
-6.   npoint = (rl_point < rl_mark) ? rl_point : rl_mark;
-5.   r = region_kill_internal (1);
-4.   _rl_fix_point (1",Useful
/*Yank back the last killed text.  This ignores arguments.*/,"-10.   return (_rl_copy_word_as_kill (count, 1));
-9. }
-8. int
-7. rl_copy_backward_word (count, key)
-6.      int count, key;
-5. {
-4.   if (count < 0)
-3.     return (rl_copy_forward_word (-count, key));
-2.   return (_rl_copy_word_as_kill (count, -1)",Useful
"/*If the last command was yank, or yank_pop, and the text just
   before point is identical to the current kill item, then
   delete that text from the line, rotate the index down, and
   yank back some other text.*/","-10. {
-9.   if (rl_kill_ring == 0)
-8.     {
-7.       _rl_abort_internal ();
-6.       return -1;
-5.     }
-4.   _rl_set_mark_at_pos (rl_point);
-3.   rl_insert_text (rl_kill_ring[rl_kill_index]);
-2.   return 0;
-1. }

 /*If the last command was yank,",Useful
"/*Yank the COUNTh argument from the previous history line, skipping
   HISTORY_SKIP lines before looking for the `previous line'.*/","-10. 	rl_kill_index = rl_kill_ring_length - 1;
-9.       rl_yank (1, 0);
-8.       return 0;
-7.     }
-6.   else
-5.     {
-4.       _rl_abort_internal ();
-3.       return -1;
-2.     }
-1. }

 /*Yank the COUNTh argument from the previous history line, ",Useful
"/*Vi mode always inserts a space before yanking the argument, and it
     inserts it right *after* rl_point.*/","-10.   arg = history_arg_extract (count, count, entry->line);
-9.   if (!arg || !*arg)
-8.     {
-7.       rl_ding ();
-6.       FREE (arg);
-5.       return -1;
-4.     }
-3.   rl_begin_undo_group ();
-2.   _rl_set_mark_at_pos (rl_point);
-1. #if defined",Useful
/*Yank the COUNTth argument from the previous history line.*/,"-5.   rl_insert_text (arg);
-4.   free (arg);
-3.   rl_end_undo_group ();
-2.   return 0;
-1. }

 /*Yank the COUNTth argument from the previous history line.*/

1. int
2. rl_yank_nth_arg (count, ignore)
3.      int count, ignore;
4. {
5.   return (rl_yank",Useful
"/*Yank the last argument from the previous history line.  This `knows'
   how rl_yank_nth_arg treats a count of `$'.  With an argument, this
   behaves the same as rl_yank_nth_arg.*/","-6. int
-5. rl_yank_nth_arg (count, ignore)
-4.      int count, ignore;
-3. {
-2.   return (rl_yank_nth_arg_internal (count, ignore, 0));
-1. }

 /*Yank the last argument from the previous history line.  This `knows'
   how rl_yank_nth_arg treats a count ",Useful
/*A special paste command for users of Cygnus's cygwin32.*/,"-10.       if (history_skip < 0)
-9. 	history_skip = 0;
-8.     }
-7.   if (explicit_arg_p)
-6.     retval = rl_yank_nth_arg_internal (count_passed, key, history_skip);
-5.   else
-4.     retval = rl_yank_nth_arg_internal ('$', key, history_skip);
-3.   u",Useful
/*Some strings to control terminal actions.  These are output by tputs ().*/,"-2. char PC, *BC, *UP;

 /*Some strings to control terminal actions.  These are output by tputs ().*/

1. const char *_rl_term_clreol;
2. const char *_rl_term_clrpag;
3. const char *_rl_term_cr;
4. const char *_rl_term_backspace;
5. char _rl_term_backspac",Useful
/*Non-zero if we determine that the terminal can do character insertion.*/,"-7. const char *_rl_term_clreol;
-6. const char *_rl_term_clrpag;
-5. const char *_rl_term_cr;
-4. const char *_rl_term_backspace;
-3. char _rl_term_backspace_default[2] = { '\b', 0 };
-2. const char *_rl_term_goto;
-1. const char *_rl_term_pc;

 /*Non-ze",Useful
/*How to insert characters.*/,"-1. int _rl_terminal_can_insert = 0;

 /*How to insert characters.*/

1. const char *_rl_term_im;
2. const char *_rl_term_ei;
3. const char *_rl_term_ic;
4. const char *_rl_term_ip;
5. const char *_rl_term_IC;",Useful
/*How to delete characters.*/,"-5. const char *_rl_term_im;
-4. const char *_rl_term_ei;
-3. const char *_rl_term_ic;
-2. const char *_rl_term_ip;
-1. const char *_rl_term_IC;

 /*How to delete characters.*/

1. const char *_rl_term_dc;
2. const char *_rl_term_DC;
3. const char *_rl_te",Useful
/*Non-zero means the terminal can auto-wrap lines.*/,"-1. static const char *_rl_visible_bell;

 /*Non-zero means the terminal can auto-wrap lines.*/

1. int _rl_term_autowrap = -1;",Useful
"/*The sequences to write to turn on and off the meta key, if this
   terminal has one.*/","-1. static int term_has_meta;

 /*The sequences to write to turn on and off the meta key, if this
   terminal has one.*/

1. static const char *_rl_term_mm;
2. static const char *_rl_term_mo;",Useful
"/*The key sequences output by the arrow keys, if this terminal has any.*/","-2. static const char *_rl_term_mm;
-1. static const char *_rl_term_mo;

 /*The key sequences output by the arrow keys, if this terminal has any.*/

1. static const char *_rl_term_ku;
2. static const char *_rl_term_kd;
3. static const char *_rl_term_kr;
4",Useful
"/*How to initialize and reset the arrow keys, if this terminal has any.*/","-4. static const char *_rl_term_ku;
-3. static const char *_rl_term_kd;
-2. static const char *_rl_term_kr;
-1. static const char *_rl_term_kl;

 /*How to initialize and reset the arrow keys, if this terminal has any.*/

1. static const char *_rl_term_ks;",Useful
"/*The key sequences sent by the Home and End keys, if any.*/","-2. static const char *_rl_term_ks;
-1. static const char *_rl_term_ke;

 /*The key sequences sent by the Home and End keys, if any.*/

1. static const char *_rl_term_kh;
2. static const char *_rl_term_kH;",Useful
"/*Variables that hold the screen dimensions, used by the display code.*/","-1. static void bind_termcap_arrow_keys PARAMS((Keymap));

 /*Variables that hold the screen dimensions, used by the display code.*/

1. int _rl_screenwidth, _rl_screenheight, _rl_screenchars;",Useful
"/*Environment variable COLUMNS overrides setting of ""co"" if IGNORE_ENV
     is unset.  If we prefer the environment, check it first before
     assigning the value returned by the kernel.*/","-10. #elif defined (__MINGW32__)
-9.   _win_get_screensize (&wc, &wr);
-8. #endif
-7.   if (ignore_env || rl_prefer_env_winsize == 0)
-6.     {
-5.       _rl_screenwidth = wc;
-4.       _rl_screenheight = wr;
-3.     }
-2.   else
-1.     _rl_screenwidth =",Useful
"/*Environment variable LINES overrides setting of ""li"" if IGNORE_ENV
     is unset.*/","-10.     {
-9.       if (ignore_env == 0 && (ss = sh_get_env_value (""COLUMNS"")))
-8. 	_rl_screenwidth = atoi (ss);
-7.       if (_rl_screenwidth <= 0)
-6.         _rl_screenwidth = wc;
-5. #if !defined (__DJGPP__)
-4.       if (_rl_screenwidth <= 0 && ter",Useful
"/*If all else fails, default to 80x24 terminal.*/","-10.     {
-9.       if (ignore_env == 0 && (ss = sh_get_env_value (""LINES"")))
-8. 	_rl_screenheight = atoi (ss);
-7.       if (_rl_screenheight <= 0)
-6.         _rl_screenheight = wr;
-5. #if !defined (__DJGPP__)
-4.       if (_rl_screenheight <= 0 && t",Useful
"/*This should be kept sorted, just in case we decide to change the
   search algorithm to something smarter.*/","-10.       if (CUSTOM_REDISPLAY_FUNC ())
-9. 	rl_forced_update_display ();
-8.       else
-7. 	_rl_redisplay_after_sigwinch ();
-6.     }
-5. }
-4. struct _tc_string {
-3.      const char *tc_var;
-2.      const char **tc_value;
-1. };

 /*This should be ",Useful
"/*Read the desired terminal capability strings into BP.  The capabilities
   are described in the TC_STRINGS table.*/","-10.   { ""mm"", &_rl_term_mm },
-9.   { ""mo"", &_rl_term_mo },
-8.   { ""nd"", &_rl_term_forward_char },
-7.   { ""pc"", &_rl_term_pc },
-6.   { ""up"", &_rl_term_up },
-5.   { ""vb"", &_rl_visible_bell },
-4.   { ""vs"", &_rl_term_vs },
-3.   { ""ve"", &_rl_term_ve },",Useful
"/*I've separated this out for later work on not calling tgetent at all
     if the calling application has supplied a custom redisplay function,
     (and possibly if the application has supplied a custom input function).*/","-10.      const char *terminal_name;
-9. {
-8.   const char *term;
-7.   char *buffer;
-6.   int tty, tgetent_ret;
-5.   term = terminal_name ? terminal_name : sh_get_env_value (""TERM"");
-4.   _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL",Useful
"/*Allow calling application to set default height and width, using
	 rl_set_screen_size*/","-10. 	term_buffer = (char *)xmalloc(4080);
-9.       buffer = term_string_buffer;
-8.       tgetent_ret = tgetent (term_buffer, term);
-7.     }
-6.   if (tgetent_ret <= 0)
-5.     {
-4.       FREE (term_string_buffer);
-3.       FREE (term_buffer);
-2.  ",Useful
"/*Reasonable defaults for tgoto().  Readline currently only uses
         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
         change that later...*/","-10.       _rl_term_cr = ""\r"";
-9.       _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
-8.       _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
-7.       _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_ter",Useful
"/*Allow calling application to set default height and width, using
     rl_set_screen_size*/","-6.   PC = _rl_term_pc ? *_rl_term_pc : 0;
-5.   BC = (char*)_rl_term_backspace;
-4.   UP = (char*)_rl_term_up;
-3.   if (!_rl_term_cr)
-2.     _rl_term_cr = ""\r"";
-1.   _rl_term_autowrap = tgetflag ((char *)""am"") && tgetflag ((char *)""xn"");

 /*Allow cal",Useful
"/*""An application program can assume that the terminal can do
      character insertion if *any one of* the capabilities `IC',
      `im', `ic' or `ip' is provided.""  But we can't do anything if
      only `ip' is provided, so...*/","-2.   if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-1.     _rl_get_screen_size (tty, 0);

 /*""An application program can assume that the terminal can do
      character insertion if *any one of* the capabilities `IC',
      `im', `ic' or `ip' is pro",Useful
"/*Check to see if this terminal has a meta key and clear the capability
     variables if there is none.*/","-1.   _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);

 /*Check to see if this terminal has a meta key and clear the capability
     variables if there is none.*/

1.   term_has_meta = (tgetflag ((char *)""km"") || tgetflag ((char *)""",Useful
/*Write COUNT characters from STRING to the output stream.*/,"-7. int
-6. _rl_output_character_function (c)
-5.      int c;
-4. {
-3.   return putc (c, _rl_out_stream);
-2. }

 /*Write COUNT characters from STRING to the output stream.*/

1. void
2. _rl_output_some_chars (string, count)
3.      const char *string;
4",Useful
/*Move to the start of the next line.*/,"-10. {
-9.   register int i;
-8.   if (_rl_term_backspace)
-7.     for (i = 0; i < count; i++)
-6.       tputs (_rl_term_backspace, 1, _rl_output_character_function);
-5.   else
-4.     for (i = 0; i < count; i++)
-3.       putc ('\b', _rl_out_stream);
-2",Useful
"/*Set the cursor appropriately depending on IM, which is one of the
   insert modes (insert or overwrite).  Insert mode gets the normal
   cursor.  Overwrite mode gets a very visible cursor.  Only does
   anything if we have both capabilities.*/","-10.     tputs (_rl_term_ks, 1, _rl_output_character_function);
-9.   else if (!on && _rl_term_ke)
-8.     tputs (_rl_term_ke, 1, _rl_output_character_function);
-7. #endif
-6. }

 /*Set the cursor appropriately depending on IM, which is one of the
   ins",Useful
"/*After initializing the function map, this is the index of the first
   program specific function.*/","-10. #include ""xmalloc.h""
-9. #ifdef __STDC__
-8. typedef int QSFUNC (const void *, const void *);
-7. #else
-6. typedef int QSFUNC ();
-5. #endif
-4. extern int _rl_qsort_string_compare PARAMS((char **, char **));
-3. FUNMAP **funmap;
-2. static int funm",Useful
/*Make the funmap contain all of the default entries.*/,"-10.       funmap_size += 64;
-9.       funmap = (FUNMAP **)xrealloc (funmap, funmap_size * sizeof (FUNMAP *));
-8.     }
-7.   funmap[funmap_entry] = (FUNMAP *)xmalloc (sizeof (FUNMAP));
-6.   funmap[funmap_entry]->name = name;
-5.   funmap[funmap_entry]",Useful
"/*Produce a NULL terminated array of known function names.  The array
   is sorted.  The array itself is allocated, but not the strings inside.
   You should free () the array when you done, but not the pointrs.*/","-10. rl_initialize_funmap ()
-9. {
-8.   register int i;
-7.   if (funmap_initialized)
-6.     return;
-5.   for (i = 0; default_funmap[i].name; i++)
-4.     rl_add_funmap_entry (default_funmap[i].name, default_funmap[i].function);
-3.   funmap_initialize",Useful
/*Make sure that the function map has been initialized.*/,"-5. const char **
-4. rl_funmap_names ()
-3. {
-2.   const char **result;
-1.   int result_size, result_index;

 /*Make sure that the function map has been initialized.*/

1.   rl_initialize_funmap ();
2.   for (result_index = result_size = 0, result = (c",Useful
"/*TODO: copy-pasted shared definitions from the XtraDB bitmap write code.
Remove these on the first opportunity, i.e. single-binary XtraBackup.*/","-4. #include ""changed_page_bitmap.h""
-3. #include ""common.h""
-2. #include ""xtrabackup.h""
-1. #include ""srv0srv.h""

 /*TODO: copy-pasted shared definitions from the XtraDB bitmap write code.
Remove these on the first opportunity, i.e. single-binary XtraBac",Useful
/*!< Name with full path*/,"-1. struct log_online_bitmap_file_t {

 /*!< Name with full path*/

111",Useful
"/*!< Offset of the next read,
						or count of already-read bytes*/","ib_uint64_t	offset;			/*!< Offset of the next read,
						or count of already-read bytes

 /*!< Offset of the next read,
						or count of already-read bytes*/

1. 						*/
2. };",Useful
/** A set of bitmap files containing some LSN range*/,"-1. };

 /** A set of bitmap files containing some LSN range*/

1. struct log_online_bitmap_file_range_t {",Useful
/** The bitmap file block size in bytes.  All writes will be multiples of this.*/,"-1. static const char* bmp_file_name_stem = ""ib_modified_log_"";
/** The bitmap file block size in bytes.  All writes will be multiples of this.

 /** The bitmap file block size in bytes.  All writes will be multiples of this.*/

1.  */
2. enum {
3. 	MODIF",Useful
"/*1 if last block in the current
					write, 0 otherwise.*/","-1. enum {

 /*1 if last block in the current
					write, 0 otherwise.*/

111",Useful
"/*The starting tracked LSN of this and
					other blocks in the same write*/","-3. enum {

 /*The starting tracked LSN of this and
					other blocks in the same write*/

111",Useful
"/*The ending tracked LSN of this and
					other blocks in the same write*/","-5. enum {

 /*The ending tracked LSN of this and
					other blocks in the same write*/

111",Useful
"/*The page ID of the first tracked
					page in this block*/","-9. enum {

 /*The page ID of the first tracked
					page in this block*/

111",Useful
"/*Unused in order to align the start
					  of bitmap at 8 byte boundary*/","-10. 	MODIFIED_PAGE_IS_LAST_BLOCK = 0,/* 1 if last block in the current
-9. 					write, 0 otherwise. */
-8. 	MODIFIED_PAGE_START_LSN = 4,	/* The starting tracked LSN of this and
-7. 					other blocks in the same write */
-6. 	MODIFIED_PAGE_END_LSN = 12,	/",Useful
"/*Unused in order to align the end of
					bitmap at 8 byte boundary*/","-1. 	MODIFIED_PAGE_BLOCK_UNUSED_2 = MODIFIED_PAGE_BLOCK_SIZE - 8,

 /*Unused in order to align the end of
					bitmap at 8 byte boundary*/

1. 	MODIFIED_PAGE_BLOCK_CHECKSUM = MODIFIED_PAGE_BLOCK_SIZE - 4",Useful
/*The checksum of the current block*/,"-1. 	MODIFIED_PAGE_BLOCK_CHECKSUM = MODIFIED_PAGE_BLOCK_SIZE - 4

 /*The checksum of the current block*/

1. };",Useful
/** Length of the bitmap data in a block*/,"-1. };

 /** Length of the bitmap data in a block*/

111",Useful
/** Length of the bitmap data in a block in page ids*/,"-2. enum { MODIFIED_PAGE_BLOCK_BITMAP_LEN
-1.        = MODIFIED_PAGE_BLOCK_UNUSED_2 - MODIFIED_PAGE_BLOCK_BITMAP };

 /** Length of the bitmap data in a block in page ids*/

111",Useful
"/**
Calculate a bitmap block checksum.  Algorithm borrowed from
log_block_calc_checksum.
@return checksum*/","-10. };
-9. /** Length of the bitmap data in a block */
-8. enum { MODIFIED_PAGE_BLOCK_BITMAP_LEN
-7.        = MODIFIED_PAGE_BLOCK_UNUSED_2 - MODIFIED_PAGE_BLOCK_BITMAP };
-6. /** Length of the bitmap data in a block in page ids */
-5. enum { MODIFIED_PAG",Useful
"/**
Provide a comparisson function for the RB-tree tree (space,
block_start_page) pairs.  Actual implementation does not matter as
long as the ordering is full.
@return -1 if p1 < p2, 0 if p1 == p2, 1 if p1 > p2*/","Provide a comparisson function for the RB-tree tree (space,
block_start_page) pairs.  Actual implementation does not matter as
long as the ordering is full.
@return -1 if p1 < p2, 0 if p1 == p2, 1 if p1 > p2

 /**
Provide a comparisson function for the RB-tree tree (space,
block_start_page) pairs.  Actual implementation does not matter as
long as the ordering is full.
@return -1 if p1 < p2, 0 if p1 == p2, 1 if p1 > p2*/

1. */
2. static
3. int
4. log_online_compare_bmp_keys(",Useful
"/**
Calculate a bitmap block checksum.  Algorithm borrowed from
log_block_calc_checksum.
@return checksum*/","-10. };
-9. /** Length of the bitmap data in a block */
-8. enum { MODIFIED_PAGE_BLOCK_BITMAP_LEN
-7.        = MODIFIED_PAGE_BLOCK_UNUSED_2 - MODIFIED_PAGE_BLOCK_BITMAP };
-6. /** Length of the bitmap data in a block in page ids */
-5. enum { MODIFIED_PAG",Useful
"/**
Read one bitmap data page and check it for corruption.

@return TRUE if page read OK, FALSE if I/O error*/","-10. 		sum += b << sh;
-9. 		sh++;
-8. 		if (sh > 24) {
-7. 			sh = 0;
-6. 		}
-5. 	}
-4. 	return sum;
-3. }
-2. /****************************************************************//**
-1. Read one bitmap data page and check it for corruption.
@return TRUE ",Useful
"/*!<out: read page.  Must be at
						least MODIFIED_PAGE_BLOCK_SIZE
						bytes long*/","-6. static
-5. ibool
-4. log_online_read_bitmap_page(

 /*!<out: read page.  Must be at
						least MODIFIED_PAGE_BLOCK_SIZE
						bytes long*/

111",Useful
"/*!<out: TRUE if page
							checksum OK*/","-10. @return TRUE if page read OK, FALSE if I/O error */
-9. static
-8. ibool
-7. log_online_read_bitmap_page(

 /*!<out: TRUE if page
							checksum OK*/

1. {
2. 	ulint	checksum;
3. 	ulint	actual_checksum;
4. 	ibool	success;
5. 	ut_a(bitmap_file->size ",Useful
"/**
Check the name of a given file if it's a changed page bitmap file and
return file sequence and start LSN name components if it is.  If is not,
the values of output parameters are undefined.

@return TRUE if a given file is a changed page bitmap file.*/","-10. 	ut_ad(bitmap_file->offset <= bitmap_file->size);
-9. 	checksum = mach_read_from_4(page + MODIFIED_PAGE_BLOCK_CHECKSUM);
-8. 	actual_checksum = log_online_calc_checksum(page);
-7. 	*checksum_ok = (checksum == actual_checksum);
-6. 	return TRUE;
-5. }",Useful
"/*!<out: bitmap file
							sequence number*/","-10. Check the name of a given file if it's a changed page bitmap file and
-9. return file sequence and start LSN name components if it is.  If is not,
-8. the values of output parameters are undefined.
-7. @return TRUE if a given file is a changed page b",Useful
"/*!<out: bitmap file
							start LSN*/","-10. the values of output parameters are undefined.
-9. @return TRUE if a given file is a changed page bitmap file.  */
-8. static
-7. ibool
-6. log_online_is_bitmap_file(

 /*!<out: bitmap file
							start LSN*/

1. {
2. 	char	stem[FN_REFLEN];
3. 	ut_ad",Useful
"/**
List the bitmap files in srv_data_home and setup their range that contains the
specified LSN interval.  This range, if non-empty, will start with a file that
has the greatest LSN equal to or less than the start LSN and will include all
the files up to the one with the greatest LSN less than the end LSN.  Caller
must free bitmap_files->files when done if bitmap_files set to non-NULL and
this function returned TRUE.  Field bitmap_files->count might be set to a
larger value than the actual count of the files, and space for the unused array
slots will be allocated but cleared to zeroes.

@return TRUE if succeeded*/","
List the bitmap files in srv_data_home and setup their range that contains the
specified LSN interval.  This range, if non-empty, will start with a file that
has the greatest LSN equal to or less than the start LSN and will include all
the files up to the one with the greatest LSN less than the end LSN.  Caller
must free bitmap_files->files when done if bitmap_files set to non-NULL and
this function returned TRUE.  Field bitmap_files->count might be set to a
larger value than the actual count of the files, and space for the unused array
slots will be allocated but cleared to zeroes.

@return TRUE if succeeded



 /**
List the bitmap files in srv_data_home and setup their range that contains the
specified LSN interval.  This range, if non-empty, will start with a file that
has the greatest LSN equal to or less than the start LSN and will include all
the files up to the one with the greatest LSN less than the end LSN.  Caller
must free bitmap_files->files when done if bitmap_files set to non-NULL and
this function returned TRUE.  Field bitmap_files->count might be set to a
larger value than the actual count of the files, and space for the unused array
slots will be allocated but cleared to zeroes.

@return TRUE if succeeded*/

1. */
2. static
3. ibool
4. log_online_setup_bitmap_file_range(",Useful
/*1st pass: size the info array*/,"-9. {
-8. 	os_file_dir_t	bitmap_dir;
-7. 	os_file_stat_t	bitmap_dir_file_info;
-6. 	ulong		first_file_seq_num	= ULONG_MAX;
-5. 	ulong		last_file_seq_num	= 0;
-4. 	lsn_t		first_file_start_lsn	= LSN_MAX;
-3. 	xb_ad(range_end >= range_start);
-2. 	bitmap_fil",Useful
"/*A file that has LSN closer to the range start
			but smaller than it, replacing another such file*/","-7. 			if (file_start_lsn < first_file_start_lsn) {
-6. 				first_file_start_lsn = file_start_lsn;
-5. 			}
-4. 			if (file_seq_num < first_file_seq_num) {
-3. 				first_file_seq_num = file_seq_num;
-2. 			}
-1. 		} else if (file_start_lsn > first_file_st",Useful
/*2nd pass: get the file names in the file_seq_num order*/,"-10. 	if (UNIV_UNLIKELY(os_file_closedir_failed(bitmap_dir))) {
-9. 		os_file_get_last_error(TRUE);
-8. 		msg(""InnoDB: Error: cannot close \'%s\'"",srv_data_home);
-7. 		return FALSE;
-6. 	}
-5. 	if (first_file_seq_num == ULONG_MAX && last_file_seq_num == ",Useful
"/**
Open a bitmap file for reading.

@return whether opened successfully*/","-10. 		ut_ad(bitmap_files->files[i].seq_num
-9. 		      > bitmap_files->files[i - 1].seq_num);
-8. 		ut_ad(bitmap_files->files[i].start_lsn
-7. 		      >= bitmap_files->files[i - 1].start_lsn);
-6. 	}
-5. #endif
-4. 	return TRUE;
-3. }
-2. /**************",Useful
"/*Here and below assume that bitmap file names do not
		contain apostrophes, thus no need for ut_print_filename().*/","-8. {
-7. 	bool	success	= false;
-6. 	xb_ad(name[0] != '\0');
-5. 	snprintf(bitmap_file->name, FN_REFLEN, ""%s%s"", srv_data_home, name);
-4. 	bitmap_file->file = os_file_create_simple_no_error_handling(
-3. 		0, bitmap_file->name,
-2. 		OS_FILE_OPEN, OS_FI",Useful
"/**
Diagnose one or both of the following situations if we read close to
the end of bitmap file:
1) Warn if the remainder of the file is less than one page.
2) Error if we cannot read any more full pages but the last read page
did not have the last-in-run flag set.

@return FALSE for the error*/","-10. 	posix_fadvise(bitmap_file->file, 0, 0, POSIX_FADV_NOREUSE);
-9. #endif
-8. 	return success;
-7. }
-6. /****************************************************************//**
-5. Diagnose one or both of the following situations if we read close to
-4. ",Useful
"/*!< in: ""last page in
							run"" flag value in the
							last read page*/","-10. the end of bitmap file:
-9. 1) Warn if the remainder of the file is less than one page.
-8. 2) Error if we cannot read any more full pages but the last read page
-7. did not have the last-in-run flag set.
-6. @return FALSE for the error */
-5. static",Useful
/*Check if we are too close to EOF to read a full page*/,"-1. {

 /*Check if we are too close to EOF to read a full page*/

1. 	if ((bitmap_file->size < MODIFIED_PAGE_BLOCK_SIZE)
2. 	    || (bitmap_file->offset
3. 		> bitmap_file->size - MODIFIED_PAGE_BLOCK_SIZE)) {
4. 		if (UNIV_UNLIKELY(bitmap_file->offset != ",Useful
"/*If we are not at EOF and we have less than one page
			to read, it's junk.  This error is not fatal in
			itself.*/","-4. 	if ((bitmap_file->size < MODIFIED_PAGE_BLOCK_SIZE)
-3. 	    || (bitmap_file->offset
-2. 		> bitmap_file->size - MODIFIED_PAGE_BLOCK_SIZE)) {
-1. 		if (UNIV_UNLIKELY(bitmap_file->offset != bitmap_file->size)) {

 /*If we are not at EOF and we have les",Useful
"/*We are at EOF but the last read page did not finish
			a run*/","-4. 			msg(""InnoDB: Warning: junk at the end of changed ""
-3. 			    ""page bitmap file \'%s\'."", bitmap_file->name);
-2. 		}
-1. 		if (UNIV_UNLIKELY(!last_page_in_run)) {

 /*We are at EOF but the last read page did not finish
			a run*/

111",Useful
"/*It's a ""Warning"" here because it's not a fatal error
			for the whole server*/","-6. 			msg(""InnoDB: Warning: junk at the end of changed ""
-5. 			    ""page bitmap file \'%s\'."", bitmap_file->name);
-4. 		}
-3. 		if (UNIV_UNLIKELY(!last_page_in_run)) {

 /*It's a ""Warning"" here because it's not a fatal error
			for the whole server*/

",Useful
/** Iterator structure over changed page bitmap*/,"-10. 			for the whole server */
-9. 			msg(""InnoDB: Warning: changed page bitmap ""
-8. 			    ""file \'%s\' does not contain a complete run ""
-7. 			    ""at the end."", bitmap_file->name);
-6. 			return FALSE;
-5. 		}
-4. 	}
-3. 	return TRUE;
-2. }

 /** It",Useful
"/*Space id for this
					        iterator*/","-2. struct xb_page_bitmap_range_struct {

 /*Space id for this
					        iterator*/

111",Useful
"/*Bit index of the iterator
						position in the current page*/","-4. struct xb_page_bitmap_range_struct {

 /*Bit index of the iterator
						position in the current page*/

111",Useful
/*Current bitmap tree node*/,"-6. struct xb_page_bitmap_range_struct {

 /*Current bitmap tree node*/

111",Useful
"/**
Print a diagnostic message on missing bitmap data for an LSN range.*/","-10. 	const xb_page_bitmap	*bitmap;	/* Bitmap with data */
-9. 	ulint			space_id;	/* Space id for this
-8. 					        iterator */
-7. 	ulint			bit_i;		/* Bit index of the iterator
-6. 						position in the current page */
-5. 	const ib_rbt_node_t	*bitma",Useful
"/**
Scan a bitmap file until data for a desired LSN or EOF is found and check that
the page before the starting one is not corrupted to ensure that the found page
indeed contains the very start of the desired LSN data.  The caller must check
the page LSN values to determine if the bitmap file was scanned until the data
was found or until EOF.  Page must be at least MODIFIED_PAGE_BLOCK_SIZE big.

@return TRUE if the scan successful without corruption detected*/","
Scan a bitmap file until data for a desired LSN or EOF is found and check that
the page before the starting one is not corrupted to ensure that the found page
indeed contains the very start of the desired LSN data.  The caller must check
the page LSN values to determine if the bitmap file was scanned until the data
was found or until EOF.  Page must be at least MODIFIED_PAGE_BLOCK_SIZE big.

@return TRUE if the scan successful without corruption detected



 /**
Scan a bitmap file until data for a desired LSN or EOF is found and check that
the page before the starting one is not corrupted to ensure that the found page
indeed contains the very start of the desired LSN data.  The caller must check
the page LSN values to determine if the bitmap file was scanned until the data
was found or until EOF.  Page must be at least MODIFIED_PAGE_BLOCK_SIZE big.

@return TRUE if the scan successful without corruption detected*/

1. */
2. static
3. ibool
4. xb_find_lsn_in_bitmap_file(",Useful
"/*!<out: end LSN of the
							last read page*/","-10. @return TRUE if the scan successful without corruption detected
-9. */
-8. static
-7. ibool
-6. xb_find_lsn_in_bitmap_file(

 /*!<out: end LSN of the
							last read page*/

111",Useful
"/*We check two pages here because the last read page already contains
	the required LSN data. If the next to the last one page is corrupted,
	then we have no way of telling if that page contained the required LSN
	range data too*/","-10. 	while ((*page_end_lsn <= lsn)
-9. 	       && (bitmap_file->offset
-8. 		   <= bitmap_file->size - MODIFIED_PAGE_BLOCK_SIZE)) {
-7. 		next_to_last_page_ok = last_page_ok;
-6. 		if (!log_online_read_bitmap_page(bitmap_file, page,
-5. 						 &last_page",Useful
"/**
Read the disk bitmap and build the changed page bitmap tree for the
LSN interval incremental_lsn to checkpoint_lsn_start.

@return the built bitmap tree or NULL if unable to read the full interval for
any reason.*/","-10. 	/* We check two pages here because the last read page already contains
-9. 	the required LSN data. If the next to the last one page is corrupted,
-8. 	then we have no way of telling if that page contained the required LSN
-7. 	range data too */
-6. ",Useful
/*Only accept no bitmap files returned if start LSN == end LSN*/,"-10. 	if (UNIV_UNLIKELY(bmp_start_lsn > bmp_end_lsn)) {
-9. 		msg(""mariabackup: incremental backup LSN "" LSN_PF
-8. 		    "" is larger than than the last checkpoint LSN "" LSN_PF
-7. 		    , bmp_start_lsn, bmp_end_lsn);
-6. 		return NULL;
-5. 	}
-4. 	if (!l",Useful
/*Empty range - empty bitmap*/,"-6. 	if (bitmap_files.count == 0 && bmp_end_lsn != bmp_start_lsn) {
-5. 		return NULL;
-4. 	}
-3. 	result = rbt_create(MODIFIED_PAGE_BLOCK_SIZE,
-2. 			    log_online_compare_bmp_keys);
-1. 	if (bmp_start_lsn == bmp_end_lsn) {

 /*Empty range - empty bitm",Useful
/*The 1st file does not have the starting LSN data*/,"-5. 		return result;
-4. 	}
-3. 	bmp_i = 0;
-2. 	if (UNIV_UNLIKELY(bitmap_files.files[bmp_i].start_lsn
-1. 			  > bmp_start_lsn)) {

 /*The 1st file does not have the starting LSN data*/

1. 		xb_msg_missing_lsn_data(bmp_start_lsn,
2. 					bitmap_files.fi",Useful
"/*If the 1st file is truncated, no data.  Not merged with the case
	below because zero-length file indicates not a corruption but missing
	subsequent files instead.*/","-7. 	if (UNIV_UNLIKELY(!log_online_open_bitmap_file_read_only(
-6. 				  bitmap_files.files[bmp_i].name,
-5. 				  &bitmap_file))) {
-4. 		rbt_free(result);
-3. 		free(bitmap_files.files);
-2. 		return NULL;
-1. 	}

 /*If the 1st file is truncated, no dat",Useful
/*Find the start of the required LSN range in the file*/,"-7. 	if (UNIV_UNLIKELY(bitmap_file.size < MODIFIED_PAGE_BLOCK_SIZE)) {
-6. 		xb_msg_missing_lsn_data(bmp_start_lsn, bmp_end_lsn);
-5. 		rbt_free(result);
-4. 		free(bitmap_files.files);
-3. 		os_file_close(bitmap_file.file);
-2. 		return NULL;
-1. 	}

 /*",Useful
"/*1st bitmap page found, add it to the tree.*/","-10. 		os_file_close(bitmap_file.file);
-9. 		return NULL;
-8. 	}
-7. 	if (UNIV_UNLIKELY(current_page_end_lsn < bmp_start_lsn)) {
-6. 		xb_msg_missing_lsn_data(current_page_end_lsn, bmp_start_lsn);
-5. 		rbt_free(result);
-4. 		free(bitmap_files.files);
-",Useful
/*Read next pages/files until all required data is read*/,"-1. 	rbt_insert(result, page, page);

 /*Read next pages/files until all required data is read*/

1. 	while (last_page_ok
2. 	       && (current_page_end_lsn < bmp_end_lsn
3. 		   || (current_page_end_lsn == bmp_end_lsn
4. 		       && !last_page_in_run)))",Useful
"/*If EOF, advance the file skipping over any empty files*/","-5. 	while (last_page_ok
-4. 	       && (current_page_end_lsn < bmp_end_lsn
-3. 		   || (current_page_end_lsn == bmp_end_lsn
-2. 		       && !last_page_in_run))) {
-1. 		ib_rbt_bound_t	tree_search_pos;

 /*If EOF, advance the file skipping over any empty ",Useful
"/*Merge the current page with an existing page or insert a new
		page into the tree*/","-10. 			return NULL;
-9. 		}
-8. 		if (UNIV_UNLIKELY(!last_page_ok)) {
-7. 			msg(""mariabackup: warning: changed page bitmap file ""
-6. 			    ""\'%s\' corrupted."", bitmap_file.name);
-5. 			rbt_free(result);
-4. 			free(bitmap_files.files);
-3. 			os_file",Useful
"/**
Free the bitmap tree.*/","-10. 			= mach_read_from_8(page + MODIFIED_PAGE_END_LSN);
-9. 		last_page_in_run
-8. 			= mach_read_from_4(page + MODIFIED_PAGE_IS_LAST_BLOCK);
-7. 	}
-6. 	xb_a (current_page_end_lsn >= bmp_end_lsn);
-5. 	free(bitmap_files.files);
-4. 	os_file_close(bitma",Useful
"/**
Advance to the next bitmap page or setup the first bitmap page for the
given bitmap range.  Assumes that bitmap_range->bitmap_page has been
already found/bumped by rbt_search()/rbt_next().

@return FALSE if no more bitmap data for the range space ID*/","-10. 	xb_page_bitmap*	bitmap)	/*!<in/out: bitmap tree */
-9. {
-8. 	if (bitmap) {
-7. 		rbt_free(bitmap);
-6. 	}
-5. }
-4. /****************************************************************//**
-3. Advance to the next bitmap page or setup the first bitmap ",Useful
/*No more data for the current page id.*/,"-10. 	ulint	new_space_id;
-9. 	ulint	new_1st_page_id;
-8. 	if (bitmap_range->bitmap_node == NULL) {
-7. 		bitmap_range->current_page_id = ULINT_UNDEFINED;
-6. 		return FALSE;
-5. 	}
-4. 	bitmap_range->bitmap_page = rbt_value(byte, bitmap_range->bitmap_nod",Useful
"/** Find the node with the smallest key that greater than equal to search key.
@param[in]	tree	red-black tree
@param[in]	key	search key
@return	node with the smallest greater-than-or-equal key
@retval	NULL	if none was found*/","-10. 		return FALSE;
-9. 	}
-8. 	new_1st_page_id = mach_read_from_4(bitmap_range->bitmap_page +
-7. 					   MODIFIED_PAGE_1ST_PAGE_ID);
-6. 	xb_a (new_1st_page_id >= bitmap_range->current_page_id
-5. 	      || bitmap_range->current_page_id == ULINT_UNDEFI",Useful
"/**
Set up a new bitmap range iterator over a given space id changed
pages in a given bitmap.

@return bitmap range iterator*/","-10. 				break;
-9. 			}
-8. 			node = node->left;
-7. 		}
-6. 	}
-5. 	return(ge);
-4. }
-3. /****************************************************************//**
-2. Set up a new bitmap range iterator over a given space id changed
-1. pages in a given bi",Useful
/*Search for the 1st page for the given space id*/,"-8. {
-7. 	byte			search_page[MODIFIED_PAGE_BLOCK_SIZE];
-6. 	xb_page_bitmap_range	*result
-5. 		= static_cast<xb_page_bitmap_range *>(malloc(sizeof(*result)));
-4. 	memset(result, 0, sizeof(*result));
-3. 	result->bitmap = bitmap;
-2. 	result->space_id =",Useful
"/**
Get the value of the bitmap->range->bit_i bitmap bit

@return the current bit value*/","-10. 	/* This also sets MODIFIED_PAGE_1ST_PAGE_ID to 0, which is what we
-9. 	want. */
-8. 	memset(search_page, 0, MODIFIED_PAGE_BLOCK_SIZE);
-7. 	mach_write_to_4(search_page + MODIFIED_PAGE_SPACE_ID, space_id);
-6. 	result->bitmap_node = rbt_lower_bound(",Useful
"/**
Get the next page id that has its bit set or cleared, i.e. equal to
bit_value.

@return page id*/","-10. 							range */
-9. {
-8. 	return ((*(((bitmap_word_t *)(bitmap_range->bitmap_page
-7. 				     + MODIFIED_PAGE_BLOCK_BITMAP))
-6. 		  + (bitmap_range->bit_i >> 6)))
-5. 		& (1ULL << (bitmap_range->bit_i & 0x3F))) ? TRUE : FALSE;
-4. }
-3. /*********",Useful
"/**
Free the bitmap range iterator.*/","-10. 				return result;
-9. 			}
-8. 		}
-7. 		bitmap_range->bitmap_node
-6. 			= rbt_next(bitmap_range->bitmap,
-5. 				   bitmap_range->bitmap_node);
-4. 	} while (xb_page_bitmap_setup_next_page(bitmap_range));
-3. 	return ULINT_UNDEFINED;
-2. }
-1. /**",Useful
/*bind.c -- key binding and startup file support for the readline library.*/,"
/* bind.c -- key binding and startup file support for the readline library. */


 /*bind.c -- key binding and startup file support for the readline library.*/

1. /* Copyright (C) 1987-2006 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
"/*rl_add_defun (char *name, rl_command_func_t *function, int key)
   Add NAME to the list of named functions.  Make FUNCTION be the function
   that gets called.  If KEY is not -1, then bind it.*/","-6. static int _rl_prefer_visible_bell = 1;

 /*rl_add_defun (char *name, rl_command_func_t *function, int key)
   Add NAME to the list of named functions.  Make FUNCTION be the function
   that gets called.  If KEY is not -1, then bind it.*/

1. int
2. r",Useful
/*Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range.*/,"-10. rl_add_defun (name, function, key)
-9.      const char *name;
-8.      rl_command_func_t *function;
-7.      int key;
-6. {
-5.   if (key != -1)
-4.     rl_bind_key (key, function);
-3.   rl_add_funmap_entry (name, function);
-2.   return 0;
-1. }

 ",Useful
"/*Bind KEY to FUNCTION in MAP.  Returns non-zero in case of invalid
   KEY.*/","-10. 	  escmap[key].function = function;
-9. 	  return (0);
-8. 	}
-7.       return (key);
-6.     }
-5.   _rl_keymap[key].type = ISFUNC;
-4.   _rl_keymap[key].function = function;
-3.   rl_binding_keymap = _rl_keymap;
-2.   return (0);
-1. }

 /*Bind KEY",Useful
"/*Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode.*/","-10.      Keymap map;
-9. {
-8.   int result;
-7.   Keymap oldmap;
-6.   oldmap = _rl_keymap;
-5.   _rl_keymap = map;
-4.   result = rl_bind_key (key, function);
-3.   _rl_keymap = oldmap;
-2.   return (result);
-1. }

 /*Bind key sequence KEYSEQ to DEFAU",Useful
"/*Make KEY do nothing in the currently selected keymap.
   Returns non-zero in case of error.*/","-10. int
-9. rl_bind_key_if_unbound (key, default_func)
-8.      int key;
-7.      rl_command_func_t *default_func;
-6. {
-5.   char keyseq[2];
-4.   keyseq[0] = (unsigned char)key;
-3.   keyseq[1] = '\0';
-2.   return (rl_bind_keyseq_if_unbound_in_map (k",Useful
"/*Make KEY do nothing in MAP.
   Returns non-zero in case of error.*/","-6. int
-5. rl_unbind_key (key)
-4.      int key;
-3. {
-2.   return (rl_bind_key (key, (rl_command_func_t *)NULL));
-1. }

 /*Make KEY do nothing in MAP.
   Returns non-zero in case of error.*/

1. int
2. rl_unbind_key_in_map (key, map)
3.      int key;
",Useful
"/*Bind the key sequence represented by the string KEYSEQ to
   FUNCTION, starting in the current keymap.  This makes new
   keymaps as necessary.*/","-10. rl_unbind_command_in_map (command, map)
-9.      const char *command;
-8.      Keymap map;
-7. {
-6.   rl_command_func_t *func;
-5.   func = rl_named_function (command);
-4.   if (func == 0)
-3.     return 0;
-2.   return (rl_unbind_function_in_map (",Useful
"/*Bind the key sequence represented by the string KEYSEQ to
   FUNCTION.  This makes new keymaps as necessary.  The initial
   place to do bindings is in MAP.*/","-7. int
-6. rl_bind_keyseq (keyseq, function)
-5.      const char *keyseq;
-4.      rl_command_func_t *function;
-3. {
-2.   return (rl_generic_bind (ISFUNC, keyseq, (char *)function, _rl_keymap));
-1. }

 /*Bind the key sequence represented by the string",Useful
"/*Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
   now, this is always used to attempt to bind the arrow keys, hence the
   check for rl_vi_movement_mode.*/","-10.      Keymap map;
-9. {
-8.   int result;
-7.   Keymap oldmap;
-6.   oldmap = _rl_keymap;
-5.   _rl_keymap = map;
-4.   result = rl_bind_key (key, function);
-3.   _rl_keymap = oldmap;
-2.   return (result);
-1. }

 /*Bind key sequence KEYSEQ to DEFAU",Useful
"/*Bind the key sequence represented by the string KEYSEQ to
   the string of characters MACRO.  This makes new keymaps as
   necessary.  The initial place to do bindings is in MAP.*/","-10.     }
-9.   return 0;
-8. }
-7. int
-6. rl_bind_keyseq_if_unbound (keyseq, default_func)
-5.      const char *keyseq;
-4.      rl_command_func_t *default_func;
-3. {
-2.   return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
",Useful
"/*Bind the key sequence represented by the string KEYSEQ to
   the arbitrary pointer DATA.  TYPE says what kind of data is
   pointed to by DATA, right now this can be a function (ISFUNC),
   a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps
   as necessary.  The initial place to do bindings is in MAP.*/","-10.   int macro_keys_len;
-9.   macro_keys = (char *)xmalloc ((2 * strlen (macro)) + 1);
-8.   if (rl_translate_keyseq (macro, macro_keys, &macro_keys_len))
-7.     {
-6.       free (macro_keys);
-5.       return -1;
-4.     }
-3.   rl_generic_bind (ISMA",Useful
"/*If no keys to bind to, exit right away.*/","-10. rl_generic_bind (type, keyseq, data, map)
-9.      int type;
-8.      const char *keyseq;
-7.      char *data;
-6.      Keymap map;
-5. {
-4.   char *keys;
-3.   int keys_len;
-2.   register int i;
-1.   KEYMAP_ENTRY k= { 0, NULL };

 /*If no keys to",Useful
"/*Translate the ASCII representation of KEYSEQ into an array of
     characters.  Stuff the characters into KEYS, and the length of
     KEYS into KEYS_LEN.*/","-7.   if (keyseq == 0 || *keyseq == 0)
-6.     {
-5.       if (type == ISMACR)
-4. 	free (data);
-3.       return -1;
-2.     }
-1.   keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));

 /*Translate the ASCII representation of KEYSEQ into an array of
   ",Useful
"/*We allow subsequences of keys.  If a keymap is being
		 created that will `shadow' an existing function or macro
		 key binding, we save that keybinding into the ANYOTHERKEY
		 index in the new map.  The dispatch code will look there
		 to find the function to execute if the subsequence is not
		 matched.  ANYOTHERKEY was chosen to be greater than
		 UCHAR_MAX.*/","-10.       if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
-9. 	{
-8. 	  ic = UNMETA (ic);
-7. 	  if (map[ESC].type == ISKMAP)
-6. 	    map = FUNCTION_TO_KEYMAP (map, ESC);
-5. 	}
-4.       if ((i + 1) < keys_len)
-3. 	{
-2. 	  if (map[ic].type != ",Useful
"/*The dispatch code will return this function if no matching
	     key sequence is found in the keymap.  This (with a little
	     help from the dispatch code in readline.c) allows `a' to be
	     mapped to something, `abc' to be mapped to something else,
	     and the function bound  to `a' to be executed when the user
	     types `abx', leaving `bx' in the input queue.*/","-10. 		 key binding, we save that keybinding into the ANYOTHERKEY
-9. 		 index in the new map.  The dispatch code will look there
-8. 		 to find the function to execute if the subsequence is not
-7. 		 matched.  ANYOTHERKEY was chosen to be greater than
-",Useful
"/*Translate the ASCII representation of SEQ, stuffing the values into ARRAY,
   an array of characters.  LEN gets the final length of ARRAY.  Return
   non-zero if there was an error parsing SEQ.*/","-10. 	      ic = ANYOTHERKEY;
-9. 	    }
-8. 	  map[ic].function = KEYMAP_TO_FUNCTION (data);
-7. 	  map[ic].type = type;
-6. 	}
-5.       rl_binding_keymap = map;
-4.     }
-3.   free (keys);
-2.   return 0;
-1. }

 /*Translate the ASCII representation o",Useful
/*Handle special case of backwards define.*/,"-2. 	  if ((c == 'C' || c == 'M') && seq[i + 1] == '-')
-1. 	    {

 /*Handle special case of backwards define.*/

1. 	      if (strncmp (&seq[i], ""C-\\M-"", 5) == 0)
2. 		{",Useful
"/*This doesn't yet handle things like \M-\a, which may
			 or may not have any reasonable meaning.  You're
			 probably better off using straight octal or hex.*/","-8. 		  else if (seq[i+1] == '\\' && seq[i+2] == 'C' && seq[i+3] == '-')
-7. 		    {
-6. 		      i += 4;
-5. 		      temp = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
-4. 		      array[l++] = META (temp);
-3. 		    }
-2. 		  else
-1. 		    {",Useful
"/*Translate other backslash-escaped characters.  These are the
	     same escape sequences that bash's `echo' and `printf' builtins
	     handle, with the addition of \d -> RUBOUT.  A backslash
	     preceding a character that is not special is stripped.*/","-4. 		  array[l++] = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
-3. 		}
-2. 	      continue;
-1. 	    }

 /*Translate other backslash-escaped characters.  These are the
	     same escape sequences that bash's `echo' and `printf' builtins
	  ",Useful
/*backslashes before non-special chars just add the char*/,"-2. 	      array[l++] = c & largest_char;
-1. 	      break;

 /*backslashes before non-special chars just add the char*/

1. 	      array[l++] = c;",Useful
"/*Return a pointer to the function that STRING represents.
   If STRING doesn't have a matching function, then a NULL pointer
   is returned.*/","-10. 	  *r++ = '\\';
-9. 	  c = 'e';
-8. 	}
-7.       else if (c == '\\' || c == '""')
-6. 	*r++ = '\\';
-5.       *r++ = (unsigned char)c;
-4.     }
-3.   *r = '\0';
-2.   return ret;
-1. }

 /*Return a pointer to the function that STRING represents.
   I",Useful
"/*Return the function (or macro) definition which would be invoked via
   KEYSEQ if executed in MAP.  If MAP is NULL, then the current keymap is
   used.  TYPE, if non-NULL, is a pointer to an int which will receive the
   type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),
   or ISMACR (macro).*/","-10. rl_named_function (string)
-9.      const char *string;
-8. {
-7.   register int i;
-6.   rl_initialize_funmap ();
-5.   for (i = 0; funmap[i]; i++)
-4.     if (_rl_stricmp (funmap[i]->name, string) == 0)
-3.       return (funmap[i]->function);
-2.  ",Useful
"/*XXX - should we just return NULL here, since this obviously
	     doesn't match?*/","-10.   for (i = 0; keyseq && keyseq[i]; i++)
-9.     {
-8.       unsigned char ic = keyseq[i];
-7.       if (META_CHAR_FOR_UCHAR(ic) && _rl_convert_meta_chars_to_ascii)
-6. 	{
-5. 	  if (map[ESC].type == ISKMAP)
-4. 	    {
-3. 	      map = FUNCTION_TO_KEY",Useful
"/*If this is the last key in the key sequence, return the
	     map.*/","-10. 	     doesn't match? */
-9. 	  else
-8. 	    {
-7. 	      if (type)
-6. 		*type = map[ESC].type;
-5. 	      return (map[ESC].function);
-4. 	    }
-3. 	}
-2.       if (map[ic].type == ISKMAP)
-1. 	{

 /*If this is the last key in the key sequence, re",Useful
"/*If we're not at the end of the key sequence, and the current key
	 is bound to something other than a keymap, then the entire key
	 sequence is not bound.*/","-10. 	     map. */
-9. 	  if (keyseq[i + 1] == '\0')
-8. 	    {
-7. 	      if (type)
-6. 		*type = ISKMAP;
-5. 	      return (map[ic].function);
-4. 	    }
-3. 	  else
-2. 	    map = FUNCTION_TO_KEYMAP (map, ic);
-1. 	}

 /*If we're not at the end of the ",Useful
"/*Read FILENAME into a locally-allocated buffer and return the buffer.
   The size of the buffer is returned in *SIZEP.  Returns NULL if any
   errors were encountered.*/","-3. static const char *current_readline_init_file;
-2. static int current_readline_init_include_level;
-1. static int current_readline_init_lineno;

 /*Read FILENAME into a locally-allocated buffer and return the buffer.
   The size of the buffer is retur",Useful
/*check for overflow on very large files*/,"-10.      char *filename;
-9.      size_t *sizep;
-8. {
-7.   struct stat finfo;
-6.   size_t file_size;
-5.   char *buffer;
-4.   int i, file;
-3.   if ((stat (filename, &finfo) < 0) || (file = open (filename, O_RDONLY, 0666)) < 0)
-2.     return ((char ",Useful
/*Read the file into BUFFER.*/,"-10.   if ((sizeof(off_t) > sizeof(size_t) && finfo.st_size > (off_t)(size_t)~0) ||  
-9.     file_size + 1 < file_size)
-8.     {
-7.       if (file >= 0)
-6. 	close (file);
-5. #if defined (EFBIG)
-4.       errno = EFBIG;
-3. #endif
-2.       return ((c",Useful
"/*Do key bindings from a file.  If FILENAME is NULL it defaults
   to the first non-null filename from this list:
     1. the filename used for the previous call
     2. the value of the shell variable `INPUTRC'
     3. ~/.inputrc
     4. /etc/inputrc
   If the file existed and could be opened and read, 0 is returned,
   otherwise errno is returned.*/","-9. int
-8. rl_re_read_init_file (count, ignore)
-7.      int count __attribute__((unused)), ignore __attribute__((unused));
-6. {
-5.   int r;
-4.   r = rl_read_init_file ((const char *)NULL);
-3.   rl_set_keymap_from_edit_mode ();
-2.   return r;
-1. }
",Useful
"/*Loop over the lines in the file.  Lines that start with `#' are
     comments; all other lines are commands for readline initialization.*/","-10.   buffer = _rl_read_file (openname, &file_size);
-9.   free (openname);
-8.   if (buffer == 0)
-7.     return (errno);
-6.   if (include_level == 0 && filename != last_readline_init_file)
-5.     {
-4.       FREE (last_readline_init_file);
-3.       ",Useful
"/*If the line is not a comment, then parse it.*/","-5.       while (*line && whitespace (*line))
-4.         {
-3. 	  line++;
-2. 	  i--;
-1.         }

 /*If the line is not a comment, then parse it.*/

1.       if (*line && *line != '#')
2. 	rl_parse_and_bind (line);",Useful
/*Stack of previous values of parsing_conditionalized_out.*/,"-1. const char *rl_readline_name = ""other"";

 /*Stack of previous values of parsing_conditionalized_out.*/

1. static unsigned char *if_stack = (unsigned char *)NULL;
2. static int if_stack_depth;
3. static int if_stack_size;",Useful
"/*Push _rl_parsing_conditionalized_out, and set parser state based
   on ARGS.*/","-3. static unsigned char *if_stack = (unsigned char *)NULL;
-2. static int if_stack_depth;
-1. static int if_stack_size;

 /*Push _rl_parsing_conditionalized_out, and set parser state based
   on ARGS.*/

1. static int
2. parser_if (args)
3.      char *ar",Useful
/*Push parser state.*/,"-5. static int
-4. parser_if (args)
-3.      char *args;
-2. {
-1.   register int i;

 /*Push parser state.*/

1.   if (if_stack_depth + 1 >= if_stack_size)
2.     {
3.       if (!if_stack)
4. 	if_stack = (unsigned char *)xmalloc (if_stack_size = 20);
5. ",Useful
"/*If parsing is turned off, then nothing can turn it back on except
     for finding the matching endif.  In that case, return right now.*/","-8.   if (if_stack_depth + 1 >= if_stack_size)
-7.     {
-6.       if (!if_stack)
-5. 	if_stack = (unsigned char *)xmalloc (if_stack_size = 20);
-4.       else
-3. 	if_stack = (unsigned char *)xrealloc (if_stack, if_stack_size += 20);
-2.     }
-1.   if_s",Useful
/*Isolate first argument.*/,"-2.   if (_rl_parsing_conditionalized_out)
-1.     return 0;

 /*Isolate first argument.*/

1.   for (i = 0; args[i] && !whitespace (args[i]); i++);
2.   if (args[i])
3.     args[i++] = '\0';",Useful
"/*Handle ""$if term=foo"" and ""$if mode=emacs"" constructs.  If this
     isn't term=foo, or mode=emacs, then check to see if the first
     word in ARGS is the same as the value stored in rl_readline_name.*/","-3.   for (i = 0; args[i] && !whitespace (args[i]); i++);
-2.   if (args[i])
-1.     args[i++] = '\0';

 /*Handle ""$if term=foo"" and ""$if mode=emacs"" constructs.  If this
     isn't term=foo, or mode=emacs, then check to see if the first
     word in ARGS",Useful
"/*Test the `long' and `short' forms of the terminal name so that
	 if someone has a `sun-cmd' and does not want to have bindings
	 that will be executed if the terminal is a `sun', they can put
	 `$if term=sun-cmd' into their .inputrc.*/","-4.       tname = savestring (rl_terminal_name);
-3.       tem = strchr (tname, '-');
-2.       if (tem)
-1. 	*tem = '\0';

 /*Test the `long' and `short' forms of the terminal name so that
	 if someone has a `sun-cmd' and does not want to have bindings
	",Useful
"/*Check to see if the first word in ARGS is the same as the
     value stored in rl_readline_name.*/","-10.       int mode;
-9.       if (_rl_stricmp (args + 5, ""emacs"") == 0)
-8. 	mode = emacs_mode;
-7.       else if (_rl_stricmp (args + 5, ""vi"") == 0)
-6. 	mode = vi_mode;
-5.       else
-4. 	mode = no_mode;
-3.       _rl_parsing_conditionalized_out = mod",Useful
/*Invert the current parser state if there is anything on the stack.*/,"-6.   else if (_rl_stricmp (args, rl_readline_name) == 0)
-5.     _rl_parsing_conditionalized_out = 0;
-4.   else
-3.     _rl_parsing_conditionalized_out = 1;
-2.   return 0;
-1. }

 /*Invert the current parser state if there is anything on the stack.*/

",Useful
"/*Check the previous (n - 1) levels of the stack to make sure that
     we haven't previously turned off parsing.*/","-10. parser_else (args)
-9.      char *args __attribute__((unused));
-8. {
-7.   register int i;
-6.   if (if_stack_depth == 0)
-5.     {
-4.       _rl_init_file_error (""$else found without matching $if"");
-3.       return 0;
-2.     }
-1. #if 0

 /*Check",Useful
"/*Check the previous (n) levels of the stack to make sure that
     we haven't previously turned off parsing.*/","-2.   for (i = 0; i < if_stack_depth - 1; i++)
-1. #else

 /*Check the previous (n) levels of the stack to make sure that
     we haven't previously turned off parsing.*/

1.   for (i = 0; i < if_stack_depth; i++)
2. #endif
3.     if (if_stack[i] == 1)
4.",Useful
/*Invert the state of parsing if at top level.*/,"-4.   for (i = 0; i < if_stack_depth; i++)
-3. #endif
-2.     if (if_stack[i] == 1)
-1.       return 0;

 /*Invert the state of parsing if at top level.*/

1.   _rl_parsing_conditionalized_out = !_rl_parsing_conditionalized_out;
2.   return 0;
3. }",Useful
"/*Terminate a conditional, popping the value of
   _rl_parsing_conditionalized_out from the stack.*/","-3.   _rl_parsing_conditionalized_out = !_rl_parsing_conditionalized_out;
-2.   return 0;
-1. }

 /*Terminate a conditional, popping the value of
   _rl_parsing_conditionalized_out from the stack.*/

1. static int
2. parser_endif (args)
3.      char *args",Useful
"/*Handle a parser directive.  STATEMENT is the line of the directive
   without any leading `$'.*/","-10. static struct {
-9.   const char *name;
-8.   _rl_parser_func_t *function;
-7. } parser_directives [] = {
-6.   { ""if"", parser_if },
-5.   { ""endif"", parser_endif },
-4.   { ""else"", parser_else },
-3.   { ""include"", parser_include },
-2.   { (char *)",Useful
/*display an error message about the unknown parser directive*/,"-6.   for (i = 0; parser_directives[i].name; i++)
-5.     if (_rl_stricmp (directive, parser_directives[i].name) == 0)
-4.       {
-3. 	(*parser_directives[i].function) (args);
-2. 	return (0);
-1.       }

 /*display an error message about the unknown pa",Useful
"/*Read the binding command from STRING and perform it.
   A key binding command looks like: Keyname: function-name\0,
   a variable binding command looks like: set variable value.
   A new-style keybinding looks like ""\C-x\C-x"": exchange-point-and-mark.*/","-3.   _rl_init_file_error (""unknown parser directive"");
-2.   return (1);
-1. }

 /*Read the binding command from STRING and perform it.
   A key binding command looks like: Keyname: function-name\0,
   a variable binding command looks like: set variable ",Useful
"/*If this is a parser directive, act on it.*/","-10. rl_parse_and_bind (string)
-9.      char *string;
-8. {
-7.   char *funname, *kname;
-6.   register int c, i;
-5.   int key, equivalency;
-4.   while (string && whitespace (*string))
-3.     string++;
-2.   if (!string || !*string || *string == '#')
",Useful
"/*If we aren't supposed to be parsing right now, then we're done.*/","-5.   if (*string == '$')
-4.     {
-3.       handle_parser_directive (&string[1]);
-2.       return 0;
-1.     }

 /*If we aren't supposed to be parsing right now, then we're done.*/

1.   if (_rl_parsing_conditionalized_out)
2.     return 0;
3.   i = 0;",Useful
"/*If this keyname is a complex key expression surrounded by quotes,
     advance to after the matching close quote.  This code allows the
     backslash to quote characters in the key expression.*/","-3.   if (_rl_parsing_conditionalized_out)
-2.     return 0;
-1.   i = 0;

 /*If this keyname is a complex key expression surrounded by quotes,
     advance to after the matching close quote.  This code allows the
     backslash to quote characters in the",Useful
"/*If we didn't find a closing quote, abort the line.*/","-10. 	      continue;
-9. 	    }
-8. 	  if (c == '\\')
-7. 	    {
-6. 	      passc++;
-5. 	      continue;
-4. 	    }
-3. 	  if (c == '""')
-2. 	    break;
-1. 	}

 /*If we didn't find a closing quote, abort the line.*/

1.       if (string[i] == '\0')
2. ",Useful
/*Advance to the colon (:) or whitespace which separates the two objects.*/,"-6.       if (string[i] == '\0')
-5.         {
-4.           _rl_init_file_error (""no closing `\""' in key binding"");
-3.           return 1;
-2.         }
-1.     }

 /*Advance to the colon (:) or whitespace which separates the two objects.*/

1.   for (;",Useful
"/*If doing assignment, skip the '=' sign as well.*/","-2.   if (string[i])
-1.     string[i++] = '\0';

 /*If doing assignment, skip the '=' sign as well.*/

1.   if (equivalency)
2.     string[i++] = '\0';",Useful
"/*If this is a command to set a variable, then do that.*/","-2.   if (equivalency)
-1.     string[i++] = '\0';

 /*If this is a command to set a variable, then do that.*/

1.   if (_rl_stricmp (string, ""set"") == 0)
2.     {
3.       char *var, *value, *e;
4.       var = string + i;",Useful
/*Make VAR point to start of variable name.*/,"-4.   if (_rl_stricmp (string, ""set"") == 0)
-3.     {
-2.       char *var, *value, *e;
-1.       var = string + i;

 /*Make VAR point to start of variable name.*/

1.       while (*var && whitespace (*var)) var++;",Useful
/*Make VALUE point to start of value string.*/,"-1.       while (*var && whitespace (*var)) var++;

 /*Make VALUE point to start of value string.*/

1.       value = var;
2.       while (*value && !whitespace (*value)) value++;
3.       if (*value)
4. 	*value++ = '\0';
5.       while (*value && whitesp",Useful
"/*Strip trailing whitespace from values to boolean variables.  Temp
	 fix until I get a real quoted-string parser here.*/","-5.       value = var;
-4.       while (*value && !whitespace (*value)) value++;
-3.       if (*value)
-2. 	*value++ = '\0';
-1.       while (*value && whitespace (*value)) value++;

 /*Strip trailing whitespace from values to boolean variables.  Temp
	 f",Useful
"/*Now isolate funname.
     For straight function names just look for whitespace, since
     that will signify the end of the string.  But this could be a
     macro definition.  In that case, the string is quoted, so skip
     to the matching delimiter.  We allow the backslash to quote the
     delimiter characters in the macro body.*/","-2.   for (; string[i] && whitespace (string[i]); i++);
-1.   funname = &string[i];

 /*Now isolate funname.
     For straight function names just look for whitespace, since
     that will signify the end of the string.  But this could be a
     macro def",Useful
"/*This code exists to allow whitespace in macro expansions, which
     would otherwise be gobbled up by the next `for' loop.*/","-8.   for (; string[i] && whitespace (string[i]); i++);
-7.   funname = &string[i];

 /*This code exists to allow whitespace in macro expansions, which
     would otherwise be gobbled up by the next `for' loop.*/

111",Useful
"/*XXX - it may be desirable to allow backslash quoting only if "" is
     the quoted string delimiter, like the shell.*/","-10.   for (; string[i] && whitespace (string[i]); i++);
-9.   funname = &string[i];

 /*XXX - it may be desirable to allow backslash quoting only if "" is
     the quoted string delimiter, like the shell.*/

1.   if (*funname == '\'' || *funname == '""')
2",Useful
/*Advance to the end of the string.*/,"-10. 	    {
-9. 	      passc = 1;
-8. 	      continue;
-7. 	    }
-6. 	  if (c == delimiter)
-5. 	    break;
-4. 	}
-3.       if (c)
-2. 	i++;
-1.     }

 /*Advance to the end of the string.*/

1.   for (; string[i] && !whitespace (string[i]); i++);",Useful
/*No extra whitespace at the end of the string.*/,"-1.   for (; string[i] && !whitespace (string[i]); i++);

 /*No extra whitespace at the end of the string.*/

1.   string[i] = '\0';",Useful
"/*Handle equivalency bindings here.  Make the left-hand side be exactly
     whatever the right-hand evaluates to, including keymaps.*/","-1.   string[i] = '\0';

 /*Handle equivalency bindings here.  Make the left-hand side be exactly
     whatever the right-hand evaluates to, including keymaps.*/

1.   if (equivalency)
2.     {
3.       return 0;
4.     }",Useful
"/*If this is a new-style key-binding, then do the binding with
     rl_bind_keyseq ().  Otherwise, let the older code deal with it.*/","-4.   if (equivalency)
-3.     {
-2.       return 0;
-1.     }

 /*If this is a new-style key-binding, then do the binding with
     rl_bind_keyseq ().  Otherwise, let the older code deal with it.*/

1.   if (*string == '""')
2.     {
3.       char *seq;
4",Useful
"/*Allow backslash to quote characters, but leave them in place.
	     This allows a string to end with a backslash quoting another
	     backslash, or with a backslash quoting a double quote.  The
	     backslashes are left in place for rl_translate_keyseq ().*/","-7.   if (*string == '""')
-6.     {
-5.       char *seq;
-4.       register int j, k, passc;
-3.       seq = (char *)xmalloc (1 + strlen (string));
-2.       for (j = 1, k = passc = 0; string[j]; j++)
-1. 	{

 /*Allow backslash to quote characters, but le",Useful
/*Remove the delimiting quotes from each end of FUNNAME.*/,"-3.       if (*funname == '\'' || *funname == '""')
-2. 	{
-1. 	  j = strlen (funname);

 /*Remove the delimiting quotes from each end of FUNNAME.*/

1. 	  if (j && funname[j - 1] == *funname)
2. 	    funname[j - 1] = '\0';
3. 	  rl_macro_bind (seq, &funna",Useful
/*Get the actual character we want to deal with.*/,"-9. 	  if (j && funname[j - 1] == *funname)
-8. 	    funname[j - 1] = '\0';
-7. 	  rl_macro_bind (seq, &funname[1], _rl_keymap);
-6. 	}
-5.       else
-4. 	rl_bind_keyseq (seq, rl_named_function (funname));
-3.       free (seq);
-2.       return 0;
-1.   ",Useful
/*Add in control and meta bits.*/,"-6.   kname = strrchr (string, '-');
-5.   if (!kname)
-4.     kname = string;
-3.   else
-2.     kname++;
-1.   key = glean_key_from_name (kname);

 /*Add in control and meta bits.*/

1.   if (substring_member_of_array (string, _rl_possible_control_prefi",Useful
/*Temporary.  Handle old-style keyname with macro-binding.*/,"-4.   if (substring_member_of_array (string, _rl_possible_control_prefixes))
-3.     key = CTRL (_rl_to_upper (key));
-2.   if (substring_member_of_array (string, _rl_possible_meta_prefixes))
-1.     key = META (key);

 /*Temporary.  Handle old-style keyn",Useful
"/*Hooks for handling special boolean variables, where a
   function needs to be called or another variable needs
   to be changed when they're changed.*/","-10. static int
-9. find_boolean_var (name)
-8.      const char *name;
-7. {
-6.   register int i;
-5.   for (i = 0; boolean_varlist[i].name; i++)
-4.     if (_rl_stricmp (name, boolean_varlist[i].name) == 0)
-3.       return i;
-2.   return -1;
-1. }

 /",Useful
"/*These *must* correspond to the array indices for the appropriate
   string variable.  (Though they're not used right now.)*/","-10.     _rl_enable_paren_matching (rl_blink_matching_paren);
-9.   else if (_rl_stricmp (name, ""prefer-visible-bell"") == 0)
-8.     {
-7.       if (_rl_prefer_visible_bell)
-6. 	_rl_bell_preference = VISIBLE_BELL;
-5.       else
-4. 	_rl_bell_preference ",Useful
"/*A boolean value that can appear in a `set variable' command is true if
   the value is null or empty, `on' (case-insenstive), or ""1"".  Any other
   values result in 0 (false).*/","-10. static int
-9. find_string_var (name)
-8.      const char *name;
-7. {
-6.   register int i;
-5.   for (i = 0; string_varlist[i].name; i++)
-4.     if (_rl_stricmp (name, string_varlist[i].name) == 0)
-3.       return i;
-2.   return -1;
-1. }

 /*A ",Useful
/*Check for simple variables first.*/,"-10. {
-9.   return (value == 0 || *value == '\0' ||
-8. 		(_rl_stricmp (value, ""on"") == 0) ||
-7. 		(value[0] == '1' && value[1] == '\0'));
-6. }
-5. const char *
-4. rl_variable_value (name)
-3.      const char *name;
-2. {
-1.   register int i;

 /*Che",Useful
/*Unknown variable names return NULL.*/,"-6.   i = find_boolean_var (name);
-5.   if (i >= 0)
-4.     return (*boolean_varlist[i].value ? ""on"" : ""off"");
-3.   i = find_string_var (name);
-2.   if (i >= 0)
-1.     return (_rl_get_string_variable_value (string_varlist[i].name));

 /*Unknown variab",Useful
/*Check for simple variables first.*/,"-10. {
-9.   return (value == 0 || *value == '\0' ||
-8. 		(_rl_stricmp (value, ""on"") == 0) ||
-7. 		(value[0] == '1' && value[1] == '\0'));
-6. }
-5. const char *
-4. rl_variable_value (name)
-3.      const char *name;
-2. {
-1.   register int i;

 /*Che",Useful
"/*For the time being, unknown variable names or string names without a
     handler function are simply ignored.*/","-9.   i = find_boolean_var (name);
-8.   if (i >= 0)
-7.     {
-6.       *boolean_varlist[i].value = bool_to_int (value);
-5.       if (boolean_varlist[i].flags & V_SPECIAL)
-4. 	hack_special_boolean_var (i);
-3.       return 0;
-2.     }
-1.   i = find_s",Useful
/*Isolate the value and translate it into a character string.*/,"-10.   return 0;
-9. }
-8. static int
-7. sv_isrchterm (value)
-6.      const char *value;
-5. {
-4.   int beg, end, delim;
-3.   char *v;
-2.   if (value == 0)
-1.     return 1;

 /*Isolate the value and translate it into a character string.*/

1.   v = ",Useful
/*The value starts at v + beg.  Translate it into a character string.*/,"-10.       delim = v[0];
-9.       for (beg = end = 1; v[end] && v[end] != delim; end++)
-8. 	;
-7.     }
-6.   else
-5.     {
-4.       for (beg = end = 0; whitespace (v[end]) == 0; end++)
-3. 	;
-2.     }
-1.   v[end] = '\0';

 /*The value starts at v +",Useful
"/*Return the character which matches NAME.
   For example, `Space' returns ' '.*/","-6.   _rl_isearch_terminators = (char *)xmalloc (2 * strlen (v) + 1);
-5.   rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
-4.   _rl_isearch_terminators[end] = '\0';
-3.   free (v);
-2.   return 0;
-1. }

 /*Return the character which match",Useful
"/*Each of the following functions produces information about the
   state of keybindings and functions known to Readline.  The info
   is always printed to rl_outstream, and in such a way that it can
   be read back in (i.e., passed to rl_parse_and_bind ()).*/","-8.   else
-7.     return ""none"";
-6. }

 /*Each of the following functions produces information about the
   state of keybindings and functions known to Readline.  The info
   is always printed to rl_outstream, and in such a way that it can
   be read ba",Useful
"/*Since this is going to be used to write out keysequence-function
     pairs for possible inclusion in an inputrc file, we don't want to
     do any special meta processing on KEY.*/","-10.   free (funmap_names);
-9. }
-8. static char *
-7. _rl_get_keyname (key)
-6.      int key;
-5. {
-4.   char *keyname;
-3.   int i, c;
-2.   keyname = (char *)xmalloc (8);
-1.   c = key;

 /*Since this is going to be used to write out keysequence-func",Useful
"/*If this is an escape character, we don't want to do any more processing.
     Just add the special ESC key sequence and return.*/","-3. #if 1

 /*If this is an escape character, we don't want to do any more processing.
     Just add the special ESC key sequence and return.*/

1.   if (c == ESC)
2.     {
3.       keyname[0] = '\\';
4.       keyname[1] = 'e';
5.       keyname[2] = '\0';",Useful
"/*Now add special prefixes needed for control characters.  This can
     potentially change C.*/","-10.   if (key == RUBOUT)
-9.     {
-8.       keyname[0] = '\\';
-7.       keyname[1] = 'C';
-6.       keyname[2] = '-';
-5.       keyname[3] = '?';
-4.       keyname[4] = '\0';
-3.       return keyname;
-2.     }
-1.   i = 0;

 /*Now add special prefixes",Useful
"/*XXX experimental code.  Turn the characters that are not ASCII or
     ISO Latin 1 (128 - 159) into octal escape sequences (\200 - \237).
     This changes C.*/","-7.   if (CTRL_CHAR (c))
-6.     {
-5.       keyname[i++] = '\\';
-4.       keyname[i++] = 'C';
-3.       keyname[i++] = '-';
-2.       c = _rl_to_lower (UNCTRL (c));
-1.     }

 /*XXX experimental code.  Turn the characters that are not ASCII or
     ISO",Useful
"/*Now, if the character needs to be quoted with a backslash, do that.*/","-10.      ISO Latin 1 (128 - 159) into octal escape sequences (\200 - \237).
-9.      This changes C. */
-8.   if (c >= 128 && c <= 159)
-7.     {
-6.       keyname[i++] = '\\';
-5.       keyname[i++] = '2';
-4.       c -= 128;
-3.       keyname[i++] = (c",Useful
"/*Now add the key, terminate the string, and return it.*/","-2.   if (c == '\\' || c == '""')
-1.     keyname[i++] = '\\';

 /*Now add the key, terminate the string, and return it.*/

1.   keyname[i++] = (char) c;
2.   keyname[i] = '\0';
3.   return keyname;
4. }",Useful
"/*Return a NULL terminated array of strings which represent the key
   sequences that are used to invoke FUNCTION in MAP.*/","-4.   keyname[i++] = (char) c;
-3.   keyname[i] = '\0';
-2.   return keyname;
-1. }

 /*Return a NULL terminated array of strings which represent the key
   sequences that are used to invoke FUNCTION in MAP.*/

1. char **
2. rl_invoking_keyseqs_in_map (fu",Useful
"/*Macros match, if, and only if, the pointers are identical.
	     Thus, they are treated exactly like functions in here.*/","-10.   register int key;
-9.   char **result;
-8.   int result_index, result_size;
-7.   result = (char **)NULL;
-6.   result_index = result_size = 0;
-5.   for (key = 0; key < KEYMAP_SIZE; key++)
-4.     {
-3.       switch (map[key].type)
-2. 	{
-1. 	cas",Useful
"/*If the function in the keymap is the one we are looking for,
	     then add the current KEY to the list of invoking keys.*/","-1. 	case ISFUNC:

 /*If the function in the keymap is the one we are looking for,
	     then add the current KEY to the list of invoking keys.*/

1. 	  if (map[key].function == function)
2. 	    {
3. 	      char *keyname;
4. 	      keyname = _rl_get_keyn",Useful
"/*Find the list of keyseqs in this map which have FUNCTION as
	       their target.  Add the key sequences found to RESULT.*/","-10. 		  result = (char **)xrealloc (result, result_size * sizeof (char *));
-9. 	        }
-8. 	      result[result_index++] = keyname;
-7. 	      result[result_index] = (char *)NULL;
-6. 	    }
-5. 	  break;
-4. 	case ISKMAP:
-3. 	  {
-2. 	    char **se",Useful
"/*If ESC is the meta prefix and we're converting chars
		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC.*/","-10. 	        rl_invoking_keyseqs_in_map (function, FUNCTION_TO_KEYMAP (map, key));
-9. 	    else
-8. 	      break;
-7. 	    if (seqs == 0)
-6. 	      break;
-5. 	    for (i = 0; seqs[i]; i++)
-4. 	      {
-3. 		char *keyname = (char *)xmalloc (6 + strlen",Useful
"/*Return a NULL terminated array of strings which represent the key
   sequences that can be used to invoke FUNCTION using the current keymap.*/","-10. 		result[result_index++] = keyname;
-9. 		result[result_index] = (char *)NULL;
-8. 	      }
-7. 	    free (seqs);
-6. 	  }
-5. 	  break;
-4. 	}
-3.     }
-2.   return (result);
-1. }

 /*Return a NULL terminated array of strings which represent the k",Useful
"/*Print all of the functions and their bindings to rl_outstream.  If
   PRINT_READABLY is non-zero, then print the output in such a way
   that it can be read back in.*/","-6. char **
-5. rl_invoking_keyseqs (function)
-4.      rl_command_func_t *function;
-3. {
-2.   return (rl_invoking_keyseqs_in_map (function, _rl_keymap));
-1. }

 /*Print all of the functions and their bindings to rl_outstream.  If
   PRINT_READABLY is ",Useful
"/*Print all of the current functions and their bindings to
   rl_outstream.  If an explicit argument is given, then print
   the output in such a way that it can be read back in.*/","-10. 		}
-9. 	      if (j == 5 && invokers[j])
-8. 		fprintf (rl_outstream, ""...\n"");
-7. 	      for (j = 0; invokers[j]; j++)
-6. 		free (invokers[j]);
-5. 	      free (invokers);
-4. 	    }
-3. 	}
-2.     }
-1. }

 /*Print all of the current functions a",Useful
"/*Print all of the current variables and their values to
   rl_outstream.  If an explicit argument is given, then print
   the output in such a way that it can be read back in.*/","-7. 	continue;
-6.       if (print_readably)
-5.         fprintf (rl_outstream, ""set %s %s\n"", string_varlist[i].name, v);
-4.       else
-3.         fprintf (rl_outstream, ""%s is set to `%s'\n"", string_varlist[i].name, v);
-2.     }
-1. }

 /*Print all o",Useful
/*Return non-zero if any members of ARRAY are a substring in STRING.*/,"-10. int
-9. rl_dump_variables (count, key)
-8.      int count __attribute__((unused)), key __attribute__((unused));
-7. {
-6.   if (rl_dispatching)
-5.     fprintf (rl_outstream, ""\r\n"");
-4.   rl_variable_dumper (rl_explicit_arg);
-3.   rl_on_new_line (",Useful
/*Provide backwards-compatible entry points for old function names.*/,"-10. extern void rl_free_undo_list PARAMS((void));
-9. extern int rl_maybe_save_line PARAMS((void));
-8. extern int rl_maybe_unsave_line PARAMS((void));
-7. extern int rl_maybe_replace_line PARAMS((void));
-6. extern int rl_crlf PARAMS((void));
-5. extern",Useful
/*mbutil.c -- readline multibyte character utility functions*/,"
/* mbutil.c -- readline multibyte character utility functions */


 /*mbutil.c -- readline multibyte character utility functions*/

1. /* Copyright (C) 2001-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
/*Multibyte Character Utility Functions*/,"-7. #if defined (HANDLE_MULTIBYTE)
-6. int rl_byte_oriented = 0;
-5. #else
-4. int rl_byte_oriented = 1;
-3. #endif

 /*Multibyte Character Utility Functions*/

111",Useful
"/*if this is true, means that seed was not pointed character
     started byte.  So correct the point and consume count*/","-10.   mbstate_t ps;
-9.   int point;
-8.   wchar_t wc;
-7.   tmp = 0;
-6.   memset(&ps, 0, sizeof (mbstate_t));
-5.   if (seed < 0)
-4.     seed = 0;
-3.   if (count <= 0)
-2.     return seed;
-1.   point = seed + _rl_adjust_point (string, seed, &ps);

 ",Useful
/*invalid bytes. asume a byte represents a character*/,"-7.   if (seed < point)
-6.     count--;
-5.   while (count > 0)  
-4.     {
-3.       tmp = mbrtowc (&wc, string+point, strlen(string + point), &ps);
-2.       if (MB_INVALIDCH ((size_t)tmp))
-1. 	{

 /*invalid bytes. asume a byte represents a character*",Useful
"/*in this case, bytes are invalid or shorted to compose
	     multibyte char, so assume that the first byte represents
	     a single character anyway.*/","-10.   if (seed < 0)
-9.     return 0;
-8.   else if (length < seed)
-7.     return length;
-6.   prev = non_zero_prev = point = 0;
-5.   while (point < seed)
-4.     {
-3.       tmp = mbrtowc (&wc, string + point, length - point, &ps);
-2.       if (MB_I",Useful
"/*clear the state of the byte sequence, because
	     in this case effect of mbstate is undefined*/","-1. 	  tmp = 1;

 /*clear the state of the byte sequence, because
	     in this case effect of mbstate is undefined*/

1. 	  memset(&ps, 0, sizeof (mbstate_t));",Useful
"/*Since we're assuming that this byte represents a single
	     non-zero-width character, don't forget about it.*/","-1. 	  memset(&ps, 0, sizeof (mbstate_t));

 /*Since we're assuming that this byte represents a single
	     non-zero-width character, don't forget about it.*/

1. 	  prev = point;
2. 	}
3.       else if (MB_NULLWCH (tmp))",Useful
"/*return the number of bytes parsed from the multibyte sequence starting
   at src, if a non-L'\0' wide character was recognized. It returns 0, 
   if a L'\0' wide character was recognized. It  returns (size_t)(-1), 
   if an invalid multibyte sequence was encountered. It returns (size_t)(-2) 
   if it couldn't parse a complete  multibyte character.*/","-10. 	      if (wcwidth (wc) != 0)
-9. 		prev = point;
-8. 	    }
-7. 	  else
-6. 	    prev = point;  
-5. 	}
-4.       point += tmp;
-3.     }
-2.   return prev;
-1. }

 /*return the number of bytes parsed from the multibyte sequence starting
   at src, ",Useful
/*shorted to compose multibyte char*/,"-10.    if it couldn't parse a complete  multibyte character.  */
-9. int
-8. _rl_get_char_len (src, ps)
-7.      char *src;
-6.      mbstate_t *ps;
-5. {
-4.   size_t tmp;
-3.   tmp = mbrlen((const char *)src, (size_t)strlen (src), ps);
-2.   if (tmp == ",Useful
/*invalid to compose multibyte char*/,"-6.       if (ps)
-5. 	memset (ps, 0, sizeof(mbstate_t));
-4.       return -2;
-3.     }
-2.   else if (tmp == (size_t)(-1))
-1.     {

 /*invalid to compose multibyte char*/

111",Useful
"/*compare the specified two characters. If the characters matched,
   return 1. Otherwise return 0.*/","-9.       if (ps)
-8. 	memset (ps, 0, sizeof(mbstate_t));
-7.       return -1;
-6.     }
-5.   else if (tmp == (size_t)0)
-4.     return 0;
-3.   else
-2.     return (int)tmp;
-1. }

 /*compare the specified two characters. If the characters matched,
   r",Useful
"/*adjust pointed byte and find mbstate of the point of string.
   adjusted point will be point <= adjusted_point, and returns
   differences of the byte(adjusted_point - point).
   if point is invalied (point < 0 || more than string length),
   it returns -1*/","-10.   if ((w1 = _rl_get_char_len (&buf1[pos1], ps1)) <= 0 || 
-9. 	(w2 = _rl_get_char_len (&buf2[pos2], ps2)) <= 0 ||
-8. 	(w1 != w2) ||
-7. 	(buf1[pos1] != buf2[pos2]))
-6.     return 0;
-5.   for (i = 1; i < w1; i++)
-4.     if (buf1[pos1+i] != buf2[po",Useful
"/*in this case, bytes are invalid or shorted to compose
	     multibyte char, so assume that the first byte represents
	     a single character anyway.*/","-10.   if (seed < 0)
-9.     return 0;
-8.   else if (length < seed)
-7.     return length;
-6.   prev = non_zero_prev = point = 0;
-5.   while (point < seed)
-4.     {
-3.       tmp = mbrtowc (&wc, string + point, length - point, &ps);
-2.       if (MB_I",Useful
"/*clear the state of the byte sequence, because
	     in this case effect of mbstate is undefined*/","-1. 	  tmp = 1;

 /*clear the state of the byte sequence, because
	     in this case effect of mbstate is undefined*/

1. 	  memset(&ps, 0, sizeof (mbstate_t));",Useful
"/*Find next `count' characters started byte point of the specified seed.
   If flags is MB_FIND_NONZERO, we look for non-zero-width multibyte
   characters.*/","-10.   l = strlen (buf);
-9.   if (ind >= l - 1)
-8.     return ((wchar_t) buf[ind]);
-7.   memset (&ps, 0, sizeof (mbstate_t));
-6.   tmp = mbrtowc (&wc, buf + ind, l - ind, &ps);
-5.   if (MB_INVALIDCH (tmp) || MB_NULLWCH (tmp))  
-4.     return ((wchar",Useful
"/*Find previous character started byte point of the specified seed.
   Returned point will be point <= seed.  If flags is MB_FIND_NONZERO,
   we look for non-zero-width multibyte characters.*/","-10. _rl_find_next_mbchar (string, seed, count, flags)
-9.      char *string __attribute__((unused));
-8.      int seed, count, flags __attribute__((unused));
-7. {
-6. #if defined (HANDLE_MULTIBYTE)
-5.   return _rl_find_next_mbchar_internal (string, see",Useful
/*Group writes smaller than this into a single chunk*/,"-10. GNU General Public License for more details.
-9. You should have received a copy of the GNU General Public License
-8. along with this program; if not, write to the Free Software
-7. Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  0211",Useful
"/*Normalize path on Windows, so we can restore elsewhere.*/","-10. 	size_t			path_len;
-9. 	path_len = strlen(path);
-8. 	if (path_len > FN_REFLEN) {
-7. 		msg(""xb_stream_write_open(): file path is too long."");
-6. 		return NULL;
-5. 	}
-4. 	file = (xb_wstream_file_t *) my_malloc(PSI_NOT_INSTRUMENTED, sizeof(xb_wstr",Useful
"/*Chunk magic + flags + chunk type + path_len + path + len + offset +
	checksum*/","-10. 		return 1;
-9. 	}
-8. 	file->chunk_ptr = file->chunk;
-7. 	file->chunk_free = XB_STREAM_MIN_CHUNK_SIZE;
-6. 	return 0;
-5. }
-4. static
-3. int
-2. xb_stream_write_chunk(xb_wstream_file_t *file, const void *buf, size_t len)
-1. {

 /*Chunk magic + f",Useful
/*Path length*/,"-4. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-3. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

 /*Path length*/

1. 	ptr += 4;",Useful
/*Path*/,"-4. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-3. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

 /*Path*/

1. 	ptr += 4;",Useful
/*Chunk magic + flags + chunk type + path_len + path*/,"-10. 		return 1;
-9. 	}
-8. 	file->chunk_ptr = file->chunk;
-7. 	file->chunk_free = XB_STREAM_MIN_CHUNK_SIZE;
-6. 	return 0;
-5. }
-4. static
-3. int
-2. xb_stream_write_chunk(xb_wstream_file_t *file, const void *buf, size_t len)
-1. {
	/* Chunk magic + f",Useful
/*Path length*/,"-4. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-3. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

 /*Path length*/

1. 	ptr += 4;",Useful
/*Path*/,"-4. 	memcpy(ptr, XB_STREAM_CHUNK_MAGIC, sizeof(XB_STREAM_CHUNK_MAGIC) - 1);
-3. 	ptr += sizeof(XB_STREAM_CHUNK_MAGIC) - 1;

 /*Path*/

1. 	ptr += 4;",Useful
"/*Return a new, empty keymap.
   Free it with free() when you are done.*/","-10. #include ""emacs_keymap.c""
-9. #if defined (VI_MODE)
-8. #include ""vi_keymap.c""
-7. #endif
-6. #include ""xmalloc.h""

 /*Return a new, empty keymap.
   Free it with free() when you are done.*/

1. Keymap
2. rl_make_bare_keymap ()
3. {
4.   register int",Useful
/*Return a new keymap which is a copy of MAP.*/,"-10.     }
-9. #if 0
-8.   for (i = 'A'; i < ('Z' + 1); i++)
-7.     {
-6.       keymap[i].type = ISFUNC;
-5.       keymap[i].function = rl_do_lowercase_version;
-4.     }
-3. #endif
-2.   return (keymap);
-1. }

 /*Return a new keymap which is a copy of ",Useful
"/*Return a new keymap with the printing characters bound to rl_insert,
   the uppercase Meta characters bound to run their lowercase equivalents,
   and the Meta digits bound to produce numeric arguments.*/","-10.   register int i;
-9.   Keymap temp;
-8.   temp = rl_make_bare_keymap ();
-7.   for (i = 0; i < KEYMAP_SIZE; i++)
-6.     {
-5.       temp[i].type = map[i].type;
-4.       temp[i].function = map[i].function;
-3.     }
-2.   return (temp);
-1. }

 /*R",Useful
/*Printing characters in ISO Latin-1 and some 8-bit character sets.*/,"-2.   newmap[CTRL('H')].function = rl_rubout;
-1. #if KEYMAP_SIZE > 128

 /*Printing characters in ISO Latin-1 and some 8-bit character sets.*/

1.   for (i = 128; i < 256; i++)
2.     newmap[i].function = rl_insert;",Useful
/*Free the storage associated with MAP.*/,"-2.   return (newmap);
-1. }

 /*Free the storage associated with MAP.*/

1. void
2. rl_discard_keymap (map)
3.      Keymap map;
4. {
5.   int i;
6.   if (!map)
7.     return;
8.   for (i = 0; i < KEYMAP_SIZE; i++)
9.     {
10.       switch (map[i].type)",Useful
"/*Does buffered output to a destination datasink set with ds_set_pipe().
Writes to the destination datasink are guaranteed to not be smaller than a
specified buffer size (DS_DEFAULT_BUFFER_SIZE by default), with the only
exception for the last write for a file.*/","-10. it under the terms of the GNU General Public License as published by
-9. the Free Software Foundation; version 2 of the License.
-8. This program is distributed in the hope that it will be useful,
-7. but WITHOUT ANY WARRANTY; without even the implie",Useful
/*Change the default buffer size*/,"-10. static int buffer_close(ds_file_t *file);
-9. static void buffer_deinit(ds_ctxt_t *ctxt);
-8. datasink_t datasink_buffer = {
-7. 	&buffer_init,
-6. 	&buffer_open,
-5. 	&buffer_write,
-4. 	&buffer_close,
-3. 	&dummy_remove,
-2. 	&buffer_deinit
-1. };
",Useful
"/*We don't have any buffered bytes, just write
				the entire source buffer*/","-10. 				       bytes);
-9. 				if (ds_write(buffer_file->dst_file,
-8. 					     buffer_file->buf,
-7. 					     buffer_file->size)) {
-6. 					return 1;
-5. 				}
-4. 				buffer_file->pos = 0;
-3. 				buf += bytes;
-2. 				len -= bytes;
-1. 			} else {
",Useful
"/*readline.c -- a general facility for reading lines of input
   with emacs style editing and completion.*/","
/* readline.c -- a general facility for reading lines of input
   with emacs style editing and completion. */


 /*readline.c -- a general facility for reading lines of input
   with emacs style editing and completion.*/

1. /* Copyright (C) 1987, 1989, 1992, 2006 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
"/*Non-zero tells rl_delete_text and rl_insert_text to not add to
   the undo list.*/","-5. #include ""readline.h""
-4. #include ""history.h""
-3. #include ""rlprivate.h""
-2. #include ""xmalloc.h""
-1. extern void replace_history_data PARAMS((int, histdata_t *, histdata_t *));

 /*Non-zero tells rl_delete_text and rl_insert_text to not add to
   th",Useful
/*The current undo list for THE_LINE.*/,"-1. int _rl_undo_group_level = 0;

 /*The current undo list for THE_LINE.*/

1. UNDO_LIST *rl_undo_list = (UNDO_LIST *)NULL;",Useful
"/*Remember how to undo something.  Concatenate some undos if that
   seems right.*/","-10. {
-9.   UNDO_LIST *temp;
-8.   temp = (UNDO_LIST *)xmalloc (sizeof (UNDO_LIST));
-7.   temp->what = what;
-6.   temp->start = start;
-5.   temp->end = end;
-4.   temp->text = text;
-3.   temp->next = (UNDO_LIST *)NULL;
-2.   return temp;
-1. }

 /*Re",Useful
"/*Undo the next thing in the list.  Return 0 if there
   is nothing to undo, or non-zero if there was.*/","-10.       else
-9. 	{
-8. 	  roving->next = c;
-7. 	  roving = roving->next;
-6. 	}
-5.       list = list->next;
-4.     }
-3.   roving->next = 0;
-2.   return new;
-1. }

 /*Undo the next thing in the list.  Return 0 if there
   is nothing to undo, or n",Useful
"/*To better support vi-mode, a start or end value of -1 means
	 rl_point, and a value of -2 means rl_end.*/","-10.   UNDO_LIST *release;
-9.   int waiting_for_begin, start, end;
-8. #define TRANS(i) ((i) == -1 ? rl_point : ((i) == -2 ? rl_end : (i)))
-7.   start = end = waiting_for_begin = 0;
-6.   do
-5.     {
-4.       if (!rl_undo_list)
-3. 	return (0);
-2.   ",Useful
/*Undoing deletes means inserting some text.*/,"-7.       if (rl_undo_list->what == UNDO_DELETE || rl_undo_list->what == UNDO_INSERT)
-6. 	{
-5. 	  start = TRANS (rl_undo_list->start);
-4. 	  end = TRANS (rl_undo_list->end);
-3. 	}
-2.       switch (rl_undo_list->what)
-1. 	{

 /*Undoing deletes means ",Useful
/*Undoing inserts means deleting some text.*/,"-5. 	case UNDO_DELETE:
-4. 	  rl_point = start;
-3. 	  rl_insert_text (rl_undo_list->text);
-2. 	  free (rl_undo_list->text);
-1. 	  break;

 /*Undoing inserts means deleting some text.*/

1. 	case UNDO_INSERT:
2. 	  rl_delete_text (start, end);
3. 	  rl_",Useful
/*Undoing an END means undoing everything 'til we get to a BEGIN.*/,"-4. 	case UNDO_INSERT:
-3. 	  rl_delete_text (start, end);
-2. 	  rl_point = start;
-1. 	  break;

 /*Undoing an END means undoing everything 'til we get to a BEGIN.*/

1. 	case UNDO_END:
2. 	  waiting_for_begin++;
3. 	  break;",Useful
/*Undoing a BEGIN means that we are done with this group.*/,"-3. 	case UNDO_END:
-2. 	  waiting_for_begin++;
-1. 	  break;

 /*Undoing a BEGIN means that we are done with this group.*/

1. 	case UNDO_BEGIN:
2. 	  if (waiting_for_begin)
3. 	    waiting_for_begin--;
4. 	  else
5. 	    rl_ding ();
6. 	  break;
7. 	}
8",Useful
/*Begin a group.  Subsequent undos are undone as an atomic operation.*/,"-10.     {
-9.       if (rl->what == type)
-8. 	{
-7. 	  rl->start = start;
-6. 	  rl->end = end;
-5. 	  return 0;
-4. 	}
-3.     }
-2.   return 1;
-1. }

 /*Begin a group.  Subsequent undos are undone as an atomic operation.*/

1. int
2. rl_begin_undo_gr",Useful
/*End an undo group started with rl_begin_undo_group ().*/,"-7. int
-6. rl_begin_undo_group ()
-5. {
-4.   rl_add_undo (UNDO_BEGIN, 0, 0, 0);
-3.   _rl_undo_group_level++;
-2.   return 0;
-1. }

 /*End an undo group started with rl_begin_undo_group ().*/

1. int
2. rl_end_undo_group ()
3. {
4.   rl_add_undo (UNDO_",Useful
/*Save an undo entry for the text from START to END.*/,"-7. int
-6. rl_end_undo_group ()
-5. {
-4.   rl_add_undo (UNDO_END, 0, 0, 0);
-3.   _rl_undo_group_level--;
-2.   return 0;
-1. }

 /*Save an undo entry for the text from START to END.*/

1. int
2. rl_modifying (start, end)
3.      int start, end;
4. {
5.",Useful
/*Revert the current line to its previous state.*/,"-10.   if (start != end)
-9.     {
-8.       char *temp = rl_copy_text (start, end);
-7.       rl_begin_undo_group ();
-6.       rl_add_undo (UNDO_DELETE, start, end, temp);
-5.       rl_add_undo (UNDO_INSERT, start, end, (char *)NULL);
-4.       rl_end_u",Useful
"/************************************************************************
Write to a datasink file.
@return 0 on success, 1 on error.*/","-10. ds_file_t *
-9. ds_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *stat)
-8. {
-7. 	ds_file_t	*file;
-6. 	file = ctxt->datasink->open(ctxt, path, stat);
-5. 	if (file != NULL) {
-4. 		file->datasink = ctxt->datasink;
-3. 	}
-2. 	return file;
-1. }

",Useful
"/************************************************************************
Close a datasink file.
@return 0 on success, 1, on error.*/","-10. Write to a datasink file.
-9. @return 0 on success, 1 on error. */
-8. int
-7. ds_write(ds_file_t *file, const void *buf, size_t len)
-6. {
-5. 	if (len == 0) {
-4. 		return 0;
-3. 	}
-2. 	return file->datasink->write(file, (const uchar *)buf, len);
",Useful
"/************************************************************************
Destroy a datasink handle*/","-5. int
-4. ds_close(ds_file_t *file)
-3. {
-2. 	return file->datasink->close(file);
-1. }

 /************************************************************************
Destroy a datasink handle*/

1. void
2. ds_destroy(ds_ctxt_t *ctxt)
3. {
4. 	ctxt->datas",Useful
"/************************************************************************
Set the destination pipe for a datasink (only makes sense for compress and
tmpfile).*/","-5. void
-4. ds_destroy(ds_ctxt_t *ctxt)
-3. {
-2. 	ctxt->datasink->deinit(ctxt);
-1. }

 /************************************************************************
Set the destination pipe for a datasink (only makes sense for compress and
tmpfile).*/

1. ",Useful
/*signals.c -- signal handling support for readline.*/,"
/* signals.c -- signal handling support for readline. */


 /*signals.c -- signal handling support for readline.*/

1. /* Copyright (C) 1987-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
"/*This typedef is equivalent to the one for Function; it allows us
   to say SigHandler *foo = signal (SIGKILL, SIG_IGN);*/","-5. #if defined (VOID_SIGHANDLER)
-4. #  define SIGHANDLER_RETURN return
-3. #else
-2. #  define SIGHANDLER_RETURN return (0)
-1. #endif

 /*This typedef is equivalent to the one for Function; it allows us
   to say SigHandler *foo = signal (SIGKILL, SIG_",Useful
"/*If non-zero, readline will install its own signal handlers for
   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU.*/","-6. #ifndef SA_RESTART
-5. #  define SA_RESTART 0
-4. #endif
-3. static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-2. static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));

 /*If non-zero, re",Useful
"/*If non-zero, readline will install a signal handler for SIGWINCH.*/","-1. int rl_catch_signals = 1;

 /*If non-zero, readline will install a signal handler for SIGWINCH.*/

1. #ifdef SIGWINCH
2. int rl_catch_sigwinch = 1;
3. #else",Useful
/*Readline signal handler functions.*/,"-7. static sighandler_cxt old_int, old_term, old_alrm, old_quit;
-6. #if defined (SIGTSTP)
-5. static sighandler_cxt old_tstp, old_ttou, old_ttin;
-4. #endif
-3. #if defined (SIGWINCH)
-2. static sighandler_cxt old_winch;
-1. #endif

 /*Readline signal ha",Useful
"/*Since the signal will not be blocked while we are in the signal
     handler, ignore it until rl_clear_signals resets the catcher.*/","-2.   RL_SETSTATE(RL_STATE_SIGHANDLER);
-1. #if !defined (HAVE_BSD_SIGNALS) && !defined (HAVE_POSIX_SIGNALS)

 /*Since the signal will not be blocked while we are in the signal
     handler, ignore it until rl_clear_signals resets the catcher.*/

1. #  if",Useful
"/*We don't want to change old_winch -- it holds the state of SIGWINCH
     disposition set by the calling application.  We need this state
     because we call the application's SIGWINCH handler after updating
     our own idea of the screen size.*/","-10.   SIGHANDLER_RETURN;
-9. }
-8. #if defined (SIGWINCH)
-7. static RETSIGTYPE
-6. rl_sigwinch_handler (sig)
-5.      int sig;
-4. {
-3.   SigHandler *oh;
-2. #if defined (MUST_REINSTALL_SIGHANDLERS)
-1.   sighandler_cxt dummy_winch;

 /*We don't want t",Useful
"/*If another sigwinch handler has been installed, call it.*/","-4.   rl_set_sighandler (SIGWINCH, rl_sigwinch_handler, &dummy_winch);
-3. #endif
-2.   RL_SETSTATE(RL_STATE_SIGHANDLER);
-1.   rl_resize_terminal ();

 /*If another sigwinch handler has been installed, call it.*/

1.   oh = (SigHandler *)old_winch.sa_han",Useful
/*Functions to manage signal handling.*/,"-7.   oh = (SigHandler *)old_winch.sa_handler;
-6.   if (oh &&  oh != (SigHandler *)SIG_IGN && oh != (SigHandler *)SIG_DFL)
-5.     (*oh) (sig);
-4.   RL_UNSETSTATE(RL_STATE_SIGHANDLER);
-3.   SIGHANDLER_RETURN;
-2. }

 /*Functions to manage signal handli",Useful
"/*Set up a readline-specific signal handler, saving the old signal
   information in OHANDLER.  Return the old signal handler, like
   signal().*/","-10. #if !defined (HAVE_POSIX_SIGNALS)
-9. static int
-8. rl_sigaction (sig, nh, oh)
-7.      int sig;
-6.      sighandler_cxt *nh, *oh;
-5. {
-4.   oh->sa_handler = signal (sig, nh->sa_handler);
-3.   return 0;
-2. }

 /*Set up a readline-specific signal",Useful
"/*If rl_set_signals is called twice in a row, don't set the old handler to
     rl_signal_handler, because that would cause infinite recursion.*/","-10.   struct sigaction act;
-9.   act.sa_handler = handler;
-8.   act.sa_flags = (sig == SIGWINCH) ? SA_RESTART : 0;
-7.   sigemptyset (&act.sa_mask);
-6.   sigemptyset (&ohandler->sa_mask);
-5.   sigaction (sig, &act, &old_handler);
-4. #else
-3.   old_",Useful
"/*If the application using readline has already installed a signal
	 handler with SA_RESTART, SIGALRM will cause reads to be restarted
	 automatically, so readline should just get out of the way.  Since
	 we tested for SIG_IGN above, we can just test for SIG_DFL here.*/","-10.       rl_maybe_set_sighandler (SIGINT, rl_signal_handler, &old_int);
-9.       rl_maybe_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
-8. #if defined (SIGQUIT)
-7.       rl_maybe_set_sighandler (SIGQUIT, rl_signal_handler, &old_quit);
-6. #",Useful
"/*Clean up the terminal and readline state after catching a signal, before
   resending it to the calling application.*/","-10. #if defined (SIGWINCH)
-9.   if (rl_catch_sigwinch && sigwinch_set_flag == 1)
-8.     {
-7.       sigemptyset (&dummy.sa_mask);
-6.       rl_sigaction (SIGWINCH, &old_winch, &dummy);
-5.       sigwinch_set_flag = 0;
-4.     }
-3. #endif
-2.   return ",Useful
/*Reset the terminal and readline state after a signal handler returns.*/,"-10.    resending it to the calling application. */
-9. void
-8. rl_cleanup_after_signal ()
-7. {
-6.   _rl_clean_up_for_exit ();
-5.   if (rl_deprep_term_function)
-4.     (*rl_deprep_term_function) ();
-3.   rl_clear_pending_input ();
-2.   rl_clear_sig",Useful
"/*Free up the readline variable line state for the current line (undo list,
   any partial history entry, any keyboard macros in progress, and any
   numeric arguments in process) after catching a signal, before calling
   rl_cleanup_after_signal().*/","-7. void
-6. rl_reset_after_signal ()
-5. {
-4.   if (rl_prep_term_function)
-3.     (*rl_prep_term_function) (_rl_meta_flag);
-2.   rl_set_signals ();
-1. }

 /*Free up the readline variable line state for the current line (undo list,
   any partial hist",Useful
"/*The goal is to make the implementation transparent, so that you
   don't have to know what data types are used, just what functions
   you can call.  I think I have done that.*/","-10.    the Free Software Foundation; either version 2, or (at your option)
-9.    any later version.
-8.    The Library is distributed in the hope that it will be useful, but
-7.    WITHOUT ANY WARRANTY; without even the implied warranty of
-6.    MERCHA",Useful
"/*If we're compiling for __EMX__ (OS/2) or __CYGWIN__ (cygwin32 environment
   on win 95/98/nt), we want to open files with O_BINARY mode so that there
   is no \n -> \r\n conversion performed.  On other systems, we don't want to
   mess around with O_BINARY at all, so we ensure that it's defined to 0.*/","-10. #    define MAP_RFLAGS	(MAP_FILE|MAP_PRIVATE)
-9. #    define MAP_WFLAGS	(MAP_FILE|MAP_SHARED)
-8. #  else
-7. #    define MAP_RFLAGS	MAP_PRIVATE
-6. #    define MAP_WFLAGS	MAP_SHARED
-5. #  endif
-4. #  ifndef MAP_FAILED
-3. #    define MAP_FAILED	(",Useful
"/*Add the contents of FILENAME to the history list, a line at a time.
   If FILENAME is NULL, then read from ~/.history.  Returns 0 if
   successful, or errno if not.*/","-9.   strcpy (return_val, home);
-8.   return_val[home_len] = '/';
-7. #if defined (__MSDOS__)
-6.   strcpy (return_val + home_len + 1, ""_history"");
-5. #else
-4.   strcpy (return_val + home_len + 1, "".history"");
-3. #endif
-2.   return (return_val);
-1. ",Useful
"/*Read a range of lines from FILENAME, adding them to the history list.
   Start reading at the FROM'th line and end at the TO'th.  If FROM
   is zero, start at the beginning.  If TO is less than FROM, read
   until the end of the file.  If FILENAME is NULL, then read from
   ~/.history.  Returns 0 if successful, or errno if not.*/","-6. int
-5. read_history (filename)
-4.      const char *filename;
-3. {
-2.   return (read_history_range (filename, 0, -1));
-1. }

 /*Read a range of lines from FILENAME, adding them to the history list.
   Start reading at the FROM'th line and end at t",Useful
/*check for overflow on very large files*/,"-10.   int overflow_errno = EOVERFLOW;
-9. #else
-8.   int overflow_errno = EIO;
-7. #endif
-6.   buffer = last_ts = (char *)NULL;
-5.   input = history_filename (filename);
-4.   file = open (input, O_RDONLY|O_BINARY, 0666);
-3.   if ((file < 0) || (fsta",Useful
"/*We map read/write and private so we can change newlines to NULs without
     affecting the underlying object.*/","-7.   if ((sizeof(off_t) > sizeof(size_t) && finfo.st_size > (off_t)(size_t)~0) ||  
-6.     file_size + 1 < file_size)
-5.     {
-4.       errno = overflow_errno;
-3.       goto error_and_exit;
-2.     }
-1. #ifdef HISTORY_USE_MMAP

 /*We map read/write ",Useful
/*Set TO to larger than end of file if negative.*/,"-10. 	chars_read = EIO;
-9.       if (file >= 0)
-8. 	close (file);
-7.       FREE (input);
-6. #ifndef HISTORY_USE_MMAP
-5.       FREE (buffer);
-4. #endif
-3.       return (chars_read);
-2.     }
-1.   close (file);

 /*Set TO to larger than end of file",Useful
"/*If we see something we think is a timestamp, continue with this
	   line.  We should check more extensively here...*/","-4.   for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
-3.     if (*line_end == '\n')
-2.       {
-1.       	p = line_end + 1;

 /*If we see something we think is a timestamp, continue with this
	   line.  We shou",Useful
"/*If there are lines left to gobble, then gobble them now.*/","-4. 	if (HIST_TIMESTAMP_START(p) == 0)
-3. 	  current_line++;
-2. 	line_start = p;
-1.       }

 /*If there are lines left to gobble, then gobble them now.*/

1.   for (line_end = line_start; line_end < bufend; line_end++)
2.     if (*line_end == '\n')
3.",Useful
"/*Truncate the history file FNAME, leaving only LINES trailing lines.
   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
   on failure.*/","-10. 	line_start = line_end + 1;
-9.       }
-8.   FREE (input);
-7. #ifndef HISTORY_USE_MMAP
-6.   FREE (buffer);
-5. #else
-4.   munmap (buffer, file_size);
-3. #endif
-2.   return (0);
-1. }

 /*Truncate the history file FNAME, leaving only LINES trail",Useful
/*check for overflow on very large files*/,"-10.   int overflow_errno = EOVERFLOW;
-9. #else
-8.   int overflow_errno = EIO;
-7. #endif
-6.   buffer = last_ts = (char *)NULL;
-5.   input = history_filename (filename);
-4.   file = open (input, O_RDONLY|O_BINARY, 0666);
-3.   if ((file < 0) || (fsta",Useful
"/*Count backwards from the end of buffer until we have passed
     LINES lines.  bp1 is set funny initially.  But since bp[1] can't
     be a comment character (since it's off the end) and *bp can't be
     both a newline and the history comment character, it should be OK.*/","-10.       close (file);
-9.       goto truncate_exit;
-8.     }
-7.   chars_read = read (file, buffer, file_size);
-6.   close (file);
-5.   if (chars_read <= 0)
-4.     {
-3.       rv = (chars_read < 0) ? errno : 0;
-2.       goto truncate_exit;
-1.    ",Useful
"/*If this is the first line, then the file contains exactly the
     number of lines we want to truncate to, so we don't need to do
     anything.  It's the first line if we don't find a newline between
     the current value of i and 0.  Otherwise, write from the start of
     this line until the end of the buffer.*/","-6.   for (bp1 = bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
-5.     {
-4.       if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
-3. 	lines--;
-2.       bp1 = bp;
-1.     }

 /*If this is the first line, then the file contains exactly the",Useful
"/*Workhorse function for writing history.  Writes NELEMENT entries
   from the history list to FILENAME.  OVERWRITE is non-zero if you
   wish to replace FILENAME with the entries.*/","-9.       ftruncate (file, chars_read - (bp - buffer));
-8. #endif
-7.       close (file);
-6.     }
-5.  truncate_exit:
-4.   FREE (buffer);
-3.   free (filename);
-2.   return rv;
-1. }

 /*Workhorse function for writing history.  Writes NELEMENT entrie",Useful
"/*Build a buffer of all the lines to write, and write them in one syscall.
     Suggested by Peter Ho (peter@robosts.oxford.ac.uk).*/","-10.   if ((file = open (output, mode, 0600)) == -1)
-9.     {
-8.       FREE (output);
-7.       return (errno);
-6.     }
-5. #ifdef HISTORY_USE_MMAP
-4.   cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);
-3. #endif
-2.   if (nelements > history_len",Useful
/*Calculate the total number of bytes to write.*/,"-4.     register int j;
-3.     int buffer_size;
-2.     char *buffer;
-1.     the_history = history_list ();

 /*Calculate the total number of bytes to write.*/

1.     for (buffer_size = 0, i = history_length - nelements; i < history_length; i++)
2. #if",Useful
"/*Allocate the buffer, and fill it.*/","-10.     for (buffer_size = 0, i = history_length - nelements; i < history_length; i++)
-9. #if 0
-8.       buffer_size += 2 + HISTENT_BYTES (the_history[i]);
-7. #else
-6.       {
-5. 	if (history_write_timestamps && the_history[i]->timestamp && the_hist",Useful
"/*Append NELEMENT entries to FILENAME.  The entries appended are from
   the end of the list minus NELEMENTs up to the end of the list.*/","-10. #else
-9.     if (write (file, buffer, buffer_size) < 0)
-8.       rv = errno;
-7.     free (buffer);
-6. #endif
-5.   }
-4.   close (file);
-3.   FREE (output);
-2.   return (rv);
-1. }

 /*Append NELEMENT entries to FILENAME.  The entries appended ",Useful
"/*Overwrite FILENAME with the current history.  If FILENAME is NULL,
   then write the history list to ~/.history.  Values returned
   are as in read_history ().*/","-7. int
-6. append_history (nelements, filename)
-5.      int nelements;
-4.      const char *filename;
-3. {
-2.   return (history_do_write (filename, nelements, HISTORY_APPEND));
-1. }

 /*Overwrite FILENAME with the current history.  If FILENAME is NUL",Useful
"/*The character that represents the start of a history expansion
   request.  This is usually `!'.*/","-10. static char *subst_lhs;
-9. static char *subst_rhs;
-8. static int subst_lhs_len;
-7. static int subst_rhs_len;
-6. static char *get_history_word_specifier PARAMS((char *, char *, int *));
-5. static char *history_find_word PARAMS((char *, int));
-4.",Useful
"/*The character that invokes word substitution if found at the start of
   a line.  This is usually `^'.*/","-1. char history_expansion_char = '!';

 /*The character that invokes word substitution if found at the start of
   a line.  This is usually `^'.*/

1. char history_subst_char = '^';",Useful
"/*During tokenization, if this character is seen as the first character
   of a word, then it, and all subsequent characters upto a newline are
   ignored.  For a Bourne shell, this should be '#'.  Bash special cases
   the interactive comment character to not be a comment delimiter.*/","-1. char history_subst_char = '^';

 /*During tokenization, if this character is seen as the first character
   of a word, then it, and all subsequent characters upto a newline are
   ignored.  For a Bourne shell, this should be '#'.  Bash special cases
 ",Useful
"/*The list of characters which inhibit the expansion of text if found
   immediately following history_expansion_char.*/","-1. char history_comment_char = '\0';

 /*The list of characters which inhibit the expansion of text if found
   immediately following history_expansion_char.*/

1. const char *history_no_expand_chars = "" \t\n\r="";",Useful
"/*If set to a non-zero value, single quotes inhibit history expansion.
   The default is 0.*/","-1. const char *history_no_expand_chars = "" \t\n\r="";

 /*If set to a non-zero value, single quotes inhibit history expansion.
   The default is 0.*/

1. int history_quotes_inhibit_expansion = 0;",Useful
"/*If set, this points to a function that is called to verify that a
   particular history expansion should be performed.*/","-1. const char *history_word_delimiters = HISTORY_WORD_DELIMITERS;

 /*If set, this points to a function that is called to verify that a
   particular history expansion should be performed.*/

1. rl_linebuf_func_t *history_inhibit_expansion_function;",Useful
/*The last string searched for by a !?string? search.*/,"-8. rl_linebuf_func_t *history_inhibit_expansion_function;

 /*The last string searched for by a !?string? search.*/

1. static char *search_string;",Useful
/*The last string matched by a !?string? search.*/,"-10. rl_linebuf_func_t *history_inhibit_expansion_function;

 /*The last string matched by a !?string? search.*/

1. static char *search_match;
2. /* Return the event specified at TEXT + OFFSET modifying OFFSET to
3.    point to after the event specifier.",Useful
"/*The event can be specified in a number of ways.

     !!   the previous command
     !n   command line N
     !-n  current command-line minus N
     !str the most recent command starting with STR
     !?str[?]
	  the most recent command containing STR

     All values N are determined via HISTORY_BASE.*/","-10.      const char *string;
-9.      int *caller_index;
-8.      int delimiting_quote;
-7. {
-6.   register int i;
-5.   register char c;
-4.   HIST_ENTRY *entry;
-3.   int which, sign, local_index, substring_okay;
-2.   _hist_search_func_t *search_func",Useful
/*Get the extent of the digits and compute the value.*/,"-7.   if (string[i] == '-')
-6.     {
-5.       sign = -1;
-4.       i++;
-3.     }
-2.   if (_rl_digit_p (string[i]))
-1.     {

 /*Get the extent of the digits and compute the value.*/

1.       for (which = 0; _rl_digit_p (string[i]); i++)
2. 	which = ",Useful
"/*This must be something to search for.  If the spec begins with
     a '?', then the string may be anywhere on the line.  Otherwise,
     the string must be found at the start of a line.*/","-7.       for (which = 0; _rl_digit_p (string[i]); i++)
-6. 	which = (which * 10) + _rl_digit_value (string[i]);
-5.       *caller_index = i;
-4.       if (sign < 0)
-3. 	which = (history_length + history_base) - which;
-2.       RETURN_ENTRY (entry, whic",Useful
/*Only a closing `?' or a newline delimit a substring search string.*/,"-5.   if (string[i] == '?')
-4.     {
-3.       substring_okay++;
-2.       i++;
-1.     }

 /*Only a closing `?' or a newline delimit a substring search string.*/

1.   for (local_index = i; (c = string[i]); i++)
2.     {
3. #if defined (HANDLE_MULTIBYTE",Useful
"/*These produce warnings because we're passing a const string to a
	     function that takes a non-const string.*/","-8.   for (local_index = i; (c = string[i]); i++)
-7.     {
-6. #if defined (HANDLE_MULTIBYTE)
-5.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
-4. 	{
-3. 	  int v;
-2. 	  mbstate_t ps;
-1. 	  memset (&ps, 0, sizeof (mbstate_t));

 /*These produce w",Useful
"/*If there is no search string, try to use the previous search string,
     if one exists.  If not, fail immediately.*/","-10.   if (which)
-9.     strncpy (temp, string + local_index, which);
-8.   temp[which] = '\0';
-7.   if (substring_okay && string[i] == '?')
-6.     i++;
-5.   *caller_index = i;
-4. #define FAIL_SEARCH() \
-3.   do { \
-2.     history_offset = history_",Useful
"/*If this was a substring search, then remember the
	     string that we matched for word substitution.*/","-10.   search_func = substring_okay ? history_search : history_search_prefix;
-9.   while (1)
-8.     {
-7.       local_index = (*search_func) (temp, -1);
-6.       if (local_index < 0)
-5. 	FAIL_SEARCH ();
-4.       if (local_index == 0 || substring_okay",Useful
"/*Function for extracting single-quoted strings.  Used for inhibiting
   history expansion within single quotes.*/","-10. 	  return (entry->line);
-9. 	}
-8.       if (history_offset)
-7. 	history_offset--;
-6.       else
-5. 	FAIL_SEARCH ();
-4.     }
-3. #undef FAIL_SEARCH
-2. #undef RETURN_ENTRY
-1. }

 /*Function for extracting single-quoted strings.  Used for inhib",Useful
"/*Extract the contents of STRING as if it is enclosed in single quotes.
   SINDEX, when passed in, is the offset of the character immediately
   following the opening single quote; on exit, SINDEX is left pointing
   to the closing single quote.*/","-10.       if (history_offset)
-9. 	history_offset--;
-8.       else
-7. 	FAIL_SEARCH ();
-6.     }
-5. #undef FAIL_SEARCH
-4. #undef RETURN_ENTRY
-3. }

 /*Extract the contents of STRING as if it is enclosed in single quotes.
   SINDEX, when passed in, i",Useful
"/*Get a history substitution string from STR starting at *IPTR
   and return it.  The length is returned in LENPTR.

   A backslash can quote the delimiter.  If the string is the
   empty string, the previous pattern is used.  If there is
   no previous pattern for the lhs, the last history search
   string is used.

   If IS_RHS is 1, we ignore empty strings and set the pattern
   to """" anyway.  subst_lhs is not changed if the lhs is empty;
   subst_rhs is allowed to be set to the empty string.*/","-10.       elen = 23;
-9.       break;
-8.     }
-7.   temp = (char *)xmalloc (ll + elen + 3);
-6.   strncpy (temp, s + start, ll);
-5.   temp[ll] = ':';
-4.   temp[ll + 1] = ' ';
-3.   strcpy (temp + ll + 2, emsg);
-2.   return (temp);
-1. }

 /*Get a hi",Useful
/*Remove a backslash quoting the search string delimiter.*/,"-7.       if (str[si] == '\\' && str[si + 1] == delimiter)
-6. 	si++;
-5.   if (si > i || is_rhs)
-4.     {
-3.       s = (char *)xmalloc (si - i + 1);
-2.       for (j = 0, k = i; k < si; j++, k++)
-1. 	{

 /*Remove a backslash quoting the search string ",Useful
/*a single backslash protects the `&' from lhs interpolation*/,"-10.     {
-9.       if (subst_rhs[i] == '&')
-8. 	{
-7. 	  if (j + subst_lhs_len >= new_size)
-6. 	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
-5. 	  strcpy (new + j, subst_lhs);
-4. 	  j += subst_lhs_len;
-3. 	}
-2.     ",Useful
"/*Expand the bulk of a history specifier starting at STRING[START].
   Returns 0 if everything is OK, -1 if an error occurred, and 1
   if the `p' modifier was supplied and the caller should just print
   the returned string.  Returns the new index into string in
   *END_INDEX_PTR, and the expanded specifier in *RET_STRING.*/","-10. 	  if (j >= new_size)
-9. 	    new = (char *)xrealloc (new, new_size *= 2);
-8. 	  new[j++] = subst_rhs[i];
-7. 	}
-6.     }
-5.   new[j] = '\0';
-4.   free (subst_rhs);
-3.   subst_rhs = new;
-2.   subst_rhs_len = j;
-1. }

 /*Expand the bulk of a h",Useful
"/*If it is followed by something that starts a word specifier,
     then !! is implied as the event specifier.*/","-10.   int i, n, starting_index;
-9.   int substitute_globally, subst_bywords, want_quotes, print_only;
-8.   char *event, *temp, *result, *tstr, *t, c, *word_spec;
-7.   int result_len;
-6. #if defined (HANDLE_MULTIBYTE)
-5.   mbstate_t ps;
-4.   memset ",Useful
"/*If the character before this `!' is a double or single
	 quote, then this expansion takes place inside of the
	 quoted string.  If we have to search for some text (""!foo""),
	 allow the delimiter to end the search string.*/","-10.       event = get_history_event (fake_s, &fake_i, 0);
-9.     }
-8.   else if (string[i + 1] == '#')
-7.     {
-6.       i += 2;
-5.       event = current_line;
-4.     }
-3.   else
-2.     {
-1.       int quoted_search_delimiter = 0;

 /*If the char",Useful
/*XXX - original patch had i - 1 ???  If i == 0 it would fail.*/,"-6. #if defined (HANDLE_MULTIBYTE)
-5.       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
-4. 	{
-3. 	  int ch, l;
-2. 	  l = _rl_find_prev_mbchar (string, i, MB_FIND_ANY);
-1. 	  ch = string[l];

 /*XXX - original patch had i - 1 ???  If i == 0 it would ",Useful
"/*If a word specifier is found, then do what that requires.*/","-10. 	if (i && (string[i - 1] == '\'' || string[i - 1] == '""'))
-9. 	  quoted_search_delimiter = string[i - 1];
-8.       event = get_history_event (string, &i, quoted_search_delimiter);
-7.     }
-6.   if (event == 0)
-5.     {
-4.       *ret_string = hi",Useful
"/*There is no such thing as a `malformed word specifier'.  However,
     it is possible for a specifier that has no match.  In that case,
     we complain.*/","-2.   starting_index = i;
-1.   word_spec = get_history_word_specifier (string, event, &i);

 /*There is no such thing as a `malformed word specifier'.  However,
     it is possible for a specifier that has no match.  In that case,
     we complain.*/

1.",Useful
"/*If no word specifier, than the thing of interest was the event.*/","-6.   if (word_spec == (char *)&error_pointer)
-5.     {
-4.       *ret_string = hist_error (string, starting_index, i, BAD_WORD_SPEC);
-3.       free (result);
-2.       return (-1);
-1.     }

 /*If no word specifier, than the thing of interest was the ",Useful
/*Perhaps there are other modifiers involved.  Do what they say.*/,"-2.   temp = word_spec ? savestring (word_spec) : savestring (event);
-1.   FREE (word_spec);

 /*Perhaps there are other modifiers involved.  Do what they say.*/

1.   want_quotes = substitute_globally = subst_bywords = print_only = 0;
2.   starting_inde",Useful
"/*:p means make this the last executed line.  So we
	     return an error state after adding this line to the
	     history.*/","-10. 	  *ret_string = hist_error (string, i+1, i+2, BAD_MODIFIER);
-9. 	  free (result);
-8. 	  free (temp);
-7. 	  return -1;
-6. 	case 'q':
-5. 	  want_quotes = 'q';
-4. 	  break;
-3. 	case 'x':
-2. 	  want_quotes = 'x';
-1. 	  break;

 /*:p means make ",Useful
/*:t discards all but the last part of the pathname.*/,"-3. 	case 'p':
-2. 	  print_only++;
-1. 	  break;

 /*:t discards all but the last part of the pathname.*/

1. 	case 't':
2. 	  tstr = strrchr (temp, '/');
3. 	  if (tstr)
4. 	    {
5. 	      tstr++;
6. 	      t = savestring (tstr);
7. 	      free (temp);",Useful
/*:h discards the last part of a pathname.*/,"-10. 	case 't':
-9. 	  tstr = strrchr (temp, '/');
-8. 	  if (tstr)
-7. 	    {
-6. 	      tstr++;
-5. 	      t = savestring (tstr);
-4. 	      free (temp);
-3. 	      temp = t;
-2. 	    }
-1. 	  break;

 /*:h discards the last part of a pathname.*/

1. 	c",Useful
"/*:s/this/that substitutes `that' for the first
	   occurrence of `this'.  :gs/this/that substitutes `that'
	   for each occurrence of `this'.  :& repeats the last
	   substitution.  :g& repeats the last substitution
	   globally.*/","-9. 	case 'e':
-8. 	  tstr = strrchr (temp, '.');
-7. 	  if (tstr)
-6. 	    {
-5. 	      t = savestring (tstr);
-4. 	      free (temp);
-3. 	      temp = t;
-2. 	    }
-1. 	  break;

 /*:s/this/that substitutes `that' for the first
	   occurrence of `this",Useful
"/*An empty substitution lhs with no previous substitution
		   uses the last search string as the lhs.*/","-2. 		i += 3;
-1. 		t = get_subst_pattern (string, &i, delimiter, 0, &subst_lhs_len);

 /*An empty substitution lhs with no previous substitution
		   uses the last search string as the lhs.*/

1. 		if (t)
2. 		  {
3. 		    FREE (subst_lhs);
4. 		    subs",Useful
"/*If `&' appears in the rhs, it's supposed to be replaced
		   with the lhs.*/","-10. 			subst_lhs_len = strlen (subst_lhs);
-9. 		      }
-8. 		    else
-7. 		      {
-6. 			subst_lhs = (char *) NULL;
-5. 			subst_lhs_len = 0;
-4. 		      }
-3. 		  }
-2. 		FREE (subst_rhs);
-1. 		subst_rhs = get_subst_pattern (string, &i, delimiter, ",Useful
/*Ignore impossible cases.*/,"-8. 	    if (subst_lhs_len == 0)
-7. 	      {
-6. 		*ret_string = hist_error (string, starting_index, i, NO_PREV_SUBST);
-5. 		free (result);
-4. 		free (temp);
-3. 		return -1;
-2. 	      }
-1. 	    l_temp = strlen (temp);

 /*Ignore impossible cases.*/
",Useful
"/*Substitute SUBST_RHS for SUBST_LHS in TEMP.  There are three
	       cases to consider:

		 1.  substitute_globally == subst_bywords == 0
		 2.  substitute_globally == 1 && subst_bywords == 0
		 3.  substitute_globally == 0 && subst_bywords == 1

	       In the first case, we substitute for the first occurrence only.
	       In the second case, we substitute for every occurrence.
	       In the third case, we tokenize into words and substitute the
	       first occurrence of each word.*/","-8. 	    if (subst_lhs_len > l_temp)
-7. 	      {
-6. 		*ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
-5. 		free (result);
-4. 		free (temp);
-3. 		return (-1);
-2. 	      }

 /*Substitute SUBST_RHS for SUBST_LHS in TEMP.  There are ",Useful
"/*First skip whitespace and find word boundaries if
		   we're past the end of the word boundary we found
		   the last time.*/","-10. 		 1.  substitute_globally == subst_bywords == 0
-9. 		 2.  substitute_globally == 1 && subst_bywords == 0
-8. 		 3.  substitute_globally == 0 && subst_bywords == 1
-7. 	       In the first case, we substitute for the first occurrence only.
-6. 	    ",Useful
"/*Reported to fix a bug that causes it to skip every
			   other match when matching a single character.  Was
			   si += subst_rhs_len previously.*/","-10. 		    strncpy (new_event + si, subst_rhs, subst_rhs_len);
-9. 		    strncpy (new_event + si + subst_rhs_len,
-8. 			     temp + si + subst_lhs_len,
-7. 			     l_temp - (si + subst_lhs_len));
-6. 		    new_event[len] = '\0';
-5. 		    free (temp);
-4",Useful
"/*Expand the string STRING, placing the result into OUTPUT, a pointer
   to a string.  Returns:

  -1) If there was an error in expansion.
   0) If no expansions took place (or, if the only change in
      the text was the de-slashifying of the history expansion
      character)
   1) If expansions did take place
   2) If the `p' modifier was given and the caller should print the result

  If an error ocurred in expansion, then OUTPUT contains a descriptive
  error message.*/","-10.     }
-9.   n = strlen (temp);
-8.   if (n >= result_len)
-7.     result = (char *)xrealloc (result, n + 2);
-6.   strcpy (result, temp);
-5.   free (temp);
-4.   *end_index_ptr = i;
-3.   *ret_string = result;
-2.   return (print_only);
-1. }

 /*Ex",Useful
"/*The output string, and its length.*/","-10. 	  } \
-9. 	while (0)
-8. int
-7. history_expand (hstring, output)
-6.      char *hstring;
-5.      char **output;
-4. {
-3.   register int j;
-2.   int i, r, l, passc, cc, modified, eindex, only_printing, dquote;
-1.   char *string;

 /*The output s",Useful
/*Used when adding the string.*/,"-6.   int result_len;
-5.   char *result;
-4. #if defined (HANDLE_MULTIBYTE)
-3.   char mb[MB_LEN_MAX];
-2.   mbstate_t ps;
-1. #endif

 /*Used when adding the string.*/

1.   char *temp;
2.   if (output == 0)
3.     return 0;",Useful
"/*Setting the history expansion character to 0 inhibits all
     history expansion.*/","-3.   char *temp;
-2.   if (output == 0)
-1.     return 0;

 /*Setting the history expansion character to 0 inhibits all
     history expansion.*/

1.   if (history_expansion_char == 0)
2.     {
3.       *output = savestring (hstring);
4.       return (0)",Useful
/*Prepare the buffer for printing error messages.*/,"-5.   if (history_expansion_char == 0)
-4.     {
-3.       *output = savestring (hstring);
-2.       return (0);
-1.     }

 /*Prepare the buffer for printing error messages.*/

1.   result = (char *)xmalloc (result_len = 256);
2.   result[0] = '\0';
3.  ",Useful
"/*Grovel the string.  Only backslash and single quotes can quote the
     history escape character.  We also handle arg specifiers.*/","-4.   result = (char *)xmalloc (result_len = 256);
-3.   result[0] = '\0';
-2.   only_printing = modified = 0;
-1.   l = strlen (hstring);

 /*Grovel the string.  Only backslash and single quotes can quote the
     history escape character.  We also handl",Useful
"/*The quick substitution character is a history expansion all right.  That
     is to say, ""^this^that^"" is equivalent to ""!!:s^this^that^"", and in fact,
     that is the substitution that we do.*/","-8.   result = (char *)xmalloc (result_len = 256);
-7.   result[0] = '\0';
-6.   only_printing = modified = 0;
-5.   l = strlen (hstring);

 /*The quick substitution character is a history expansion all right.  That
     is to say, ""^this^that^"" is equiva",Useful
"/*If not quick substitution, still maybe have to do expansion.*/","-10.       string[3] = 's';
-9.       strcpy (string + 4, hstring);
-8.       l += 4;
-7.     }
-6.   else
-5.     {
-4. #if defined (HANDLE_MULTIBYTE)
-3.       memset (&ps, 0, sizeof (mbstate_t));
-2. #endif
-1.       string = hstring;

 /*If not quick ",Useful
"/*`!' followed by one of the characters in history_no_expand_chars
	 is NOT an expansion.*/","-10.       strcpy (string + 4, hstring);
-9.       l += 4;
-8.     }
-7.   else
-6.     {
-5. #if defined (HANDLE_MULTIBYTE)
-4.       memset (&ps, 0, sizeof (mbstate_t));
-3. #endif
-2.       string = hstring;

 /*`!' followed by one of the characters in",Useful
"/*The history_comment_char, if set, appearing at the beginning
	     of a word signifies that the rest of the line should not have
	     history expansion performed on it.
	     Skip the rest of the line and break out of the loop.*/","-1. 	  cc = string[i + 1];

 /*The history_comment_char, if set, appearing at the beginning
	     of a word signifies that the rest of the line should not have
	     history expansion performed on it.
	     Skip the rest of the line and break out of the l",Useful
"/*If the calling application has set
		 history_inhibit_expansion_function to a function that checks
		 for special cases that should not be history expanded,
		 call the function and skip the expansion if it returns a
		 non-zero value.*/","-10. 	      (i == 0 || member (string[i - 1], history_word_delimiters)))
-9. 	    {
-8. 	      while (string[i])
-7. 		i++;
-6. 	      break;
-5. 	    }
-4. 	  else if (string[i] == history_expansion_char)
-3. 	    {
-2. 	      if (!cc || member (cc, hist",Useful
"/*Shell-like quoting: allow backslashes to quote double quotes
	     inside a double-quoted string.*/","-10. 		 history_inhibit_expansion_function to a function that checks
-9. 		 for special cases that should not be history expanded,
-8. 		 call the function and skip the expansion if it returns a
-7. 		 non-zero value. */
-6. 	      else if (history_inhibi",Useful
"/*More shell-like quoting:  if we're paying attention to single
	     quotes and letting them quote the history expansion character,
	     then we need to pay attention to double quotes, because single
	     quotes are not special inside double-quoted strings.*/","-2. 	  else if (dquote && string[i] == '\\' && cc == '""')
-1. 	    i++;

 /*More shell-like quoting:  if we're paying attention to single
	     quotes and letting them quote the history expansion character,
	     then we need to pay attention to double qu",Useful
"/*If this is bash, single quotes inhibit history expansion.*/","-6. 	  else if (history_quotes_inhibit_expansion && string[i] == '""')
-5. 	    {
-4. 	      dquote = 1 - dquote;
-3. 	    }
-2. 	  else if (dquote == 0 && history_quotes_inhibit_expansion && string[i] == '\'')
-1. 	    {

 /*If this is bash, single quotes",Useful
"/*If this is bash, allow backslashes to quote single
		 quotes and the history expansion character.*/","-5. 	      i++;
-4. 	      hist_string_extract_single_quoted (string, &i);
-3. 	    }
-2. 	  else if (history_quotes_inhibit_expansion && string[i] == '\\')
-1. 	    {

 /*If this is bash, allow backslashes to quote single
		 quotes and the history expans",Useful
"/*If history_quotes_inhibit_expansion is set, single quotes
	       inhibit history expansion.*/","-10. 	case '\\':
-9. 	  passc++;
-8. 	  ADD_CHAR (tchar);
-7. 	  break;
-6. 	case '""':
-5. 	  dquote = 1 - dquote;
-4. 	  ADD_CHAR (tchar);
-3. 	  break;
-2. 	case '\'':
-1. 	  {

 /*If history_quotes_inhibit_expansion is set, single quotes
	       inhibi",Useful
"/*If the history_expansion_char is followed by one of the
	     characters in history_no_expand_chars, then it is not a
	     candidate for expansion of any kind.*/","-1. 	  cc = string[i + 1];

 /*If the history_expansion_char is followed by one of the
	     characters in history_no_expand_chars, then it is not a
	     candidate for expansion of any kind.*/

1. 	  if (member (cc, history_no_expand_chars))
2. 	    {
3.",Useful
"/*There is something that is listed as a `word specifier' in csh
	     documentation which means `the expanded text to this point'.
	     That is not a word specifier, it is an event specifier.  If we
	     don't want to allow modifiers with `!#', just stick the current
	     output line in again.*/","-6. 	  if (member (cc, history_no_expand_chars))
-5. 	    {
-4. 	      ADD_CHAR (string[i]);
-3. 	      break;
-2. 	    }
-1. #if defined (NO_BANG_HASH_MODIFIERS)

 /*There is something that is listed as a `word specifier' in csh
	     documentation which",Useful
"/*Return a consed string which is the word specified in SPEC, and found
   in FROM.  NULL is returned if there is no spec.  The address of
   ERROR_POINTER is returned if the word specified cannot be found.
   CALLER_INDEX is the offset in SPEC to start looking; it is updated
   to point to just after the last character parsed.*/","-10.     free (string);
-9.   if (only_printing)
-8.     {
-7. #if 0
-6.       add_history (result);
-5. #endif
-4.       return (2);
-3.     }
-2.   return (modified != 0);
-1. }

 /*Return a consed string which is the word specified in SPEC, and found
 ",Useful
/*The range of words to return doesn't exist yet.*/,"-10.    to point to just after the last character parsed. */
-9. static char *
-8. get_history_word_specifier (spec, from, caller_index)
-7.      char *spec, *from;
-6.      int *caller_index;
-5. {
-4.   register int i = *caller_index;
-3.   int first, l",Useful
"/*If we found a colon, then this *must* be a word specification.  If
     it isn't, then it is an error.*/","-2.   first = last = 0;
-1.   result = (char *)NULL;

 /*If we found a colon, then this *must* be a word specification.  If
     it isn't, then it is an error.*/

1.   if (spec[i] == ':')
2.     {
3.       i++;
4.       expecting_word_spec++;
5.     }",Useful
/*Handle special cases first.*/,"-5.   if (spec[i] == ':')
-4.     {
-3.       i++;
-2.       expecting_word_spec++;
-1.     }

 /*Handle special cases first.*/

111",Useful
/*`%' is the word last searched for.*/,"-6.   if (spec[i] == ':')
-5.     {
-4.       i++;
-3.       expecting_word_spec++;
-2.     }

 /*`%' is the word last searched for.*/

1.   if (spec[i] == '%')
2.     {
3.       *caller_index = i + 1;
4.       return (search_match ? savestring (search_ma",Useful
"/*`*' matches all of the arguments, but not the command.*/","-5.   if (spec[i] == '%')
-4.     {
-3.       *caller_index = i + 1;
-2.       return (search_match ? savestring (search_match) : savestring (""""));
-1.     }

 /*`*' matches all of the arguments, but not the command.*/

1.   if (spec[i] == '*')
2.     {
3",Useful
/*Try to get FIRST and LAST figured out.*/,"-5.   if (spec[i] == '$')
-4.     {
-3.       *caller_index = i + 1;
-2.       return (history_arg_extract ('$', '$', from));
-1.     }

 /*Try to get FIRST and LAST figured out.*/

1.   if (spec[i] == '-')
2.     first = 0;
3.   else if (spec[i] == '^')
",Useful
/*no valid `first' for word specifier*/,"-10.     {
-9.       first = 1;
-8.       i++;
-7.     }
-6.   else if (_rl_digit_p (spec[i]) && expecting_word_spec)
-5.     {
-4.       for (first = 0; _rl_digit_p (spec[i]); i++)
-3. 	first = (first * 10) + _rl_digit_value (spec[i]);
-2.     }
-1.   el",Useful
/*check against `:' because there could be a modifier separator*/,"-10. 	  for (last = 0; _rl_digit_p (spec[i]); i++)
-9. 	    last = (last * 10) + _rl_digit_value (spec[i]);
-8. 	}
-7.       else if (spec[i] == '$')
-6. 	{
-5. 	  i++;
-4. 	  last = '$';
-3. 	}
-2. #if 0
-1.       else if (!spec[i] || spec[i] == ':')

 /",Useful
"/*csh seems to allow anything to terminate the word spec here,
	   leaving it as an abbreviation.*/","-2. #else
-1.       else

 /*csh seems to allow anything to terminate the word spec here,
	   leaving it as an abbreviation.*/

1. #endif",Useful
"/*Extract the args specified, starting at FIRST, and ending at LAST.
   The args are taken from STRING.  If either FIRST or LAST is < 0,
   then make that arg count from the right (subtract from the number of
   tokens, so that FIRST = -1 means the next to last token on the line).
   If LAST is `$' the last arg from STRING is used.*/","-6.     }
-5.   *caller_index = i;
-4.   if (last >= first || last == '$' || last < 0)
-3.     result = history_arg_extract (first, last, from);
-2.   return (result ? result : (char *)&error_pointer);
-1. }

 /*Extract the args specified, starting at FIR",Useful
"/*XXX - think about making history_tokenize return a struct array,
     each struct in array being a string and a length to avoid the
     calls to strlen below.*/","-10.    If LAST is `$' the last arg from STRING is used. */
-9. char *
-8. history_arg_extract (first, last, string)
-7.      int first, last;
-6.      const char *string;
-5. {
-4.   register int i, len;
-3.   char *result;
-2.   int size, offset;
-1.   ",Useful
"/*Parse STRING into tokens and return an array of strings.  If WIND is
   not -1 and INDP is not null, we also want the word surrounding index
   WIND.  The position in the returned array of strings is returned in
   *INDP.*/","-10.      int start, end;
-9. {
-8.   register int len;
-7.   register char *result;
-6.   len = end - start;
-5.   result = (char *)xmalloc (len + 1);
-4.   strncpy (result, string + start, len);
-3.   result[len] = '\0';
-2.   return result;
-1. }

 /*P",Useful
"/*If we're searching for a string that's not part of a word (e.g., "" ""),
     make sure we set *INDP to a reasonable value.*/","-10.    not -1 and INDP is not null, we also want the word surrounding index
-9.    WIND.  The position in the returned array of strings is returned in
-8.    *INDP. */
-7. static char **
-6. history_tokenize_internal (string, wind, indp)
-5.      const c",Useful
"/*Get a token, and stuff it into RESULT.  The tokens are split
     exactly where the shell would split them.*/","-2.   if (indp && wind != -1)
-1.     *indp = -1;

 /*Get a token, and stuff it into RESULT.  The tokens are split
     exactly where the shell would split them.*/

1.   for (i = result_index = size = 0, result = (char **)NULL; string[i]; )
2.     {",Useful
"/*If we have a non-whitespace delimiter character (which would not be
	 skipped by the loop above), use it and any adjacent delimiters to
	 make a separate field.  Any adjacent white space will be skipped the
	 next time through the loop.*/","-6.       for (; string[i] && whitespace (string[i]); i++)
-5. 	;
-4.       if (string[i] == 0 || string[i] == history_comment_char)
-3. 	return (result);
-2.       start = i;
-1.       i = history_tokenize_word (string, start);

 /*If we have a non-white",Useful
"/*If we are looking for the word in which the character at a
	 particular index falls, remember it.*/","-6.       if (i == start && history_word_delimiters)
-5. 	{
-4. 	  i++;
-3. 	  while (string[i] && member (string[i], history_word_delimiters))
-2. 	    i++;
-1. 	}

 /*If we are looking for the word in which the character at a
	 particular index falls, r",Useful
"/*Return an array of tokens, much as the shell might.  The tokens are
   parsed out of STRING.*/","-10. 	 particular index falls, remember it. */
-9.       if (indp && wind != -1 && wind >= start && wind < i)
-8.         *indp = result_index;
-7.       if (result_index + 2 >= size)
-6. 	result = (char **)xrealloc (result, ((size += 10) * sizeof (char *",Useful
"/*Find and return the word which contains the character at index IND
   in the history line LINE.  Used to save the word matched by the
   last history !?string? search.*/","-6. char **
-5. history_tokenize (string)
-4.      const char *string;
-3. {
-2.   return (history_tokenize_internal (string, -1, (int *)NULL));
-1. }

 /*Find and return the word which contains the character at index IND
   in the history line LINE.  Use",Useful
/*input.c -- character input functions for readline.*/,"
/* input.c -- character input functions for readline. */


 /*input.c -- character input functions for readline.*/

1. /* Copyright (C) 1994-2005 Free Software Foundation, Inc.
2.    This file is part of the GNU Readline Library, a library for
3.    reading lines of text with interactive input and history editing.
4.    The GNU Readline Library is free software; you can redistribute it
5.    and/or modify it under the terms of the GNU General Public License
6.    as published by the Free Software Foundation; either version 2, or
7.    (at your option) any later version.
8.    The GNU Readline Library is distributed in the hope that it will be
9.    useful, but WITHOUT ANY WARRANTY; without even the implied warranty
10.    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",Useful
"/*Non-null means it is a pointer to a function to run while waiting for
   character input.*/","-1. #endif

 /*Non-null means it is a pointer to a function to run while waiting for
   character input.*/

1. rl_hook_func_t *rl_event_hook = (rl_hook_func_t *)NULL;
2. rl_getc_func_t *rl_getc_function = rl_getc;",Useful
/*Character Input Buffering*/,"-5. static int ibuffer_space PARAMS((void));
-4. static int rl_get_char PARAMS((int *));
-3. static int rl_gather_tyi PARAMS((void));

 /*Character Input Buffering*/

111",Useful
"/*Return the amount of space available in the buffer for stuffing
   characters.*/","-9. static int pop_index, push_index;
-8. static unsigned char ibuffer[512];
-7. static int ibuffer_len = sizeof (ibuffer) - 1;
-6. #define any_typein (push_index != pop_index)
-5. int
-4. _rl_any_typein ()
-3. {
-2.   return any_typein;
-1. }

 /*Return ",Useful
"/*Get a key from the buffer of characters to be read.
   Return the key in KEY.
   Result is KEY if there was a key, or 0 if there wasn't.*/","-8. static int
-7. ibuffer_space ()
-6. {
-5.   if (pop_index > push_index)
-4.     return (pop_index - push_index - 1);
-3.   else
-2.     return (ibuffer_len - (push_index - pop_index));
-1. }

 /*Get a key from the buffer of characters to be read.
   R",Useful
"/*Stuff KEY into the *front* of the input buffer.
   Returns non-zero if successful, zero if there is
   no space left in the buffer.*/","-10. rl_get_char (key)
-9.      int *key;
-8. {
-7.   if (push_index == pop_index)
-6.     return (0);
-5.   *key = ibuffer[pop_index++];
-4.   if (pop_index >= ibuffer_len)
-3.     pop_index = 0;
-2.   return (1);
-1. }

 /*Stuff KEY into the *front* of ",Useful
"/*If a character is available to be read, then read it and stuff it into
   IBUFFER.  Otherwise, just return.  Returns number of characters read
   (0 if none available) and -1 on error (EIO).*/","-10.       ibuffer[pop_index] = key;
-9.       return (1);
-8.     }
-7.   return (0);
-6. }
-5. int
-4. _rl_pushed_input_available ()
-3. {
-2.   return (push_index != pop_index);
-1. }

 /*If a character is available to be read, then read it and stuff i",Useful
"/*Use getch/_kbhit to check for available console input, in the same way
     that we read it normally.*/","-1. #if defined (__MINGW32__)

 /*Use getch/_kbhit to check for available console input, in the same way
     that we read it normally.*/

1.    chars_avail = isatty (tty) ? _kbhit () : 0;
2.    result = 0;
3. #endif",Useful
"/*If there's nothing available, don't waste time trying to read
     something.*/","-3.    chars_avail = isatty (tty) ? _kbhit () : 0;
-2.    result = 0;
-1. #endif

 /*If there's nothing available, don't waste time trying to read
     something.*/

1.   if (chars_avail <= 0)
2.     return 0;
3.   tem = ibuffer_space ();
4.   if (chars_a",Useful
"/*One cannot read all of the available input.  I can only read a single
     character at a time, or else programs which require input can be
     thwarted.  If the buffer is larger than one character, I lose.
     Damn!*/","-5.   if (chars_avail <= 0)
-4.     return 0;
-3.   tem = ibuffer_space ();
-2.   if (chars_avail > tem)
-1.     chars_avail = tem;

 /*One cannot read all of the available input.  I can only read a single
     character at a time, or else programs which ",Useful
"/*Is there input available to be read on the readline input file
   descriptor?  Only works if the system has select(2) or FIONREAD.
   Uses the value of _keyboard_input_timeout as the timeout; if another
   readline function wants to specify a timeout and not leave it up to
   the user, it should use _rl_input_queued(timeout_value_in_microseconds)
   instead.*/","-10. int
-9. rl_set_keyboard_input_timeout (u)
-8.      int u;
-7. {
-6.   int o;
-5.   o = _keyboard_input_timeout;
-4.   if (u >= 0)
-3.     _keyboard_input_timeout = u;
-2.   return (o);
-1. }

 /*Is there input available to be read on the readline inp",Useful
"/*Add KEY to the buffer of characters to be read.  Returns 1 if the
   character was stuffed correctly; 0 otherwise.*/","-10.   while ((t = rl_get_char (&key)) &&
-9. 	 _rl_keymap[key].type == ISFUNC &&
-8. 	 _rl_keymap[key].function == rl_insert)
-7.     string[i++] = key;
-6.   if (t)
-5.     _rl_unget_char (key);
-4.   string[i] = '\0';
-3.   rl_insert_text (string);
-2.",Useful
/*Make C be the next command to be executed.*/,"-10.     {
-9.       key = NEWLINE;
-8.       rl_pending_input = EOF;
-7.       RL_SETSTATE (RL_STATE_INPUTPENDING);
-6.     }
-5.   ibuffer[push_index++] = key;
-4.   if (push_index >= ibuffer_len)
-3.     push_index = 0;
-2.   return 1;
-1. }

 /*Make C",Useful
/*Clear any pending input pushed with rl_execute_next()*/,"-8. int
-7. rl_execute_next (c)
-6.      int c;
-5. {
-4.   rl_pending_input = c;
-3.   RL_SETSTATE (RL_STATE_INPUTPENDING);
-2.   return 0;
-1. }

 /*Clear any pending input pushed with rl_execute_next()*/

1. int
2. rl_clear_pending_input ()
3. {
4.   r",Useful
"/*Read a key, including pending input.*/","-10. {
-9.   rl_pending_input = 0;
-8.   RL_UNSETSTATE (RL_STATE_INPUTPENDING);
-7.   return 0;
-6. }

 /*Read a key, including pending input.*/

1. int
2. rl_read_key ()
3. {
4.   int c;
5.   rl_key_sequence_length++;
6.   if (rl_pending_input)
7.     {
",Useful
"/*If input is coming from a macro, then use that.*/","-10. {
-9.   int c;
-8.   rl_key_sequence_length++;
-7.   if (rl_pending_input)
-6.     {
-5.       c = rl_pending_input;
-4.       rl_clear_pending_input ();
-3.     }
-2.   else
-1.     {

 /*If input is coming from a macro, then use that.*/

1.       i",Useful
"/*If zero characters are returned, then the file that we are
	 reading from is empty!  Return EOF in that case.*/","-10.   unsigned char c;
-9.   while (1)
-8.     {
-7. #if defined (__MINGW32__)
-6.       if (isatty (fileno (stream)))
-5. 	return (getch ());
-4. #endif
-3.       result = read (fileno (stream), &c, sizeof (unsigned char));
-2.       if (result == sizeo",Useful
"/*If the error that we received was SIGINT, then try again,
	 this is simply an interrupted system call to read ().
	 Otherwise, some error ocurred, also signifying EOF.*/","-10. #  define X_EAGAIN -99
-9. #endif
-8.       if (errno == X_EWOULDBLOCK || errno == X_EAGAIN)
-7. 	{
-6. 	  if (sh_unset_nodelay_mode (fileno (stream)) < 0)
-5. 	    return (EOF);
-4. 	  continue;
-3. 	}
-2. #undef X_EWOULDBLOCK
-1. #undef X_EAGAIN

 ",Useful
/*invalid byte sequence for the current locale*/,"-10.   mbstate_t ps, ps_back;
-9.   memset(&ps, 0, sizeof (mbstate_t));
-8.   memset(&ps_back, 0, sizeof (mbstate_t));
-7.   while (mb_len < size)
-6.     {
-5.       RL_SETSTATE(RL_STATE_MOREINPUT);
-4.       mbchar[mb_len++] = rl_read_key ();
-3.       ",Useful
"/*Read a multibyte-character string whose first character is FIRST into
   the buffer MB of length MLEN.  Returns the last character read, which
   may be FIRST.  Used by the search functions, among others.  Very similar
   to _rl_read_mbchar.*/","-8. 	  mb_len = 1;
-7. 	  break;
-6. 	}
-5.       else if (mbchar_bytes_length > (size_t)(0))
-4. 	break;
-3.     }
-2.   return mb_len;
-1. }

 /*Read a multibyte-character string whose first character is FIRST into
   the buffer MB of length MLEN.  Retu",Useful
/*Read more for multibyte character*/,"-10.   int i, c;
-9.   mbstate_t ps;
-8.   c = first;
-7.   memset (mb, 0, mlen);
-6.   for (i = 0; i < mlen; i++)
-5.     {
-4.       mb[i] = (char)c;
-3.       memset (&ps, 0, sizeof (mbstate_t));
-2.       if (_rl_get_char_len (mb, &ps) == -2)
-1. 	{

",Useful
/*store result set on client if there is a result*/,"-10. {
-9. 	MYSQL_RES *mysql_result = NULL;
-8. 	if (mysql_query(connection, query)) {
-7. 		if (die_on_error) {
-6. 			die(""failed to execute query %s: %s"", query, mysql_error(connection));
-5. 		} else {
-4. 			msg(""Error: failed to execute query %s: %s",Useful
"/**
Receive options important for XtraBackup from MySQL server.
@return	true on success.*/","-10. 	} else if (!version_supported) {
-9. 		msg(""Error: Unsupported server version: '%s'. Please ""
-8. 		    ""report a bug at ""
-7. 		    ""https://bugs.launchpad.net/percona-xtrabackup"",
-6. 		    version_string);
-5. 	}
-4. 	return(version_supported);
-",Useful
/*make sure datadir value is the same in configuration file*/,"-10.   if ((gtid_mode_var && strcmp(gtid_mode_var, ""ON"") == 0) ||
-9.       (gtid_slave_pos_var && *gtid_slave_pos_var))
-8.   {
-7.     have_gtid_slave= true;
-6.   }
-5.   msg(""Using server version %s"", version_var);
-4.   if (!(ret= detect_mysql_capabi",Useful
/*get some default values is they are missing from my.cnf*/,"-10.     }
-9.     if (!equal_paths(mysql_data_home, datadir_var))
-8.     {
-7.       msg(""Warning: option 'datadir' has different ""
-6.           ""values:\n""
-5.           ""  '%s' in defaults file\n""
-4.           ""  '%s' in SHOW VARIABLES"",
-3.        ",Useful
"/**
Query the server to find out what backup capabilities it supports.
@return	true on success.*/","-10. 	} else if (!version_supported) {
-9. 		msg(""Error: Unsupported server version: '%s'. Please ""
-8. 		    ""report a bug at ""
-7. 		    ""https://bugs.launchpad.net/percona-xtrabackup"",
-6. 		    version_string);
-5. 	}
-4. 	return(version_supported);
-",Useful
/*do some sanity checks*/,"-10. 		INFORMATION_SCHEMA.PLUGINS in MariaDB, but
-9. 		FLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS
-8. 		is not supported for versions below 10.1.6
-7. 		(see MDEV-7472) */
-6. 		if (server_flavor == FLAVOR_MARIADB &&
-5. 		    mysql_server_version < 1",Useful
"/**
Function acquires either a backup tables lock, if supported
by the server, or a global read lock (FLUSH TABLES WITH READ LOCK)
otherwise.
@returns true if lock acquired*/","-10.   while (kill_query_thread_running);
-9.   mysql_cond_destroy(&kill_query_thread_stop);
-8.   mysql_cond_destroy(&kill_query_thread_stopped);
-7.   mysql_mutex_unlock(&kill_query_thread_mutex);
-6.   mysql_mutex_destroy(&kill_query_thread_mutex);
-5.",Useful
"/*Set the maximum supported session value for
		lock_wait_timeout to prevent unnecessary timeouts when the
		global value is changed from the default*/","nan


 /*Set the maximum supported session value for
		lock_wait_timeout to prevent unnecessary timeouts when the
		global value is changed from the default*/

nan
",Useful
"/**
If backup locks are used, execute LOCK BINLOG FOR BACKUP provided that we are
not in the --no-lock mode and the lock has not been acquired already.
@returns true if lock acquired*/","-10.   while (kill_query_thread_running);
-9.   mysql_cond_destroy(&kill_query_thread_stop);
-8.   mysql_cond_destroy(&kill_query_thread_stopped);
-7.   mysql_mutex_unlock(&kill_query_thread_mutex);
-6.   mysql_mutex_destroy(&kill_query_thread_mutex);
-5.",Useful
"/**
Releases either global read lock acquired with FTWRL and the binlog
lock acquired with LOCK BINLOG FOR BACKUP, depending on
the locking strategy being used*/","-10. 		msg(""Executing LOCK BINLOG FOR BACKUP..."");
-9. 		xb_mysql_query(connection, ""LOCK BINLOG FOR BACKUP"", false);
-8. 		binlog_locked = true;
-7. 		return(true);
-6. 	}
-5. 	return(false);
-4. }
-3. /***************************************************",Useful
"/**
Wait until it's safe to backup a slave.  Returns immediately if
the host isn't a slave.  Currently there's only one check:
Slave_open_temp_tables has to be zero.  Dies on timeout.*/","-10. 	int result = false;
-9. 	read_mysql_variables(connection,
-8. 		""SHOW STATUS LIKE 'slave_open_temp_tables'"", status, true);
-7. 	result = slave_open_temp_tables ? atoi(slave_open_temp_tables) : 0;
-6. 	free_mysql_variables(status);
-5. 	return(resul",Useful
/*Restart the slave if it was running at start*/,"-10. 	while (open_temp_tables && n_attempts--) {
-9. 		msg(""Starting slave SQL thread, waiting %d seconds, then ""
-8. 		       ""checking Slave_open_temp_tables again (%d attempts ""
-7. 		       ""remaining)..."", sleep_time, n_attempts);
-6. 		xb_mysql_quer",Useful
"/*Print slave status to a file.
	If GTID mode is used, construct a CHANGE MASTER statement with
	MASTER_AUTO_POSITION and correct a gtid_purged value.*/","-3. 		result = true;
-2. 		goto cleanup;
-1. 	}

 /*Print slave status to a file.
	If GTID mode is used, construct a CHANGE MASTER statement with
	MASTER_AUTO_POSITION and correct a gtid_purged value.*/

1. 	if (gtid_executed != NULL && *gtid_executed) {",Useful
"/*When backup locks are supported by the server, we should skip
	creating xtrabackup_galera_info file on the backup stage, because
	wsrep_local_state_uuid and wsrep_last_committed will be inconsistent
	without blocking commits. The state file will be created on the prepare
	stage using the WSREP recovery procedure.*/","-10. 	char *state_uuid = NULL, *state_uuid55 = NULL;
-9. 	char *last_committed = NULL, *last_committed55 = NULL;
-8. 	bool result;
-7. 	mysql_variable status[] = {
-6. 		{""Wsrep_local_state_uuid"", &state_uuid},
-5. 		{""wsrep_local_state_uuid"", &state_uuid",Useful
"/**
Flush and copy the current binary log file into the backup,
if GTID is enabled*/","-10. 	free_mysql_variables(status);
-9. 	return(result);
-8. }
-7. static
-6. bool
-5. write_binlog_info(MYSQL *connection, char *log_bin_dir,
-4. 		  MYSQL_RES *mysql_result, my_ulonglong n_rows,
-3. 		  my_ulonglong start);
-2. /************************",Useful
"/*If log_bin is set, it has priority*/","-8. 	if (filename == NULL || position == NULL) {
-7. 		goto no_replication;
-6. 	}
-5. 	read_mysql_variables(connection, ""SHOW VARIABLES"", vars, true);
-4. 	gtid_exists = (executed_gtid_set && *executed_gtid_set)
-3. 			|| (gtid_binlog_state && *gtid_binl",Useful
/*strip final slash if it is not the only path component*/,"-8. 			log_bin_dir = static_cast<char*>(malloc(3));
-7. 			ut_a(log_bin_dir);
-6. 			log_bin_dir[0] = '.';
-5. 			log_bin_dir[1] = FN_LIBCHAR;
-4. 			log_bin_dir[2] = 0;
-3. 		}
-2. 		size_t log_bin_dir_length;
-1. 		dirname_part(log_bin_dir, log_bin_dir,",Useful
"/**
Retrieves MySQL binlog position and
saves it in a file. It also prints it to stdout.*/","-10. 			""master host '%s', filename '%s', position '%s'"",
-9. 			master, filename, position) != -1);
-8. 	}
-7. cleanup:
-6. 	free_mysql_variables(status);
-5. 	free_mysql_variables(variables);
-4. 	return(result);
-3. }
-2. /*****************************",Useful
"/*Do not create xtrabackup_binlog_info if binary
		log is disabled*/","nan


 /*Do not create xtrabackup_binlog_info if binary
		log is disabled*/

nan
",Useful
"/**
Writes xtrabackup_info file and if backup_history is enable creates
PERCONA_SCHEMA.xtrabackup_history and writes a new history record to the
table containing all the history info particular to the just completed
backup.*/","-10. Copyright (c) 2000, 2011, MySQL AB & Innobase Oy. All Rights Reserved.
-9. This program is free software; you can redistribute it and/or modify it under
-8. the terms of the GNU General Public License as published by the Free Software
-7. Foundation;",Useful
"/**
Deallocate memory, disconnect from MySQL server, etc.
@return	true on success.*/","-10. 	} else if (!version_supported) {
-9. 		msg(""Error: Unsupported server version: '%s'. Please ""
-8. 		    ""report a bug at ""
-7. 		    ""https://bugs.launchpad.net/percona-xtrabackup"",
-6. 		    version_string);
-5. 	}
-4. 	return(version_supported);
-",Useful
/*list of files to sync for --rsync mode*/,"-10. #include ""xtrabackup.h""
-9. #include ""common.h""
-8. #include ""backup_copy.h""
-7. #include ""backup_debug.h""
-6. #include ""backup_mysql.h""
-5. #include <btr0btr.h>
-4. #ifdef _WIN32
-3. #include <aclapi.h>
-2. #endif
-1. #define ROCKSDB_BACKUP_DIR ""#ro",Useful
/*Whether LOCK BINLOG FOR BACKUP has been issued during backup*/,"-1. static std::map<std::string, std::string> tablespace_locations;

 /*Whether LOCK BINLOG FOR BACKUP has been issued during backup*/

1. bool binlog_locked;
2. static void rocksdb_create_checkpoint();
3. static bool has_rocksdb_plugin();
4. static void ",Useful
"/************************************************************************
Represents the context of the thread processing MySQL data directory.*/","-10. 	pthread_mutex_t	mutex;
-9. 	os_file_dir_t	dir;
-8. 	os_file_dir_t	dbdir;
-7. 	os_file_stat_t	dbinfo;
-6. 	os_file_stat_t	fileinfo;
-5. 	dberr_t		err;
-4. 	bool		is_empty_dir;
-3. 	bool		is_file;
-2. 	bool		skip_first_level;
-1. };

 /***************",Useful
"/************************************************************************
Retirn true if character if file separator*/","-8. struct datadir_thread_ctxt_t {
-7. 	datadir_iter_t		*it;
-6. 	uint			n_thread;
-5. 	uint			*count;
-4. 	pthread_mutex_t*	count_mutex;
-3. 	bool			ret;
-2. };
-1. static bool backup_files_from_datadir(const char *dir_path);

 /*************************",Useful
"/************************************************************************
Fill the node struct. Memory for node need to be allocated and freed by
the caller. It is caller responsibility to initialize node with
datadir_node_init and cleanup the memory with datadir_node_free.
Node can not be shared between threads.*/","-5. bool
-4. is_path_separator(char c)
-3. {
-2. 	return(c == FN_LIBCHAR || c == FN_LIBCHAR2);
-1. }

 /************************************************************************
Fill the node struct. Memory for node need to be allocated and freed by
the ca",Useful
"/************************************************************************
Create the MySQL data directory iterator. Memory needs to be released
with datadir_iter_free. Position should be advanced with
datadir_iter_next_file. Iterator can be shared between multiple
threads. It is guaranteed that each thread receives unique file from
data directory into its local node struct.*/","-10. 	free(node->filepath);
-9. 	free(node->filepath_rel);
-8. 	memset(node, 0, sizeof(datadir_node_t));
-7. }
-6. static
-5. void
-4. datadir_node_init(datadir_node_t *node)
-3. {
-2. 	memset(node, 0, sizeof(datadir_node_t));
-1. }

 /*******************",Useful
"/*We found a symlink or a directory; try opening it to see
		if a symlink is a directory*/","-10. 		it->dbdir = NULL;
-9. 	}
-8. 	while (os_file_readdir_next_file(it->datadir_path,
-7. 					  it->dir, &it->dbinfo) == 0) {
-6. 		ulint	len;
-5. 		if ((it->dbinfo.type == OS_FILE_TYPE_FILE
-4. 		     && it->skip_first_level)
-3. 		    || it->dbinfo.t",Useful
"/*We want wrong directory permissions to be a fatal error for
		XtraBackup.*/","-10. 		snprintf(it->dbpath, it->dbpath_len, ""%s/%s"",
-9. 			 it->datadir_path, it->dbinfo.name);
-8. 		if (it->dbinfo.type == OS_FILE_TYPE_FILE) {
-7. 			it->is_file = true;
-6. 			return(true);
-5. 		}
-4. 		if (check_if_skip_database_by_path(it->dbpath)",Useful
"/************************************************************************
Concatenate n parts into single path*/","-8. 		it->dbdir = os_file_opendir(it->dbpath);
-7. 		if (it->dir != IF_WIN(INVALID_HANDLE_VALUE, nullptr)) {
-6. 			it->is_file = false;
-5. 			return(true);
-4. 		}
-3. 	}
-2. 	return(false);
-1. }

 /*****************************************************",Useful
"/************************************************************************
Interface to read MySQL data file sequentially. One should open file
with datafile_open to get cursor and close the cursor with
datafile_close. Cursor can not be shared between multiple
threads.*/","-5. bool
-4. is_path_separator(char c)
-3. {
-2. 	return(c == FN_LIBCHAR || c == FN_LIBCHAR2);
-1. }

 /************************************************************************
Interface to read MySQL data file sequentially. One should open file
with data",Useful
"/*Get the relative path for the destination tablespace name, i.e. the
	one that can be appended to the backup root directory. Non-system
	tablespaces may have absolute paths for remote tablespaces in MySQL
	5.6+. We want to make ""local"" copies for the backup.*/","-10. 		os_file_close(cursor->file);
-9. 	}
-8. 	free(cursor->buf);
-7. }
-6. static
-5. bool
-4. datafile_open(const char *file, datafile_cur_t *cursor, uint thread_n)
-3. {
-2. 	bool		success;
-1. 	new (cursor) datafile_cur_t(file);

 /*Get the relative ",Useful
"/************************************************************************
Check to see if a file exists.
Takes name of the file to check.
@return true if file exists.*/","-10. 			  cursor->file, cursor->buf, cursor->buf_offset,
-9. 			  to_read) != DB_SUCCESS) {
-8. 		return(XB_FIL_CUR_ERROR);
-7. 	}
-6. 	posix_fadvise(cursor->file, cursor->buf_offset, to_read,
-5. 		      POSIX_FADV_DONTNEED);
-4. 	cursor->buf_read = to_r",Useful
"/************************************************************************
Trim leading slashes from absolute path so it becomes relative*/","-10. @return true if file exists. */
-9. bool
-8. file_exists(const char *filename)
-7. {
-6. 	MY_STAT stat_arg;
-5. 	if (!my_stat(filename, &stat_arg, MYF(0))) {
-4. 		return(false);
-3. 	}
-2. 	return(true);
-1. }

 /************************************",Useful
"/************************************************************************
Check if string ends with given suffix.
@return true if string ends with given suffix.*/","-10. 			continue;
-9. 		}
-8. 		if (*path == '.' && is_path_separator(path[1])) {
-7. 			path += 2;
-6. 			continue;
-5. 		}
-4. 		break;
-3. 	}
-2. 	return(path);
-1. }

 /************************************************************************
Check if ",Useful
"/************************************************************************
Create directories recursively.
@return 0 if directories created successfully.*/","-10. {
-9. 	size_t suffix_len = strlen(suffix);
-8. 	size_t str_len = strlen(str);
-7. 	return(str_len >= suffix_len
-6. 	       && strcmp(str + str_len - suffix_len, suffix) == 0);
-5. }
-4. static bool starts_with(const char *str, const char *prefix)
-3",Useful
/*make a parent directory path*/,"-5. static
-4. int
-3. mkdirp(const char *pathname, int Flags, myf MyFlags)
-2. {
-1. 	char *parent, *p;

 /*make a parent directory path*/

1. 	if (!(parent= strdup(pathname)))
2.           return(-1);
3. 	for (p = parent + strlen(parent);
4. 	    !is_pa",Useful
/*try to make parent directory*/,"-5. 	if (!(parent= strdup(pathname)))
-4.           return(-1);
-3. 	for (p = parent + strlen(parent);
-2. 	    !is_path_separator(*p) && p != parent; p--) ;
-1. 	*p = 0;

 /*try to make parent directory*/

1. 	if (p != parent && mkdirp(parent, Flags, MyF",Useful
/*make this one if parent has been made*/,"-4. 	if (p != parent && mkdirp(parent, Flags, MyFlags) != 0) {
-3. 		free(parent);
-2. 		return(-1);
-1. 	}

 /*make this one if parent has been made*/

1. 	if (my_mkdir(pathname, Flags, MyFlags) == 0) {
2. 		free(parent);
3. 		return(0);
4. 	}",Useful
"/************************************************************************
Return true if first and second arguments are the same path.*/","-7. 	if (errno == EEXIST) {
-6. 		free(parent);
-5. 		return(0);
-4. 	}
-3. 	free(parent);
-2. 	return(-1);
-1. }

 /************************************************************************
Return true if first and second arguments are the same path.*/

1",Useful
"/************************************************************************
Check if directory exists. Optionally create directory if doesn't
exist.
@return true if directory exists and if it was created successfully.*/","-10. 		return false;
-9. 	}
-8. 	result = strcmp(real_first, real_second);
-7. 	free(real_first);
-6. 	free(real_second);
-5. 	return result == 0;
-4. #else
-3. 	return strcmp(first, second) == 0;
-2. #endif
-1. }

 /**************************************",Useful
"/************************************************************************
Check that directory exists and it is empty.*/","-10. 	os_dir = os_file_opendir(dir);
-9. 	if (os_dir == IF_WIN(INVALID_HANDLE_VALUE, nullptr)) {
-8. 		my_strerror(errbuf, sizeof(errbuf), my_errno);
-7. 		msg(""Can not open directory %s: %s"", dir,
-6. 			errbuf);
-5. 		return(false);
-4. 	}
-3. 	os_file_",Useful
"/************************************************************************
Check if file name ends with given set of suffixes.
@return true if it does.*/","-10. 		msg(""%s can not open directory %s"", comment, dir);
-9. 		return(false);
-8. 	}
-7. 	empty = (fil_file_readdir_next_file(&err, dir, os_dir, &info) != 0);
-6. 	os_file_closedir(os_dir);
-5. 	if (!empty) {
-4. 		msg(""%s directory %s is not empty!"", co",Useful
"/************************************************************************
Copy data file for backup. Also check if it is allowed to copy by
comparing its name to the list of known data file types and checking
if passes the rules for partial backup.
@return true if file backed up or skipped successfully.*/","-10. filename_matches(const char *filename, const char **ext_list)
-9. {
-8. 	const char **ext;
-7. 	for (ext = ext_list; *ext; ext++) {
-6. 		if (ends_with(filename, *ext)) {
-5. 			return(true);
-4. 		}
-3. 	}
-2. 	return(false);
-1. }

 /**************",Useful
"/*Get the name and the path for the tablespace. node->name always
	contains the path (which may be absolute for remote tablespaces in
	5.6+). space->name contains the tablespace name in the form
	""./database/table.ibd"" (in 5.5-) or ""database/table"" (in 5.6+). For a
	multi-node shared tablespace, space->name contains the name of the first
	node, but that's irrelevant, since we only need node_name to match them
	against filters, and the shared tablespace is always copied regardless
	of the filters value.*/","-10. comparing its name to the list of known data file types and checking
-9. if passes the rules for partial backup.
-8. @return true if file backed up or skipped successfully. */
-7. static
-6. bool
-5. datafile_copy_backup(const char *filepath, uint th",Useful
"/************************************************************************
Same as datafile_copy_backup, but put file name into the list for
rsync command.*/","-10. 	of the filters value. */
-9. 	if (check_if_skip_table(filepath)) {
-8. 		msg(thread_n,""Skipping %s."", filepath);
-7. 		return(true);
-6. 	}
-5. 	if (filename_matches(filepath, ext_list)) {
-4. 		return copy_file(ds_data, filepath, filepath, thread_n",Useful
"/*Get the name and the path for the tablespace. node->name always
	contains the path (which may be absolute for remote tablespaces in
	5.6+). space->name contains the tablespace name in the form
	""./database/table.ibd"" (in 5.5-) or ""database/table"" (in 5.6+). For a
	multi-node shared tablespace, space->name contains the name of the first
	node, but that's irrelevant, since we only need node_name to match them
	against filters, and the shared tablespace is always copied regardless
	of the filters value.*/","-10. comparing its name to the list of known data file types and checking
-9. if passes the rules for partial backup.
-8. @return true if file backed up or skipped successfully. */
-7. static
-6. bool
-5. datafile_copy_backup(const char *filepath, uint th",Useful
"/*On Windows, fix permission of the file after ""copyback""
  We assume that after copyback, mysqld will run as service as NetworkService
  user, thus well give full permission on given file to that user.*/","nan


 /*On Windows, fix permission of the file after ""copyback""
  We assume that after copyback, mysqld will run as service as NetworkService
  user, thus well give full permission on given file to that user.*/

nan
",Useful
"/************************************************************************
Copy file for backup/restore.
@return true in case of success.*/","-10. 	ret = true;
-9. 	for (i = 0; i < n; i++) {
-8. 		ret = data_threads[i].ret && ret;
-7. 		if (!data_threads[i].ret) {
-6. 			msg(""Error: thread %u failed."", i);
-5. 		}
-4. 	}
-3. 	free(data_threads);
-2. 	return(ret);
-1. }

 /**********************",Useful
"/************************************************************************
Try to move file by renaming it. If source and destination are on
different devices fall back to copy and unlink.
@return true in case of success.*/","-10. 	ret = true;
-9. 	for (i = 0; i < n; i++) {
-8. 		ret = data_threads[i].ret && ret;
-7. 		if (!data_threads[i].ret) {
-6. 			msg(""Error: thread %u failed."", i);
-5. 		}
-4. 	}
-3. 	free(data_threads);
-2. 	return(ret);
-1. }

 /**********************",Useful
"/************************************************************************
Read link from .isl file if any and store it in the global map associated
with given tablespace.*/","-10. 		}
-9. 		my_strerror(errbuf, sizeof(errbuf), my_errno);
-8. 		msg(""Can not move file %s to %s: %s"",
-7. 			src_file_path, dst_file_path_abs,
-6. 			errbuf);
-5. 		return(false);
-4. 	}
-3. 	msg(thread_n,""        ...done"");
-2. 	return(true);
-1. }

",Useful
/*Trim whitespace from end of filepath*/,"-10. void
-9. read_link_file(const char *ibd_filepath, const char *link_filepath)
-8. {
-7. 	char *filepath= NULL;
-6. 	FILE *file = fopen(link_filepath, ""r+b"");
-5. 	if (file) {
-4. 		filepath = static_cast<char*>(malloc(OS_FILE_MAX_PATH));
-3. 		os_file",Useful
"/************************************************************************
Return the location of given .ibd if it was previously read
from .isl file.
@return NULL or destination .ibd file path.*/","-9. 			ulint lastch = len - 1;
-8. 			while (lastch > 4 && filepath[lastch] <= 0x20) {
-7. 				filepath[lastch--] = 0x00;
-6. 			}
-5. 		}
-4. 		tablespace_locations[ibd_filepath] = filepath;
-3. 	}
-2. 	free(filepath);
-1. }

 /**************************",Useful
"/************************************************************************
Copy or move file depending on current mode.
@return true in case of success.*/","-10. 	ret = true;
-9. 	for (i = 0; i < n; i++) {
-8. 		ret = data_threads[i].ret && ret;
-7. 		if (!data_threads[i].ret) {
-6. 			msg(""Error: thread %u failed."", i);
-5. 		}
-4. 	}
-3. 	free(data_threads);
-2. 	return(ret);
-1. }

 /**********************",Useful
/*check if there is .isl file*/,"-7. 	if (ends_with(src_file_path, "".isl"")) {
-6. 		char *ibd_filepath;
-5. 		ibd_filepath = strdup(src_file_path);
-4. 		strcpy(ibd_filepath + strlen(ibd_filepath) - 3, ""ibd"");
-3. 		read_link_file(ibd_filepath, src_file_path);
-2. 		free(ibd_filepath);
-",Useful
"/*Remove files that have been removed between first and
			second passes. Cannot use ""rsync --delete"" because it
			does not work with --files-from.*/","-10. 		if ((err = system(cmd.str().c_str()) && !prep_mode) != 0) {
-9. 			msg(""Error: rsync failed with error code %d"", err);
-8. 			ret = false;
-7. 			goto out;
-6. 		}
-5. 		msg(""rsync finished successfully."");
-4. 		if (!prep_mode && !opt_no_lock) {
-",Useful
"/*There is no need to stop slave thread before coping non-Innodb data when
--no-lock option is used because --no-lock option requires that no DDL or
DML to non-transaction tables can occur.*/","-10. 	}
-9. 	msg(""Waiting for log copy thread to read lsn %llu"", (ulonglong)server_lsn_after_lock);
-8. 	backup_wait_for_lsn(server_lsn_after_lock);
-7. 	DBUG_EXECUTE_FOR_KEY(""sleep_after_waiting_for_lsn"", {},
-6. 		{
-5. 			ulong milliseconds = strtoul(d",Useful
"/*The only reason why Galera/binlog info is written before
	wait_for_ibbackup_log_copy_finish() is that after that call the xtrabackup
	binary will start streamig a temporary copy of REDO log to stdout and
	thus, any streaming from innobackupex would interfere. The only way to
	avoid that is to have a single process, i.e. merge innobackupex and
	xtrabackup.*/","-10. 				return(false);
-9. 			}
-8. 		}
-7. 	}
-6. 	if (opt_slave_info) {
-5. 		lock_binlog_maybe(mysql_connection);
-4. 		if (!write_slave_info(mysql_connection)) {
-3. 			return(false);
-2. 		}
-1. 	}

 /*The only reason why Galera/binlog info is writt",Useful
"/*If we were applying an incremental change set, we need to make
	sure non-InnoDB files and xtrabackup_* metainfo files are copied
	to the full backup directory.*/","-10. 				   ""xtrabackup_slave_info"",
-9. 				   ""xtrabackup_info"",
-8. 				   ""ib_lru_dump"",
-7. 				   NULL};
-6. 	datadir_iter_t *it = NULL;
-5. 	datadir_node_t node;
-4. 	bool ret = true;
-3. 	char path[FN_REFLEN];
-2. 	int i;
-1. 	datadir_node_init(&n",Useful
"/*If we are applying an incremental change set, we need to make
	sure non-InnoDB files are cleaned up from full backup dir before
	we copy files from incremental dir.*/","-10. 	return(ret);
-9. }
-8. bool
-7. ibx_cleanup_full_backup()
-6. {
-5. 	const char *ext_list[] = {""delta"", ""meta"", ""ibd"", NULL};
-4. 	datadir_iter_t *it = NULL;
-3. 	datadir_node_t node;
-2. 	bool ret = true;
-1. 	datadir_node_init(&node);

 /*If we ar",Useful
/*parse data file path*/,"-5. 	if (my_setwd(xtrabackup_target_dir, MYF(MY_WME)))
-4. 	{
-3. 		msg(""Can't my_setwd %s"", xtrabackup_target_dir);
-2. 		return(false);
-1. 	}

 /*parse data file path*/

1. 	if (!innobase_data_file_path) {
2.   		innobase_data_file_path = (char*) ""ibda",Useful
"/*--backup generates a single ib_logfile0, which we must copy
	if it exists.*/","nan


 /*--backup generates a single ib_logfile0, which we must copy
	if it exists.*/

nan
",Useful
"/*After completed --prepare, redo log files are redundant.
		We must delete any redo logs at the destination, so that
		the database will not jump to a different log sequence number
		(LSN).*/","nan


 /*After completed --prepare, redo log files are redundant.
		We must delete any redo logs at the destination, so that
		the database will not jump to a different log sequence number
		(LSN).*/

nan
",Useful
"/*Copy some files from top level datadir.
  Do not copy the Innodb files (ibdata1, redo log files),
  as this is done in a separate step.*/","-10. 	if (it != NULL) {
-9. 		datadir_iter_free(it);
-8. 	}
-7. 	if (ds_data != NULL) {
-6. 		ds_destroy(ds_data);
-5. 	}
-4. 	ds_data = NULL;
-3. 	return(ret);
-2. }
-1. /*
  Copy some files from top level datadir.
  Do not copy the Innodb files (ibdata1",Useful
"/*Copy aria log files, and aws keys for encryption plugins.*/","nan


 /*Copy aria log files, and aws keys for encryption plugins.*/

nan
",Useful
"/*Create a file hardlink.
@return true on success, false on error.*/","-10. 		char c = path[path_len - 1];
-9. 		if (c == '/' IF_WIN(|| c == '\\', ))
-8. 			path_len--;
-7. 		else
-6. 			break;
-5. 	}
-4. 	path[path_len] = 0;
-3. 	return path;
-2. }
-1. /*
Create a file hardlink.
@return true on success, false on error.

 /*",Useful
"/*Copies or moves a directory (non-recursively so far).
 Helper function used to backup rocksdb checkpoint, or copy-back the
 rocksdb files.

 Has optimization that allows to use hardlinks when possible
 (source and destination are directories on the same device)*/","-10. 	{
-9. 		strncpy(to_path_full, to_path, sizeof(to_path_full));
-8. 	}
-7. #ifdef _WIN32
-6. 	return  CreateHardLink(to_path_full, from_path, NULL);
-5. #else
-4. 	return !link(from_path, to_path_full);
-3. #endif
-2. }
-1. /*
 Copies or moves a direc",Useful
"/*Obtain user level lock , to protect the checkpoint directory of the server
  from being  user/overwritten by different backup processes, if backups are
  running in parallel.
  
  This lock will be acquired before rocksdb checkpoint is created,  held
  while all files from it are being copied to their final backup destination,
  and finally released after the checkpoint is removed.*/","-10. 				move_file(ds_data, from_path, node.filepath_rel,
-9. 					to, 1));
-8. 		}
-7. 		if (!rc)
-6. 			die(""copy or move file failed"");
-5. 	}
-4. 	datadir_iter_free(it);
-3. 	datadir_node_free(&node);
-2. }
-1. /*
  Obtain user level lock , to protect",Useful
"/*Create temporary checkpoint in $rocksdb_datadir/mariabackup-checkpoint
  directory.
  A (user-level) lock named 'mariabackup_rocksdb_checkpoint' will also be
  acquired be this function.*/","-10. 		exit(EXIT_FAILURE);
-9. 	}
-8. 	mysql_free_result(res);
-7. }
-6. static void rocksdb_unlock_checkpoint()
-5. {
-4. 	xb_mysql_query(mysql_connection, 
-3. 		""SELECT RELEASE_LOCK('mariabackup_rocksdb_checkpoint')"", false, true);
-2. }
-1. /*
  Creat",Useful
"/*Copy files from rocksdb temporary checkpoint to final destination.
  remove temp.checkpoint directory (in server's datadir)
  and release user level lock acquired inside rocksdb_create_checkpoint().*/","-10. 	if (!access(rocksdb_checkpoint_dir, 0))
-9. 	{
-8. 		msg(""Removing rocksdb checkpoint from previous backup attempt."");
-7. 		rocksdb_remove_checkpoint_directory();
-6. 	}
-5. 	char query[FN_REFLEN + 32];
-4. 	snprintf(query, sizeof(query), ""SET GLOB",Useful
"/*The techniques used to implement each of these filters in SSE operate on
    * one pixel at a time.
    * So they generally speed up 3bpp images about 3x, 4bpp images about 4x.
    * They can scale up to 6 and 8 bpp images and down to 2 bpp images,
    * but they'd not likely have any benefit for 1bpp images.
    * Most of these can be implemented using only MMX and 64-bit registers,
    * but they end up a bit slower than using the equally-ubiquitous SSE2.*/","nan


 /*The techniques used to implement each of these filters in SSE operate on
    * one pixel at a time.
    * So they generally speed up 3bpp images about 3x, 4bpp images about 4x.
    * They can scale up to 6 and 8 bpp images and down to 2 bpp images,
    * but they'd not likely have any benefit for 1bpp images.
    * Most of these can be implemented using only MMX and 64-bit registers,
    * but they end up a bit slower than using the equally-ubiquitous SSE2.*/

nan
",Useful
/*first check the eight byte PNG signature*/,"-10.     if (!pstrFileName)
-9.     {
-8.         *ppbImageData = pbImageData = NULL;
-7.         return FALSE;
-6.     }
-5.     if (!(pfFile = fopen(pstrFileName, ""rb"")))
-4.     {
-3.         *ppbImageData = pbImageData = NULL;
-2.         return FALSE",Useful
"/*get width, height, bit-depth and color-type*/","-1.         png_read_info(png_ptr, info_ptr);

 /*get width, height, bit-depth and color-type*/

1.         png_get_IHDR(png_ptr, info_ptr, piWidth, piHeight, &iBitDepth,
2.             &iColorType, NULL, NULL, NULL);",Useful
/*expand images of all color-type and bit-depth to 3x8-bit RGB*/,"-2.         png_get_IHDR(png_ptr, info_ptr, piWidth, piHeight, &iBitDepth,
-1.             &iColorType, NULL, NULL, NULL);

 /*expand images of all color-type and bit-depth to 3x8-bit RGB*/

111",Useful
"/*let the library process alpha, transparency, background, etc.*/","-3.         png_get_IHDR(png_ptr, info_ptr, piWidth, piHeight, &iBitDepth,
-2.             &iColorType, NULL, NULL, NULL);

 /*let the library process alpha, transparency, background, etc.*/

1. #ifdef PNG_READ_16_TO_8_SUPPORTED
2.     if (iBitDepth == 16",Useful
/*set the background color to draw transparent and alpha images over*/,"-10. #endif
-9.         if (iColorType == PNG_COLOR_TYPE_PALETTE)
-8.             png_set_expand(png_ptr);
-7.         if (iBitDepth < 8)
-6.             png_set_expand(png_ptr);
-5.         if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
-4.        ",Useful
/*if required set gamma conversion*/,"-10.         {
-9.             png_set_background(png_ptr, pBackground, PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
-8.             pBkgColor->red   = (byte) pBackground->red;
-7.             pBkgColor->green = (byte) pBackground->green;
-6.             pBkgColor",Useful
"/*after the transformations are registered, update info_ptr data*/","-2.         if (png_get_gAMA(png_ptr, info_ptr, &dGamma))
-1.             png_set_gamma(png_ptr, (double) 2.2, dGamma);

 /*after the transformations are registered, update info_ptr data*/

1.         png_read_update_info(png_ptr, info_ptr);",Useful
"/*get again width, height and the new bit-depth and color-type*/","-1.         png_read_update_info(png_ptr, info_ptr);

 /*get again width, height and the new bit-depth and color-type*/

1.         png_get_IHDR(png_ptr, info_ptr, piWidth, piHeight, &iBitDepth,
2.             &iColorType, NULL, NULL, NULL);",Useful
/*now we can allocate memory to store the image*/,"-3.         ulRowBytes = png_get_rowbytes(png_ptr, info_ptr);
-2.         ulChannels = png_get_channels(png_ptr, info_ptr);
-1.         *piChannels = ulChannels;

 /*now we can allocate memory to store the image*/

1.         if (pbImageData)
2.         {",Useful
/*and allocate memory for an array of row-pointers*/,"-10.         if ((*piHeight) > ((size_t)(-1))/ulRowBytes) {
-9.         {
-8.             png_error(png_ptr, ""Visual PNG: image is too big"");
-7.         }
-6.         if ((pbImageData = (png_byte *) malloc(ulRowBytes * (*piHeight)
-5.                    ",Useful
/*set the individual row-pointers to point at the correct offsets*/,"-5.         if ((ppbRowPointers = (png_bytepp) malloc((*piHeight)
-4.                             * sizeof(png_bytep))) == NULL)
-3.         {
-2.             png_error(png_ptr, ""Visual PNG: out of memory"");
-1.         }

 /*set the individual row-pointe",Useful
/*read the additional chunks in the PNG file (not really needed)*/,"-1.         png_read_image(png_ptr, ppbRowPointers);

 /*read the additional chunks in the PNG file (not really needed)*/

1.         png_read_end(png_ptr, NULL);",Useful
/*we're going to write a very simple 3x8-bit RGB image*/,"-5. #ifdef PNG_STDIO_SUPPORTED
-4.         png_init_io(png_ptr, pfFile);
-3. #else
-2.         png_set_write_fn(png_ptr, (png_voidp)pfFile, png_write_data, png_flush);
-1. #endif

 /*we're going to write a very simple 3x8-bit RGB image*/

1.         png_s",Useful
/*swap the BGR pixels in the DiData structure to RGB*/,"-1.         png_write_info(png_ptr, info_ptr);

 /*swap the BGR pixels in the DiData structure to RGB*/

1.         png_set_bgr(png_ptr);",Useful
/*we can allocate memory for an array of row-pointers*/,"-1.         ulRowBytes = iWidth * ciChannels;

 /*we can allocate memory for an array of row-pointers*/

1.         if ((ppbRowPointers = (png_bytepp) malloc(iHeight * sizeof(png_bytep))) == NULL)
2.             Throw ""Visualpng: Out of memory"";",Useful
/*set the individual row-pointers to point at the correct offsets*/,"-5.         if ((ppbRowPointers = (png_bytepp) malloc((*piHeight)
-4.                             * sizeof(png_bytep))) == NULL)
-3.         {
-2.             png_error(png_ptr, ""Visual PNG: out of memory"");
-1.         }

 /*set the individual row-pointe",Useful
/*write out the entire image data in one call*/,"-2.         for (i = 0; i < iHeight; i++)
-1.             ppbRowPointers[i] = pDiData + i * (((ulRowBytes + 3) >> 2) << 2);

 /*write out the entire image data in one call*/

1.         png_write_image (png_ptr, ppbRowPointers);",Useful
/*write the additional chunks to the PNG file (not really needed)*/,"-1.         png_write_image (png_ptr, ppbRowPointers);

 /*write the additional chunks to the PNG file (not really needed)*/

1.         png_write_end(png_ptr, info_ptr);",Useful
"/*clean up after the write, and free any memory allocated*/","-2.         free (ppbRowPointers);
-1.         ppbRowPointers = NULL;

 /*clean up after the write, and free any memory allocated*/

1.         png_destroy_write_struct(&png_ptr, (png_infopp) NULL);",Useful
"/*fread() returns 0 on error, so it is OK to store this in a size_t
    * instead of an int, which is what fread() actually returns.*/","nan


 /*fread() returns 0 on error, so it is OK to store this in a size_t
    * instead of an int, which is what fread() actually returns.*/

nan
",Useful
"/*Functions in this file look at most 3 pixels (a,b,c) to predict the 4th (d).
 * They're positioned like this:
 *    prev:  c b
 *    row:   a d
 * The Sub filter predicts d=a, Avg d=(a+b)/2, and Paeth predicts d to be
 * whichever of a, b, or c is closest to p=a+b-c.*/","nan


 /*Functions in this file look at most 3 pixels (a,b,c) to predict the 4th (d).
 * They're positioned like this:
 *    prev:  c b
 *    row:   a d
 * The Sub filter predicts d=a, Avg d=(a+b)/2, and Paeth predicts d to be
 * whichever of a, b, or c is closest to p=a+b-c.*/

nan
",Useful
"/*The Sub filter predicts each pixel as the previous pixel, a.
    * There is no pixel to the left of the first pixel.  It's encoded directly.
    * That works with our main loop if we just say that left pixel was zero.*/","nan


 /*The Sub filter predicts each pixel as the previous pixel, a.
    * There is no pixel to the left of the first pixel.  It's encoded directly.
    * That works with our main loop if we just say that left pixel was zero.*/

nan
",Useful
"/*The Sub filter predicts each pixel as the previous pixel, a.
    * There is no pixel to the left of the first pixel.  It's encoded directly.
    * That works with our main loop if we just say that left pixel was zero.*/","nan


 /*The Sub filter predicts each pixel as the previous pixel, a.
    * There is no pixel to the left of the first pixel.  It's encoded directly.
    * That works with our main loop if we just say that left pixel was zero.*/

nan
",Useful
"/*The Avg filter predicts each pixel as the (truncated) average of a and b.
    * There's no pixel to the left of the first pixel.  Luckily, it's
    * predicted to be half of the pixel above it.  So again, this works
    * perfectly with our loop if we make sure a starts at zero.*/","nan


 /*The Avg filter predicts each pixel as the (truncated) average of a and b.
    * There's no pixel to the left of the first pixel.  Luckily, it's
    * predicted to be half of the pixel above it.  So again, this works
    * perfectly with our loop if we make sure a starts at zero.*/

nan
",Useful
"/*PNG requires a truncating average, so we can't just use _mm_avg_epu8*/","nan


 /*PNG requires a truncating average, so we can't just use _mm_avg_epu8*/

nan
",Useful
/*...but we can fix it up by subtracting off 1 if it rounded up.*/,"nan


 /*...but we can fix it up by subtracting off 1 if it rounded up.*/

nan
",Useful
"/*PNG requires a truncating average, so we can't just use _mm_avg_epu8*/","nan


 /*PNG requires a truncating average, so we can't just use _mm_avg_epu8*/

nan
",Useful
/*...but we can fix it up by subtracting off 1 if it rounded up.*/,"nan


 /*...but we can fix it up by subtracting off 1 if it rounded up.*/

nan
",Useful
"/*The Avg filter predicts each pixel as the (truncated) average of a and b.
    * There's no pixel to the left of the first pixel.  Luckily, it's
    * predicted to be half of the pixel above it.  So again, this works
    * perfectly with our loop if we make sure a starts at zero.*/","nan


 /*The Avg filter predicts each pixel as the (truncated) average of a and b.
    * There's no pixel to the left of the first pixel.  Luckily, it's
    * predicted to be half of the pixel above it.  So again, this works
    * perfectly with our loop if we make sure a starts at zero.*/

nan
",Useful
"/*PNG requires a truncating average, so we can't just use _mm_avg_epu8*/","nan


 /*PNG requires a truncating average, so we can't just use _mm_avg_epu8*/

nan
",Useful
/*...but we can fix it up by subtracting off 1 if it rounded up.*/,"nan


 /*...but we can fix it up by subtracting off 1 if it rounded up.*/

nan
",Useful
"/*Read this all as, return x<0 ? -x : x.
   * To negate two's complement, you flip all the bits then add 1.*/","nan


 /*Read this all as, return x<0 ? -x : x.
   * To negate two's complement, you flip all the bits then add 1.*/

nan
",Useful
"/*Paeth tries to predict pixel d using the pixel to the left of it, a,
    * and two pixels from the previous row, b and c:
    *   prev: c b
    *   row:  a d
    * The Paeth function predicts d to be whichever of a, b, or c is nearest to
    * p=a+b-c.
    *
    * The first pixel has no left context, and so uses an Up filter, p = b.
    * This works naturally with our main loop's p = a+b-c if we force a and c
    * to zero.
    * Here we zero b and d, which become c and a respectively at the start of
    * the loop.*/","nan


 /*Paeth tries to predict pixel d using the pixel to the left of it, a,
    * and two pixels from the previous row, b and c:
    *   prev: c b
    *   row:  a d
    * The Paeth function predicts d to be whichever of a, b, or c is nearest to
    * p=a+b-c.
    *
    * The first pixel has no left context, and so uses an Up filter, p = b.
    * This works naturally with our main loop's p = a+b-c if we force a and c
    * to zero.
    * Here we zero b and d, which become c and a respectively at the start of
    * the loop.*/

nan
",Useful
"/*It's easiest to do this math (particularly, deal with pc) with 16-bit
       * intermediates.*/","nan


 /*It's easiest to do this math (particularly, deal with pc) with 16-bit
       * intermediates.*/

nan
",Useful
"/*It's easiest to do this math (particularly, deal with pc) with 16-bit
       * intermediates.*/","nan


 /*It's easiest to do this math (particularly, deal with pc) with 16-bit
       * intermediates.*/

nan
",Useful
"/*Paeth tries to predict pixel d using the pixel to the left of it, a,
    * and two pixels from the previous row, b and c:
    *   prev: c b
    *   row:  a d
    * The Paeth function predicts d to be whichever of a, b, or c is nearest to
    * p=a+b-c.
    *
    * The first pixel has no left context, and so uses an Up filter, p = b.
    * This works naturally with our main loop's p = a+b-c if we force a and c
    * to zero.
    * Here we zero b and d, which become c and a respectively at the start of
    * the loop.*/","nan


 /*Paeth tries to predict pixel d using the pixel to the left of it, a,
    * and two pixels from the previous row, b and c:
    *   prev: c b
    *   row:  a d
    * The Paeth function predicts d to be whichever of a, b, or c is nearest to
    * p=a+b-c.
    *
    * The first pixel has no left context, and so uses an Up filter, p = b.
    * This works naturally with our main loop's p = a+b-c if we force a and c
    * to zero.
    * Here we zero b and d, which become c and a respectively at the start of
    * the loop.*/

nan
",Useful
"/*It's easiest to do this math (particularly, deal with pc) with 16-bit
       * intermediates.*/","nan


 /*It's easiest to do this math (particularly, deal with pc) with 16-bit
       * intermediates.*/

nan
",Useful
/*Write out all the unknown chunks for the current given location*/,"-2. #ifdef PNG_WRITE_SUPPORTED
-1. #ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED

 /*Write out all the unknown chunks for the current given location*/

1. static void
2. write_unknown_chunks(png_structrp png_ptr, png_const_inforp info_ptr,
3.     unsigned int",Useful
"/*If per-chunk unknown chunk handling is enabled use it, otherwise
          * just write the chunks the application has set.*/","-10. {
-9.    if (info_ptr->unknown_chunks_num != 0)
-8.    {
-7.       png_const_unknown_chunkp up;
-6.       png_debug(5, ""writing extra chunks"");
-5.       for (up = info_ptr->unknown_chunks;
-4.            up < info_ptr->unknown_chunks + info_ptr->unk",Useful
"/*NOTE: this code is radically different from the read side in the
          * matter of handling an ancillary unknown chunk.  In the read side
          * the default behavior is to discard it, in the code below the default
          * behavior is to write it.  Critical chunks are, however, only
          * written if explicitly listed or if the default is set to write all
          * unknown chunks.
          *
          * The default handling is also slightly weird - it is not possible to
          * stop the writing of all unsafe-to-copy chunks!
          *
          * TODO: REVIEW: this would seem to be a bug.*/","-2. #ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
-1.          int keep = png_handle_as_unknown(png_ptr, up->name);
         /* NOTE: this code is radically different from the read side in the
          * matter of handling an ancillary unknown chunk.  In the r",Useful
"/*Write only one of sRGB or an ICC profile.  If a profile was supplied
       * and it matches one of the known sRGB ones issue a warning.*/","-10.        */
-9. #ifdef PNG_GAMMA_SUPPORTED
-8. #  ifdef PNG_WRITE_gAMA_SUPPORTED
-7.       if ((info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) == 0 &&
-6.           (info_ptr->colorspace.flags & PNG_COLORSPACE_FROM_gAMA) != 0 &&
-5.           (in",Useful
/*WRITE_sRGB*/,"-4. #  ifdef PNG_WRITE_iCCP_SUPPORTED
-3.          if ((info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) == 0 &&
-2.              (info_ptr->valid & PNG_INFO_iCCP) != 0)
-1.          {
#    ifdef PNG_WRITE_sRGB_SUPPORTED

 /*WRITE_sRGB*/

1.          ",Useful
/*COLORSPACE*/,"-10.           info_ptr->filter_type,
-9. #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-8.           info_ptr->interlace_type
-7. #else
-6.           0
-5. #endif
-4.          );
-3.       /* The rest of these check to see if the valid field has the appropriate",Useful
/*Invert the alpha channel (in tRNS)*/,"-10.    png_write_info_before_PLTE(png_ptr, info_ptr);
-9.    if ((info_ptr->valid & PNG_INFO_PLTE) != 0)
-8.       png_write_PLTE(png_ptr, info_ptr->palette,
-7.           (png_uint_32)info_ptr->num_palette);
-6.    else if (info_ptr->color_type == PNG_C",Useful
/*Check to see if we need to write text chunks*/,"-1. #ifdef PNG_WRITE_TEXT_SUPPORTED

 /*Check to see if we need to write text chunks*/

1.    for (i = 0; i < info_ptr->num_text; i++)
2.    {
3.       png_debug2(2, ""Writing header text chunk %d, type %d"", i,
4.           info_ptr->text[i].compression);",Useful
/*See if user wants us to write information chunks*/,"-10. {
-9.    png_debug(1, ""in png_write_end"");
-8.    if (png_ptr == NULL)
-7.       return;
-6.    if ((png_ptr->mode & PNG_HAVE_IDAT) == 0)
-5.       png_error(png_ptr, ""No IDATs written into file"");
-4. #ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORT",Useful
/*Check to see if user has supplied a time chunk*/,"-2. #endif
-1. #ifdef PNG_WRITE_tIME_SUPPORTED

 /*Check to see if user has supplied a time chunk*/

1.       if ((info_ptr->valid & PNG_INFO_tIME) != 0 &&
2.           (png_ptr->mode & PNG_WROTE_tIME) == 0)
3.          png_write_tIME(png_ptr, &(info_ptr-",Useful
"/*This flush, added in libpng-1.0.8, removed from libpng-1.0.9beta03,
    * and restored again in libpng-1.2.30, may cause some applications that
    * do not set png_ptr->output_flush_fn to crash.  If your application
    * experiences a problem, please try building libpng with
    * PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED defined, and report the event to
    * png-mng-implement at lists.sf.net .*/","-1.    png_write_IEND(png_ptr);
   /* This flush, added in libpng-1.0.8, removed from libpng-1.0.9beta03,
    * and restored again in libpng-1.2.30, may cause some applications that
    * do not set png_ptr->output_flush_fn to crash.  If your application
",Useful
"/*Initialize png_ptr structure, and allocate any memory needed*/","-10. }
-9. void PNGAPI
-8. png_convert_from_time_t(png_timep ptime, time_t ttime)
-7. {
-6.    struct tm *tbuf;
-5.    png_debug(1, ""in png_convert_from_time_t"");
-4.    tbuf = gmtime(&ttime);
-3.    png_convert_from_struct_tm(ptime, tbuf);
-2. }
-1. #end",Useful
"/*Alternate initialize png_ptr structure, and allocate any memory needed*/","-10. png_create_write_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
-9.     png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)
-8. {
-7. #ifndef PNG_USER_MEM_SUPPORTED
-6.    png_structrp png_ptr = png_create_png_struct(user_png_ve",Useful
"/*Set the zlib control values to defaults; they can be overridden by the
       * application after the struct has been created.*/","-2.    if (png_ptr != NULL)
-1.    {
      /* Set the zlib control values to defaults; they can be overridden by the
       * application after the struct has been created.

 /*Set the zlib control values to defaults; they can be overridden by the
       ",Useful
"/*This is a highly dubious configuration option; by default it is off,
       * but it may be appropriate for private builds that are testing
       * extensions not conformant to the current specification, or of
       * applications that must not fail to write at all costs!*/","
      /* This is a highly dubious configuration option; by default it is off,
       * but it may be appropriate for private builds that are testing
       * extensions not conformant to the current specification, or of
       * applications that must not fail to write at all costs!



 /*This is a highly dubious configuration option; by default it is off,
       * but it may be appropriate for private builds that are testing
       * extensions not conformant to the current specification, or of
       * applications that must not fail to write at all costs!*/

1.        */
2. #ifdef PNG_BENIGN_WRITE_ERRORS_SUPPORTED",Useful
"/*In stable builds only warn if an application error can be completely
       * handled.*/","-1. #ifdef PNG_BENIGN_WRITE_ERRORS_SUPPORTED
      /* In stable builds only warn if an application error can be completely
       * handled.

 /*In stable builds only warn if an application error can be completely
       * handled.*/

1.        */
2.     ",Useful
"/*App warnings are warnings in release (or release candidate) builds but
       * are errors during development.*/","-2.       png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;
-1. #endif
      /* App warnings are warnings in release (or release candidate) builds but
       * are errors during development.

 /*App warnings are warnings in release (or release candidate) bui",Useful
"/*Write the image.  You only need to call this function once, even
 * if you are writing an interlaced image.*/","-5.    for (i = 0, rp = row; i < num_rows; i++, rp++)
-4.    {
-3.       png_write_row(png_ptr, *rp);
-2.    }
-1. }
/* Write the image.  You only need to call this function once, even
 * if you are writing an interlaced image.

 /*Write the image.  You o",Useful
"/*Initialize interlace handling.  If image is not interlaced,
    * this will set pass to 1*/","-4.    if (png_ptr == NULL)
-3.       return;
-2.    png_debug(1, ""in png_write_image"");
-1. #ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* Initialize interlace handling.  If image is not interlaced,
    * this will set pass to 1

 /*Initialize interlace ha",Useful
/*Called by user to write a row of image data*/,"-3.    }
-2. }

 /*Called by user to write a row of image data*/

1. void PNGAPI
2. png_write_row(png_structrp png_ptr, png_const_bytep row)
3. {",Useful
/*Initialize transformations and other stuff if first time*/,"-5.    png_row_info row_info;
-4.    if (png_ptr == NULL)
-3.       return;
-2.    png_debug2(1, ""in png_write_row (row %u, pass %d)"",
-1.        png_ptr->row_number, png_ptr->pass);

 /*Initialize transformations and other stuff if first time*/

1.    if",Useful
/*Check for transforms that have been set but were defined out*/,"-3.       if ((png_ptr->mode & PNG_WROTE_INFO_BEFORE_PLTE) == 0)
-2.          png_error(png_ptr,
-1.              ""png_write_info was never called before png_write_row"");

 /*Check for transforms that have been set but were defined out*/

1. #if !defined(",Useful
"/*If interlaced and not interested in row, return*/","-10.       if ((png_ptr->transformations & PNG_BGR) != 0)
-9.          png_warning(png_ptr, ""PNG_WRITE_BGR_SUPPORTED is not defined"");
-8. #endif
-7. #if !defined(PNG_WRITE_SWAP_SUPPORTED) && defined(PNG_READ_SWAP_SUPPORTED)
-6.       if ((png_ptr->transf",Useful
/*error: ignore it*/,"-10.                return;
-9.             }
-8.             break;
-7.          case 6:
-6.             if ((png_ptr->row_number & 0x01) == 0)
-5.             {
-4.                png_write_finish_row(png_ptr);
-3.                return;
-2.            ",Useful
"/*Copy user's row into buffer, leaving room for filter byte.*/","-10.    row_info.channels = png_ptr->usr_channels;
-9.    row_info.bit_depth = png_ptr->usr_bit_depth;
-8.    row_info.pixel_depth = (png_byte)(row_info.bit_depth * row_info.channels);
-7.    row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info",Useful
"/*Write filter_method 64 (intrapixel differencing) only if
    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    * 2. Libpng did not write a PNG signature (this filter_method is only
    *    used in PNG datastreams that are embedded in MNG datastreams) and
    * 3. The application called png_permit_mng_features with a mask that
    *    included PNG_FLAG_MNG_FILTER_64 and
    * 4. The filter_method is 64 and
    * 5. The color_type is RGB or RGBA*/","-4.    if (row_info.pixel_depth != png_ptr->pixel_depth ||
-3.        row_info.pixel_depth != png_ptr->transformed_pixel_depth)
-2.       png_error(png_ptr, ""internal write transform logic error"");
-1. #ifdef PNG_MNG_FEATURES_SUPPORTED
   /* Write filter_",Useful
/*Check for out-of-range palette index*/,"-1. #ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED

 /*Check for out-of-range palette index*/

1.    if (row_info.color_type == PNG_COLOR_TYPE_PALETTE &&
2.        png_ptr->num_palette_max >= 0)
3.       png_do_check_palette_indexes(png_ptr, &row_info",Useful
"/*Find a filter if necessary, filter the row and write it out.*/","-4.    if (row_info.color_type == PNG_COLOR_TYPE_PALETTE &&
-3.        png_ptr->num_palette_max >= 0)
-2.       png_do_check_palette_indexes(png_ptr, &row_info);
-1. #endif

 /*Find a filter if necessary, filter the row and write it out.*/

1.    png_writ",Useful
/*Set the automatic flush interval or 0 to turn flushing off*/,"-5.    png_write_find_filter(png_ptr, &row_info);
-4.    if (png_ptr->write_row_fn != NULL)
-3.       (*(png_ptr->write_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
-2. }
-1. #ifdef PNG_WRITE_FLUSH_SUPPORTED

 /*Set the automatic flush interval ",Useful
/*Flush the current output buffers now*/,"-8. void PNGAPI
-7. png_set_flush(png_structrp png_ptr, int nrows)
-6. {
-5.    png_debug(1, ""in png_set_flush"");
-4.    if (png_ptr == NULL)
-3.       return;
-2.    png_ptr->flush_dist = (nrows < 0 ? 0 : (png_uint_32)nrows);
-1. }

 /*Flush the current ",Useful
/*We have already written out all of the data*/,"-6. void PNGAPI
-5. png_write_flush(png_structrp png_ptr)
-4. {
-3.    png_debug(1, ""in png_write_flush"");
-2.    if (png_ptr == NULL)
-1.       return;

 /*We have already written out all of the data*/

1.    if (png_ptr->row_number >= png_ptr->num_rows)",Useful
/*Free any memory used in png_ptr struct without freeing the struct itself.*/,"-7.    if (png_ptr->row_number >= png_ptr->num_rows)
-6.       return;
-5.    png_compress_IDAT(png_ptr, NULL, 0, Z_SYNC_FLUSH);
-4.    png_ptr->flush_rows = 0;
-3.    png_flush(png_ptr);
-2. }

 /*Free any memory used in png_ptr struct without freeing th",Useful
/*Free any memory zlib uses*/,"-4. static void
-3. png_write_destroy(png_structrp png_ptr)
-2. {
-1.    png_debug(1, ""in png_write_destroy"");

 /*Free any memory zlib uses*/

1.    if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
2.       deflateEnd(&png_ptr->zstream);",Useful
/*Free our memory.  png_free checks NULL for us.*/,"-2.    if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
-1.       deflateEnd(&png_ptr->zstream);

 /*Free our memory.  png_free checks NULL for us.*/

1.    png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list);
2.    png_free(png_ptr, png_ptr->r",Useful
"/*The error handling and memory handling information is left intact at this
    * point: the jmp_buf may still have to be freed.  See png_destroy_png_struct
    * for how this happens.*/","-10.    png_free(png_ptr, png_ptr->try_row);
-9.    png_free(png_ptr, png_ptr->tst_row);
-8.    png_ptr->prev_row = NULL;
-7.    png_ptr->try_row = NULL;
-6.    png_ptr->tst_row = NULL;
-5. #endif
-4. #ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
-3.    png_fre",Useful
"/*Free all memory used by the write.
 * In libpng 1.6.0 this API changed quietly to no longer accept a NULL value for
 * *png_ptr_ptr.  Prior to 1.6.0 it would accept such a value and it would free
 * the passed in info_structs but it would quietly fail to free any of the data
 * inside them.  In 1.6.0 it quietly does nothing (it has to be quiet because it
 * has no png_ptr.)*/","-1. }
/* Free all memory used by the write.
 * In libpng 1.6.0 this API changed quietly to no longer accept a NULL value for
 * *png_ptr_ptr.  Prior to 1.6.0 it would accept such a value and it would free
 * the passed in info_structs but it would quietly",Useful
"/*If we have allocated the row_buf, this means we have already started
       * with the image and we should have allocated all of the filter buffers
       * that have been selected.  If prev_row isn't already allocated, then
       * it is too late to start using the filters that need it, since we
       * will be missing the data in the previous row.  If an application
       * wants to start and stop using particular filters during compression,
       * it should start out with all of the filters, and then remove them
       * or add them back after the start of compression.
       *
       * NOTE: this is a nasty constraint on the code, because it means that the
       * prev_row buffer must be maintained even if there are currently no
       * 'prev_row' requiring filters active.*/","-2.       }
-1. #ifdef PNG_WRITE_FILTER_SUPPORTED
      /* If we have allocated the row_buf, this means we have already started
       * with the image and we should have allocated all of the filter buffers
       * that have been selected.  If prev_row i",Useful
"/*This is the error case, however it is benign - the previous row
             * is not available so the filter can't be used.  Just warn here.*/","-10.           * images cannot benefit from certain filters.  If this isn't done here
-9.           * the check below will fire on 1 pixel high images.
-8.           */
-7.          if (png_ptr->height == 1)
-6.             filters &= ~(PNG_FILTER_UP|PNG_",Useful
"/*Allocate needed row buffers if they have not already been
          * allocated.*/","-10.          }
-9.          num_filters = 0;
-8.          if (filters & PNG_FILTER_SUB)
-7.             num_filters++;
-6.          if (filters & PNG_FILTER_UP)
-5.             num_filters++;
-4.          if (filters & PNG_FILTER_AVG)
-3.             num",Useful
/*Provide floating and fixed point APIs*/,"-10.                    png_malloc(png_ptr, buf_size));
-9.          }
-8.       }
-7.       png_ptr->do_filter = (png_byte)filters;
-6. #endif
-5.    }
-4.    else
-3.       png_error(png_ptr, ""Unknown custom filter method"");
-2. }

 /*Provide floating a",Useful
"/*If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.*/","-3.    png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_STRATEGY;
-2.    png_ptr->zlib_strategy = strategy;
-1. }
/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.

 /*If PNG_WRITE_OPTIMIZE_",Useful
"/*This would produce an invalid PNG file if it worked, but it doesn't and
    * deflate will fault it, so it is harmless to just warn here.*/","-10.       window_bits = 8;
-9.    }
-8.    png_ptr->zlib_window_bits = window_bits;
-7. }
-6. void PNGAPI
-5. png_set_compression_method(png_structrp png_ptr, int method)
-4. {
-3.    png_debug(1, ""in png_set_compression_method"");
-2.    if (png_ptr == N",Useful
/*Invert monochrome pixels*/,"-2.    png_write_info(png_ptr, info_ptr);

 /*Invert monochrome pixels*/

1.    if ((transforms & PNG_TRANSFORM_INVERT_MONO) != 0)
2. #ifdef PNG_WRITE_INVERT_SUPPORTED
3.       png_set_invert_mono(png_ptr);
4. #else
5.       png_app_error(png_ptr, ""PNG_TR",Useful
"/*Shift the pixels up to a legal bit depth and fill in
    * as appropriate to correctly scale the image.*/","-6.    if ((transforms & PNG_TRANSFORM_INVERT_MONO) != 0)
-5. #ifdef PNG_WRITE_INVERT_SUPPORTED
-4.       png_set_invert_mono(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_INVERT_MONO not supported"");
-1. #endif
   /* Shift the pixel",Useful
/*Pack pixels into bytes*/,"-7.    if ((transforms & PNG_TRANSFORM_SHIFT) != 0)
-6. #ifdef PNG_WRITE_SHIFT_SUPPORTED
-5.       if ((info_ptr->valid & PNG_INFO_sBIT) != 0)
-4.          png_set_shift(png_ptr, &info_ptr->sig_bit);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFO",Useful
/*Swap location of alpha bytes from ARGB to RGBA*/,"-6.    if ((transforms & PNG_TRANSFORM_PACKING) != 0)
-5. #ifdef PNG_WRITE_PACK_SUPPORTED
-4.       png_set_packing(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_PACKING not supported"");
-1. #endif

 /*Swap location of alpha bytes fr",Useful
"/*Remove a filler (X) from XRGB/RGBX/AG/GA into to convert it into
    * RGB, note that the code expects the input color type to be G or RGB; no
    * alpha channel.*/","-6.    if ((transforms & PNG_TRANSFORM_SWAP_ALPHA) != 0)
-5. #ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
-4.       png_set_swap_alpha(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_SWAP_ALPHA not supported"");
-1. #endif
   /* Remove a fille",Useful
/*Continue if ignored - this is the pre-1.6.10 behavior*/,"-10.     */
-9.    if ((transforms & (PNG_TRANSFORM_STRIP_FILLER_AFTER|
-8.        PNG_TRANSFORM_STRIP_FILLER_BEFORE)) != 0)
-7.    {
-6. #ifdef PNG_WRITE_FILLER_SUPPORTED
-5.       if ((transforms & PNG_TRANSFORM_STRIP_FILLER_AFTER) != 0)
-4.       {
-3.",Useful
/*Flip BGR pixels to RGB*/,"-8.          png_set_filler(png_ptr, 0, PNG_FILLER_AFTER);
-7.       }
-6.       else if ((transforms & PNG_TRANSFORM_STRIP_FILLER_BEFORE) != 0)
-5.          png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
-4. #else
-3.       png_app_error(png_ptr, ""PNG_TR",Useful
/*Swap bytes of 16-bit files to most significant byte first*/,"-6.    if ((transforms & PNG_TRANSFORM_BGR) != 0)
-5. #ifdef PNG_WRITE_BGR_SUPPORTED
-4.       png_set_bgr(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_BGR not supported"");
-1. #endif

 /*Swap bytes of 16-bit files to most significa",Useful
/*Invert the alpha channel from opacity to transparency*/,"-6.    if ((transforms & PNG_TRANSFORM_PACKSWAP) != 0)
-5. #ifdef PNG_WRITE_PACKSWAP_SUPPORTED
-4.       png_set_packswap(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_PACKSWAP not supported"");
-1. #endif

 /*Invert the alpha channel",Useful
/*Initialize the write structure - general purpose utility.*/,"-5.    png_write_end(png_ptr, info_ptr);
-4.    PNG_UNUSED(params)
-3. }
-2. #endif
-1. #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED

 /*Initialize the write structure - general purpose utility.*/

1. static int
2. png_image_write_init(png_imagep image)
3. {
4. ",Useful
/*Byte count for memory writing*/,"-3.    png_const_voidp first_row;
-2.    ptrdiff_t       row_bytes;
-1.    png_voidp       local_row;

 /*Byte count for memory writing*/

1.    png_bytep        memory;",Useful
"/*Calculate a reciprocal.  The correct calculation is simply
          * component/alpha*65535 << 15. (I.e. 15 bits of precision); this
          * allows correct rounding by adding .5 before the shift.  'reciprocal'
          * is only initialized when required.*/","-10.    for (; y > 0; --y)
-9.    {
-8.       png_const_uint_16p in_ptr = input_row;
-7.       png_uint_16p out_ptr = output_row;
-6.       while (out_ptr < row_end)
-5.       {
-4.          const png_uint_16 alpha = in_ptr[aindex];
-3.          png_uint_",Useful
"/*The following gives 65535 for an alpha of 0, which is fine,
             * otherwise if 0/0 is represented as some other value there is more
             * likely to be a discontinuity which will probably damage
             * compression when moving from a fully transparent area to a
             * nearly transparent one.  (The assumption here is that opaque
             * areas tend not to be 0 intensity.)*/","-2.          {
-1.             png_uint_16 component = *in_ptr++;
            /* The following gives 65535 for an alpha of 0, which is fine,
             * otherwise if 0/0 is represented as some other value there is more
             * likely to be a dis",Useful
/*Skip to next component (skip the intervening alpha channel)*/,"-5.                component = (png_uint_16)(calc >> 15);
-4.             }
-3.             *out_ptr++ = component;
-2.          }
-1.          while (--c > 0);

 /*Skip to next component (skip the intervening alpha channel)*/

1.          ++in_ptr;
2.   ",Useful
"/*Given 16-bit input (1 to 4 channels) write 8-bit output.  If an alpha channel
 * is present it must be removed from the components, the components are then
 * written in sRGB encoding.  No components are added or removed.
 *
 * Calculate an alpha reciprocal to reverse pre-multiplication.  As above the
 * calculation can be done to 15 bits of accuracy; however, the output needs to
 * be scaled in the range 0..255*65535, so include that scaling here.*/","-8.          ++in_ptr;
-7.          ++out_ptr;
-6.       }
-5.       png_write_row(png_ptr, png_voidcast(png_const_bytep, display->local_row));
-4.       input_row += (png_uint_16)display->row_bytes/(sizeof (png_uint_16));
-3.    }
-2.    return 1;
-1. }
",Useful
"/*The following gives 1.0 for an alpha of 0, which is fine, otherwise if 0/0
    * is represented as some other value there is more likely to be a
    * discontinuity which will probably damage compression when moving from a
    * fully transparent area to a nearly transparent one.  (The assumption here
    * is that opaque areas tend not to be 0 intensity.)
    *
    * There is a rounding problem here; if alpha is less than 128 it will end up
    * as 0 when scaled to 8 bits.  To avoid introducing spurious colors into the
    * output change for this too.*/","-1. {
   /* The following gives 1.0 for an alpha of 0, which is fine, otherwise if 0/0
    * is represented as some other value there is more likely to be a
    * discontinuity which will probably damage compression when moving from a
    * fully transpar",Useful
"/*The test is that alpha/257 (rounded) is less than 255, the first value
       * that becomes 255 is 65407.
       * NOTE: this must agree with the PNG_DIV257 macro (which must, therefore,
       * be exact!)  [Could also test reciprocal != 0]*/","-2.    else if (component > 0)
-1.    {
      /* The test is that alpha/257 (rounded) is less than 255, the first value
       * that becomes 255 is 65407.
       * NOTE: this must agree with the PNG_DIV257 macro (which must, therefore,
       * be exact!",Useful
/*Convert the component to sRGB.*/,"-4.          component >>= 7;
-3.       }
-2.       else
-1.          component *= 255;

 /*Convert the component to sRGB.*/

1.       return (png_byte)PNG_sRGB_FROM_LINEAR(component);
2.    }
3.    else
4.       return 0;
5. }
6. static int
7. png_write_",Useful
/*Scale and write the alpha channel.*/,"-10.       for (; y > 0; --y)
-9.       {
-8.          png_const_uint_16p in_ptr = input_row;
-7.          png_bytep out_ptr = output_row;
-6.          while (out_ptr < row_end)
-5.          {
-4.             png_uint_16 alpha = in_ptr[aindex];
-3.       ",Useful
/*always at least one channel*/,"-3.          if (alpha > 0 && alpha < 65535)
-2.             reciprocal = ((0xffff<<15)+(alpha>>1))/alpha;
-1.          c = (int)channels;

 /*always at least one channel*/

1.          {
2.             png_uint_16 component = *in_ptr++;",Useful
/*Skip to next component (skip the intervening alpha channel)*/,"-5.                component = (png_uint_16)(calc >> 15);
-4.             }
-3.             *out_ptr++ = component;
-2.          }
-1.          while (--c > 0);

 /*Skip to next component (skip the intervening alpha channel)*/

1.          ++in_ptr;
2.   ",Useful
"/*No alpha channel, so the row_end really is the end of the row and it
       * is sufficient to loop over the components one by one.*/","-3.    }
-2.    else
-1.    {
      /* No alpha channel, so the row_end really is the end of the row and it
       * is sufficient to loop over the components one by one.

 /*No alpha channel, so the row_end really is the end of the row and it
       * is",Useful
/*NOTE: the caller must check for cmap != NULL and entries != 0*/,"-10.    }
-9.    return 1;
-8. }
-7. static void
-6. png_image_set_PLTE(png_image_write_control *display)
-5. {
-4.    const png_imagep image = display->image;
-3.    const void *cmap = display->colormap;
-2.    const int entries = image->colormap_entries",Useful
"/*This gets automatically converted to sRGB with reversal of the
       * pre-multiplication if the color-map has an alpha channel.*/","-10. #   else
-9. #     define bgr 0
-8. #   endif
-7.    int i, num_trans;
-6.    png_color palette[256];
-5.    png_byte tRNS[256];
-4.    memset(tRNS, 255, (sizeof tRNS));
-3.    memset(palette, 0, (sizeof palette));
-2.    for (i=num_trans=0; i<entrie",Useful
"/*Calculate a reciprocal, as in the png_write_image_8bit code above
             * this is designed to produce a value scaled to 255*65535 when
             * divided by 128 (i.e. asr 7).*/","-4.          {
-3.             png_uint_16 alpha = entry[afirst ? 0 : channels-1];
-2.             png_byte alphabyte = (png_byte)PNG_DIV257(alpha);
-1.             png_uint_32 reciprocal = 0;
            /* Calculate a reciprocal, as in the png_write_ima",Useful
/*Color-map has sRGB values*/,"-4.                palette[i].blue = palette[i].red = palette[i].green =
-3.                    png_unpremultiply(entry[afirst], alpha, reciprocal);
-2.          }
-1.       }

 /*Color-map has sRGB values*/

1.       {
2.          png_const_bytep entry =",Useful
/*Make sure we error out on any bad situation*/,"-3.    int alpha = !colormap && (format & PNG_FORMAT_FLAG_ALPHA);
-2.    int write_16bit = linear && (display->convert_to_8bit == 0);
-1. #   ifdef PNG_BENIGN_ERRORS_SUPPORTED

 /*Make sure we error out on any bad situation*/

111",Useful
"/*Default the 'row_stride' parameter if required, also check the row stride
    * and total image size to ensure that they are within the system limits.*/","-1. #   endif
   /* Default the 'row_stride' parameter if required, also check the row stride
    * and total image size to ensure that they are within the system limits.

 /*Default the 'row_stride' parameter if required, also check the row stride
    * ",Useful
"/*Now check for overflow of the image buffer calculation; this
             * limits the whole image size to 32 bits for API compatibility with
             * the current, 32-bit, PNG_IMAGE_BUFFER_SIZE macro.*/","-6.          if (display->row_stride < 0)
-5.             check = (png_uint_32)(-display->row_stride);
-4.          else
-3.             check = (png_uint_32)display->row_stride;
-2.          if (check >= png_row_stride)
-1.          {
            /* Now ",Useful
/*Set the required transforms then write the rows in the correct order.*/,"-10.              */
-9.             if (image->height > 0xffffffffU/png_row_stride)
-8.                png_error(image->opaque->png_ptr, ""memory image too large"");
-7.          }
-6.          else
-5.             png_error(image->opaque->png_ptr, ""suppli",Useful
/*The gamma here is 1.0 (linear) and the cHRM chunk matches sRGB.*/,"-2.    if (write_16bit != 0)
-1.    {

 /*The gamma here is 1.0 (linear) and the cHRM chunk matches sRGB.*/

1.       png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_LINEAR);
2.       if ((image->flags & PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB) == 0)
3.       ",Useful
"/*Else writing an 8-bit file and the *colors* aren't sRGB, but the 8-bit
    * space must still be gamma encoded.*/","-4.          );
-3.    }
-2.    else if ((image->flags & PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB) == 0)
-1.       png_set_sRGB(png_ptr, info_ptr, PNG_sRGB_INTENT_PERCEPTUAL);
   /* Else writing an 8-bit file and the *colors* aren't sRGB, but the 8-bit
    * sp",Useful
"/*Now set up the data transformations (*after* the header is written),
    * remove the handled transformations from the 'format' flags for checking.
    *
    * First check for a little endian system if writing 16-bit files.*/","-1.    png_write_info(png_ptr, info_ptr);
   /* Now set up the data transformations (*after* the header is written),
    * remove the handled transformations from the 'format' flags for checking.
    *
    * First check for a little endian system if writi",Useful
"/*If there are 16 or fewer color-map entries we wrote a lower bit depth
    * above, but the application data is still byte packed.*/","-10.       }
-9. #   endif
-8. #   ifdef PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
-7.       if ((format & PNG_FORMAT_FLAG_AFIRST) != 0)
-6.       {
-5.          if (colormap == 0 && (format & PNG_FORMAT_FLAG_ALPHA) != 0)
-4.             png_set_swap_alpha(pn",Useful
"/*NOTE: determined by experiment using pngstest, this reflects some
       * balance between the time to write the image once and the time to read
       * it about 50 times.  The speed-up in pngstest was about 10-20% of the
       * total (user) time on a heavily loaded system.*/","-3.    if ((image->flags & PNG_IMAGE_FLAG_FAST) != 0)
-2.    {
-1.       png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, PNG_NO_FILTERS);
      /* NOTE: determined by experiment using pngstest, this reflects some
       * balance between the time to write t",Useful
"/*Check for the cases that currently require a pre-transform on the row
    * before it is written.  This only applies when the input is 16-bit and
    * either there is an alpha channel or it is converted to 8-bit.*/","-4. #   ifdef PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
-3.       png_set_compression_level(png_ptr, 3);
-2. #   endif
-1.    }
   /* Check for the cases that currently require a pre-transform on the row
    * before it is written.  This only applies when",Useful
"/*Otherwise this is the case where the input is in a format currently
    * supported by the rest of the libpng write code; call it directly.*/","-3.       if (result == 0)
-2.          return 0;
-1.    }
   /* Otherwise this is the case where the input is in a format currently
    * supported by the rest of the libpng write code; call it directly.

 /*Otherwise this is the case where the input is ",Useful
/*Check for overflow; this should never happen:*/,"-1.    const png_alloc_size_t ob = display->output_bytes;

 /*Check for overflow; this should never happen:*/

1.    if (size <= ((png_alloc_size_t)-1) - ob)
2.    {",Useful
"/*The rest of the memory-specific init and write_main in an error protected
    * environment.  This case needs to use callbacks for the write operations
    * since libpng has no built in support for writing to memory.*/","-10. static void (PNGCBAPI
-9. image_memory_flush)(png_structp png_ptr)
-8. {
-7.    PNG_UNUSED(png_ptr)
-6. }
-5. static int
-4. png_image_write_memory(png_voidp argument)
-3. {
-2.    png_image_write_control *display = png_voidcast(png_image_write_contr",Useful
"/*Write the image to the given buffer, or count the bytes if it is NULL*/","-8.        image_memory_write, image_memory_flush);
-7.    return png_image_write_main(display);
-6. }
-5. int PNGAPI
-4. png_image_write_to_memory(png_imagep image, void *memory,
-3.     png_alloc_size_t * PNG_RESTRICT memory_bytes, int convert_to_8bit,
",Useful
"/*This is to give the caller an easier error detection in the NULL
          * case and guard against uninitialized variable problems:*/","-4.    if (image != NULL && image->version == PNG_IMAGE_VERSION)
-3.    {
-2.       if (memory_bytes != NULL && buffer != NULL)
-1.       {
         /* This is to give the caller an easier error detection in the NULL
          * case and guard against uni",Useful
/*write_memory returns true even if we ran out of buffer.*/,"-10.             display.image = image;
-9.             display.buffer = buffer;
-8.             display.row_stride = row_stride;
-7.             display.colormap = colormap;
-6.             display.convert_to_8bit = convert_to_8bit;
-5.             displ",Useful
"/*On out-of-buffer this function returns '0' but still updates
                * memory_bytes:*/","-2.             if (result)
-1.             {
               /* On out-of-buffer this function returns '0' but still updates
                * memory_bytes:

 /*On out-of-buffer this function returns '0' but still updates
                * memory_bytes:*/",Useful
"/*This is slightly evil, but png_init_io doesn't do anything other
             * than this and we haven't changed the standard IO functions so
             * this saves a 'safe' function.*/","-8.    if (image != NULL && image->version == PNG_IMAGE_VERSION)
-7.    {
-6.       if (file != NULL && buffer != NULL)
-5.       {
-4.          if (png_image_write_init(image) != 0)
-3.          {
-2.             png_image_write_control display;
-1.     ",Useful
"/*The image has already been cleaned up; this is just used to
                * set the error (because the original write succeeded).*/","-3.                   (void)fclose(fp);
-2.                }
-1.                (void)remove(file_name);
               /* The image has already been cleaned up; this is just used to
                * set the error (because the original write succeeded).
",Useful
/*treat Win32 native ports of gcc as Unix environments*/,"---*/
-6. #define PROGNAME  ""wpng""
-5. #define VERSION   ""2.00 of 2 June 2007""
-4. #define APPNAME   ""Simple PGM/PPM/PAM to PNG Converter""
-3. #if defined(__MSDOS__) || defined(__OS2__)
-2. #  define DOS_OS2_W32
-1. #elif defined(WIN32) || defined(_WIN32)",Useful
/*#define DEBUG  :  this enables the Trace() macros*/,"-2. #  define FGETS fgets
-1. #endif

 /*#define DEBUG  :  this enables the Trace() macros*/

111",Useful
"/*#define FORBID_LATIN1_CTRL  :  this requires the user to re-enter any
   text that includes control characters discouraged by the PNG spec; text
   that includes an escape character (27) must be re-entered regardless*/","-3. #  define FGETS fgets
-2. #endif

 /*#define FORBID_LATIN1_CTRL  :  this requires the user to re-enter any
   text that includes control characters discouraged by the PNG spec; text
   that includes an escape character (27) must be re-entered regardle",Useful
"/*typedefs, common macros, writepng prototypes*/","-6. #  define FGETS fgets
-5. #endif

 /*typedefs, common macros, writepng prototypes*/

111",Useful
"/*First get the default value for our display-system exponent, i.e.,
     * the product of the CRT exponent and the exponent corresponding to
     * the frame-buffer's lookup table (LUT), if any.  If the PNM image
     * looks correct on the user's display system, its file gamma is the
     * inverse of this value.  (Note that this is not an exhaustive list
     * of LUT values--e.g., OpenStep has a lot of weird ones--but it should
     * cover 99% of the current possibilities.  This section must ensure
     * that default_display_exponent is positive.)*/","-10.     wpng_info.infile = NULL;
-9.     wpng_info.outfile = NULL;
-8.     wpng_info.image_data = NULL;
-7.     wpng_info.row_pointers = NULL;
-6.     wpng_info.filter = FALSE;
-5.     wpng_info.interlaced = FALSE;
-4.     wpng_info.have_bg = FALSE;
-3. ",Useful
/*third-party utilities can modify the default LUT exponent*/,"-1. #if defined(NeXT)

 /*third-party utilities can modify the default LUT exponent*/

1.     LUT_exponent = 1.0 / 2.2;",Useful
"/*there doesn't seem to be any documented function to
     * get the ""gamma"" value, so we do it the hard way*/","-2. #elif defined(sgi)
-1.     LUT_exponent = 1.0 / 1.7;

 /*there doesn't seem to be any documented function to
     * get the ""gamma"" value, so we do it the hard way*/

1.     tmpfile = fopen(""/etc/config/system.glGammaVal"", ""r"");
2.     if (tmpfile) {
",Useful
"/*If the user has set the SCREEN_GAMMA environment variable as suggested
     * (somewhat imprecisely) in the libpng documentation, use that; otherwise
     * use the default value we just calculated.  Either way, the user may
     * override this via a command-line option.*/","-1.     default_display_exponent = LUT_exponent * CRT_exponent;

 /*If the user has set the SCREEN_GAMMA environment variable as suggested
     * (somewhat imprecisely) in the libpng documentation, use that; otherwise
     * use the default value we just ",Useful
"/*open the input and output files, or register an error and abort*/","-2.         }
-1.     }

 /*open the input and output files, or register an error and abort*/

1.     if (!inname) {
2.         if (isatty(0)) {
3.             fprintf(stderr, PROGNAME
4.               "":  must give input filename or provide image data vi",Useful
"/*check if outname already exists; if not, open*/","-10.                 if ((p = strrchr(inname, '.')) == NULL ||
-9.                     (p - inname) != (len - 4))
-8.                 {
-7.                     strcpy(outname, inname);
-6.                     strcpy(outname+len, "".png"");
-5.              ",Useful
"/*if we had any errors, print usage and die horrible death...arrr!*/","-10.         }
-9.         if (error) {
-8.             fclose(wpng_info.infile);
-7.             wpng_info.infile = NULL;
-6.             if (wpng_info.filter) {
-5.                 fclose(wpng_info.outfile);
-4.                 wpng_info.outfile = NULL;",Useful
"/*prepare the text buffers for libpng's use; note that even though
     * PNG's png_text struct includes a length field, we don't have to fill
     * it out*/","-10. ""unofficial and unsupported!) PAM (`P8') file.  Currently it is required\n""
-9. ""to have maxval == 255 (i.e., no scaling).  If pnmfile is specified, it\n""
-8. ""is converted to the corresponding PNG file with the same base name but a\n""
-7. ""``.png'' ",Useful
/*now points at NULL; char before is newline*/,"-10.             }
-9.         } while (!valid);
-8.         do {
-7.             valid = TRUE;
-6.             p = textbuf + TEXT_DESC_OFFSET;
-5.             fprintf(stderr, ""  Description (up to 9 lines):\n"");
-4.             for (i = 1;  i < 10;  ++i)",Useful
"/*allocate libpng stuff, initialize transformations, write pre-IDAT data*/","-10.             }
-9.         } while (!valid);
-8. #ifndef DOS_OS2_W32
-7.         fclose(keybd);
-6. #endif
-5.     } else if (text) {
-4.         fprintf(stderr, PROGNAME "":  unable to allocate memory for text\n"");
-3.         text = FALSE;
-2.       ",Useful
"/*free textbuf, since it's a completely local variable and all text info
     * has just been written to the PNG file*/","-10.                 fprintf(stderr, PROGNAME
-9.                   "":  internal logic error (unexpected PNM type)\n"");
-8.                 break;
-7.             default:
-6.                 fprintf(stderr, PROGNAME
-5.                   "":  unknown writ",Useful
"/*calculate rowbytes on basis of image type; note that this becomes much
     * more complicated if we choose to support PBM type, ASCII PNM types, or
     * 16-bit-per-sample binary data [currently not an official NetPBM type]*/","-4.     if (text && textbuf) {
-3.         free(textbuf);
-2.         textbuf = NULL;
-1.     }

 /*calculate rowbytes on basis of image type; note that this becomes much
     * more complicated if we choose to support PBM type, ASCII PNM types, or
     *",Useful
"/*read and write the image, either in its entirety (if writing interlaced
     * PNG) or row by row (if non-interlaced)*/","-1.         rowbytes = wpng_info.width * 4;

 /*read and write the image, either in its entirety (if writing interlaced
     * PNG) or row by row (if non-interlaced)*/

1.     fprintf(stderr, ""Encoding image data...\n"");
2.     fflush(stderr);
3.     if (",Useful
/*not interlaced:  write progressively (row by row)*/,"-10.               image_bytes, bytes);
-9.             fprintf(stderr, ""  (continuing anyway)\n"");
-8.         }
-7.         if (writepng_encode_image(&wpng_info) != 0) {
-6.             fprintf(stderr, PROGNAME
-5.               "":  libpng problem (long",Useful
"/*Read the data from whatever input you are using.  The default routine
 * reads from a file pointer.  Note that this routine sometimes gets called
 * with very small lengths, so you should implement some kind of simple
 * buffering if you are using unbuffered reads.  This should never be asked
 * to read more than 64K on a 16-bit machine.*/",#NAME?,Useful
"/*This is the function that does the actual reading of data.  If you are
 * not reading from a standard C stream, you should create a replacement
 * read_data function and use it at run time with png_set_read_fn(), rather
 * than changing the library.*/","-9. png_read_data(png_structrp png_ptr, png_bytep data, png_size_t length)
-8. {
-7.    png_debug1(4, ""reading %d bytes"", (int)length);
-6.    if (png_ptr->read_data_fn != NULL)
-5.       (*(png_ptr->read_data_fn))(png_ptr, data, length);
-4.    else
-3. ",Useful
"/*fread() returns 0 on error, so it is OK to store this in a size_t
    * instead of an int, which is what fread() actually returns.*/","nan


 /*fread() returns 0 on error, so it is OK to store this in a size_t
    * instead of an int, which is what fread() actually returns.*/

nan
",Useful
"/*This function allows the application to supply a new input function
 * for libpng if standard C streams aren't being used.
 *
 * This function takes as its arguments:
 *
 * png_ptr      - pointer to a png input data structure
 *
 * io_ptr       - pointer to user supplied structure containing info about
 *                the input functions.  May be NULL.
 *
 * read_data_fn - pointer to a new input function that takes as its
 *                arguments a pointer to a png_struct, a pointer to
 *                a location where input data can be stored, and a 32-bit
 *                unsigned int that is the number of bytes to be read.
 *                To exit and output any fatal error messages the new write
 *                function should call png_error(png_ptr, ""Error msg"").
 *                May be NULL, in which case libpng's default function will
 *                be used.*/","-5.    check = fread(data, 1, length, png_voidcast(png_FILE_p, png_ptr->io_ptr));
-4.    if (check != length)
-3.       png_error(png_ptr, ""Read Error"");
-2. }
-1. #endif
/* This function allows the application to supply a new input function
 * for libpng",Useful
/*It is an error to write to a read device*/,"-10.    png_ptr->io_ptr = io_ptr;
-9. #ifdef PNG_STDIO_SUPPORTED
-8.    if (read_data_fn != NULL)
-7.       png_ptr->read_data_fn = read_data_fn;
-6.    else
-5.       png_ptr->read_data_fn = png_default_read_data;
-4. #else
-3.    png_ptr->read_data_fn =",Useful
/*To find how libpng was configured.*/,#NAME?,Useful
"/*WARNING:
    *
    * This test is here to allow POSIX.1b extensions to be used if enabled in
    * the compile; specifically the code requires_POSIX_C_SOURCE support of
    * 199309L or later to enable clock_gettime use.
    *
    * IF this causes problems THEN compile with a strict ANSI C compiler and let
    * this code turn on the POSIX features that it minimally requires.
    *
    * IF this does not work there is probably a bug in your ANSI C compiler or
    * your POSIX implementation.*/","-1. #ifdef PNG_PNGCP_TIMING_SUPPORTED
   /* WARNING:
    *
    * This test is here to allow POSIX.1b extensions to be used if enabled in
    * the compile; specifically the code requires_POSIX_C_SOURCE support of
    * 199309L or later to enable clock_get",Useful
"/*Define the following to use this test against your installed libpng, rather
 * than the one being built here:*/","-6. #  define _POSIX_SOURCE 1
-5. #endif
-4. #if defined(HAVE_CONFIG_H) && !defined(PNG_NO_CONFIG_H)
-3. #  include <config.h>
-2. #endif
-1. #include <stdio.h>
/* Define the following to use this test against your installed libpng, rather
 * than the one",Useful
"/*Many versions of GCC erroneously report that local variables unmodified
    * within the scope of a setjmp may be clobbered.  This hacks round the
    * problem (sometimes) without harming other compilers.*/","-1. #ifdef __GNUC__
   /* Many versions of GCC erroneously report that local variables unmodified
    * within the scope of a setjmp may be clobbered.  This hacks round the
    * problem (sometimes) without harming other compilers.

 /*Many versions of GC",Useful
"/*CLOCK_PROCESS_CPUTIME_ID' is one of the clock timers for clock_gettime.  It
 * need not be supported even when clock_gettime is available.  It returns the
 * 'CPU' time the process has consumed.  'CPU' time is assumed to include time
 * when the CPU is actually blocked by a pending cache fill but not time
 * waiting for page faults.  The attempt is to get a measure of the actual time
 * the implementation takes to read a PNG ignoring the potentially very large IO
 * overhead.*/","-4. #  define gv volatile
-3. #else
-2. #  define gv
-1. #endif
/* 'CLOCK_PROCESS_CPUTIME_ID' is one of the clock timers for clock_gettime.  It
 * need not be supported even when clock_gettime is available.  It returns the
 * 'CPU' time the process has co",Useful
/*continuable error - no need to longjmp*/,"-3.    LIBPNG_WARNING,
-2.    APP_WARNING,

 /*continuable error - no need to longjmp*/

111",Useful
/*Report input and output sizes*/,"-6.    INTERNAL_ERROR
-5. } error_level;

 /*Report input and output sizes*/

111",Useful
/*Search IDAT compression options*/,"-7.    INTERNAL_ERROR
-6. } error_level;

 /*Search IDAT compression options*/

111",Useful
/*Do not write an output file*/,"-8.    INTERNAL_ERROR
-7. } error_level;

 /*Do not write an output file*/

1. #ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED",Useful
/*Ignore out of range palette indices (BAD!)*/,"-10.    INTERNAL_ERROR
-9. } error_level;

 /*Ignore out of range palette indices (BAD!)*/

1. #  ifdef PNG_GET_PALETTE_MAX_SUPPORTED",Useful
/*Fix' out of range palette indices (OK)*/,"-10. #define LEVEL_MASK      0xf   /* where the level is in 'options' */
-9. #define STRICT          0x010 /* Fail on warnings as well as errors */
-8. #define LOG             0x020 /* Log pass/fail to stdout */
-7. #define CONTINUE        0x040 /* Contin",Useful
"/*Result masks apply to the result bits in the 'results' field below; these
 * bits are simple 1U<<error_level.  A pass requires either nothing worse than
 * warnings (--relaxes) or nothing worse than information (--strict)*/","-6. #  ifdef PNG_GET_PALETTE_MAX_SUPPORTED

 /*Result masks apply to the result bits in the 'results' field below; these
 * bits are simple 1U<<error_level.  A pass requires either nothing worse than
 * warnings (--relaxes) or nothing worse than informati",Useful
"/*Overall compression control.  The order controls the search order for
    * 'all'.  Since the search is for the smallest the order used is low memory
    * then high speed.*/","-5. }  value_list;
-4. static const value_list
-3. #ifdef PNG_SW_COMPRESS_png_level
-2. vl_compression[] =
-1. {
   /* Overall compression control.  The order controls the search order for
    * 'all'.  Since the search is for the smallest the order used ",Useful
/*This controls the order of search.*/,"-4. #if defined(PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED) ||\
-3.     defined(PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED)
-2. vl_strategy[] =
-1. {

 /*This controls the order of search.*/

1.    { ""huffman"", Z_HUFFMAN_ONLY },
2.    { ""RLE"", Z_RLE },",Useful
/*the remainder do window searches*/,"nan


 /*the remainder do window searches*/

nan
",Useful
/*for explicit testing*/,"-3.    { ""2"", 2 },
-2.    { ""3"", 3 },
-1.    { ""4"", 4 },

 /*for explicit testing*/

111",Useful
/*exclude 5 and below: zlib bugs*/,"-4.    { ""2"", 2 },
-3.    { ""3"", 3 },
-2.    { ""4"", 4 },

 /*exclude 5 and below: zlib bugs*/

1.    { all, 0 }
2. },",Useful
"/*stack limit in display, below*/","-2. #  define png_set_IDAT_size(p,v) png_set_compression_buffer_size(p, v)

 /*stack limit in display, below*/

1. vl_log_depth[] = { { ""on"", 1 }, { ""off"", 0 }, RANGE(0, SL) },
2. vl_on_off[] = { { ""on"", 1 }, { ""off"", 0 } };
3. #ifdef PNG_WRITE_CUSTOMIZE_",Useful
/*IDAT compression*/,"-7.    INTERNAL_ERROR
-6. } error_level;

 /*IDAT compression*/

111",Useful
/*length of the list of values:*/,"-5. typedef struct option
-4. {

 /*length of the list of values:*/

111",Useful
/*values for OPTION or LIST*/,"-6. typedef struct option
-5. {

 /*values for OPTION or LIST*/

1. }  option;
2. static const option options[] =
3. {",Useful
"/*struct display options, these are set when the command line is read*/","-3. }  option;
-2. static const option options[] =
-1. {

 /*struct display options, these are set when the command line is read*/

1. #  define S(n,v) { #n, v, 0, 2, vl_on_off },
2.    S(verbose,  VERBOSE)
3.    S(warnings, WARNINGS)
4.    S(errors,   ER",Useful
"/*OPTION settings, these and LIST settings are read on demand*/","-1. #  undef S

 /*OPTION settings, these and LIST settings are read on demand*/

1. #  define VLNAME(name) vl_ ## name
2. #  define VLSIZE(name) voidcast(png_byte,\
3.                            (sizeof VLNAME(name))/(sizeof VLNAME(name)[0]))
4. #  defin",Useful
"/*The libpng compression level isn't searched because it justs sets the
       * other things that are searched!*/","nan


 /*The libpng compression level isn't searched because it justs sets the
       * other things that are searched!*/

nan
",Useful
/*Used on both read and write:*/,"-10.       default:                         return ""INVALID"";
-9.    }
-8. }
-7. struct display
-6. {

 /*Used on both read and write:*/

1.    FILE            *fp;",Useful
"/*Used on a read, both the original read and when validating a written
    * image.*/","-1.    FILE            *fp;
   /* Used on a read, both the original read and when validating a written
    * image.

 /*Used on a read, both the original read and when validating a written
    * image.*/

1.     */
2.    png_alloc_size_t read_size;
3.    ",Useful
/*Used to write a new image (the original info_ptr is used)*/,"-6. #  ifdef PNG_PNGCP_TIMING_SUPPORTED
-5.       struct timespec   read_time;
-4.       struct timespec   read_time_total;
-3.       struct timespec   write_time;
-2.       struct timespec   write_time_total;

 /*Used to write a new image (the original i",Useful
"/*The selected entry+1 of an option
                                          * that appears on the command line, or
                                          * 0 if it was not given.*/","-10.    png_alloc_size_t size;
-9.    png_uint_32      w;
-8.    png_uint_32      h;
-7.    int              bpp;
-6.    png_byte         ct;

 /*The selected entry+1 of an option
                                          * that appears on the command lin",Useful
"/*Temporary variables used only while testing a single collection of
    * settings:*/","-10.    int              no_warnings;       /* Do not output libpng warnings */
-9.    int              min_windowBits;    /* The windowBits range is 8..8 */
-8.    /* Options handling */
-7.    png_uint_32      results;             /* A mask of errors se",Useful
"/*Values used while iterating through all the combinations of settings for a
    * single file:*/","
   /* Values used while iterating through all the combinations of settings for a
    * single file:



 /*Values used while iterating through all the combinations of settings for a
    * single file:*/

1.     */",Useful
"/*Position in buffer for the first
                                        * searched option; non-zero if earlier
                                        * options were set on the command line.*/","
   int              opt_string_start;  /* Position in buffer for the first
                                        * searched option; non-zero if earlier
                                        * options were set on the command line.



 /*Position in buffer for the first
                                        * searched option; non-zero if earlier
                                        * options were set on the command line.*/

1.                                         */
2.    struct stack
3.    {",Useful
/*For binary chop of a range*/,"-2.       png_alloc_size_t lo_size;
-1.       png_alloc_size_t hi_size;

 /*For binary chop of a range*/

111",Useful
/*End of the option string in 'curr'*/,"-4.       png_alloc_size_t lo_size;
-3.       png_alloc_size_t hi_size;

 /*End of the option string in 'curr'*/

111",Useful
"/*Call this only once right at the start to initialize the control
    * structure, the (struct buffer) lists are maintained across calls - the
    * memory is not freed.*/","-10.       png_byte         opt;            /* The option being tested */
-9.       png_byte         entry;          /* The next value entry to be tested */
-8.       png_byte         end;            /* This is the last entry */
-7.    }                st",Useful
"/*This is actually created and used by the write code, but only
       * once; it has to be retained for subsequent writes of the same file.*/","-10.    if (dp->write_pp != NULL)
-9.       png_destroy_write_struct(&dp->write_pp, dp->tsp > 0 ? NULL : &dp->ip);
-8. }
-7. static void
-6. display_clean(struct display *dp)
-5. {
-4.    display_clean_read(dp);
-3.    display_clean_write(dp);
-2.    dp->",Useful
/*reset for next time*/,"-10.        */
-9.       if (dp->text_stashed)
-8.       {
-7.          dp->text_stashed = 0;
-6.          dp->num_text = 0;
-5.          free(dp->text_ptr);
-4.          dp->text_ptr = NULL;
-3.       }

 /*reset for next time*/

1. }
2. static void
3. d",Useful
/*Release any memory held in the display.*/,"-4. }
-3. static void
-2. display_destroy(struct display *dp)
-1. {

 /*Release any memory held in the display.*/

1.    display_clean(dp);
2. }
3. static struct display *
4. get_dp(png_structp pp)",Useful
/*The display pointer is always stored in the png_struct error pointer*/,"-4.    display_clean(dp);
-3. }
-2. static struct display *
-1. get_dp(png_structp pp)

 /*The display pointer is always stored in the png_struct error pointer*/

1. {
2.    struct display *dp = (struct display*)png_get_error_ptr(pp);
3.    if (dp == NULL",Useful
"/*Required to quiet GNUC warnings when the compiler sees a stdarg function
    * that calls one of the stdio v APIs.*/","-2. #ifdef __GNUC__
-1. #  define VGATTR __attribute__((__format__ (__printf__,3,4)))
   /* Required to quiet GNUC warnings when the compiler sees a stdarg function
    * that calls one of the stdio v APIs.

 /*Required to quiet GNUC warnings when the com",Useful
"/*level' is as above, fmt is a stdio style format string.  This routine
    * does not return if level is above LIBPNG_WARNING*/","-5. #else
-4. #  define VGATTR
-3. #endif
-2. static void VGATTR
-1. display_log(struct display *dp, error_level level, const char *fmt, ...)
   /* 'level' is as above, fmt is a stdio style format string.  This routine
    * does not return if level is ab",Useful
/*anything unexpected is an internal error:*/,"-10.       switch (level)
-9.       {
-8.          case INFORMATION:    lp = ""information""; break;
-7.          case LIBPNG_WARNING: lp = ""warning(libpng)""; break;
-6.          case APP_WARNING:    lp = ""warning(pngcp)""; break;
-5.          case APP_FAIL:",Useful
/*else do not output any message*/,"-10.          default:             lp = ""bug(pngcp)""; break;
-9.       }
-8.       fprintf(stderr, ""%s: %s: %s"",
-7.          dp->filename != NULL ? dp->filename : ""<stdin>"", lp, dp->operation);
-6.       fprintf(stderr, "": "");
-5.       va_start(ap, fmt)",Useful
/*Errors cause this routine to exit to the fail code*/,"-10.       }
-9.       fprintf(stderr, ""%s: %s: %s"",
-8.          dp->filename != NULL ? dp->filename : ""<stdin>"", lp, dp->operation);
-7.       fprintf(stderr, "": "");
-6.       va_start(ap, fmt);
-5.       vfprintf(stderr, fmt, ap);
-4.       va_end(ap);",Useful
"/*libpng 1.6 and earlier fixed a bug whereby text chunks were written
    * multiple times by png_write_png; the issue was that png_write_png passed
    * the same png_info to both png_write_info and png_write_end.  Rather than
    * fixing it by recording the information in the png_struct, or by recording
    * where to write the chunks, the fix made was to change the 'compression'
    * field of the chunk to invalid values, rendering the png_info somewhat
    * useless.
    *
    * The only fix for this given that we use the png_info more than once is to
    * make a copy of the text chunks and png_set_text it each time.  This adds a
    * text chunks, so they get replicated, but only the new set gets written
    * each time.  This uses memory like crazy but there is no way to delete the
    * useless chunks from the png_info.
    *
    * To make this slightly more efficient only the top level structure is
    * copied; since the old strings are actually preserved (in 1.6 and earlier)
    * this happens to work.*/","-10.       if (dp->errset)
-9.          longjmp(dp->error_return, level);
-8.       else
-7.          exit(99);
-6.    }
-5. }
-4. #if PNG_LIBPNG_VER < 10700 && defined PNG_TEXT_SUPPORTED
-3. static void
-2. text_stash(struct display *dp)
-1. {
   /* libp",Useful
"/*OPTIONS:
 *
 * The command handles options of the forms:
 *
 *    --option
 *       Turn an option on (Option)
 *    --no-option
 *       Turn an option off (Option)
 *    --option=value
 *       Set an option to a value (Value)
 *    --option=val1,val2,val3
 *       Set an option to a bitmask constructed from the values (List)*/","/* OPTIONS:
 *
 * The command handles options of the forms:
 *
 *    --option
 *       Turn an option on (Option)
 *    --no-option
 *       Turn an option off (Option)
 *    --option=value
 *       Set an option to a value (Value)
 *    --option=val1,val2,val3
 *       Set an option to a bitmask constructed from the values (List)

 /*OPTIONS:
 *
 * The command handles options of the forms:
 *
 *    --option
 *       Turn an option on (Option)
 *    --no-option
 *       Turn an option off (Option)
 *    --option=value
 *       Set an option to a value (Value)
 *    --option=val1,val2,val3
 *       Set an option to a bitmask constructed from the values (List)*/

1.  */
2. static png_byte
3. option_index(struct display *dp, const char *opt, size_t len)",Useful
"/*Return the index (in options[]) of the given option, outputs an error if
    * it does not exist.  Takes the name of the option and a length (number of
    * characters in the name).*/",#NAME?,Useful
"/*If the setjmp buffer is set the code is asking for an option index; this
    * is bad.  Otherwise this is the command line option parsing.*/","-5. {
-4.    png_byte j;
-3.    for (j=0; j<option_count; ++j)
-2.       if (strncmp(options[j].name, opt, len) == 0 && options[j].name[len] == 0)
-1.          return j;
   /* If the setjmp buffer is set the code is asking for an option index; this
    * ",Useful
/*option was set on command line*/,"-5. #define OPTIND(dp, name) option_index(dp, #name, (sizeof #name)-1)
-4. static int
-3. get_option(struct display *dp, const char *opt, int *value)
-2. {
-1.    const png_byte i = option_index(dp, opt, strlen(opt));

 /*option was set on command line*/
",Useful
/*Add the appropriate option string to dp->curr.*/,"-10.    {
-9.       *value = dp->value[i];
-8.       return 1;
-7.    }
-6.    else
-5.       return 0;
-4. }
-3. static int
-2. set_opt_string_(struct display *dp, unsigned int sp, png_byte opt,
-1.       const char *entry_name)

 /*Add the appropriate o",Useful
/*Add the appropriate option string to dp->curr.*/,"-10.    {
-9.       *value = dp->value[i];
-8.       return 1;
-7.    }
-6.    else
-5.       return 0;
-4. }
-3. static int
-2. set_opt_string_(struct display *dp, unsigned int sp, png_byte opt,
-1.       const char *entry_name)

 /*Add the appropriate o",Useful
"/*Record this option in dp->curr; called for an option not being searched,
    * the caller passes in the name of the value, or range_lo to use the
    * numerical value.*/","-6. {
-5.    dp->stack[sp].opt_string_end = set_opt_string_(dp, sp, dp->stack[sp].opt, 
-4.       options[dp->stack[sp].opt].values[dp->stack[sp].entry].name);
-3. }
-2. static void
-1. record_opt(struct display *dp, png_byte opt, const char *entry_name)
",Useful
/*stack entry of next searched option*/,"-1. {

 /*stack entry of next searched option*/

1.    if (sp >= dp->tsp)
2.    {",Useful
"/*At top of stack; add the opt string for this entry to the previous
       * searched entry or the start of the dp->curr buffer if there is nothing
       * on the stack yet (sp == 0).*/","-2.    if (sp >= dp->tsp)
-1.    {
      /* At top of stack; add the opt string for this entry to the previous
       * searched entry or the start of the dp->curr buffer if there is nothing
       * on the stack yet (sp == 0).

 /*At top of stack; add th",Useful
/*else do nothing: option already recorded*/,"-6.       const int offset = set_opt_string_(dp, sp, opt, entry_name);
-5.       if (sp > 0)
-4.          dp->stack[sp-1].opt_string_end = offset;
-3.       else
-2.          dp->opt_string_start = offset;
-1.    }

 /*else do nothing: option already reco",Useful
"/*Push a new option onto the stack, initializing the new stack entry
    * appropriately; this does all the work of next_opt (setting end/nsp) for
    * the first entry in the list.*/","-3. }
-2. static void
-1. push_opt(struct display *dp, unsigned int sp, png_byte opt, int search)
   /* Push a new option onto the stack, initializing the new stack entry
    * appropriately; this does all the work of next_opt (setting end/nsp) for
    * ",Useful
"/*The starting entry is entry 0 unless there is a range in which case it is
    * the entry corresponding to range_lo:*/","-4. {
-3.    png_byte entry;
-2.    const char *entry_name;
-1.    assert(sp == dp->tsp && sp < SL);
   /* The starting entry is entry 0 unless there is a range in which case it is
    * the entry corresponding to range_lo:

 /*The starting entry is entry",Useful
/*check for a mal-formed RANGE above:*/,"-2.    {
-1.       dp->stack[sp].lo = options[opt].values[entry].value;

 /*check for a mal-formed RANGE above:*/

1.       assert(entry+1 < options[opt].value_count &&
2.              options[opt].values[entry+1].name == range_hi);
3.       dp->stack[sp]",Useful
/*next_opt will just iterate over the range.*/,"-6.       assert(entry+1 < options[opt].value_count &&
-5.              options[opt].values[entry+1].name == range_hi);
-4.       dp->stack[sp].hi = options[opt].values[entry+1].value;
-3.    }
-2.    else
-1.    {

 /*next_opt will just iterate over the ",Useful
"/*This works for the search case too; if the range has only one entry 'end'
    * will be marked here.*/","-5.    }
-4.    dp->stack[sp].opt = opt;
-3.    dp->stack[sp].entry = entry;
-2.    dp->stack[sp].best_val = dp->value[opt] = options[opt].values[entry].value;
-1.    set_opt_string(dp, sp);
   /* This works for the search case too; if the range has only ",Useful
"/*Do a lazy cache of the text chunks for libpng 1.6 and earlier; this is
    * because they can only be written once(!) so if we are going to re-use the
    * png_info we need a copy.*/","-10.        */
-9.       if (opt != dp->min_windowBits)
-8.          display_log(dp, APP_WARNING, ""%s: only testing one value"",
-7.                options[opt].name);
-6.    }
-5.    else
-4.    {
-3.       dp->stack[sp].end = 0;
-2.       dp->nsp = dp->t",Useful
"/*Return the next value for this option.  When called 'sp' is expected to be
    * the topmost stack entry - only the topmost entry changes each time round -
    * and there must be a valid entry to return.  next_opt will set dp->nsp to
    * sp+1 if more entries are available, otherwise it will not change it and
    * set dp->stack[s].end to true.*/","-4.    text_stash(dp);
-3. }
-2. static void
-1. next_opt(struct display *dp, unsigned int sp)
   /* Return the next value for this option.  When called 'sp' is expected to be
    * the topmost stack entry - only the topmost entry changes each time round ",Useful
/*dp->stack[sp] must be the top stack entry and it must be active:*/,"-4. {
-3.    int search = 0;
-2.    png_byte entry, opt;
-1.    const char *entry_name;

 /*dp->stack[sp] must be the top stack entry and it must be active:*/

1.    assert(sp+1U == dp->tsp && !dp->stack[sp].end);
2.    opt = dp->stack[sp].opt;
3.    entr",Useful
"/*For ranges increment the value but don't change the entry, for all other
    * cases move to the next entry and load its value:*/","-6.    assert(sp+1U == dp->tsp && !dp->stack[sp].end);
-5.    opt = dp->stack[sp].opt;
-4.    entry = dp->stack[sp].entry;
-3.    assert(entry+1U < options[opt].value_count);
-2.    entry_name = options[opt].values[entry].name;
-1.    assert(entry_name !=",Useful
"/*A range can be iterated over or searched.  The default iteration option
       * is indicated by hi < lo on the stack, otherwise the range being search
       * is [lo..hi] (inclusive).*/","-1.    {
      /* A range can be iterated over or searched.  The default iteration option
       * is indicated by hi < lo on the stack, otherwise the range being search
       * is [lo..hi] (inclusive).

 /*A range can be iterated over or searched.  The ",Useful
/*This is the best size found for this option value:*/,"-4.       if (dp->stack[sp].lo > dp->stack[sp].hi)
-3.          dp->value[opt]++;
-2.       else
-1.       {

 /*This is the best size found for this option value:*/

1.          png_alloc_size_t best_size = dp->stack[sp].best_size;
2.          int lo = d",Useful
/*Finding the best for the low end of the range:*/,"-3.          assert(best_size < MAX_SIZE);
-2.          if (val == lo)
-1.          {

 /*Finding the best for the low end of the range:*/

1.             dp->stack[sp].lo_size = best_size;
2.             assert(hi > val);",Useful
/*else 'end' set above*/,"-6.                dp->stack[sp].end = 1;
-5.             val = hi;
-4.          }
-3.          else if (val == hi)
-2.          {
-1.             dp->stack[sp].hi_size = best_size;

 /*else 'end' set above*/

111",Useful
"/*These cases arise with the 'probe' handling below when there is a
             * dip or peak in the size curve.*/","-1.             assert(lo_size < MAX_SIZE && hi_size < MAX_SIZE);
            /* These cases arise with the 'probe' handling below when there is a
             * dip or peak in the size curve.

 /*These cases arise with the 'probe' handling below when the",Useful
/*probing a new lo*/,"-4.             assert(lo_size < MAX_SIZE && hi_size < MAX_SIZE);

 /*probing a new lo*/

1.             {",Useful
/*probing a new hi*/,"-7.                dp->stack[sp].lo = val;
-6.                dp->stack[sp].lo_size = best_size;
-5.                val = lo;
-4.                best_size = lo_size;
-3.                lo = dp->stack[sp].lo;
-2.                lo_size = dp->stack[sp].lo_s",Useful
"/*Because of the 'probe' code val can either be lo+1 or hi-1; we
                * need to test the other.*/","-2.             if (hi == lo+3)
-1.             {
               /* Because of the 'probe' code val can either be lo+1 or hi-1; we
                * need to test the other.

 /*Because of the 'probe' code val can either be lo+1 or hi-1; we
               ",Useful
"/*There are at least 2 entries still untested between lo and hi,
                * i.e. hi >= lo+4.  'val' is the midpoint +/- 0.5
                *
                * Separate out the four easy cases when lo..val..hi are
                * monotonically decreased or (more weird) increasing:*/","-6.                val = lo + ((val == lo+1) ? 2 : 1);
-5.                assert(lo < val && val < hi);
-4.                dp->stack[sp].end = 1;
-3.             }
-2.             else
-1.             {
               /* There are at least 2 entries still",Useful
"/*Select the low range; testing this first favours the low
                   * range over the high range when everything comes out equal.
                   * Because of the probing 'val' may be lo+1.  In that case end
                   * the search and set 'val' to lo+2.*/","-3.                assert(hi > lo+3);
-2.                if (lo_size <= best_size && best_size <= hi_size)
-1.                {
                  /* Select the low range; testing this first favours the low
                   * range over the high range wh",Useful
"/*Monotonically decreasing size; this is the expected case.
                   * Select the high end of the range.  As above, val may be
                   * hi-1.*/","-10.                   }
-9.                   else
-8.                   {
-7.                      dp->stack[sp].hi = hi = val;
-6.                      dp->stack[sp].hi_size = best_size;
-5.                      val = (lo + val) / 2;
-4.               ",Useful
"/*If both those tests failed 'best_size' is either greater than
                * or less than both lo_size and hi_size.  There is a peak or dip
                * in the curve of sizes from lo to hi and val is on the peak or
                * dip.
                *
                * Because the ranges being searched as so small (level is 1..9,
                * windowBits 8..15, memLevel 1..9) there will only be at most
                * three untested values between lo..val and val..hi, so solve
                * the problem by probing down from hi or up from lo, whichever
                * is the higher.
                *
                * This is the place where 'val' is set to outside the range
                * lo..hi, described as 'probing', though maybe 'narrowing' would
                * be more accurate.*/","-10.                      --val;
-9.                      dp->stack[sp].end = 1;
-8.                   }
-7.                   else
-6.                   {
-5.                      dp->stack[sp].lo = lo = val;
-4.                      dp->stack[sp].lo_siz",Useful
"/*lo and hi are still the true range limits, check for the end
                * condition.*/","-5.                {
-4.                   dp->stack[sp].lo = val;
-3.                   dp->stack[sp].lo_size = best_size;
-2.                   val = ++lo;
-1.                }
               /* lo and hi are still the true range limits, check for the e",Useful
"/*If the best so far is numerically less than the current value the
    * current set of options is invariably worse.*/","-6.       dp->nsp = dp->tsp;
-5. }
-4. static int
-3. compare_option(const struct display *dp, unsigned int sp)
-2. {
-1.    int opt = dp->stack[sp].opt;
   /* If the best so far is numerically less than the current value the
    * current set of options ",Useful
"/*Lists of options are searched out of numerical order (currently only
    * strategy), so only return +1 here when a range is being searched.*/","-2.    if (dp->stack[sp].best_val < dp->value[opt])
-1.       return -1;
   /* Lists of options are searched out of numerical order (currently only
    * strategy), so only return +1 here when a range is being searched.

 /*Lists of options are searched o",Useful
/*match; current value is the best one*/,"-5.          return 1;
-4.       else
-3.          return -1;
-2.    }
-1.    else

 /*match; current value is the best one*/

1. }
2. static int
3. advance_opt(struct display *dp, png_byte opt, int search)
4. {",Useful
"/*If the entry was active in the previous run dp->stack[sp] is already
    * set up and dp->tsp will be greater than sp, otherwise a new entry
    * needs to be created.
    *
    * dp->nsp is handled this way:
    *
    * 1) When an option is pushed onto the stack dp->nsp and dp->tsp are
    *    both set (by push_opt) to the next stack entry *unless* there is
    *    only one entry in the new list, in which case dp->stack[sp].end
    *    is set.
    *
    * 2) For the top stack entry next_opt is called.  The entry must be
    *    active (dp->stack[sp].end is not set) and either 'nsp' or 'end'
    *    will be updated as appropriate.
    *
    * 3) For lower stack entries nsp is set unless the stack entry is
    *    already at the end.  This means that when all the higher entries
    *    are popped this entry will be too.*/","/* If the entry was active in the previous run dp->stack[sp] is already
    * set up and dp->tsp will be greater than sp, otherwise a new entry
    * needs to be created.
    *
    * dp->nsp is handled this way:
    *
    * 1) When an option is pushed onto the stack dp->nsp and dp->tsp are
    *    both set (by push_opt) to the next stack entry *unless* there is
    *    only one entry in the new list, in which case dp->stack[sp].end
    *    is set.
    *
    * 2) For the top stack entry next_opt is called.  The entry must be
    *    active (dp->stack[sp].end is not set) and either 'nsp' or 'end'
    *    will be updated as appropriate.
    *
    * 3) For lower stack entries nsp is set unless the stack entry is
    *    already at the end.  This means that when all the higher entries
    *    are popped this entry will be too.

 /*If the entry was active in the previous run dp->stack[sp] is already
    * set up and dp->tsp will be greater than sp, otherwise a new entry
    * needs to be created.
    *
    * dp->nsp is handled this way:
    *
    * 1) When an option is pushed onto the stack dp->nsp and dp->tsp are
    *    both set (by push_opt) to the next stack entry *unless* there is
    *    only one entry in the new list, in which case dp->stack[sp].end
    *    is set.
    *
    * 2) For the top stack entry next_opt is called.  The entry must be
    *    active (dp->stack[sp].end is not set) and either 'nsp' or 'end'
    *    will be updated as appropriate.
    *
    * 3) For lower stack entries nsp is set unless the stack entry is
    *    already at the end.  This means that when all the higher entries
    *    are popped this entry will be too.*/

1.     */
2.    if (sp >= dp->tsp)
3.    {",Useful
"/*An option that is already on the stack; update best_size and best_val
       * if appropriate.  On the first run there are no previous values and
       * dp->write_size will be MAX_SIZE, however on the first run dp->tsp
       * starts off as 0.*/","/* An option that is already on the stack; update best_size and best_val
       * if appropriate.  On the first run there are no previous values and
       * dp->write_size will be MAX_SIZE, however on the first run dp->tsp
       * starts off as 0.

 /*An option that is already on the stack; update best_size and best_val
       * if appropriate.  On the first run there are no previous values and
       * dp->write_size will be MAX_SIZE, however on the first run dp->tsp
       * starts off as 0.*/

1.        */
2.       assert(dp->write_size > 0U && dp->write_size < MAX_SIZE);
3.       if (dp->stack[sp].best_size > dp->write_size ||
4.           (dp->stack[sp].best_size == dp->write_size &&
5.            compare_option(dp, sp) > 0))
6.       {
7.          dp->stack[sp].best_size = dp->write_size;
8.          dp->stack[sp].best_val = dp->value[opt];
9.       }
10.       if (sp+1U >= dp->tsp)",Useful
"/*Active, not at top of stack*/","-1.       }

 /*Active, not at top of stack*/

1.          dp->nsp = sp+1U;",Useful
"/*Like getop but iterate over all the values if the option was set to ""all"".*/","-4.    }
-3. }
-2. static int
-1. getallopts_(struct display *dp, const png_byte opt, int *value, int record)
   /* Like getop but iterate over all the values if the option was set to ""all"".

 /*Like getop but iterate over all the values if the option was",Useful
/*option was set on command line*/,"-5. #define OPTIND(dp, name) option_index(dp, #name, (sizeof #name)-1)
-4. static int
-3. get_option(struct display *dp, const char *opt, int *value)
-2. {
-1.    const png_byte i = option_index(dp, opt, strlen(opt));

 /*option was set on command line*/
",Useful
"/*Simple, single value, entries don't have a stack frame and have a fixed
       * value (it doesn't change once set on the command line).  Otherwise the
       * value (entry) selected from the command line is 'all':*/","-1.    {
      /* Simple, single value, entries don't have a stack frame and have a fixed
       * value (it doesn't change once set on the command line).  Otherwise the
       * value (entry) selected from the command line is 'all':

 /*Simple, single va",Useful
/*do not search; iterate*/,"-2.       const char *entry_name = options[opt].values[dp->entry[opt]-1].name;
-1.       if (entry_name == all)

 /*do not search; iterate*/

1.       else if (record)
2.          record_opt(dp, opt, entry_name);
3.       *value = dp->value[opt];",Useful
/*As above except that if the option was not set try a search*/,"-8. }
-7. static int
-6. getallopts(struct display *dp, const char *opt_str, int *value)
-5. {
-4.    return getallopts_(dp, option_index(dp, opt_str, strlen(opt_str)), value, 0);
-3. }
-2. static int
-1. getsearchopts(struct display *dp, const char *opt_",Useful
"/*If it was set on the command line honour the setting, including 'all'
    * which will override the built in search:*/","-5. {
-4.    png_byte istrat;
-3.    const png_byte opt = option_index(dp, opt_str, strlen(opt_str));
-2.    int record = options[opt].search;
-1.    const char *entry_name;
   /* If it was set on the command line honour the setting, including 'all'
    *",Useful
/*not a search option*/,"-2.    if (getallopts_(dp, opt, value, record))
-1.       return 1;

 /*not a search option*/

111",Useful
"/*record the value, not the name*/","-1.    istrat = OPTIND(dp, strategy);

 /*record the value, not the name*/

111",Useful
"/*Changing windowBits for strategies that do not search the window is
       * pointless.  Huffman-only does not search, RLE only searches backwards
       * one byte, so given that the maximum string length is 258, a windowBits
       * of 9 is always sufficient.*/","-3.    }
-2.    else if (opt == OPTIND(dp, windowBits))
-1.    {
      /* Changing windowBits for strategies that do not search the window is
       * pointless.  Huffman-only does not search, RLE only searches backwards
       * one byte, so given that t",Useful
"/*Like option_index but sets (index+i) of the entry in options[opt] that
    * matches str[0..len-1] into dp->entry[opt] as well as returning the actual
    * value.*/","-5.    *value = dp->value[opt];
-4.    return 1;
-3. }
-2. static int
-1. find_val(struct display *dp, png_byte opt, const char *str, size_t len)
   /* Like option_index but sets (index+i) of the entry in options[opt] that
    * matches str[0..len-1] into",Useful
"/*So arg[0..i-1] is the argument name, this does not return if this isn't
       * a valid option name.*/","-1.       while (arg[i] != 0 && arg[i] != '=') ++i;
      /* So arg[0..i-1] is the argument name, this does not return if this isn't
       * a valid option name.

 /*So arg[0..i-1] is the argument name, this does not return if this isn't
       * a valid",Useful
/*It matcheth an option; check the remainder.*/,"-1.       j = option_index(dp, arg, i);

 /*It matcheth an option; check the remainder.*/

111",Useful
"/*no specified value, use the default*/","-2.       j = option_index(dp, arg, i);

 /*no specified value, use the default*/

1.       {
2.          val = options[j].values[negate].value;",Useful
"/*Expect a single value here unless this is a list, in which case
          * multiple values are combined.*/","-4.       }
-3.       else
-2.       {
-1.          const char *list = arg + (i+1);
         /* Expect a single value here unless this is a list, in which case
          * multiple values are combined.

 /*Expect a single value here unless this is a list,",Useful
/*find_val sets 'dp->entry[j]' to a non-zero value:*/,"-2.          if (options[j].opt != LIST)
-1.          {

 /*find_val sets 'dp->entry[j]' to a non-zero value:*/

1.             val = find_val(dp, j, list, strlen(list));
2.             if (negate)
3.             {
4.                if (options[j].opt < O",Useful
"/*multiple options separated by ',' characters*/","-3.                }
-2.             }
-1.          }

 /*multiple options separated by ',' characters*/

1.          {",Useful
"/*--no-option negates list values from the default, which should
             * therefore be 'all'.  Notice that if the option list is empty in
             * this case nothing will be removed and therefore --no-option= is
             * the same as --option.*/","-1.          {
            /* --no-option negates list values from the default, which should
             * therefore be 'all'.  Notice that if the option list is empty in
             * this case nothing will be removed and therefore --no-option= is
    ",Useful
"/*A value is terminated by the end of the list or a ','
                * character.*/","-1.             {
               /* A value is terminated by the end of the list or a ','
                * character.

 /*A value is terminated by the end of the list or a ','
                * character.*/

1.                 */
2.                int v,",Useful
/*an index into 'list'*/,"-1.                int v, iv;

 /*an index into 'list'*/

1.                while (list[++iv] != 0 && list[iv] != ',') {}
2.                v = find_val(dp, j, list, iv);
3.                if (negate)
4.                   val &= ~v;
5.                else",Useful
"/*val' is the new value, store it for use later and debugging:*/","-3.             }
-2.          }
-1.       }

 /*val' is the new value, store it for use later and debugging:*/

1.       dp->value[j] = val;
2.       if (options[j].opt < LEVEL_MASK)
3.       {",Useful
/*The handling for error levels is to set the level.*/,"-3.       dp->value[j] = val;
-2.       if (options[j].opt < LEVEL_MASK)
-1.       {

 /*The handling for error levels is to set the level.*/

111",Useful
/*Do the timing using clock_gettime and the per-process timer.*/,"-5. }
-4. #ifdef PNG_PNGCP_TIMING_SUPPORTED
-3. static void
-2. set_timer(struct display *dp, struct timespec *timer)
-1. {

 /*Do the timing using clock_gettime and the per-process timer.*/

1.    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, timer))
2.   ",Useful
"/*The following is used in main to verify that the final argument is a
 * directory:*/","
/* The following is used in main to verify that the final argument is a
 * directory:



 /*The following is used in main to verify that the final argument is a
 * directory:*/

1.  */
2. static int
3. checkdir(const char *pathname)
4. {
5.    struct stat buf;
6.    return stat(pathname, &buf) == 0 && S_ISDIR(buf.st_mode);
7. }
8. /* Work out whether a path is valid (if not a display_log occurs), a directory
9.  * (1 is returned) or a file *or* non-existent (0 is returned).
10.  *",Useful
"/*Work out whether a path is valid (if not a display_log occurs), a directory
 * (1 is returned) or a file *or* non-existent (0 is returned).
 *
 * Used for a write path.*/","-6. static int
-5. checkdir(const char *pathname)
-4. {
-3.    struct stat buf;
-2.    return stat(pathname, &buf) == 0 && S_ISDIR(buf.st_mode);
-1. }
/* Work out whether a path is valid (if not a display_log occurs), a directory
 * (1 is returned) or a f",Useful
/*Else expect an object that exists and can be written:*/,"-3.       {
-2.          if (S_ISDIR(buf.st_mode))
-1.             return 1;

 /*Else expect an object that exists and can be written:*/

1.          if (access(pathname, W_OK) != 0)
2.             display_log(dp, USER_ERROR, ""%s: cannot be written (%s)"",",Useful
/*Make a name for an output file (and check it).*/,"-6.       }
-5.    }
-4. }
-3. static void
-2. makename(struct display *dp, const char *dir, const char *infile)
-1. {

 /*Make a name for an output file (and check it).*/

1.    dp->namebuf[0] = 0;
2.    if (dir == NULL || infile == NULL)
3.       displa",Useful
/*Find the rightmost non-/ character:*/,"-5.          if (infile[istart] == '/')
-4.             display_log(dp, INTERNAL_ERROR, ""infile with trailing /"");
-3.          memcpy(dp->namebuf, dir, dsize);
-2.          if (dsize > 0 && dp->namebuf[dsize-1] != '/')
-1.             dp->namebuf[dsize++",Useful
/*error handler callbacks for libpng*/,"-8.             display_log(dp, USER_ERROR, ""%s%s: output file name too long"",
-7.                   dp->namebuf, infile);
-6.          }
-5.       }
-4.       else
-3.          display_log(dp, USER_ERROR, ""%s: output directory name too long"", dir);
-2.  ",Useful
"/*The png_read_png API requires us to make the info struct, but it does the
    * call to png_read_info.*/","
   /* The png_read_png API requires us to make the info struct, but it does the
    * call to png_read_info.



 /*The png_read_png API requires us to make the info struct, but it does the
    * call to png_read_info.*/

1.     */
2.    dp->ip = png_create_info_struct(dp->read_pp);
3.    if (dp->ip == NULL)
4.       png_error(dp->read_pp, ""failed to create info struct"");",Useful
"/*png_get_rowbytes should never return 0 because the value is set by the
       * first call to png_set_IHDR, which should have happened by now, but just
       * in case:*/","-7.    end_timer(dp, PNGCP_TIME_READ);
-6.    dp->w = png_get_image_width(dp->read_pp, dp->ip);
-5.    dp->h = png_get_image_height(dp->read_pp, dp->ip);
-4.    dp->ct = png_get_color_type(dp->read_pp, dp->ip);
-3.    dp->bpp = png_get_bit_depth(dp->read_",Useful
/*The size calc can overflow.*/,"-3.       png_alloc_size_t rb = png_get_rowbytes(dp->read_pp, dp->ip);
-2.       if (rb == 0)
-1.          png_error(dp->read_pp, ""invalid row byte count from libpng"");

 /*The size calc can overflow.*/

1.       if ((MAX_SIZE-dp->h)/rb < dp->h)
2.       ",Useful
"/*The write fail is classed as a USER_ERROR, so --quiet does not turn it
    * off, this seems more likely to be correct.*/","-10.       }
-9.       if (dp->fp == NULL)
-8.          display_log(dp, USER_ERROR, ""%s: file open failed (%s)"",
-7.                dp->output_file, strerror(errno));
-6.    }
-5. }
-4. static void PNGCBAPI
-3. write_function(png_structp pp, png_bytep dat",Useful
"/*Compression option, 'method' is never set: there is no choice.
 *
 * IMPORTANT: the order of the entries in this macro determines the preference
 * order when two different combos of two of these options produce an IDAT of
 * the same size.  The logic here is to put the things that affect the decoding
 * of the PNG image ahead of those that are relevant only to the encoding.*/","-10.    if (dp->fp == NULL || fwrite(data, size, 1U, dp->fp) == 1U)
-9.    {
-8.       dp->write_size += size;
-7.       if (dp->write_size < size || dp->write_size == MAX_SIZE)
-6.          png_error(pp, ""IDAT size overflow"");
-5.    }
-4.    else
-3.   ",Useful
"/*Restore the text chunks when using libpng 1.6 or less; this is a macro
    * which expands to nothing in 1.7+  In earlier versions it tests
    * dp->text_stashed, which is only set (below) *after* the first write.*/","/* Restore the text chunks when using libpng 1.6 or less; this is a macro
    * which expands to nothing in 1.7+  In earlier versions it tests
    * dp->text_stashed, which is only set (below) *after* the first write.

 /*Restore the text chunks when using libpng 1.6 or less; this is a macro
    * which expands to nothing in 1.7+  In earlier versions it tests
    * dp->text_stashed, which is only set (below) *after* the first write.*/

1.     */
2.    text_restore(dp);
3. #  ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
4.       png_set_keep_unknown_chunks(dp->write_pp, PNG_HANDLE_CHUNK_ALWAYS, NULL,
5.             0);",Useful
"/*compression outputs, IDAT and zTXt/iTXt:*/","-3.       png_set_user_limits(dp->write_pp, 0x7fffffff, 0x7fffffff);
-2. #  endif

 /*compression outputs, IDAT and zTXt/iTXt:*/

1.    dp->tsp = dp->nsp;
2.    dp->nsp = dp->csp = 0;
3. #  ifdef PNG_SW_COMPRESS_png_level
4.       {
5.          int val;",Useful
"/*This sets everything, but then the following options just override
          * the specific settings for ICC profiles and text.*/","-5.    dp->tsp = dp->nsp;
-4.    dp->nsp = dp->csp = 0;
-3. #  ifdef PNG_SW_COMPRESS_png_level
-2.       {
-1.          int val;
         /* This sets everything, but then the following options just override
          * the specific settings for ICC profi",Useful
/*filter handling*/,"-3.       if (get_option(dp, ""IDAT-size"", &val))
-2.          png_set_IDAT_size(dp->write_pp, val);
-1.    }

 /*filter handling*/

1. #  ifdef PNG_WRITE_FILTER_SUPPORTED
2.       {
3.          int val;
4.          if (get_option(dp, ""filter"", &val))
5.  ",Useful
"/*This just uses the 'read' info_struct directly, it contains the image.*/","-7. #  ifdef PNG_WRITE_FILTER_SUPPORTED
-6.       {
-5.          int val;
-4.          if (get_option(dp, ""filter"", &val))
-3.             png_set_filter(dp->write_pp, PNG_FILTER_TYPE_BASE, val);
-2.       }

 /*This just uses the 'read' info_struct direc",Useful
"/*Clean it on the way out - if control returns to the caller then the
    * written_file contains the required data.*/","-8.    if (dp->fp != NULL)
-7.    {
-6.       FILE *fp = dp->fp;
-5.       dp->fp = NULL;
-4.       if (fclose(fp))
-3.          display_log(dp, APP_ERROR, ""%s: write failed (%s)"",
-2.                destname == NULL ? ""stdout"" : destname, strerror(errno)",Useful
"/*windowBits is in the range 8..15 but zlib maps '8' to '9' so it is only
    * worth using if the data size is 256 byte or less.*/","-6.    display_clean_write(dp);
-5.    dp->operation = ""none"";
-4. }
-3. static void
-2. set_windowBits_hi(struct display *dp)
-1. {
   /* windowBits is in the range 8..15 but zlib maps '8' to '9' so it is only
    * worth using if the data size is 256 by",Useful
"/*If wb == 8 then any search has been restricted to just one windowBits
    * entry.  Record that here to avoid producing a spurious app-level warning
    * above.*/","-3.    VLNAME(windowBits_IDAT)[i].value = wb;
-2.    assert(VLNAME(windowBits_IDAT)[--i].name == range_lo);
-1.    VLNAME(windowBits_IDAT)[i].value = wb > 8 ? 9 : 8;
   /* If wb == 8 then any search has been restricted to just one windowBits
    * entry. ",Useful
"/*Are these options better than the best found so far?  Normally the
    * options are tested in preference order, best first, however when doing a
    * search operation on a range the range values are tested out of order.  In
    * that case preferable options will get tested later.
    *
    * This function looks through the stack from the bottom up looking for an
    * option that does not match the current best value.  When it finds one it
    * checks to see if it is more or less desirable and returns true or false
    * as appropriate.
    *
    * Notice that this means that the order options are pushed onto the stack
    * conveys a priority; lower/earlier options are more important than later
    * ones.*/","-6.    if (wb == 8)
-5.       dp->min_windowBits = OPTIND(dp, windowBits);
-4. }
-3. static int
-2. better_options(const struct display *dp)
-1. {
   /* Are these options better than the best found so far?  Normally the
    * options are tested in prefere",Useful
"/*Log, and reset, the search so far:*/","-10.    assert(dp->filename != NULL);
-9.    printf(""%s [%ld x %ld %d bpp %s, %lu bytes] %lu -> %lu with '%s'\n"",
-8.       dp->filename, (unsigned long)dp->w, (unsigned long)dp->h, dp->bpp,
-7.       cts(dp->ct), (unsigned long)dp->size, (unsigned long)d",Useful
/*Read it then write it:*/,"-10.       dp->best_size = MAX_SIZE;
-9.    }
-8. }
-7. static void
-6. cp_one_file(struct display *dp, const char *filename, const char *destname)
-5. {
-4.    unsigned int log_depth;
-3.    dp->filename = filename;
-2.    dp->operation = ""read"";
-1.    ",Useful
/*Limit the upper end of the windowBits range for this file*/,"-1.    dp->operation = ""write"";

 /*Limit the upper end of the windowBits range for this file*/

1.    set_windowBits_hi(dp);",Useful
"/*For logging, depth to log:*/","-1.    set_windowBits_hi(dp);

 /*For logging, depth to log:*/

1.    {
2.       int val;
3.       if (get_option(dp, ""log-depth"", &val) && val >= 0)",Useful
/*Make a temporary name for the subsequent tests:*/,"-2.       log_search(dp, log_depth);
-1.       dp->no_warnings = 1;

 /*Make a temporary name for the subsequent tests:*/

1.       if (destname != NULL)
2.       {
3.          strcpy(tmpbuf, destname);",Useful
/*space for .tmp allocated above*/,"-3.       if (destname != NULL)
-2.       {
-1.          strcpy(tmpbuf, destname);

 /*space for .tmp allocated above*/

1.          tmpname = tmpbuf;
2.       }
3.       else",Useful
"/*And compare the sizes (the write function makes sure write_size
          * doesn't overflow.)*/","-3.       do
-2.       {
-1.          write_png(dp, tmpname);
         /* And compare the sizes (the write function makes sure write_size
          * doesn't overflow.)

 /*And compare the sizes (the write function makes sure write_size
          * doesn'",Useful
/*Do this for the 'sizes' option so that it reports the correct size.*/,"-10.                      destname, strerror(errno));
-9.             strcpy(dp->best, dp->curr);
-8.             dp->best_size = dp->write_size;
-7.          }
-6.          else if (tmpname != NULL && unlink(tmpname) != 0)
-5.             display_log(dp,",Useful
"/*Exists solely to isolate the setjmp clobbers which some versions of GCC
    * erroneously generate.*/","-5.       dp->write_size = dp->best_size;
-4.    }
-3. }
-2. static int
-1. cppng(struct display *dp, const char *file, const char *gv dest)
   /* Exists solely to isolate the setjmp clobbers which some versions of GCC
    * erroneously generate.

 /*Exis",Useful
/*For each file on the command line test it with a range of transforms*/,"-7.          display_log(dp, INTERNAL_ERROR, ""unexpected return code %d"", ret);
-6.       return ret;
-5.    }
-4. }
-3. int
-2. main(const int argc, const char * const * const argv)
-1. {

 /*For each file on the command line test it with a range of tran",Useful
"/*Do a quick check on the directory target case; when there are more than
    * two arguments the last one must be a directory.*/","-9.    int option_end;
-8.    struct display d;
-7.    display_init(&d);
-6.    d.operation = ""options"";
-5.    for (option_end = 1;
-4.         option_end < argc && opt_check(&d, argv[option_end]);
-3.         ++option_end)
-2.    {
-1.    }
   /* Do a q",Useful
/*Do this at least once; if there are no arguments stdin/stdout are used.*/,"-10.    if (!(d.options & NOWRITE) && option_end+2 < argc && !checkdir(argv[argc-1]))
-9.    {
-8.       fprintf(stderr,
-7.             ""pngcp: %s: directory required with more than two arguments\n"",
-6.             argv[argc-1]);
-5.       return 99;
-4",Useful
/*abort on user or internal error*/,"-10.          int ret;
-9.          if (i < argc)
-8.          {
-7.             infile = argv[i++];
-6.             if (!(d.options & NOWRITE) && i < argc)
-5.                outfile = argv[argc-1];
-4.          }
-3.          ret = cppng(&d, infile, out",Useful
/*An error: the output is meaningless*/,"-1.                return 99;

 /*An error: the output is meaningless*/

1.          }
2.          else if (d.best[0] != 0)
3.          {",Useful
"/*This result may already have been output, in which case best_size
             * has been reset.*/","-3.          }
-2.          else if (d.best[0] != 0)
-1.          {
            /* This result may already have been output, in which case best_size
             * has been reset.

 /*This result may already have been output, in which case best_size
     ",Useful
"/*Here on any return, including failures, except user/internal issues*/","-10.                print_search_results(&d);
-9.          }
-8.          else if (d.options & SIZES)
-7.          {
-6.             printf(""%s [%ld x %ld %d bpp %s, %lu bytes] %lu -> %lu [0x%lx]\n"",
-5.                   infile, (unsigned long)d.w, (unsi",Useful
"/*When logging output the files for each file, if enabled.*/","-10.                ++errors;
-9.             if (d.options & LOG)
-8.             {
-7.                int j;
-6.                printf(""%s: pngcp"", pass ? ""PASS"" : ""FAIL"");
-5.                for (j=1; j<option_end; ++j)
-4.                   printf("" %",Useful
"/*I.e. for write cases after the first time through the loop require
          * there to be at least two arguments left and for the last one to be a
          * directory (this was checked above).*/","-7.                printf(""\n"");
-6.                fflush(stdout);
-5.             }
-4.          }
-3.          display_clean(&d);
-2.       }
-1.       while (i+!(d.options & NOWRITE) < argc);
         /* I.e. for write cases after the first time throu",Useful
/*Release allocated memory*/,"-10.                fflush(stdout);
-9.             }
-8.          }
-7.          display_clean(&d);
-6.       }
-5.       while (i+!(d.options & NOWRITE) < argc);

 /*Release allocated memory*/

1.       display_destroy(&d);
2. #     ifdef PNG_PNGCP_TIMI",Useful
/*For the floating point exception extension*/,"-10.  *   This is a C program that is intended to be linked against libpng.  It
-9.  *   generates bitmaps internally, stores them as PNG files (using the
-8.  *   sequential write code) then reads them back (using the sequential
-7.  *   read code) and v",Useful
/*For the floating point exception extension*/,"-10.  *   This is a C program that is intended to be linked against libpng.  It
-9.  *   generates bitmaps internally, stores them as PNG files (using the
-8.  *   sequential write code) then reads them back (using the sequential
-7.  *   read code) and v",Useful
"/*Define the following to use this test against your installed libpng, rather
 * than the one being built here:*/","-10. #endif
-9. #ifndef FE_DIVBYZERO
-8. #  define FE_DIVBYZERO 0
-7. #endif
-6. #ifndef FE_INVALID
-5. #  define FE_INVALID 0
-4. #endif
-3. #ifndef FE_OVERFLOW
-2. #  define FE_OVERFLOW 0
-1. #endif
/* Define the following to use this test against your ",Useful
"/*1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:*/","-1. #endif
/* 1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:

 /*1.6.1 added support for the configure test harness, which uses 77 to indicate
",Useful
/*pngvalid requires write support and one of the fixed or floating point APIs.*/,"-5. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
-4. #  define SKIP 77
-3. #else
-2. #  define SKIP 0
-1. #endif
/* pngvalid requires write support and one of the fixed or floating point APIs.

 /*pngvalid requires write support and one of the fi",Useful
/*These are needed too for the default build:*/,"-10.    (((yIn)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))
-9. #define PNG_COL_FROM_PASS_COL(xIn, pass) \
-8.    (((xIn)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))
-7. #define PNG_PASS_MASK(pass,off) ( \
-6.    ((0x110145AFU>>(((7-(off",Useful
/*RELEASE_BUILD is true for releases and release candidates:*/,"-3. #  define png_const_structp png_structp
-2. #endif
-1. #ifndef RELEASE_BUILD

 /*RELEASE_BUILD is true for releases and release candidates:*/

1. #  define RELEASE_BUILD (PNG_LIBPNG_BUILD_BASE_TYPE >= PNG_LIBPNG_BUILD_RC)
2. #endif
3. #if RELEASE_BUIL",Useful
/*For floating point constants*/,"-2. #   define debugonly(something) something

 /*For floating point constants*/

111",Useful
"/*Unused formal parameter errors are removed using the following macro which is
 * expected to have no bad effects on performance.*/","-9. #define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
-8. #define CHUNK_IHDR CHUNK(73,72,68,82)
-7. #define CHUNK_PLTE CHUNK(80,76,84,69)
-6. #define CHUNK_IDAT CHUNK(73,68,65,84)
-5. #define CHUNK_IEND CHUNK(73,69,78,68)
-4. #define CHUNK_cHRM CH",Useful
"/*This macro returns the number of elements in an array as an (unsigned int),
 * it is necessary to avoid the inability of certain versions of GCC to use
 * the value of a compile-time constant when performing range checks.  It must
 * be passed an array name.*/","-3. #define anon_context(ps) struct exception_context *the_exception_context = \
-2.    &(ps)->exception_context
-1. #define context(ps,fault) anon_context(ps); png_store *fault
/* This macro returns the number of elements in an array as an (unsigned int)",Useful
"/*GCC BUG 66447 (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66447) requires
 * some broken GCC versions to be fixed up to avoid invalid whining about auto
 * variables that are *not* changed within the scope of a setjmp being changed.
 *
 * Feel free to extend the list of broken versions.*/","
 * some broken GCC versions to be fixed up to avoid invalid whining about auto
 * variables that are *not* changed within the scope of a setjmp being changed.
 *
 * Feel free to extend the list of broken versions.



 /*GCC BUG 66447 (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66447) requires
 * some broken GCC versions to be fixed up to avoid invalid whining about auto
 * variables that are *not* changed within the scope of a setjmp being changed.
 *
 * Feel free to extend the list of broken versions.*/

1.  */
2. #define is_gnu(major,minor)\
3.    (defined __GNUC__) && __GNUC__ == (major) && __GNUC_MINOR__ == (minor)
4. #define is_gnu_patch(major,minor,patch)\
5.    is_gnu(major,minor) && __GNUC_PATCHLEVEL__ == 0",Useful
/*For the moment just do it always; all versions of GCC seem to be broken:*/,"-4. #define is_gnu(major,minor)\
-3.    (defined __GNUC__) && __GNUC__ == (major) && __GNUC_MINOR__ == (minor)
-2. #define is_gnu_patch(major,minor,patch)\
-1.    is_gnu(major,minor) && __GNUC_PATCHLEVEL__ == 0

 /*For the moment just do it always; all ve",Useful
"/*Error handling is particularly problematic in production code - error
 * handlers often themselves have bugs which lead to programs that detect
 * minor errors crashing.  The following functions deal with one very
 * common class of errors in error handlers - attempting to format error or
 * warning messages into buffers that are too small.*/","
/* Error handling is particularly problematic in production code - error
 * handlers often themselves have bugs which lead to programs that detect
 * minor errors crashing.  The following functions deal with one very
 * common class of errors in error handlers - attempting to format error or
 * warning messages into buffers that are too small.



 /*Error handling is particularly problematic in production code - error
 * handlers often themselves have bugs which lead to programs that detect
 * minor errors crashing.  The following functions deal with one very
 * common class of errors in error handlers - attempting to format error or
 * warning messages into buffers that are too small.*/

1.  */
2. static size_t safecat(char *buffer, size_t bufsize, size_t pos,
3.    const char *cat)
4. {
5.    while (pos < bufsize && cat != NULL && *cat != 0)
6.       buffer[pos++] = *cat++;
7.    if (pos >= bufsize)
8.       pos = bufsize-1;
9.    buffer[pos] = 0;
10.    return pos;",Useful
/*Convert a double precision value to fixed point.*/,"-10. }
-9. #endif
-8. static const char invalid[] = ""invalid"";
-7. static const char sep[] = "": "";
-6. static const char *colour_types[8] =
-5. {
-4.    ""grayscale"", invalid, ""truecolour"", ""indexed-colour"",
-3.    ""grayscale with alpha"", invalid, ""truecol",Useful
"/*Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick
 * ""Algorithms"") but it comes from the 'feedback taps' table in Horowitz and
 * Hill, ""The Art of Electronics"" (Pseudo-Random Bit Sequences and Noise
 * Generation.)*/","
/* Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick
 * ""Algorithms"") but it comes from the 'feedback taps' table in Horowitz and
 * Hill, ""The Art of Electronics"" (Pseudo-Random Bit Sequences and Noise
 * Generation.)



 /*Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick
 * ""Algorithms"") but it comes from the 'feedback taps' table in Horowitz and
 * Hill, ""The Art of Electronics"" (Pseudo-Random Bit Sequences and Noise
 * Generation.)*/

1.  */
2. static void
3. make_random_bytes(png_uint_32* seed, void* pv, size_t size)
4. {
5.    png_uint_32 u0 = seed[0], u1 = seed[1];
6.    png_bytep bytes = voidcast(png_bytep, pv);",Useful
"/*There are thirty three bits, the next bit in the sequence is bit-33 XOR
    * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.*/","-10.  * architecture.  It's a linear congruential generator (Knuth or Sedgewick
-9.  * ""Algorithms"") but it comes from the 'feedback taps' table in Horowitz and
-8.  * Hill, ""The Art of Electronics"" (Pseudo-Random Bit Sequences and Noise
-7.  * Generation",Useful
/*First generate 8 new bits then shift them in at the end.*/,"-3.    size_t i;
-2.    for (i=0; i<size; ++i)
-1.    {

 /*First generate 8 new bits then shift them in at the end.*/

1.       png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;
2.       u1 <<= 8;
3.       u1 |= u0 >> 24;
4.       u",Useful
/*READ_FILLER || READ_RGB_TO_GRAY*/,"-10. }
-9. #if defined PNG_READ_RGB_TO_GRAY_SUPPORTED ||\
-8.     defined PNG_READ_FILLER_SUPPORTED
-7. static png_uint_32
-6. random_u32(void)
-5. {
-4.    unsigned char b4[4];
-3.    randomize(b4, sizeof b4);
-2.    return png_get_uint_32(b4);
-1. }

 /",Useful
/*READ_RGB_TO_GRAY || READ_FILLER*/,"-7. #if (defined PNG_READ_RGB_TO_GRAY_SUPPORTED) ||\
-6.     (defined PNG_READ_FILLER_SUPPORTED)
-5. static int
-4. random_choice(void)
-3. {
-2.    return random_byte() & 1;
-1. }

 /*READ_RGB_TO_GRAY || READ_FILLER*/

111",Useful
"/*A numeric ID based on PNG file characteristics.  The 'do_interlace' field
 * simply records whether pngvalid did the interlace itself or whether it
 * was done by libpng.  Width and height must be less than 256.  'palette' is an
 * index of the palette to use for formats with a palette otherwise a boolean
 * indicating if a tRNS chunk was generated.*/","/* A numeric ID based on PNG file characteristics.  The 'do_interlace' field
 * simply records whether pngvalid did the interlace itself or whether it
 * was done by libpng.  Width and height must be less than 256.  'palette' is an
 * index of the palette to use for formats with a palette otherwise a boolean
 * indicating if a tRNS chunk was generated.

 /*A numeric ID based on PNG file characteristics.  The 'do_interlace' field
 * simply records whether pngvalid did the interlace itself or whether it
 * was done by libpng.  Width and height must be less than 256.  'palette' is an
 * index of the palette to use for formats with a palette otherwise a boolean
 * indicating if a tRNS chunk was generated.*/

1.  */
2. #define FILEID(col, depth, palette, interlace, width, height, do_interlace) \
3.    ((png_uint_32)((col) + ((depth)<<3) + ((palette)<<8) + ((interlace)<<13) + \
4.     (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))
5. #define COL_FROM_ID(id) ((png_byte)((id)& 0x7U))
6. #define DEPTH_FROM_ID(id) ((png_byte)(((id) >> 3) & 0x1fU))
7. #define PALETTE_FROM_ID(id) (((id) >> 8) & 0x1f)
8. #define INTERLACE_FROM_ID(id) ((png_byte)(((id) >> 13) & 0x3))
9. #define DO_INTERLACE_FROM_ID(id) ((int)(((id)>>15) & 1))
10. #define WIDTH_FROM_ID(id) (((id)>>16) & 0xff)",Useful
/*Utility to construct a standard name for a standard image.*/,"-10. #define FILEID(col, depth, palette, interlace, width, height, do_interlace) \
-9.    ((png_uint_32)((col) + ((depth)<<3) + ((palette)<<8) + ((interlace)<<13) + \
-8.     (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))
-7. #define COL_FRO",Useful
"/*Convenience API and defines to list valid formats.  Note that 16 bit read and
 * write support is required to do 16 bit read tests (we must be able to make a
 * 16 bit image to test!)*/","-10.    }
-9.    return pos;
-8. }
-7. static size_t
-6. standard_name_from_id(char *buffer, size_t bufsize, size_t pos, png_uint_32 id)
-5. {
-4.    return standard_name(buffer, bufsize, pos, COL_FROM_ID(id),
-3.       DEPTH_FROM_ID(id), PALETTE_FROM_ID(",Useful
"/*The following defines the number of different palettes to generate for
 * each log bit depth of a colour type 3 standard image.*/","-10. #  ifdef PNG_READ_16BIT_SUPPORTED
-9. #     define READ_BDHI 4
-8. #     define DO_16BIT
-7. #  endif
-6. #else
-5. #  define WRITE_BDHI 3
-4. #endif
-3. #ifndef DO_16BIT
-2. #  define READ_BDHI 3
-1. #endif
/* The following defines the number of dif",Useful
/*no alpha channel*/,"-10.    if (*bit_depth == 0)
-9.    {
-8.       *colour_type = 0;
-7.       if (low_depth_gray)
-6.          *bit_depth = 1;
-5.       else
-4.          *bit_depth = 8;
-3.       *palette_number = 0;
-2.       return 1;
-1.    }

 /*no alpha channel*/

11",Useful
"/*Add multiple palettes for colour type 3, one image with tRNS
       * and one without for other non-alpha formats:*/","-1.    {
      /* Add multiple palettes for colour type 3, one image with tRNS
       * and one without for other non-alpha formats:

 /*Add multiple palettes for colour type 3, one image with tRNS
       * and one without for other non-alpha formats:*/

",Useful
/*No: next bit depth*/,"-1.          return 1;

 /*No: next bit depth*/

1.       *palette_number = 0;
2.    }
3.    *bit_depth = (png_byte)(*bit_depth << 1);",Useful
/*Palette images are restricted to 8 bit depth*/,"-3.       *palette_number = 0;
-2.    }
-1.    *bit_depth = (png_byte)(*bit_depth << 1);

 /*Palette images are restricted to 8 bit depth*/

1.    if (*bit_depth <= 8
2. #ifdef DO_16BIT
3.          || (*colour_type != 3 && *bit_depth <= 16)
4. #endif
5.  ",Useful
"/*Move to the next color type, or return 0 at the end.*/","-6.    if (*bit_depth <= 8
-5. #ifdef DO_16BIT
-4.          || (*colour_type != 3 && *bit_depth <= 16)
-3. #endif
-2.       )
-1.       return 1;

 /*Move to the next color type, or return 0 at the end.*/

1.    switch (*colour_type)
2.    {
3.       case",Useful
/*Find a sample index for the desired sample:*/,"-10.       default:
-9.          return 0;
-8.    }
-7. }
-6. #ifdef PNG_READ_TRANSFORMS_SUPPORTED
-5. static unsigned int
-4. sample(png_const_bytep row, png_byte colour_type, png_byte bit_depth,
-3.     png_uint_32 x, unsigned int sample_index, int swap",Useful
/*Alpha channel*/,"-4.    {
-3.       if (colour_type & 2)
-2.          bit_index *= 3;
-1.       if (colour_type & 4)

 /*Alpha channel*/

111",Useful
/*Return the sample from the row as an integer.*/,"-3.       if (colour_type & (2+4))
-2.          bit_index += sample_index * bit_depth;
-1.    }

 /*Return the sample from the row as an integer.*/

1.    row += bit_index >> 3;
2.    result = *row;
3.    if (bit_depth == 8)
4.       return result;
5.    ",Useful
"/*Less than 8 bits per sample.  By default PNG has the big end of
    * the egg on the left of the screen, but if littleendian is set
    * then the big end is on the right.*/","-10.    result = *row;
-9.    if (bit_depth == 8)
-8.       return result;
-7.    else if (bit_depth > 8)
-6.    {
-5.       if (swap16)
-4.          return (*++row << 8) + result;
-3.       else
-2.          return (result << 8) + *++row;
-1.    }
   /* ",Useful
"/*Copy a single pixel, of a given size, from one buffer to another -
 * while this is basically bit addressed there is an implicit assumption
 * that pixels 8 or more bits in size are byte aligned and that pixels
 * do not otherwise cross byte boundaries.  (This is, so far as I know,
 * universally true in bitmap computer graphics.  [JCB 20101212])
 *
 * NOTE: The to and from buffers may be the same.*/","/* Copy a single pixel, of a given size, from one buffer to another -
 * while this is basically bit addressed there is an implicit assumption
 * that pixels 8 or more bits in size are byte aligned and that pixels
 * do not otherwise cross byte boundaries.  (This is, so far as I know,
 * universally true in bitmap computer graphics.  [JCB 20101212])
 *
 * NOTE: The to and from buffers may be the same.

 /*Copy a single pixel, of a given size, from one buffer to another -
 * while this is basically bit addressed there is an implicit assumption
 * that pixels 8 or more bits in size are byte aligned and that pixels
 * do not otherwise cross byte boundaries.  (This is, so far as I know,
 * universally true in bitmap computer graphics.  [JCB 20101212])
 *
 * NOTE: The to and from buffers may be the same.*/

1.  */
2. static void
3. pixel_copy(png_bytep toBuffer, png_uint_32 toIndex,
4.    png_const_bytep fromBuffer, png_uint_32 fromIndex, unsigned int pixelSize,
5.    int littleendian)
6. {",Useful
"/*Assume we can multiply by 'size' without overflow because we are
    * just working in a single buffer.*/","-10.  * do not otherwise cross byte boundaries.  (This is, so far as I know,
-9.  * universally true in bitmap computer graphics.  [JCB 20101212])
-8.  *
-7.  * NOTE: The to and from buffers may be the same.
-6.  */
-5. static void
-4. pixel_copy(png_byte",Useful
/*Mask to select the location of the copied pixel:*/,"-1.    {

 /*Mask to select the location of the copied pixel:*/

1.       unsigned int destMask = ((1U<<pixelSize)-1) <<
2.          (littleendian ? toIndex&7 : 8-pixelSize-(toIndex&7));",Useful
"/*Copy a complete row of pixels, taking into account potential partial
 * bytes at the end.*/","-3.       memmove(toBuffer+(toIndex>>3), fromBuffer+(fromIndex>>3), pixelSize>>3);
-2. }
-1. #ifdef PNG_READ_SUPPORTED
/* Copy a complete row of pixels, taking into account potential partial
 * bytes at the end.

 /*Copy a complete row of pixels, taking i",Useful
"/*Compare pixels - they are assumed to start at the first byte in the
 * given buffers.*/","-10.       unsigned int mask;
-9.       toBuffer += bitWidth >> 3;
-8.       fromBuffer += bitWidth >> 3;
-7.       if (littleendian)
-6.          mask = 0xff << (bitWidth & 7);
-5.       else
-4.          mask = 0xff >> (bitWidth & 7);
-3.       *toBuffe",Useful
"/*There are, but they may not be significant, remove the bits
       * after the end (the low order bits in PNG.)*/","-3.       p = pa[bit_width >> 3];
-2.       p ^= pb[bit_width >> 3];
-1.       if (p == 0) return 0;
      /* There are, but they may not be significant, remove the bits
       * after the end (the low order bits in PNG.)

 /*There are, but they may not b",Useful
"/*From libpng-1.5.6 the overwrite should be fixed, so compare the trailing
    * bits too:*/","-5.       bit_width &= 7;
-4.       p >>= 8-bit_width;
-3.       if (p == 0) return 0;
-2.    }
-1. #else
   /* From libpng-1.5.6 the overwrite should be fixed, so compare the trailing
    * bits too:

 /*From libpng-1.5.6 the overwrite should be fixed, s",Useful
/*Return the index of the changed byte.*/,"-3.    if (memcmp(pa, pb, (bit_width+7)>>3) == 0)
-2.       return 0;
-1. #endif

 /*Return the index of the changed byte.*/

1.    {
2.       png_uint_32 where = 0;
3.       while (pa[where] == pb[where]) ++where;
4.       return 1+where;
5.    }
6. }",Useful
"/*A png_store takes data from the sequential writer or provides data
 * to the sequential reader.  It can also store the result of a PNG
 * write for later retrieval.*/","
/* A png_store takes data from the sequential writer or provides data
 * to the sequential reader.  It can also store the result of a PNG
 * write for later retrieval.



 /*A png_store takes data from the sequential writer or provides data
 * to the sequential reader.  It can also store the result of a PNG
 * write for later retrieval.*/

1.  */",Useful
/*NOTE: stored in reverse order*/,"-2. typedef struct png_store_buffer
-1. {

 /*NOTE: stored in reverse order*/

1.    png_byte                  buffer[STORE_BUFFER_SIZE];
2. } png_store_buffer;
3. #define FILE_NAME_SIZE 64",Useful
/*Number of bits in IDAT size*/,"-1.    char                    name[FILE_NAME_SIZE];

 /*Number of bits in IDAT size*/

111",Useful
/*Total size of IDAT data*/,"-2.    char                    name[FILE_NAME_SIZE];

 /*Total size of IDAT data*/

111",Useful
"/*The following is a pool of memory allocated by a single libpng read or write
 * operation.*/","-9.    char                    name[FILE_NAME_SIZE];

 /*The following is a pool of memory allocated by a single libpng read or write
 * operation.*/

1.  */
2. typedef struct store_pool
3. {",Useful
/*Back pointer*/,"-2. typedef struct store_pool
-1. {

 /*Back pointer*/

111",Useful
/*List of allocated memory*/,"-3. typedef struct store_pool
-2. {

 /*List of allocated memory*/

111",Useful
/*Maximum single allocation*/,"-6. typedef struct store_pool
-5. {

 /*Maximum single allocation*/

111",Useful
"/*For cexcept.h exception handling - simply store one of these;
    * the context is a self pointer but it may point to a different
    * png_store (in fact it never does in this program.)*/","-6.    png_alloc_size_t     max_max;
-5.    png_alloc_size_t     max_limit;
-4.    png_alloc_size_t     max_total;
-3. } store_pool;
-2. typedef struct png_store
-1. {
   /* For cexcept.h exception handling - simply store one of these;
    * the context i",Useful
"/*option number, 0..30*/","-1.    struct {

 /*option number, 0..30*/

111",Useful
/*Type of chunk (valid if chunkpos >= 4)*/,"-3.    char               error[256];

 /*Type of chunk (valid if chunkpos >= 4)*/

111",Useful
/*Buffer for reading interlaced images*/,"-4.    png_infop          piread;

 /*Buffer for reading interlaced images*/

111",Useful
/*Size of this buffer*/,"-5.    png_infop          piread;

 /*Size of this buffer*/

111",Useful
"/*Use this for random 32 bit values; this function makes sure the result is
 * non-zero.*/","-7. static void
-6. store_pool_mark(png_bytep mark)
-5. {
-4.    static png_uint_32 store_seed[2] = { 0x12345678, 1};
-3.    make_four_random_bytes(store_seed, mark);
-2. }
-1. #ifdef PNG_READ_TRANSFORMS_SUPPORTED
/* Use this for random 32 bit values; thi",Useful
/*Return the number of bits in 'num'*/,"-10.          (*ppf)->palette = NULL;
-9.          (*ppf)->npalette = 0;
-8.       }
-7.       free(*ppf);
-6.       *ppf = NULL;
-5.    }
-4. }
-3. static unsigned int
-2. bits_of(png_uint_32 num)
-1. {

 /*Return the number of bits in 'num'*/

1.    uns",Useful
"/*Main interface to file storage, after writing a new PNG file (see the API
 * below) call store_storefile to store the result with the given name and id.*/","nan


 /*Main interface to file storage, after writing a new PNG file (see the API
 * below) call store_storefile to store the result with the given name and id.*/

nan
",Useful
/*Generate an error message (in the given buffer)*/,"-3.    pf->next = ps->saved;
-2.    ps->saved = pf;
-1. }

 /*Generate an error message (in the given buffer)*/

1. static size_t
2. store_message(png_store *ps, png_const_structp pp, char *buffer, size_t bufsize,
3.    size_t pos, const char *msg)
4. {
5",Useful
/*Neither reading nor writing (or a memory error in struct delete)*/,"-6.       pos = safecat(buffer, bufsize, pos, ""write: "");
-5.       pos = safecat(buffer, bufsize, pos, ps->wname);
-4.       pos = safecat(buffer, bufsize, pos, sep);
-3.    }
-2.    else
-1.    {

 /*Neither reading nor writing (or a memory error in str",Useful
/*Verbose output to the error stream:*/,"-10.       pos = safecat(buffer, bufsize, pos, ""pngvalid: "");
-9.    }
-8.    if (ps->test[0] != 0)
-7.    {
-6.       pos = safecat(buffer, bufsize, pos, ps->test);
-5.       pos = safecat(buffer, bufsize, pos, sep);
-4.    }
-3.    pos = safecat(buffer,",Useful
/*Log an error or warning - the relevant count is always incremented.*/,"-10. store_verbose(png_store *ps, png_const_structp pp, png_const_charp prefix,
-9.    png_const_charp message)
-8. {
-7.    char buffer[512];
-6.    if (prefix)
-5.       fputs(prefix, stderr);
-4.    (void)store_message(ps, pp, buffer, sizeof buffer, 0,",Useful
"/*The warning is copied to the error buffer if there are no errors and it is
    * the first warning.  The error is copied to the error buffer if it is the
    * first error (overwriting any prior warnings).*/","-4. static void
-3. store_log(png_store* ps, png_const_structp pp, png_const_charp message,
-2.    int is_error)
-1. {
   /* The warning is copied to the error buffer if there are no errors and it is
    * the first warning.  The error is copied to the er",Useful
"/*Internal error function, called with a png_store but no libpng stuff.*/","-10.     * the first warning.  The error is copied to the error buffer if it is the
-9.     * first error (overwriting any prior warnings).
-8.     */
-7.    if (is_error ? (ps->nerrors)++ == 0 :
-6.        (ps->nwarnings)++ == 0 && ps->nerrors == 0)
-5. ",Useful
"/*These somewhat odd functions are used when reading an image to ensure that
 * the buffer is big enough, the png_structp is for errors.*/","-3.    else
-2.       ps->saw_warning = 1;
-1. }
/* These somewhat odd functions are used when reading an image to ensure that
 * the buffer is big enough, the png_structp is for errors.

 /*These somewhat odd functions are used when reading an image to e",Useful
/*Return a single row from the correct image.*/,"-6.    else
-5.       ps->saw_warning = 1;
-4. }

 /*Return a single row from the correct image.*/

1. static png_bytep
2. store_image_row(const png_store* ps, png_const_structp pp, int nImage,
3.    png_uint_32 y)
4. {
5.    png_size_t coffset = (nImage ",Useful
/*Called from the startup - ignore the error for the moment.*/,"-3.       image = voidcast(png_bytep, malloc(cb+2));
-2.       if (image == NULL)
-1.       {

 /*Called from the startup - ignore the error for the moment.*/

1.          if (pp == NULL)
2.             return;
3.          png_error(pp, ""OOM allocating im",Useful
"/*We have an adequate sized image; lay out the rows.  There are 2 bytes at
    * the start and three at the end of each (this ensures that the row
    * alignment starts out odd - 2+1 and changes for larger images on each row.)*/","-6.       ++image;
-5.       image[-1] = 0xed;
-4.       image[cb] = 0xfe;
-3.       ps->image = image;
-2.       ps->cb_image = cb;
-1.    }
   /* We have an adequate sized image; lay out the rows.  There are 2 bytes at
    * the start and three at the e",Useful
"/*For error checking, the whole buffer is set to 10110010 (0xb2 - 178).
    * This deliberately doesn't match the bits in the size test image which are
    * outside the image; these are set to 0xff (all 1).  To make the row
    * comparison work in the 'size' test case the size rows are pre-initialized
    * to the same value prior to calling 'standard_row'.*/","-2.    ps->cb_row = cbRow;
-1.    ps->image_h = cRows;
   /* For error checking, the whole buffer is set to 10110010 (0xb2 - 178).
    * This deliberately doesn't match the bits in the size test image which are
    * outside the image; these are set to 0x",Useful
/*skip image first row markers*/,"-10. store_image_check(const png_store* ps, png_const_structp pp, int iImage)
-9. {
-8.    png_const_bytep image = ps->image;
-7.    if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)
-6.       png_error(pp, ""image overwrite"");
-5.    else
-4.    {
-3.",Useful
"/*Each byte in the chunk type must be in one of the ranges 65..90, 97..122
    * (both inclusive), so:*/","-3. static int
-2. valid_chunktype(png_uint_32 chunktype)
-1. {
   /* Each byte in the chunk type must be in one of the ranges 65..90, 97..122
    * (both inclusive), so:

 /*Each byte in the chunk type must be in one of the ranges 65..90, 97..122
    * (",Useful
"/*Technically this is legal, but in practice libpng never writes more than
    * the maximum chunk size at once so if it happens something weird has
    * changed inside libpng (probably).*/","-10. store_write(png_structp ppIn, png_bytep pb, png_size_t st)
-9. {
-8.    png_const_structp pp = ppIn;
-7.    png_store *ps = voidcast(png_store*, png_get_io_ptr(pp));
-6.    size_t writepos = ps->writepos;
-5.    png_uint_32 chunkpos = ps->chunkpos;
-",Useful
"/*Now process the bytes to be written.  Do this in units of the space in the
    * output (write) buffer or, at the start 4 bytes for the chunk type and
    * length limited in any case by the amount of data.*/","-2.    if (st > 0x7fffffffU)
-1.       png_error(pp, ""unexpected write size"");
   /* Now process the bytes to be written.  Do this in units of the space in the
    * output (write) buffer or, at the start 4 bytes for the chunk type and
    * length limite",Useful
/*bytes left in chunk*/,"-4.       {
-3.          png_size_t cb = st;
-2.          if (cb > STORE_BUFFER_SIZE - writepos)
-1.             cb = STORE_BUFFER_SIZE - writepos;

 /*bytes left in chunk*/

111",Useful
/*Return the bytes available for read in the current buffer.*/,"-5. }
-4. #ifdef PNG_READ_SUPPORTED
-3. static size_t
-2. store_read_buffer_size(png_store *ps)
-1. {

 /*Return the bytes available for read in the current buffer.*/

1.    if (ps->next != &ps->current->data)
2.       return STORE_BUFFER_SIZE;
3.    retu",Useful
/*Return total bytes available for read.*/,"-4.    if (ps->next != &ps->current->data)
-3.       return STORE_BUFFER_SIZE;
-2.    return ps->current->datacount;
-1. }

 /*Return total bytes available for read.*/

1. static size_t
2. store_read_buffer_avail(png_store *ps)
3. {
4.    if (ps->current ",Useful
"/*Need separate implementation and callback to allow use of the same code
 * during progressive read, where the io_ptr is set internally by libpng.*/","-1. }
/* Need separate implementation and callback to allow use of the same code
 * during progressive read, where the io_ptr is set internally by libpng.

 /*Need separate implementation and callback to allow use of the same code
 * during progressive re",Useful
/*Read the header of the next chunk:*/,"-2.       {
-1.          png_byte buffer[8];

 /*Read the header of the next chunk:*/

1.          store_read_imp(ps, buffer, 8U);
2.          chunklen = png_get_uint_32(buffer) + 12U;
3.          chunktype = png_get_uint_32(buffer+4U);",Useful
"/*Make a new IDAT chunk, if IDAT_len is 0 this is the first IDAT,
             * if IDAT_size is 0 this is the end.  At present this is set up
             * using a random number so that there is a 25% chance before
             * the start of the first IDAT chunk being 0 length.*/","-5.          if (chunkpos < 8U)
-4.             chunkpos = 8U;
-3.          if (IDAT_pos == IDAT_len)
-2.          {
-1.             png_byte random = random_byte();
            /* Make a new IDAT chunk, if IDAT_len is 0 this is the first IDAT,
          ",Useful
"/*The only option here is to add a zero length IDAT, this
                * happens 25% of the time.  Because of the check above
                * chunklen-4U-chunkpos must be zero, we just need to skip the
                * CRC now.*/","-2.                if (chunkpos != chunklen-4U)
-1.                   png_error(ps->pread, ""internal: IDAT size mismatch"");
               /* The only option here is to add a zero length IDAT, this
                * happens 25% of the time.  Because of th",Useful
/*Output another 0 length IDAT*/,"-1.                if ((random & 3U) == 0U)

 /*Output another 0 length IDAT*/

1.                else
2.                {",Useful
"/*End of IDATs, skip the CRC to make the code above load the
                   * next chunk header next time round.*/","-2.                else
-1.                {
                  /* End of IDATs, skip the CRC to make the code above load the
                   * next chunk header next time round.

 /*End of IDATs, skip the CRC to make the code above load the
           ",Useful
"/*Middle of IDATs, use 'random' to determine the number of bits
                * to use in the IDAT length.*/","-4.                }
-3.             }
-2.             else
-1.             {
               /* Middle of IDATs, use 'random' to determine the number of bits
                * to use in the IDAT length.

 /*Middle of IDATs, use 'random' to determine the n",Useful
"/*If there is still some pending IDAT data after the IDAT chunks have
          * been processed there is a problem:*/","-1.       {
         /* If there is still some pending IDAT data after the IDAT chunks have
          * been processed there is a problem:

 /*If there is still some pending IDAT data after the IDAT chunks have
          * been processed there is a proble",Useful
"/*Return chunk bytes, including the CRC*/","-10.                b = chunklen - 12U;
-9.             else
-8.                b = chunktype;
-7.             shift = 3U & chunkpos;
-6.             ++chunkpos;
-5.             if (shift < 3U)
-4.                b >>= 8U*(3U-shift);
-3.             *pb++",Useful
"/*Check for end of chunk and end-of-file; don't try to read a new
             * chunk header at this point unless instructed to do so by 'min'.*/","
            /* Check for end of chunk and end-of-file; don't try to read a new
             * chunk header at this point unless instructed to do so by 'min'.



 /*Check for end of chunk and end-of-file; don't try to read a new
             * chunk header at this point unless instructed to do so by 'min'.*/

1.              */
2.             if (chunkpos >= chunklen && max-st >= min &&
3.                      store_read_buffer_avail(ps) == 0)
4.                break;
5.          }",Useful
"/*This is another Horowitz and Hill random noise generator.  In this case
    * the aim is to stress the progressive reader with truly horrible variable
    * buffer sizes in the range 1..500, so a sequence of 9 bit random numbers
    * is generated.  We could probably just count from 1 to 32767 and get as
    * good a result.*/","-10.    png_store *ps = voidcast(png_store*, png_get_io_ptr(pp));
-9.    if (ps == NULL || ps->pread != pp)
-8.       png_error(pp, ""bad store read call"");
-7.    store_read_chunk(ps, pb, st, st);
-6. }
-5. static void
-4. store_progressive_read(png_store",Useful
/*This function can only return NULL if called with '0'!*/,"-7. static store_palette_entry *
-6. store_write_palette(png_store *ps, int npalette)
-5. {
-4.    if (ps->pwrite == NULL)
-3.       store_log(ps, NULL, ""attempt to write palette without write stream"", 1);
-2.    if (ps->palette != NULL)
-1.       png_err",Useful
"/*This is an internal error (the call has been made outside a read
    * operation.)*/","-10.       if (ps->palette == NULL)
-9.          png_error(ps->pwrite, ""store new palette: OOM"");
-8.       ps->npalette = npalette;
-7.    }
-6.    return ps->palette;
-5. }
-4. #ifdef PNG_READ_SUPPORTED
-3. static store_palette_entry *
-2. store_current",Useful
/*The result may be null if there is no palette.*/,"-5.    if (ps->current == NULL)
-4.    {
-3.       store_log(ps, ps->pread, ""no current stream for palette"", 1);
-2.       return NULL;
-1.    }

 /*The result may be null if there is no palette.*/

1.    *npalette = ps->current->npalette;
2.    return ps",Useful
"/*A store_memory is simply the header for an allocated block of memory.  The
 * pointer returned to libpng is just after the end of the header block, the
 * allocated memory is followed by a second copy of the 'mark'.*/","-1. #ifdef PNG_USER_MEM_SUPPORTED
/* A store_memory is simply the header for an allocated block of memory.  The
 * pointer returned to libpng is just after the end of the header block, the
 * allocated memory is followed by a second copy of the 'mark'.

 ",Useful
/*Singly linked list*/,"-3. typedef struct store_memory
-2. {

 /*Singly linked list*/

111",Useful
/*Size of memory allocated*/,"-4. typedef struct store_memory
-3. {

 /*Size of memory allocated*/

111",Useful
"/*Handle a fatal error in memory allocation.  This calls png_error if the
 * libpng struct is non-NULL, else it outputs a message and returns.  This means
 * that a memory problem while libpng is running will abort (png_error) the
 * handling of particular file while one in cleanup (after the destroy of the
 * struct has returned) will simply keep going and free (or attempt to free)
 * all the memory.*/","-1. } store_memory;
/* Handle a fatal error in memory allocation.  This calls png_error if the
 * libpng struct is non-NULL, else it outputs a message and returns.  This means
 * that a memory problem while libpng is running will abort (png_error) the
 * ",Useful
"/*Else we have to do it ourselves.  png_error eventually calls store_log,
    * above.  store_log accepts a NULL png_structp - it just changes what gets
    * output by store_message.*/","-10.  * that a memory problem while libpng is running will abort (png_error) the
-9.  * handling of particular file while one in cleanup (after the destroy of the
-8.  * struct has returned) will simply keep going and free (or attempt to free)
-7.  * all ",Useful
"/*Note that pp may be NULL (see store_pool_delete below), the caller has
    * found 'memory' in pool->list *and* unlinked this entry, so this is a valid
    * pointer (for sure), but the contents may have been trashed.*/","-4. }
-3. static void
-2. store_memory_free(png_const_structp pp, store_pool *pool, store_memory *memory)
-1. {
   /* Note that pp may be NULL (see store_pool_delete below), the caller has
    * found 'memory' in pool->list *and* unlinked this entry, so t",Useful
"/*The NULL means this will always return, even if the memory is
          * corrupted.*/","-10.          pool == &ps->read_memory_pool ? (ps->current != NULL ?
-9.             ps->current->name : ""unknown file"") : ps->wname);
-8.       ++ps->nerrors;
-7.       do
-6.       {
-5.          store_memory *next = pool->list;
-4.          pool->list ",Useful
/*And reset the other fields too for the next time.*/,"-4.          store_memory_free(NULL, pool, next);
-3.       }
-2.       while (pool->list != NULL);
-1.    }

 /*And reset the other fields too for the next time.*/

1.    if (pool->max > pool->max_max) pool->max_max = pool->max;
2.    pool->max = 0;",Useful
"/*NOTE: the PNG user malloc function cannot use the png_ptr it is passed
       * other than to retrieve the allocation pointer!  libpng calls the
       * store_malloc callback in two basic cases:
       *
       * 1) From png_malloc; png_malloc will do a png_error itself if NULL is
       *    returned.
       * 2) From png_struct or png_info structure creation; png_malloc is
       *    to return so cleanup can be performed.
       *
       * To handle this store_malloc can log a message, but can't do anything
       * else.*/","-10.       new->size = cb;
-9.       memcpy(new->mark, pool->mark, sizeof new->mark);
-8.       memcpy((png_byte*)(new+1) + cb, pool->mark, sizeof pool->mark);
-7.       new->pool = pool;
-6.       new->next = pool->list;
-5.       pool->list = new;
-4.  ",Useful
"/*Because libpng calls store_free with a dummy png_struct when deleting
    * png_struct or png_info via png_destroy_struct_2 it is necessary to check
    * the passed in png_structp to ensure it is valid, and not pass it to
    * png_error if it is not.*/","-9.    }
-8.    return new;
-7. }
-6. static void PNGCBAPI
-5. store_free(png_structp ppIn, png_voidp memory)
-4. {
-3.    png_const_structp pp = ppIn;
-2.    store_pool *pool = voidcast(store_pool*, png_get_mem_ptr(pp));
-1.    store_memory *this = voidc",Useful
"/*First check that this 'memory' really is valid memory - it must be in the
    * pool list.  If it is, use the shared memory_free function to free it.*/","-2.    if (pp != pool->store->pread && pp != pool->store->pwrite)
-1.       pp = NULL;
   /* First check that this 'memory' really is valid memory - it must be in the
    * pool list.  If it is, use the shared memory_free function to free it.

 /*First ch",Useful
/*Cleanup when aborting a write or after storing the new file.*/,"-6.    *test = this->next;
-5.    this->next = NULL;
-4.    store_memory_free(pp, pool, this);
-3. }

 /*Cleanup when aborting a write or after storing the new file.*/

1. static void
2. store_write_reset(png_store *ps)
3. {
4.    if (ps->pwrite != NULL)
",Useful
/*memory corruption: continue.*/,"-10. static void
-9. store_write_reset(png_store *ps)
-8. {
-7.    if (ps->pwrite != NULL)
-6.    {
-5.       anon_context(ps);
-4.       Try
-3.          png_destroy_write_struct(&ps->pwrite, &ps->piwrite);
-2.       Catch_anonymous
-1.       {

 /*memor",Useful
"/*And make sure that all the memory has been freed - this will output
    * spurious errors in the case of memory corruption above, but this is safe.*/","-4.       }
-3.       ps->pwrite = NULL;
-2.       ps->piwrite = NULL;
-1.    }
   /* And make sure that all the memory has been freed - this will output
    * spurious errors in the case of memory corruption above, but this is safe.

 /*And make sure tha",Useful
"/*The following is the main write function, it returns a png_struct and,
 * optionally, a png_info suitable for writiing a new PNG file.  Use
 * store_storefile above to record this file after it has been written.  The
 * returned libpng structures as destroyed by store_write_reset above.*/","-5. #  ifdef PNG_USER_MEM_SUPPORTED
-4.       store_pool_delete(ps, &ps->write_memory_pool);
-3. #  endif
-2.    store_freenew(ps);
-1. }
/* The following is the main write function, it returns a png_struct and,
 * optionally, a png_info suitable for writ",Useful
"/*Don't do the slow memory checks if doing a speed test, also if user
       * memory is not supported we can't do it anyway.*/","-10. static png_structp
-9. set_store_for_write(png_store *ps, png_infopp ppi, const char *name)
-8. {
-7.    anon_context(ps);
-6.    Try
-5.    {
-4.       if (ps->pwrite != NULL)
-3.          png_error(ps->pwrite, ""write store already in use"");
-2.    ",Useful
"/*Cleanup when finished reading (either due to error or in the success case).
 * This routine exists even when there is no read support to make the code
 * tidier (avoid a mass of ifdefs) and so easier to maintain.*/","-10.                   png_error(ps->pwrite, ""png option invalid"");
-9.          }
-8. #     endif
-7.       if (ppi != NULL)
-6.          *ppi = ps->piwrite = png_create_info_struct(ps->pwrite);
-5.    }
-4.    Catch_anonymous
-3.       return NULL;
-2. ",Useful
/*error already output: continue*/,"-10. store_read_reset(png_store *ps)
-9. {
-8. #  ifdef PNG_READ_SUPPORTED
-7.       if (ps->pread != NULL)
-6.       {
-5.          anon_context(ps);
-4.          Try
-3.             png_destroy_read_struct(&ps->pread, &ps->piread, NULL);
-2.          Ca",Useful
"/*The main interface for reading a saved file - pass the id number of the file
 * to retrieve.  Ids must be unique or the earlier file will be hidden.  The API
 * returns a png_struct and, optionally, a png_info.  Both of these will be
 * destroyed by store_read_reset above.*/","-10.       pf = pf->next;
-9.    }
-8.    {
-7.       size_t pos;
-6.       char msg[FILE_NAME_SIZE+64];
-5.       pos = standard_name_from_id(msg, sizeof msg, 0, id);
-4.       pos = safecat(msg, sizeof msg, pos, "": file not found"");
-3.       png_error(",Useful
"/*Both the create APIs can return NULL if used in their default mode
    * (because there is no other way of handling an error because the jmp_buf
    * by default is stored in png_struct and that has not been allocated!)
    * However, given that store_error works correctly in these circumstances
    * we don't ever expect NULL in this program.*/","-4.    safecat(ps->test, sizeof ps->test, 0, name);
-3.    if (ps->pread != NULL)
-2.       png_error(ps->pread, ""read store already in use"");
-1.    store_read_reset(ps);
   /* Both the create APIs can return NULL if used in their default mode
    * (bec",Useful
"/*The overall cleanup of a store simply calls the above then removes all the
 * saved files.  This does not delete the store itself.*/","
/* The overall cleanup of a store simply calls the above then removes all the
 * saved files.  This does not delete the store itself.



 /*The overall cleanup of a store simply calls the above then removes all the
 * saved files.  This does not delete the store itself.*/

1.  */
2. static void
3. store_delete(png_store *ps)
4. {
5.    store_write_reset(ps);
6.    store_read_reset(ps);
7.    store_freefile(&ps->saved);
8.    store_image_free(ps, NULL);
9. }",Useful
"/*Files may be modified on read.  The following structure contains a complete
 * png_store together with extra members to handle modification and a special
 * read callback for libpng.  To use this the 'modifications' field must be set
 * to a list of png_modification structures that actually perform the
 * modification, otherwise a png_modifier is functionally equivalent to a
 * png_store.  There is a special read function, set_modifier_for_read, which
 * replaces set_store_for_read.*/","
/* Files may be modified on read.  The following structure contains a complete
 * png_store together with extra members to handle modification and a special
 * read callback for libpng.  To use this the 'modifications' field must be set
 * to a list of png_modification structures that actually perform the
 * modification, otherwise a png_modifier is functionally equivalent to a
 * png_store.  There is a special read function, set_modifier_for_read, which
 * replaces set_store_for_read.



 /*Files may be modified on read.  The following structure contains a complete
 * png_store together with extra members to handle modification and a special
 * read callback for libpng.  To use this the 'modifications' field must be set
 * to a list of png_modification structures that actually perform the
 * modification, otherwise a png_modifier is functionally equivalent to a
 * png_store.  There is a special read function, set_modifier_for_read, which
 * replaces set_store_for_read.*/

1.  */
2. typedef enum modifier_state
3. {",Useful
"/*A single CIE tristimulus value, representing the unique response of a
    * standard observer to a variety of light spectra.  The observer recognizes
    * all spectra that produce this response as the same color, therefore this
    * is effectively a description of a color.*/","-3. } modifier_state;
-2. typedef struct CIE_color
-1. {
   /* A single CIE tristimulus value, representing the unique response of a
    * standard observer to a variety of light spectra.  The observer recognizes
    * all spectra that produce this respon",Useful
"/*A description of an (R,G,B) encoding of color (as defined above); this
    * includes the actual colors of the (R,G,B) triples (1,0,0), (0,1,0) and
    * (0,0,1) plus an encoding value that is used to encode the linear
    * components R, G and B to give the actual values R^gamma, G^gamma and
    * B^gamma that are stored.*/","-4.    double X, Y, Z;
-3. } CIE_color;
-2. typedef struct color_encoding
-1. {
   /* A description of an (R,G,B) encoding of color (as defined above); this
    * includes the actual colors of the (R,G,B) triples (1,0,0), (0,1,0) and
    * (0,0,1) plus an",Useful
"/*While handling PLTE, IDAT and IEND these chunks may be pended to allow
    * other chunks to be inserted.*/","-8. typedef struct png_modifier
-7. {

 /*While handling PLTE, IDAT and IEND these chunks may be pended to allow
    * other chunks to be inserted.*/

1.     */
2.    png_uint_32              pending_len;
3.    png_uint_32              pending_chunk;",Useful
/*If an encoding has been set*/,"-2.    const color_encoding *encodings;
-1.    unsigned int              nencodings;

 /*If an encoding has been set*/

111",Useful
"/*Control variables used to iterate through possible encodings, the
    * following must be set to 0 and tested by the function that uses the
    * png_modifier because the modifier only sets it to 1 (true.)*/","/* Control variables used to iterate through possible encodings, the
    * following must be set to 0 and tested by the function that uses the
    * png_modifier because the modifier only sets it to 1 (true.)

 /*Control variables used to iterate through possible encodings, the
    * following must be set to 0 and tested by the function that uses the
    * png_modifier because the modifier only sets it to 1 (true.)*/

1.     */",Useful
"/*Error control - these are the limits on errors accepted by the gamma tests
    * below.*/","-1.    png_byte                 sbitlow;
   /* Error control - these are the limits on errors accepted by the gamma tests
    * below.

 /*Error control - these are the limits on errors accepted by the gamma tests
    * below.*/

1.     */",Useful
/*Maximum output value error*/,"-4.    png_byte                 sbitlow;

 /*Maximum output value error*/

111",Useful
/*Percentage sample error 0..100%*/,"-7.    png_byte                 sbitlow;

 /*Percentage sample error 0..100%*/

111",Useful
/*Maximum output value error*/,"-4.    png_byte                 sbitlow;

 /*Maximum output value error*/

111",Useful
/*Percentage sample error 0..100%*/,"-7.    png_byte                 sbitlow;

 /*Percentage sample error 0..100%*/

111",Useful
"/*This is set by transforms that need to allow a higher limit, it is an
    * internal check on pngvalid to ensure that the calculated error limits are
    * not ridiculous; without this it is too easy to make a mistake in pngvalid
    * that allows any value through.
    *
    * NOTE: this is not checked in release builds.*/","-10.     */

 /*This is set by transforms that need to allow a higher limit, it is an
    * internal check on pngvalid to ensure that the calculated error limits are
    * not ridiculous; without this it is too easy to make a mistake in pngvalid
    * tha",Useful
"/*limit on error values, normally 4E-3*/","-10.    double                   maxcalc16;/* Absolute sample error 0..1 */
-9.    double                   maxcalcG; /* Absolute sample error 0..1 */
-8.    double                   maxpc16;  /* Percentage sample error 0..100% */
-7.    /* This is set by",Useful
"/*Log limits - values above this are logged, but not necessarily
    * warned.*/","
   /* Log limits - values above this are logged, but not necessarily
    * warned.



 /*Log limits - values above this are logged, but not necessarily
    * warned.*/

1.     */",Useful
/*Absolute error in 8 bits to log*/,"-10.     * internal check on pngvalid to ensure that the calculated error limits are
-9.     * not ridiculous; without this it is too easy to make a mistake in pngvalid
-8.     * that allows any value through.
-7.     *
-6.     * NOTE: this is not checked",Useful
/*Absolute error in 16 bits to log*/,"-10.     * not ridiculous; without this it is too easy to make a mistake in pngvalid
-9.     * that allows any value through.
-8.     *
-7.     * NOTE: this is not checked in release builds.
-6.     */

 /*Absolute error in 16 bits to log*/

111",Useful
/*Logged 8 and 16 bit errors ('output' values):*/,"-10.     * that allows any value through.
-9.     *
-8.     * NOTE: this is not checked in release builds.
-7.     */

 /*Logged 8 and 16 bit errors ('output' values):*/

1.    double                   error_gray_2;
2.    double                   error_gr",Useful
"/*Run tests on reading with a combination of transforms,*/","-1.    unsigned int             test_size :1;

 /*Run tests on reading with a combination of transforms,*/

1.    unsigned int             test_transform :1;",Useful
"/*When to use the use_input_precision option, this controls the gamma
    * validation code checks.  If set any value that is within the transformed
    * range input-.5 to input+.5 will be accepted, otherwise the value must be
    * within the normal limits.  It should not be necessary to set this; the
    * result should always be exact within the permitted error limits.*/","/* When to use the use_input_precision option, this controls the gamma
    * validation code checks.  If set any value that is within the transformed
    * range input-.5 to input+.5 will be accepted, otherwise the value must be
    * within the normal limits.  It should not be necessary to set this; the
    * result should always be exact within the permitted error limits.

 /*When to use the use_input_precision option, this controls the gamma
    * validation code checks.  If set any value that is within the transformed
    * range input-.5 to input+.5 will be accepted, otherwise the value must be
    * within the normal limits.  It should not be necessary to set this; the
    * result should always be exact within the permitted error limits.*/

1.     */
2.    unsigned int             use_input_precision :1;
3.    unsigned int             use_input_precision_sbit :1;
4.    unsigned int             use_input_precision_16to8 :1;",Useful
"/*If set assume that the calculation bit depth is set by the input
    * precision, not the output precision.*/","-3.    unsigned int             use_input_precision :1;
-2.    unsigned int             use_input_precision_sbit :1;
-1.    unsigned int             use_input_precision_16to8 :1;
   /* If set assume that the calculation bit depth is set by the input
    *",Useful
"/*If set assume that the calculations are done in 16 bits even if the sample
    * depth is 8 bits.*/","-1.    unsigned int             calculations_use_input_precision :1;
   /* If set assume that the calculations are done in 16 bits even if the sample
    * depth is 8 bits.

 /*If set assume that the calculations are done in 16 bits even if the sample
   ",Useful
"/*Whether or not to run the low-bit-depth grayscale tests.  This fails on
    * gamma images in some cases because of gross inaccuracies in the grayscale
    * gamma handling for low bit depth.*/","-6.    unsigned int             test_gamma_sbit :1;
-5.    unsigned int             test_gamma_scale16 :1;
-4.    unsigned int             test_gamma_background :1;
-3.    unsigned int             test_gamma_alpha_mode :1;
-2.    unsigned int             ",Useful
/*Log max error*/,"-5.    unsigned int             test_lbg :1;
-4.    unsigned int             test_lbg_gamma_threshold :1;
-3.    unsigned int             test_lbg_gamma_transform :1;
-2.    unsigned int             test_lbg_gamma_sbit :1;
-1.    unsigned int             ",Useful
"/*Buffer information, the buffer size limits the size of the chunks that can
    * be modified - they must fit (including header and CRC) into the buffer!*/","
   /* Buffer information, the buffer size limits the size of the chunks that can
    * be modified - they must fit (including header and CRC) into the buffer!



 /*Buffer information, the buffer size limits the size of the chunks that can
    * be modified - they must fit (including header and CRC) into the buffer!*/

1.     */",Useful
"/*This returns true if the test should be stopped now because it has already
 * failed and it is running silently.*/","-2.    png_byte                 buffer[1024];
-1. } png_modifier;
/* This returns true if the test should be stopped now because it has already
 * failed and it is running silently.

 /*This returns true if the test should be stopped now because it has al",Useful
/*Rely on the memset for all the other fields - there are no pointers*/,"-10.    pm->test_gamma_background = 0;
-9.    pm->test_gamma_alpha_mode = 0;
-8.    pm->test_gamma_expand16 = 0;
-7.    pm->test_lbg = 1;
-6.    pm->test_lbg_gamma_threshold = 1;
-5.    pm->test_lbg_gamma_transform = 1;
-4.    pm->test_lbg_gamma_sbit = 1;",Useful
"/*This controls use of checks that explicitly know how libpng digitizes the
 * samples in calculations; setting this circumvents simple error limit checking
 * in the rgb_to_gray check, replacing it with an exact copy of the libpng 1.5
 * algorithm.*/","-2. }
-1. #ifdef PNG_READ_TRANSFORMS_SUPPORTED
/* This controls use of checks that explicitly know how libpng digitizes the
 * samples in calculations; setting this circumvents simple error limit checking
 * in the rgb_to_gray check, replacing it with an ",Useful
"/*If pm->calculations_use_input_precision is set then operations will happen
 * with the precision of the input, not the precision of the output depth.
 *
 * If pm->assume_16_bit_calculations is set then even 8 bit calculations use 16
 * bit precision.  This only affects those of the following limits that pertain
 * to a calculation - not a digitization operation - unless the following API is
 * called directly.*/","-1. #define DIGITIZE PNG_LIBPNG_VER < 10700
/* If pm->calculations_use_input_precision is set then operations will happen
 * with the precision of the input, not the precision of the output depth.
 *
 * If pm->assume_16_bit_calculations is set then even 8",Useful
"/*value' is in the range 0 to 1, the result is the same value rounded to a
    * multiple of the digitization factor - 8 or 16 bits depending on both the
    * sample depth and the 'assume' setting.  Digitization is normally by
    * rounding and 'do_round' should be 1, if it is 0 the digitized value will
    * be truncated.*/","-10.  *
-9.  * If pm->assume_16_bit_calculations is set then even 8 bit calculations use 16
-8.  * bit precision.  This only affects those of the following limits that pertain
-7.  * to a calculation - not a digitization operation - unless the following A",Useful
"/*Limiting the range is done as a convenience to the caller - it's easier to
    * do it once here than every time at the call site.*/","-1.    const unsigned int digitization_factor = (1U << depth) -1;
   /* Limiting the range is done as a convenience to the caller - it's easier to
    * do it once here than every time at the call site.

 /*Limiting the range is done as a convenience to t",Useful
/*RGB_TO_GRAY*/,"-7. static png_uint_16
-6. random_u16(void)
-5. {
-4.    unsigned char b2[2];
-3.    randomize(b2, sizeof b2);
-2.    return png_get_uint_16(b2);
-1. }
#if defined PNG_READ_RGB_TO_GRAY_SUPPORTED ||\

 /*RGB_TO_GRAY*/

1.     defined PNG_READ_FILLER_SUPPOR",Useful
"/*Absolute error permitted in linear values - affected by the bit depth of
    * the calculations.*/","-3. #ifdef PNG_READ_GAMMA_SUPPORTED
-2. static double abserr(const png_modifier *pm, int in_depth, int out_depth)
-1. {
   /* Absolute error permitted in linear values - affected by the bit depth of
    * the calculations.

 /*Absolute error permitted in ",Useful
"/*Error in the linear composition arithmetic - only relevant when
    * composition actually happens (0 < alpha < 1).*/","-10.     * the calculations.
-9.     */
-8.    if (pm->assume_16_bit_calculations ||
-7.       (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
-6.       return pm->maxabs16;
-5.    else
-4.       return pm->maxabs8;
-3. }
-2. static d",Useful
"/*Percentage error permitted in the linear values.  Note that the specified
    * value is a percentage but this routine returns a simple number.*/","-10.     */
-9.    if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
-8.       return pm->maxcalc16;
-7.    else if (pm->assume_16_bit_calculations)
-6.       return pm->maxcalcG;
-5.    else
-4.       return pm->maxcalc8;
-3. }
-2.",Useful
"/*Output error - the error in the encoded value.  This is determined by the
 * digitization of the output so can be +/-0.5 in the actual output value.  In
 * the expand_16 case with the current code in libpng the expand happens after
 * all the calculations are done in 8 bit arithmetic, so even though the output
 * depth is 16 the output error is determined by the 8 bit calculation.
 *
 * This limit is not determined by the bit depth of internal calculations.
 *
 * The specified parameter does *not* include the base .5 digitization error but
 * it is added here.*/","-6.    if (pm->assume_16_bit_calculations ||
-5.       (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
-4.       return pm->maxpc16 * .01;
-3.    else
-2.       return pm->maxpc8 * .01;
-1. }
/* Output error - the error in the encoded",Useful
"/*There is a serious error in the 2 and 4 bit grayscale transform because
    * the gamma table value (8 bits) is simply shifted, not rounded, so the
    * error in 4 bit grayscale gamma is up to the value below.  This is a hack
    * to allow pngvalid to succeed:
    *
    * TODO: fix this in libpng*/","-10.  * all the calculations are done in 8 bit arithmetic, so even though the output
-9.  * depth is 16 the output error is determined by the 8 bit calculation.
-8.  *
-7.  * This limit is not determined by the bit depth of internal calculations.
-6.  *
-",Useful
"/*This is the case where the value was calculated at 8-bit precision then
    * scaled to 16 bits.*/","-10.     * to allow pngvalid to succeed:
-9.     *
-8.     * TODO: fix this in libpng
-7.     */
-6.    if (out_depth == 2)
-5.       return .73182-.5;
-4.    if (out_depth == 4)
-3.       return .90644-.5;
-2.    if ((pm->calculations_use_input_precision",Useful
"/*This does the same thing as the above however it returns the value to log,
 * rather than raising a warning.  This is useful for debugging to track down
 * exactly what set of parameters cause high error values.*/","-5.    else if (out_depth == 16)
-4.       return pm->maxout8 * 257;
-3.    else
-2.       return pm->maxout8;
-1. }
/* This does the same thing as the above however it returns the value to log,
 * rather than raising a warning.  This is useful for debugg",Useful
"/*The command line parameters are either 8 bit (0..255) or 16 bit (0..65535)
    * and so must be adjusted for low bit depth grayscale:*/","-2. static double outlog(const png_modifier *pm, int in_depth, int out_depth)
-1. {
   /* The command line parameters are either 8 bit (0..255) or 16 bit (0..65535)
    * and so must be adjusted for low bit depth grayscale:

 /*The command line parameters",Useful
"/*This is the case where the value was calculated at 8-bit precision then
    * scaled to 16 bits.*/","-10.     * to allow pngvalid to succeed:
-9.     *
-8.     * TODO: fix this in libpng
-7.     */
-6.    if (out_depth == 2)
-5.       return .73182-.5;
-4.    if (out_depth == 4)
-3.       return .90644-.5;
-2.    if ((pm->calculations_use_input_precision",Useful
"/*This complements the above by providing the appropriate quantization for the
 * final value.  Normally this would just be quantization to an integral value,
 * but in the 8 bit calculation case it's actually quantization to a multiple of
 * 257!*/","-4.    if (pm->log8 == 0)
-3.       return 65536;
-2.    return pm->log8 * 257;
-1. }
/* This complements the above by providing the appropriate quantization for the
 * final value.  Normally this would just be quantization to an integral value,
 * but in",Useful
"/*One modification structure must be provided for each chunk to be modified (in
 * fact more than one can be provided if multiple separate changes are desired
 * for a single chunk.)  Modifications include adding a new chunk when a
 * suitable chunk does not exist.
 *
 * The caller of modify_fn will reset the CRC of the chunk and record 'modified'
 * or 'added' as appropriate if the modify_fn returns 1 (true).  If the
 * modify_fn is NULL the chunk is simply removed.*/","/* One modification structure must be provided for each chunk to be modified (in
 * fact more than one can be provided if multiple separate changes are desired
 * for a single chunk.)  Modifications include adding a new chunk when a
 * suitable chunk does not exist.
 *
 * The caller of modify_fn will reset the CRC of the chunk and record 'modified'
 * or 'added' as appropriate if the modify_fn returns 1 (true).  If the
 * modify_fn is NULL the chunk is simply removed.

 /*One modification structure must be provided for each chunk to be modified (in
 * fact more than one can be provided if multiple separate changes are desired
 * for a single chunk.)  Modifications include adding a new chunk when a
 * suitable chunk does not exist.
 *
 * The caller of modify_fn will reset the CRC of the chunk and record 'modified'
 * or 'added' as appropriate if the modify_fn returns 1 (true).  If the
 * modify_fn is NULL the chunk is simply removed.*/

1.  */
2. typedef struct png_modification
3. {
4.    struct png_modification *next;
5.    png_uint_32              chunk;",Useful
/*If the following is NULL all matching chunks will be removed:*/,"-10.  * suitable chunk does not exist.
-9.  *
-8.  * The caller of modify_fn will reset the CRC of the chunk and record 'modified'
-7.  * or 'added' as appropriate if the modify_fn returns 1 (true).  If the
-6.  * modify_fn is NULL the chunk is simply rem",Useful
"/*If the following is set to PLTE, IDAT or IEND and the chunk has not been
    * found and modified (and there is a modify_fn) the modify_fn will be called
    * to add the chunk before the relevant chunk.*/","-2.    int                    (*modify_fn)(struct png_modifier *pm,
-1.                                struct png_modification *me, int add);
   /* If the following is set to PLTE, IDAT or IEND and the chunk has not been
    * found and modified (and ther",Useful
"/*Iterate through the usefully testable color encodings.  An encoding is one
 * of:
 *
 * 1) Nothing (no color space, no gamma).
 * 2) Just a gamma value from the gamma array (including 1.0)
 * 3) A color space from the encodings array with the corresponding gamma.
 * 4) The same, but with gamma 1.0 (only really useful with 16 bit calculations)
 *
 * The iterator selects these in turn, the randomizer selects one at random,
 * which is used depends on the setting of the 'test_exhaustive' flag.  Notice
 * that this function changes the colour space encoding so it must only be
 * called on completion of the previous test.  This is what 'modifier_reset'
 * does, below.
 *
 * After the function has been called the 'repeat' flag will still be set; the
 * caller of modifier_reset must reset it at the start of each run of the test!*/","-10. safecat_current_encoding(char *buffer, size_t bufsize, size_t pos,
-9.    const png_modifier *pm)
-8. {
-7.    pos = safecat_color_encoding(buffer, bufsize, pos, pm->current_encoding,
-6.       pm->current_gamma);
-5.    if (pm->encoding_ignored)
-4.",Useful
"/*The following test only works after the first time through the
       * png_modifier code because 'bit_depth' is set when the IHDR is read.
       * modifier_reset, below, preserves the setting until after it has called
       * the iterate function (also below.)
       *
       * For this reason do not rely on this function outside a call to
       * modifier_reset.*/","
      /* The following test only works after the first time through the
       * png_modifier code because 'bit_depth' is set when the IHDR is read.
       * modifier_reset, below, preserves the setting until after it has called
       * the iterate function (also below.)
       *
       * For this reason do not rely on this function outside a call to
       * modifier_reset.



 /*The following test only works after the first time through the
       * png_modifier code because 'bit_depth' is set when the IHDR is read.
       * modifier_reset, below, preserves the setting until after it has called
       * the iterate function (also below.)
       *
       * For this reason do not rely on this function outside a call to
       * modifier_reset.*/

1.        */
2.       ((pm->bit_depth == 16 || pm->assume_16_bit_calculations) ?",Useful
/*Else something needs the current encoding again.*/,"-4. }
-3. static void
-2. modifier_encoding_iterate(png_modifier *pm)
-1. {

 /*Else something needs the current encoding again.*/

111",Useful
"/*Not exhaustive - choose an encoding at random; generate a number in
          * the range 1..(max-1), so the result is always non-zero:*/","-3.       }
-2.       else
-1.       {
         /* Not exhaustive - choose an encoding at random; generate a number in
          * the range 1..(max-1), so the result is always non-zero:

 /*Not exhaustive - choose an encoding at random; generate a number",Useful
"/*The following must be set in the next run.  In particular
    * test_uses_encodings must be set in the _ini function of each transform
    * that looks at the encodings.  (Not the 'add' function!)*/","-10. static void
-9. modifier_reset(png_modifier *pm)
-8. {
-7.    store_read_reset(&pm->this);
-6.    pm->limit = 4E-3;
-5.    pm->pending_len = pm->pending_chunk = 0;
-4.    pm->flush = pm->buffer_count = pm->buffer_position = 0;
-3.    pm->modification",Useful
"/*The following must be called before anything else to get the encoding set up
 * on the modifier.  In particular it must be called before the transform init
 * functions are called.*/","-2.    pm->bit_depth = pm->colour_type = 0;
-1. }
/* The following must be called before anything else to get the encoding set up
 * on the modifier.  In particular it must be called before the transform init
 * functions are called.

 /*The following mus",Useful
"/*Set the encoding to the one specified by the current encoding counter,
    * first clear out all the settings - this corresponds to an encoding_counter
    * of 0.*/","-3. static void
-2. modifier_set_encoding(png_modifier *pm)
-1. {
   /* Set the encoding to the one specified by the current encoding counter,
    * first clear out all the settings - this corresponds to an encoding_counter
    * of 0.

 /*Set the encodin",Useful
"/*Now, if required, set the gamma and encoding fields.*/","-3.    pm->current_gamma = 0;
-2.    pm->current_encoding = 0;

 /*Now, if required, set the gamma and encoding fields.*/

1.    if (pm->encoding_counter > 0)
2.    {",Useful
"/*The gammas[] array is an array of screen gammas, not encoding gammas,
       * so we need the inverse:*/","-2.    if (pm->encoding_counter > 0)
-1.    {
      /* The gammas[] array is an array of screen gammas, not encoding gammas,
       * so we need the inverse:

 /*The gammas[] array is an array of screen gammas, not encoding gammas,
       * so we need the",Useful
"/*Linear, only in the 16 bit case*/","-10.        * so we need the inverse:
-9.        */
-8.       if (pm->encoding_counter <= pm->ngammas)
-7.          pm->current_gamma = 1/pm->gammas[pm->encoding_counter-1];
-6.       else
-5.       {
-4.          unsigned int i = pm->encoding_counter - p",Useful
"/*Enquiry functions to find out what is set.  Notice that there is an implicit
 * assumption below that the first encoding in the list is the one for sRGB.*/","-7.          }
-6.          else
-5.             pm->current_gamma = pm->encodings[i].gamma;
-4.          pm->current_encoding = pm->encodings + i;
-3.       }
-2.    }
-1. }
/* Enquiry functions to find out what is set.  Notice that there is an implicit
",Useful
/*The guts of modification are performed during a read.*/,"-10. modifier_color_encoding_is_sRGB(const png_modifier *pm)
-9. {
-8.    return pm->current_encoding != 0 && pm->current_encoding == pm->encodings &&
-7.       pm->current_encoding->gamma == pm->current_gamma;
-6. }
-5. static int
-4. modifier_color_enco",Useful
"/*Recalculate the chunk CRC - a complete chunk must be in
    * the buffer, at the start.*/","-3. static void
-2. modifier_crc(png_bytep buffer)
-1. {
   /* Recalculate the chunk CRC - a complete chunk must be in
    * the buffer, at the start.

 /*Recalculate the chunk CRC - a complete chunk must be in
    * the buffer, at the start.*/

1.     */",Useful
/*The cast to png_uint_32 is safe because a crc32 is always a 32 bit value.*/,"-2.    uInt datalen = png_get_uint_32(buffer);
-1.    uLong crc = crc32(0, buffer+4, datalen+4);
   /* The cast to png_uint_32 is safe because a crc32 is always a 32 bit value.

 /*The cast to png_uint_32 is safe because a crc32 is always a 32 bit value.*",Useful
"/*Separate the callback into the actual implementation (which is passed the
 * png_modifier explicitly) and the callback, which gets the modifier from the
 * png_struct.*/","-10.     */
-9.    png_save_uint_32(buffer+datalen+8, (png_uint_32)crc);
-8. }
-7. static void
-6. modifier_setbuffer(png_modifier *pm)
-5. {
-4.    modifier_crc(pm->buffer);
-3.    pm->buffer_count = png_get_uint_32(pm->buffer)+12;
-2.    pm->buffer_posi",Useful
/*Check the list of modifiers for modifications to the IHDR.*/,"-5.             pm->buffer_count = 13+12;
-4.             pm->buffer_position = 0;
-3.             if (png_get_uint_32(pm->buffer) != 13 ||
-2.                 png_get_uint_32(pm->buffer+4) != CHUNK_IHDR)
-1.                png_error(pm->this.pread, ""inva",Useful
/*Ignore removal or add if IHDR!*/,"-9.             mod = pm->modifications;
-8.             while (mod != NULL)
-7.             {
-6.                if (mod->chunk == CHUNK_IHDR && mod->modify_fn &&
-5.                    (*mod->modify_fn)(pm, mod, 0))
-4.                   {
-3.          ",Useful
"/*Read a new chunk and process it until we see PLTE, IDAT or
             * IEND.  'flush' indicates that there is still some data to
             * output from the preceding chunk.*/","-7.             pm->bit_depth = pm->buffer[8+8];
-6.             pm->colour_type = pm->buffer[8+8+1];
-5.             pm->state = modifier_IHDR;
-4.             pm->flush = 0;
-3.             break;
-2.          case modifier_IHDR:
-1.          default:
 ",Useful
"/*No more bytes to flush, read a header, or handle a pending
             * chunk.*/","-10.              */
-9.             if ((cb = pm->flush) > 0)
-8.             {
-7.                if (cb > st) cb = st;
-6.                pm->flush -= cb;
-5.                store_read_chunk(&pm->this, pb, cb, cb);
-4.                pb += cb;
-3.     ",Useful
/*Check for something to modify or a terminator chunk.*/,"-10.             {
-9.                png_save_uint_32(pm->buffer, pm->pending_len);
-8.                png_save_uint_32(pm->buffer+4, pm->pending_chunk);
-7.                pm->pending_len = 0;
-6.                pm->pending_chunk = 0;
-5.             }
",Useful
"/*Terminators first, they may have to be delayed for added
             * chunks*/","-2.             len = png_get_uint_32(pm->buffer);
-1.             chunk = png_get_uint_32(pm->buffer+4);
            /* Terminators first, they may have to be delayed for added
             * chunks

 /*Terminators first, they may have to be delayed for ",Useful
"/*Regardless of what the modify function does do not run
                      * this again.*/","-10.             if (chunk == CHUNK_PLTE || chunk == CHUNK_IDAT ||
-9.                 chunk == CHUNK_IEND)
-8.             {
-7.                mod = pm->modifications;
-6.                while (mod != NULL)
-5.                {
-4.                   if ",Useful
"/*The buffer has been filled with something (we assume)
                         * so output this.  Pend the current chunk.*/","-7.                         if (pm->buffer_count > 0)
-6.                            modifier_setbuffer(pm);
-5.                         else
-4.                            {
-3.                            pm->buffer_position = 0;
-2.                     ",Useful
/*out of while*/,"-2.                         pm->pending_len = len;
-1.                         pm->pending_chunk = chunk;

 /*out of while*/

1.                      }
2.                   }
3.                   mod = mod->next;
4.                }",Useful
"/*Don't do any further processing if the buffer was modified -
                * otherwise the code will end up modifying a chunk that was
                * just added.*/","-4.                      }
-3.                   }
-2.                   mod = mod->next;
-1.                }
               /* Don't do any further processing if the buffer was modified -
                * otherwise the code will end up modifying a chun",Useful
/*out of switch*/,"-1.                if (mod != NULL)

 /*out of switch*/

1.             }",Useful
"/*If we get to here then this chunk may need to be modified.  To
             * do this it must be less than 1024 bytes in total size, otherwise
             * it just gets flushed.*/","-1.             }
            /* If we get to here then this chunk may need to be modified.  To
             * do this it must be less than 1024 bytes in total size, otherwise
             * it just gets flushed.

 /*If we get to here then this chunk may ",Useful
"/*Check for a modification, else leave it be.*/","-5.             if (len+12 <= sizeof pm->buffer)
-4.             {
-3.                png_size_t s = len+12-pm->buffer_count;
-2.                store_read_chunk(&pm->this, pm->buffer+pm->buffer_count, s, s);
-1.                pm->buffer_count = len+12;
",Useful
/*Take the data from the buffer (if there is any).*/,"-10.                            break;
-9.                         }
-8.                         modifier_setbuffer(pm);
-7.                      }
-6.                   }
-5.                   mod = mod->next;
-4.                }
-3.             }
-2.  ",Useful
"/*Here to read from the modifier buffer (not directly from
       * the store, as in the flush case above.)*/","-2.             break;
-1.       }
      /* Here to read from the modifier buffer (not directly from
       * the store, as in the flush case above.)

 /*Here to read from the modifier buffer (not directly from
       * the store, as in the flush case abo",Useful
"/*Like store_progressive_read but the data is getting changed as we go so we
 * need a local buffer.*/","-9. static void PNGCBAPI
-8. modifier_read(png_structp ppIn, png_bytep pb, png_size_t st)
-7. {
-6.    png_const_structp pp = ppIn;
-5.    png_modifier *pm = voidcast(png_modifier*, png_get_io_ptr(pp));
-4.    if (pm == NULL || pm->this.pread != pp)
-3.  ",Useful
"/*This is another Horowitz and Hill random noise generator.  In this case
    * the aim is to stress the progressive reader with truly horrible variable
    * buffer sizes in the range 1..500, so a sequence of 9 bit random numbers
    * is generated.  We could probably just count from 1 to 32767 and get as
    * good a result.*/","-10.    png_store *ps = voidcast(png_store*, png_get_io_ptr(pp));
-9.    if (ps == NULL || ps->pread != pp)
-8.       png_error(pp, ""bad store read call"");
-7.    store_read_chunk(ps, pb, st, st);
-6. }
-5. static void
-4. store_progressive_read(png_store",Useful
"/*Check that this number of bytes are available (in the current buffer.)
       * (This doesn't quite work - the modifier might delete a chunk; unlikely
       * but possible, it doesn't happen at present because the modifier only
       * adds chunks to standard images.)*/","-2.       noise = (noise << 9) | ((noise ^ (noise >> (9-5))) & 0x1ff);
-1.       cb = noise & 0x1ff;
      /* Check that this number of bytes are available (in the current buffer.)
       * (This doesn't quite work - the modifier might delete a chunk; unl",Useful
"/*Check the invariants at the end (if this fails it's a problem in this
    * file!)*/","-7.          if (cbAvail == 0)
-6.             break;
-5.          cb = cbAvail;
-4.       }
-3.       modifier_read_imp(pm, buffer, cb);
-2.       png_process_data(pp, pi, buffer, cb);
-1.    }
   /* Check the invariants at the end (if this fails it's a ",Useful
/*Set up a modifier.*/,"-5.    if (pm->buffer_count > pm->buffer_position ||
-4.        pm->this.next != &pm->this.current->data ||
-3.        pm->this.readpos < pm->this.current->datacount)
-2.       png_error(pp, ""progressive read implementation error"");
-1. }

 /*Set up a mod",Useful
"/*Do this first so that the modifier fields are cleared even if an error
    * happens allocating the png_struct.  No allocation is done here so no
    * cleanup is required.*/","-4. static png_structp
-3. set_modifier_for_read(png_modifier *pm, png_infopp ppi, png_uint_32 id,
-2.     const char *name)
-1. {
   /* Do this first so that the modifier fields are cleared even if an error
    * happens allocating the png_struct.  No al",Useful
"/*Standard modifications to add chunks.  These do not require the _SUPPORTED
 * macros because the chunks can be there regardless of whether this specific
 * libpng supports them.*/","
/* Standard modifications to add chunks.  These do not require the _SUPPORTED
 * macros because the chunks can be there regardless of whether this specific
 * libpng supports them.



 /*Standard modifications to add chunks.  These do not require the _SUPPORTED
 * macros because the chunks can be there regardless of whether this specific
 * libpng supports them.*/

1.  */
2. typedef struct gama_modification
3. {
4.    png_modification this;
5.    png_fixed_point  gamma;
6. } gama_modification;
7. static int
8. gama_modify(png_modifier *pm, png_modification *me, int add)
9. {
10.    UNUSED(add)",Useful
/*This simply dumps the given gamma value into the buffer.*/,"-10.  */
-9. typedef struct gama_modification
-8. {
-7.    png_modification this;
-6.    png_fixed_point  gamma;
-5. } gama_modification;
-4. static int
-3. gama_modify(png_modifier *pm, png_modification *me, int add)
-2. {
-1.    UNUSED(add)

 /*This sim",Useful
/*As with gAMA this just adds the required cHRM chunk to the buffer.*/,"-10. typedef struct chrm_modification
-9. {
-8.    png_modification          this;
-7.    const color_encoding *encoding;
-6.    png_fixed_point           wx, wy, rx, ry, gx, gy, bx, by;
-5. } chrm_modification;
-4. static int
-3. chrm_modify(png_modifier",Useful
/*Original end points:*/,"-10.    png_save_uint_32(pm->buffer+28, ((chrm_modification*)me)->gy);
-9.    png_save_uint_32(pm->buffer+32, ((chrm_modification*)me)->bx);
-8.    png_save_uint_32(pm->buffer+36, ((chrm_modification*)me)->by);
-7.    return 1;
-6. }
-5. static void
-4. c",Useful
/*Chromaticities (in fixed point):*/,"-1.    me->encoding = encoding;

 /*Chromaticities (in fixed point):*/

1.    me->wx = fix(chromaticity_x(white));
2.    me->wy = fix(chromaticity_y(white));
3.    me->rx = fix(chromaticity_x(encoding->red));
4.    me->ry = fix(chromaticity_y(encoding->re",Useful
"/*As above, ignore add and just make a new chunk*/","-10. }
-9. typedef struct srgb_modification
-8. {
-7.    png_modification this;
-6.    png_byte         intent;
-5. } srgb_modification;
-4. static int
-3. srgb_modify(png_modifier *pm, png_modification *me, int add)
-2. {
-1.    UNUSED(add)

 /*As above,",Useful
"/*if valid, else *delete* sRGB chunks*/","-10.    png_save_uint_32(pm->buffer, 1);
-9.    png_save_uint_32(pm->buffer+4, CHUNK_sRGB);
-8.    pm->buffer[8] = ((srgb_modification*)me)->intent;
-7.    return 1;
-6. }
-5. static void
-4. srgb_modification_init(srgb_modification *me, png_modifier *pm,",Useful
"/*There are two basic forms of standard images.  Those which attempt to have
 * all the possible pixel values (not possible for 16bpp images, but a range of
 * values are produced) and those which have a range of image sizes.  The former
 * are used for testing transforms, in particular gamma correction and bit
 * reduction and increase.  The latter are reserved for testing the behavior of
 * libpng with respect to 'odd' image sizes - particularly small images where
 * rows become 1 byte and interlace passes disappear.
 *
 * The first, most useful, set are the 'transform' images, the second set of
 * small images are the 'size' images.
 *
 * The transform files are constructed with rows which fit into a 1024 byte row
 * buffer.  This makes allocation easier below.  Further regardless of the file
 * format every row has 128 pixels (giving 1024 bytes for 64bpp formats).
 *
 * Files are stored with no gAMA or sBIT chunks, with a PLTE only when needed
 * and with an ID derived from the colour type, bit depth and interlace type
 * as above (FILEID).  The width (128) and height (variable) are not stored in
 * the FILEID - instead the fields are set to 0, indicating a transform file.
 *
 * The size files ar constructed with rows a maximum of 128 bytes wide, allowing
 * a maximum width of 16 pixels (for the 64bpp case.)  They also have a maximum
 * height of 16 rows.  The width and height are stored in the FILEID and, being
 * non-zero, indicate a size file.
 *
 * Because the PNG filter code is typically the largest CPU consumer within
 * libpng itself there is a tendency to attempt to optimize it.  This results in
 * special case code which needs to be validated.  To cause this to happen the
 * 'size' images are made to use each possible filter, in so far as this is
 * possible for smaller images.
 *
 * For palette image (colour type 3) multiple transform images are stored with
 * the same bit depth to allow testing of more colour combinations -
 * particularly important for testing the gamma code because libpng uses a
 * different code path for palette images.  For size images a single palette is
 * used.*/","-10.    me->this.modify_fn = sbit_modify;
-9.    me->this.add = CHUNK_PLTE;
-8.    me->sbit = sbit;
-7.    me->this.next = pm->modifications;
-6.    pm->modifications = &me->this;
-5. }
-4. #endif /* PNG_READ_GAMMA_SUPPORTED */
-3. #endif /* PNG_READ_TRAN",Useful
"/*Make a 'standard' palette.  Because there are only 256 entries in a palette
 * (maximum) this actually makes a random palette in the hope that enough tests
 * will catch enough errors.  (Note that the same palette isn't produced every
 * time for the same test - it depends on what previous tests have been run -
 * but a given set of arguments to pngvalid will always produce the same palette
 * at the same test!  This is why pseudo-random number generators are useful for
 * testing.)
 *
 * The store must be open for write when this is called, otherwise an internal
 * error will occur.  This routine contains its own magic number seed, so the
 * palettes generated don't change if there are intervening errors (changing the
 * calls to the store_mark seed.)*/","-10.  * special case code which needs to be validated.  To cause this to happen the
-9.  * 'size' images are made to use each possible filter, in so far as this is
-8.  * possible for smaller images.
-7.  *
-6.  * For palette image (colour type 3) multipl",Useful
"/*Finally add 192 colors at random - don't worry about matches to things we
    * already have, chance is less than 1/65536.  Don't worry about grays,
    * chance is the same, so we get a duplicate or extra gray less than 1 time
    * in 170.*/","-10.          }
-9.          b = random_bytes[--j];
-8.          if (need[b])
-7.          {
-6.             values[i][1] = b;
-5.             values[i][2] = b;
-4.             values[i++][3] = b;
-3.          }
-2.       }
-1.    }
   /* Finally add 192 ",Useful
"/*Fill in the alpha values in the first byte.  Just use all possible values
    * (0..255) in an apparently random order:*/","-2.    for (; i<256; ++i)
-1.       make_four_random_bytes(palette_seed, values[i]);
   /* Fill in the alpha values in the first byte.  Just use all possible values
    * (0..255) in an apparently random order:

 /*Fill in the alpha values in the first by",Useful
"/*values' contains 256 ARGB values, but we only need 'npalette'.
       * 'npalette' will always be a power of 2: 2, 4, 16 or 256.  In the low
       * bit depth cases select colors at random, else it is difficult to have
       * a set of low bit depth palette test with any chance of a reasonable
       * range of colors.  Do this by randomly permuting values into the low
       * 'npalette' entries using an XOR mask generated here.  This also
       * permutes the npalette == 256 case in a potentially useful way (there is
       * no relationship between palette index and the color value therein!)*/","/* 'values' contains 256 ARGB values, but we only need 'npalette'.
       * 'npalette' will always be a power of 2: 2, 4, 16 or 256.  In the low
       * bit depth cases select colors at random, else it is difficult to have
       * a set of low bit depth palette test with any chance of a reasonable
       * range of colors.  Do this by randomly permuting values into the low
       * 'npalette' entries using an XOR mask generated here.  This also
       * permutes the npalette == 256 case in a potentially useful way (there is
       * no relationship between palette index and the color value therein!)

 /*values' contains 256 ARGB values, but we only need 'npalette'.
       * 'npalette' will always be a power of 2: 2, 4, 16 or 256.  In the low
       * bit depth cases select colors at random, else it is difficult to have
       * a set of low bit depth palette test with any chance of a reasonable
       * range of colors.  Do this by randomly permuting values into the low
       * 'npalette' entries using an XOR mask generated here.  This also
       * permutes the npalette == 256 case in a potentially useful way (there is
       * no relationship between palette index and the color value therein!)*/

1.        */
2.       palette = store_write_palette(ps, npalette);
3.       for (i=0; i<npalette; ++i)
4.       {
5.          palette[i].alpha = values[i ^ selector[1]][0];
6.          palette[i].red   = values[i ^ selector[1]][1];
7.          palette[i].green = values[i ^ selector[1]][2];
8.          palette[i].blue  = values[i ^ selector[1]][3];
9.       }
10.       return palette;",Useful
"/*Initialize a standard palette on a write stream.  The 'do_tRNS' argument
 * indicates whether or not to also set the tRNS chunk.*/","-10.       for (i=0; i<npalette; ++i)
-9.       {
-8.          palette[i].alpha = values[i ^ selector[1]][0];
-7.          palette[i].red   = values[i ^ selector[1]][1];
-6.          palette[i].green = values[i ^ selector[1]][2];
-5.          palette[i].b",Useful
/*Set all entries to detect overread errors.*/,"-8. static void
-7. init_standard_palette(png_store *ps, png_structp pp, png_infop pi, int npalette,
-6.    int do_tRNS)
-5. {
-4.    store_palette_entry *ppal = make_standard_palette(ps, npalette, do_tRNS);
-3.    {
-2.       int i;
-1.       png_color p",Useful
/*Just in case fill in the rest with detectable values:*/,"-6.       for (i=0; i<npalette; ++i)
-5.       {
-4.          palette[i].red = ppal[i].red;
-3.          palette[i].green = ppal[i].green;
-2.          palette[i].blue = ppal[i].blue;
-1.       }

 /*Just in case fill in the rest with detectable values:*/",Useful
/*Fill in the remainder with a detectable value:*/,"-3.       for (i=j=0; i<npalette; ++i)
-2.          if ((tRNS[i] = ppal[i].alpha) < 255)
-1.             j = i+1;

 /*Fill in the remainder with a detectable value:*/

1.       for (; i<256; ++i)
2.          tRNS[i] = 24;
3. #ifdef PNG_WRITE_tRNS_SUPPORTE",Useful
"/*To make this useful the tRNS color needs to match at least one pixel.
    * Random values are fine for gray, including the 16-bit case where we know
    * that the test image contains all the gray values.  For RGB we need more
    * method as only 65536 different RGB values are generated.*/","-8. #endif
-7.    }
-6. }
-5. #ifdef PNG_WRITE_tRNS_SUPPORTED
-4. static void
-3. set_random_tRNS(png_structp pp, png_infop pi, const png_byte colour_type,
-2.    const int bit_depth)
-1. {
   /* To make this useful the tRNS color needs to match at least ",Useful
"/*The number of passes is related to the interlace type. There was no libpng
 * API to determine this prior to 1.5, so we need an inquiry function:*/","-10.       }
-9.    }
-8.    else
-7.    {
-6.       tRNS.gray = random_u16();
-5.       tRNS.gray &= mask;
-4.    }
-3.    png_set_tRNS(pp, pi, NULL, 0, &tRNS);
-2. }
-1. #endif
/* The number of passes is related to the interlace type. There was no libpn",Useful
"/*16 pixels, max 8 bytes each - 128 bytes*/","-10.       default: png_error(pp, ""invalid color type"");
-9.       case 0:  return bit_depth;
-8.       case 2:  return 3*bit_depth;
-7.       case 3:  return bit_depth;
-6.       case 4:  return 2*bit_depth;
-5.       case 6:  return 4*bit_depth;
-4.    ",Useful
/*Maximum range of size images*/,"-10.       case 2:  return 3*bit_depth;
-9.       case 3:  return bit_depth;
-8.       case 4:  return 2*bit_depth;
-7.       case 6:  return 4*bit_depth;
-6.    }
-5. }
-4. #define TRANSFORM_WIDTH  128U
-3. #define TRANSFORM_ROWMAX (TRANSFORM_WIDTH*8U)

",Useful
"/*transform_width(pp, colour_type, bit_depth) current returns the same number
 * every time, so just use a macro:*/","-6. static size_t
-5. transform_rowsize(png_const_structp pp, png_byte colour_type,
-4.    png_byte bit_depth)
-3. {
-2.    return (TRANSFORM_WIDTH * bit_size(pp, colour_type, bit_depth)) / 8;
-1. }
/* transform_width(pp, colour_type, bit_depth) current r",Useful
"/*Error, will be caught later*/","-2. #        define TRANSFORM_HEIGHTMAX 2048
-1.       default:

 /*Error, will be caught later*/

1.    }
2. }
3. #ifdef PNG_READ_SUPPORTED",Useful
"/*The following can only be defined here, now we have the definitions
 * of the transform image sizes.*/","-3.    }
-2. }
-1. #ifdef PNG_READ_SUPPORTED
/* The following can only be defined here, now we have the definitions
 * of the transform image sizes.

 /*The following can only be defined here, now we have the definitions
 * of the transform image sizes.*/",Useful
"/*256 bytes total, 128 bytes in each row set as follows:*/","-10.       case 1:
-9.          while (i<128/8) buffer[i] = (png_byte)(v & 0xff), v += 17, ++i;
-8.          return;
-7.       case 2:
-6.          while (i<128/4) buffer[i] = (png_byte)(v & 0xff), v += 33, ++i;
-5.          return;
-4.       case 4:
-3. ",Useful
"/*Generate all 65536 pixel values in order, which includes the 8 bit
          * GA case as well as the 16 bit G case.*/","-3.          while (i<128) buffer[i] = (png_byte)(v & 0xff), ++v, ++i;
-2.          return;
-1.       case 16:
         /* Generate all 65536 pixel values in order, which includes the 8 bit
          * GA case as well as the 16 bit G case.

 /*Generate al",Useful
"/*65535 pixels, but rotate the values.*/","-10.           */
-9.          while (i<128)
-8.          {
-7.             buffer[2*i] = (png_byte)((v>>8) & 0xff);
-6.             buffer[2*i+1] = (png_byte)(v & 0xff);
-5.             ++v;
-4.             ++i;
-3.          }
-2.          return;
-1.   ",Useful
"/*Three bytes per pixel, r, g, b, make b by r^g*/","-2.          while (i<128)
-1.          {

 /*Three bytes per pixel, r, g, b, make b by r^g*/

1.             buffer[3*i+0] = (png_byte)((v >> 8) & 0xff);
2.             buffer[3*i+1] = (png_byte)(v & 0xff);
3.             buffer[3*i+2] = (png_byte)(((v >",Useful
"/*y is maximum 2047, giving 4x65536 pixels, make 'r' increase by 1 at
          * each pixel, g increase by 257 (0x101) and 'b' by 0x1111:*/","-10.          {
-9.             buffer[4*i+0] = (png_byte)((v >> 8) & 0xff);
-8.             buffer[4*i+1] = (png_byte)(v & 0xff);
-7.             buffer[4*i+2] = (png_byte)((v >> 8) & 0xff);
-6.             buffer[4*i+3] = (png_byte)(v & 0xff);
-5.      ",Useful
"/*This is just to do the right cast - could be changed to a function to check
 * 'bd' but there isn't much point.*/","-10.             buffer[8*i+6] = (png_byte)((t >> 8) & 0xff);
-9.             buffer[8*i+7] = (png_byte)(t & 0xff);
-8.             ++i;
-7.          }
-6.          return;
-5.       default:
-4.          break;
-3.    }
-2.    png_error(pp, ""internal err",Useful
"/*This is just a helper for compiling on minimal systems with no write
 * interlacing support.  If there is no write interlacing we can't generate test
 * cases with interlace:*/","-1. #define DEPTH(bd) ((png_byte)(1U << (bd)))
/* This is just a helper for compiling on minimal systems with no write
 * interlacing support.  If there is no write interlacing we can't generate test
 * cases with interlace:

 /*This is just a helper for ",Useful
"/*Prior to 1.7.0 libpng does not support the write of an interlaced image
    * unless PNG_WRITE_INTERLACING_SUPPORTED, even with do_interlace so the
    * code here does the pixel interlace itself, so:*/","-10. #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-9. #  define INTERLACE_LAST PNG_INTERLACE_LAST
-8. #  define check_interlace_type(type) ((void)(type))
-7. #  define set_write_interlace_handling(pp,type) png_set_interlace_handling(pp)
-6. #  define do_own_int",Useful
"/*This is an internal error - --interlace tests should be skipped, not
       * attempted.*/","-2.    if (interlace_type != PNG_INTERLACE_NONE)
-1.    {
      /* This is an internal error - --interlace tests should be skipped, not
       * attempted.

 /*This is an internal error - --interlace tests should be skipped, not
       * attempted.*/

1. ",Useful
"/*Do the same thing for read interlacing; this controls whether read tests do
 * their own de-interlace or use libpng.*/","-5. #if PNG_LIBPNG_VER >= 10700 || defined PNG_WRITE_INTERLACING_SUPPORTED
-4. #   define CAN_WRITE_INTERLACE 1
-3. #else
-2. #   define CAN_WRITE_INTERLACE 0
-1. #endif
/* Do the same thing for read interlacing; this controls whether read tests do
 * the",Useful
"/*Note that this can, trivially, be optimized to a memcpy on pass 7, the
    * code is presented this way to make it easier to understand.  In practice
    * consult the code in the libpng source to see other ways of doing this.
    *
    * It is OK for buffer and imageRow to be identical, because 'xin' moves
    * faster than 'xout' and we copy up.*/","-5. static void
-4. interlace_row(png_bytep buffer, png_const_bytep imageRow,
-3.    unsigned int pixel_size, png_uint_32 w, int pass, int littleendian)
-2. {
-1.    png_uint_32 xin, xout, xstep;
   /* Note that this can, trivially, be optimized to a memc",Useful
"/*The inverse of the above, 'row' is part of row 'y' of the output image,
    * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute
    * the pixels of row into buffer and return the number written (to allow
    * this to be checked).*/","-10.    {
-9.       pixel_copy(buffer, xout, imageRow, xin, pixel_size, littleendian);
-8.       ++xout;
-7.    }
-6. }
-5. #ifdef PNG_READ_SUPPORTED
-4. static void
-3. deinterlace_row(png_bytep buffer, png_const_bytep row,
-2.    unsigned int pixel_size",Useful
"/*Make a standardized image given an image colour type, bit depth and
 * interlace type.  The standard images have a very restricted range of
 * rows and heights and are used for testing transforms rather than image
 * layout details.  See make_size_images below for a way to make images
 * that test odd sizes along with the libpng interlace handling.*/","
/* Make a standardized image given an image colour type, bit depth and
 * interlace type.  The standard images have a very restricted range of
 * rows and heights and are used for testing transforms rather than image
 * layout details.  See make_size_images below for a way to make images
 * that test odd sizes along with the libpng interlace handling.



 /*Make a standardized image given an image colour type, bit depth and
 * interlace type.  The standard images have a very restricted range of
 * rows and heights and are used for testing transforms rather than image
 * layout details.  See make_size_images below for a way to make images
 * that test odd sizes along with the libpng interlace handling.*/

1.  */
2. #ifdef PNG_WRITE_FILTER_SUPPORTED
3. static void
4. choose_random_filter(png_structp pp, int start)
5. {",Useful
"/*Choose filters randomly except that on the very first row ensure that
    * there is at least one previous row filter.*/","-4. #ifdef PNG_WRITE_FILTER_SUPPORTED
-3. static void
-2. choose_random_filter(png_structp pp, int start)
-1. {
   /* Choose filters randomly except that on the very first row ensure that
    * there is at least one previous row filter.

 /*Choose filters",Useful
"/*In the event of a problem return control to the Catch statement below
       * to do the clean up - it is not possible to 'return' directly from a Try
       * block.*/","-10.     png_byte const bit_depth, unsigned int palette_number,
-9.     int interlace_type, png_const_charp name)
-8. {
-7.    context(ps, fault);
-6.    check_interlace_type(interlace_type);
-5.    Try
-4.    {
-3.       png_infop pi;
-2.       png_struc",Useful
"/*Use a compressed text string to test the correct interaction of text
          * compression and IDAT compression.*/","-3.          size_t pos;
-2.          png_text text;
-1.          char copy[FILE_NAME_SIZE];
         /* Use a compressed text string to test the correct interaction of text
          * compression and IDAT compression.

 /*Use a compressed text string to",Useful
"/*Somewhat confusingly this must be called *after* png_write_info
          * because if it is called before, the information in *pp has not been
          * updated to reflect the interlaced image.*/","-10. #     ifdef PNG_WRITE_tRNS_SUPPORTED
-9.          else if (palette_number)
-8.             set_random_tRNS(pp, pi, colour_type, bit_depth);
-7. #     endif
-6.       png_write_info(pp, pi);
-5.       if (png_get_rowbytes(pp, pi) !=
-4.           tran",Useful
"/*do_own_interlace is a pre-defined boolean (a #define) which is
             * set if we have to work out the interlaced rows here.*/","-10.           * because if it is called before, the information in *pp has not been
-9.           * updated to reflect the interlaced image.
-8.           */
-7.          int npasses = set_write_interlace_handling(pp, interlace_type);
-6.          int pa",Useful
"/*If do_own_interlace *and* the image is interlaced we need a
                   * reduced interlace row; this may be reduced to empty.*/","-5.             for (y=0; y<h; ++y)
-4.             {
-3.                png_byte buffer[TRANSFORM_ROWMAX];
-2.                transform_row(pp, buffer, colour_type, bit_depth, y);
-1. #              if do_own_interlace
                  /* If do_own_inte",Useful
"/*The row must not be written if it doesn't exist, notice
                      * that there are two conditions here, either the row isn't
                      * ever in the pass or the row would be but isn't wide
                      * enough to contribute any pixels.  In fact the wPass test
                      * can be used to skip the whole y loop in this case.*/","-2.                   if (interlace_type == PNG_INTERLACE_ADAM7)
-1.                   {
                     /* The row must not be written if it doesn't exist, notice
                      * that there are two conditions here, either the row isn't
     ",Useful
"/*Use a compressed text string to test the correct interaction of text
          * compression and IDAT compression.*/","-3.          size_t pos;
-2.          png_text text;
-1.          char copy[FILE_NAME_SIZE];
         /* Use a compressed text string to test the correct interaction of text
          * compression and IDAT compression.

 /*Use a compressed text string to",Useful
"/*Use the png_store returned by the exception. This may help the compiler
       * because 'ps' is not used in this branch of the setjmp.  Note that fault
       * and ps will always be the same value.*/","-6.       store_storefile(ps, FILEID(colour_type, bit_depth, palette_number,
-5.          interlace_type, 0, 0, 0));
-4.       store_write_reset(ps);
-3.    }
-2.    Catch(fault)
-1.    {
      /* Use the png_store returned by the exception. This may help",Useful
/*This is in case of errors.*/,"-10.        */
-9.       store_write_reset(fault);
-8.    }
-7. }
-6. static void
-5. make_transform_images(png_modifier *pm)
-4. {
-3.    png_byte colour_type = 0;
-2.    png_byte bit_depth = 0;
-1.    unsigned int palette_number = 0;

 /*This is in case",Useful
"/*Use next_format to enumerate all the combinations we test, including
    * generating multiple low bit depth palette images. Non-A images (palette
    * and direct) are created with and without tRNS chunks.*/","-1.    safecat(pm->this.test, sizeof pm->this.test, 0, ""make standard images"");
   /* Use next_format to enumerate all the combinations we test, including
    * generating multiple low bit depth palette images. Non-A images (palette
    * and direct) are ",Useful
"/*Build a single row for the 'size' test images; this fills in only the
 * first bit_width bits of the sample row.*/","-10.            interlace_type < INTERLACE_LAST; ++interlace_type)
-9.       {
-8.          char name[FILE_NAME_SIZE];
-7.          standard_name(name, sizeof name, 0, colour_type, bit_depth,
-6.             palette_number, interlace_type, 0, 0, do_own_in",Useful
"/*height is in the range 1 to 16, so:*/","-3. static void
-2. size_row(png_byte buffer[SIZE_ROWMAX], png_uint_32 bit_width, png_uint_32 y)
-1. {

 /*height is in the range 1 to 16, so:*/

1.    y = ((y & 1) << 7) + ((y & 2) << 6) + ((y & 4) << 5) + ((y & 8) << 4);",Useful
/*the following ensures bits are set in small images:*/,"-1.    y = ((y & 1) << 7) + ((y & 2) << 6) + ((y & 4) << 5) + ((y & 8) << 4);

 /*the following ensures bits are set in small images:*/

1.    y ^= 0xA5;
2.    while (bit_width >= 8)
3.       *buffer++ = (png_byte)y++, bit_width -= 8;",Useful
/*Make a name and get an appropriate id for the store:*/,"-10.     png_uint_32 const w, png_uint_32 const h,
-9.     int const do_interlace)
-8. {
-7.    context(ps, fault);
-6.    check_interlace_type(interlace_type);
-5.    Try
-4.    {
-3.       png_infop pi;
-2.       png_structp pp;
-1.       unsigned int p",Useful
"/*In the event of a problem return control to the Catch statement below
       * to do the clean up - it is not possible to 'return' directly from a Try
       * block.*/","-10.     png_byte const bit_depth, unsigned int palette_number,
-9.     int interlace_type, png_const_charp name)
-8. {
-7.    context(ps, fault);
-6.    check_interlace_type(interlace_type);
-5.    Try
-4.    {
-3.       png_infop pi;
-2.       png_struc",Useful
"/*Use a compressed text string to test the correct interaction of text
          * compression and IDAT compression.*/","-3.          size_t pos;
-2.          png_text text;
-1.          char copy[FILE_NAME_SIZE];
         /* Use a compressed text string to test the correct interaction of text
          * compression and IDAT compression.

 /*Use a compressed text string to",Useful
"/*Calculate the bit size, divide by 8 to get the byte size - this won't
       * overflow because we know the w values are all small enough even for
       * a system where 'unsigned int' is only 16 bits.*/","-1.       png_write_info(pp, pi);
      /* Calculate the bit size, divide by 8 to get the byte size - this won't
       * overflow because we know the w values are all small enough even for
       * a system where 'unsigned int' is only 16 bits.

 /*Calcu",Useful
"/*To help consistent error detection make the parts of this buffer
          * that aren't set below all '1':*/","-10.        */
-9.       pixel_size = bit_size(pp, colour_type, bit_depth);
-8.       if (png_get_rowbytes(pp, pi) != ((w * pixel_size) + 7) / 8)
-7.          png_error(pp, ""size row size incorrect"");
-6.       else
-5.       {
-4.          int npasses = ",Useful
/*Prepare the whole image first to avoid making it 7 times:*/,"-4.          memset(image, 0xff, sizeof image);
-3.          if (!do_interlace &&
-2.              npasses != set_write_interlace_handling(pp, interlace_type))
-1.             png_error(pp, ""write: png_set_interlace_handling failed"");

 /*Prepare the whol",Useful
/*The following two are for checking the macros:*/,"-4.          for (y=0; y<h; ++y)
-3.             size_row(image[y], w * pixel_size, y);
-2.          for (pass=0; pass<npasses; ++pass)
-1.          {

 /*The following two are for checking the macros:*/

1.             const png_uint_32 wPass = PNG_PASS_",Useful
"/*If do_interlace is set we don't call png_write_row for every
             * row because some of them are empty.  In fact, for a 1x1 image,
             * most of them are empty!*/","-1.             const png_uint_32 wPass = PNG_PASS_COLS(w, pass);
            /* If do_interlace is set we don't call png_write_row for every
             * row because some of them are empty.  In fact, for a 1x1 image,
             * most of them are emp",Useful
"/*If do_interlace *and* the image is interlaced we
                * need a reduced interlace row; this may be reduced
                * to empty.*/","-4.             for (y=0; y<h; ++y)
-3.             {
-2.                png_const_bytep row = image[y];
-1.                png_byte tempRow[SIZE_ROWMAX];
               /* If do_interlace *and* the image is interlaced we
                * need a reduced ",Useful
"/*The row must not be written if it doesn't exist, notice
                   * that there are two conditions here, either the row isn't
                   * ever in the pass or the row would be but isn't wide
                   * enough to contribute any pixels.  In fact the wPass test
                   * can be used to skip the whole y loop in this case.*/","-2.                   if (interlace_type == PNG_INTERLACE_ADAM7)
-1.                   {
                     /* The row must not be written if it doesn't exist, notice
                      * that there are two conditions here, either the row isn't
     ",Useful
"/*Set to all 1's for error detection (libpng tends to
                      * set unset things to 0).*/","-2.                   if (PNG_ROW_IN_INTERLACE_PASS(y, pass) && wPass > 0)
-1.                   {
                     /* Set to all 1's for error detection (libpng tends to
                      * set unset things to 0).

 /*Set to all 1's for error det",Useful
"/*Only get to here if the row has some pixels in it, set the
                * filters to 'all' for the very first row and thereafter to a
                * single filter.  It isn't well documented, but png_set_filter
                * does accept a filter number (per the spec) as well as a bit
                * mask.
                *
                * The code now uses filters at random, except that on the first
                * row of an image it ensures that a previous row filter is in
                * the set so that libpng allocates the row buffer.*/","-6.                      row = tempRow;
-5.                   }
-4.                   else
-3.                      continue;
-2.                }
-1. #           ifdef PNG_WRITE_FILTER_SUPPORTED
               /* Only get to here if the row has some pixe",Useful
"/*Use a compressed text string to test the correct interaction of text
          * compression and IDAT compression.*/","-3.          size_t pos;
-2.          png_text text;
-1.          char copy[FILE_NAME_SIZE];
         /* Use a compressed text string to test the correct interaction of text
          * compression and IDAT compression.

 /*Use a compressed text string to",Useful
"/*Use the png_store returned by the exception. This may help the compiler
       * because 'ps' is not used in this branch of the setjmp.  Note that fault
       * and ps will always be the same value.*/","-6.       store_storefile(ps, FILEID(colour_type, bit_depth, palette_number,
-5.          interlace_type, 0, 0, 0));
-4.       store_write_reset(ps);
-3.    }
-2.    Catch(fault)
-1.    {
      /* Use the png_store returned by the exception. This may help",Useful
"/*The four combinations of DIY interlace and interlace or not -
             * no interlace + DIY should be identical to no interlace with
             * libpng doing it.*/","-10.     int const bdhi)
-9. {
-8.    for (; bdlo <= bdhi; ++bdlo)
-7.    {
-6.       png_uint_32 width;
-5.       for (width = 1; width <= 16; ++width)
-4.       {
-3.          png_uint_32 height;
-2.          for (height = 1; height <= 16; ++height)
-1.",Useful
"/*1.7.0 removes the hack that prevented app write of an interlaced
             * image if WRITE_INTERLACE was not supported*/","-10.              */
-9.             make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,
-8.                width, height, 0);
-7.             make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,
-6.                width, height",Useful
/*This is in case of errors.*/,"-10.        */
-9.       store_write_reset(fault);
-8.    }
-7. }
-6. static void
-5. make_transform_images(png_modifier *pm)
-4. {
-3.    png_byte colour_type = 0;
-2.    png_byte bit_depth = 0;
-1.    unsigned int palette_number = 0;

 /*This is in case",Useful
"/*Arguments are colour_type, low bit depth, high bit depth*/","-1.    safecat(ps->test, sizeof ps->test, 0, ""make size images"");
   /* Arguments are colour_type, low bit depth, high bit depth

 /*Arguments are colour_type, low bit depth, high bit depth*/

1.     */
2.    make_size(ps, 0, 0, WRITE_BDHI);
3.    make_si",Useful
/*Return a row based on image id and 'y' for checking:*/,"-4.    make_size(ps, 4, 3, WRITE_BDHI);
-3.    make_size(ps, 6, 3, WRITE_BDHI);
-2. }
-1. #ifdef PNG_READ_SUPPORTED

 /*Return a row based on image id and 'y' for checking:*/

1. static void
2. standard_row(png_const_structp pp, png_byte std[STANDARD_ROWM",Useful
"/*Like 'make_standard' but errors are deliberately introduced into the calls
 * to ensure that they get detected - it should not be possible to write an
 * invalid image with libpng!*/","
/* Like 'make_standard' but errors are deliberately introduced into the calls
 * to ensure that they get detected - it should not be possible to write an
 * invalid image with libpng!



 /*Like 'make_standard' but errors are deliberately introduced into the calls
 * to ensure that they get detected - it should not be possible to write an
 * invalid image with libpng!*/

1.  */",Useful
"/*TODO: the 'set' functions can probably all be made to take a
 * png_const_structp rather than a modifiable one.*/","
/* TODO: the 'set' functions can probably all be made to take a
 * png_const_structp rather than a modifiable one.



 /*TODO: the 'set' functions can probably all be made to take a
 * png_const_structp rather than a modifiable one.*/

1.  */
2. #ifdef PNG_WARNINGS_SUPPORTED
3. static void
4. sBIT0_error_fn(png_structp pp, png_infop pi)
5. {",Useful
/*Now we know the bit depth we can easily generate an invalid sBIT entry*/,"-10. }
-9. static void
-8. sBIT_error_fn(png_structp pp, png_infop pi)
-7. {
-6.    png_byte bit_depth;
-5.    png_color_8 bad;
-4.    if (png_get_color_type(pp, pi) == PNG_COLOR_TYPE_PALETTE)
-3.       bit_depth = 8;
-2.    else
-1.       bit_depth = png",Useful
/*no warnings makes these errors undetectable prior to 1.7.0*/,"-2. } error_test[] =
-1.     {

 /*no warnings makes these errors undetectable prior to 1.7.0*/

1.        { sBIT0_error_fn, ""sBIT(0): failed to detect error"",
2.          PNG_LIBPNG_VER < 10700 },
3.        { sBIT_error_fn, ""sBIT(too big): failed to dete",Useful
"/*Time for a few errors; these are in various optional chunks, the
       * standard tests test the standard chunks pretty well.*/","
      /* Time for a few errors; these are in various optional chunks, the
       * standard tests test the standard chunks pretty well.



 /*Time for a few errors; these are in various optional chunks, the
       * standard tests test the standard chunks pretty well.*/

1.        */
2. #     define exception__prev exception_prev_1
3. #     define exception__env exception_env_1
4.       Try
5.       {
6.          gnu_volatile(exception__prev)",Useful
/*Normally the error is only detected here:*/,"-4.          ps->expect_error = !error_test[test].warning;
-3.          ps->expect_warning = error_test[test].warning;
-2.          ps->saw_warning = 0;
-1.          error_test[test].fn(pp, pi);

 /*Normally the error is only detected here:*/

1.         ",Useful
"/*If we get here there is a problem, we have success - no error or
          * no warning - when we shouldn't have success.  Log an error.*/","-2.          if (ps->expect_warning && ps->saw_warning)
-1.             Throw ps;
         /* If we get here there is a problem, we have success - no error or
          * no warning - when we shouldn't have success.  Log an error.

 /*If we get here there",Useful
"/*Now write the whole image, just to make sure that the detected, or
          * undetected, error has not created problems inside libpng.  This
          * doesn't work if there was a png_error in png_write_info because that
          * can abort before PLTE was written.*/","-5.       ps->expect_warning = 0;
-4.       if (ps->expect_error)
-3.          ps->expect_error = 0;
-2.       else
-1.       {
         /* Now write the whole image, just to make sure that the detected, or
          * undetected, errro has not created pr",Useful
"/*If do_own_interlace *and* the image is interlaced we
                      * need a reduced interlace row; this may be reduced to
                      * empty.*/","-10.             if (npasses != npasses_from_interlace_type(pp, interlace_type))
-9.                png_error(pp, ""write: png_set_interlace_handling failed"");
-8.             for (pass=0; pass<npasses; ++pass)
-7.             {
-6.                png_uint",Useful
"/*The row must not be written if it doesn't exist,
                         * notice that there are two conditions here, either the
                         * row isn't ever in the pass or the row would be but
                         * isn't wide enough to contribute any pixels.  In fact
                         * the wPass test can be used to skip the whole y loop
                         * in this case.*/","-2.                      if (interlace_type == PNG_INTERLACE_ADAM7)
-1.                      {
                        /* The row must not be written if it doesn't exist,
                         * notice that there are two conditions here, either the
   ",Useful
/*Need to do this here because we just write in this test.*/,"-4. static void
-3. perform_error_test(png_modifier *pm)
-2. {

 /*Need to do this here because we just write in this test.*/

1.    safecat(pm->this.test, sizeof pm->this.test, 0, ""error test"");
2.    if (!make_errors(pm, 0, 0, WRITE_BDHI))
3.       retu",Useful
"/*This is just to validate the internal PNG formatting code - if this fails
 * then the warning messages the library outputs will probably be garbage.*/","-10.    if (!make_errors(pm, 3, 0, 3))
-9.       return;
-8.    if (!make_errors(pm, 4, 3, WRITE_BDHI))
-7.       return;
-6.    if (!make_errors(pm, 6, 3, WRITE_BDHI))
-5.       return;
-4. #else
-3.    UNUSED(pm)
-2. #endif
-1. }
/* This is just to vali",Useful
"/*The handle into the formatting code is the RFC1123 support; this test does
    * nothing if that is compiled out.*/","-4. static void
-3. perform_formatting_test(png_store *ps)
-2. {
-1. #ifdef PNG_TIME_RFC1123_SUPPORTED
   /* The handle into the formatting code is the RFC1123 support; this test does
    * nothing if that is compiled out.

 /*The handle into the formatti",Useful
"/*Because we want to use the same code in both the progressive reader and the
 * sequential reader it is necessary to deal with the fact that the progressive
 * reader callbacks only have one parameter (png_get_progressive_ptr()), so this
 * must contain all the test parameters and all the local variables directly
 * accessible to the sequential reader implementation.
 *
 * The technique adopted is to reinvent part of what Dijkstra termed a
 * 'display'; an array of pointers to the stack frames of enclosing functions so
 * that a nested function definition can access the local (C auto) variables of
 * the functions that contain its definition.  In fact C provides the first
 * pointer (the local variables - the stack frame pointer) and the last (the
 * global variables - the BCPL global vector typically implemented as global
 * addresses), this code requires one more pointer to make the display - the
 * local variables (and function call parameters) of the function that actually
 * invokes either the progressive or sequential reader.
 *
 * Perhaps confusingly this technique is confounded with classes - the
 * 'standard_display' defined here is sub-classed as the 'gamma_display' below.
 * A gamma_display is a standard_display, taking advantage of the ANSI-C
 * requirement that the pointer to the first member of a structure must be the
 * same as the pointer to the structure.  This allows us to reuse standard_
 * functions in the gamma test code; something that could not be done with
 * nested functions!*/","-10.    }
-9.    Catch(fault)
-8.    {
-7.       store_write_reset(fault);
-6.    }
-5. #else
-4.    UNUSED(ps)
-3. #endif
-2. }
-1. #ifdef PNG_READ_SUPPORTED
/* Because we want to use the same code in both the progressive reader and the
 * sequential rea",Useful
/*Input data sBIT values.*/,"-2.    png_byte    colour_type;
-1.    png_byte    bit_depth;

 /*Input data sBIT values.*/

1.    png_byte    green_sBIT;
2.    png_byte    blue_sBIT;
3.    png_byte    alpha_sBIT;
4.    png_byte    interlace_type;",Useful
/*App (row) data is little endian*/,"-10.    png_byte    interlace_type;

 /*App (row) data is little endian*/

111",Useful
/*color type GRAY or RGB with a tRNS chunk.*/,"-10.    png_uint_32 id;             /* Calculated file ID */
-9.    png_uint_32 w;              /* Width of image */
-8.    png_uint_32 h;              /* Height of image */
-7.    int         npasses;        /* Number of interlaced passes */
-6.    png_u",Useful
"/*The transparent color, if set.*/","-5.    struct
-4.    {
-3.       png_uint_16 red;
-2.       png_uint_16 green;
-1.       png_uint_16 blue;

 /*The transparent color, if set.*/

111",Useful
/*Preset the transparent color to black:*/,"-10.    dp->npasses = 0;
-9.    dp->pixel_size = 0;
-8.    dp->bit_width = 0;
-7.    dp->cbRow = 0;
-6.    dp->do_interlace = do_interlace;
-5.    dp->littleendian = 0;
-4.    dp->is_transparent = 0;
-3.    dp->speed = ps->speed;
-2.    dp->use_update_inf",Useful
/*GCC can't handle the more obviously optimizable version.*/,"-4.       while (--i >= 0)
-3.          if (palette[i].alpha < 255)
-2.             break;
-1. #     ifdef __GNUC__

 /*GCC can't handle the more obviously optimizable version.*/

1.          if (i >= 0)
2.             dp->is_transparent = 1;
3.          ",Useful
"/*Utility to read the palette from the PNG file and convert it into
 * store_palette format.  This returns 1 if there is any transparency in the
 * palette (it does not check for a transparent colour in the non-palette case.)*/","-9.          if (i >= 0)
-8.             dp->is_transparent = 1;
-7.          else
-6.             dp->is_transparent = 0;
-5. #     else
-4.          dp->is_transparent = (i >= 0);
-3. #     endif
-2.    }
-1. }
/* Utility to read the palette from the PN",Useful
"/*Mark the remainder of the entries with a flag value (other than
       * white/opaque which is the flag value stored above.)*/","-10.    {
-9.       int i = *npalette;
-8.       if (i <= 0 || i > 256)
-7.          png_error(pp, ""validate: invalid PLTE count"");
-6.       while (--i >= 0)
-5.       {
-4.          palette[i].red = pal[i].red;
-3.          palette[i].green = pal[i].gre",Useful
/*returns 1 for a transparent color*/,"-1.    if ((png_get_tRNS(pp, pi, &trans_alpha, &num, 0) & PNG_INFO_tRNS) != 0 &&

 /*returns 1 for a transparent color*/

111",Useful
"/*Oops, if a palette tRNS gets expanded png_read_update_info (at least so
       * far as 1.5.4) does not remove the trans_alpha pointer, only num_trans,
       * so in the above call we get a success, we get a pointer (who knows what
       * to) and we get num_trans == 0:*/","/* Oops, if a palette tRNS gets expanded png_read_update_info (at least so
       * far as 1.5.4) does not remove the trans_alpha pointer, only num_trans,
       * so in the above call we get a success, we get a pointer (who knows what
       * to) and we get num_trans == 0:

 /*Oops, if a palette tRNS gets expanded png_read_update_info (at least so
       * far as 1.5.4) does not remove the trans_alpha pointer, only num_trans,
       * so in the above call we get a success, we get a pointer (who knows what
       * to) and we get num_trans == 0:*/

1.        */",Useful
/*TODO: fix this in libpng.*/,"-7.    if ((png_get_tRNS(pp, pi, &trans_alpha, &num, 0) & PNG_INFO_tRNS) != 0 &&

 /*TODO: fix this in libpng.*/

1.    {
2.       int i;",Useful
"/*Any of these are crash-worthy - given the implementation of
       * png_get_tRNS up to 1.5 an app won't crash if it just checks the
       * result above and fails to check that the variables it passed have
       * actually been filled in!  Note that if the app were to pass the
       * last, png_color_16p, variable too it couldn't rely on this.*/","-2.    {
-1.       int i;
      /* Any of these are crash-worthy - given the implementation of
       * png_get_tRNS up to 1.5 an app won't crash if it just checks the
       * result above and fails to check that the variables it passed have
       * act",Useful
/*No palette transparency - just set the alpha channel to opaque.*/,"-3.    }
-2.    else
-1.    {

 /*No palette transparency - just set the alpha channel to opaque.*/

1.       int i;
2.       for (i=0, num=*npalette; i<num; ++i)
3.          palette[i].alpha = 255;
4.       for (; i<256; ++i)",Useful
"/*Utility to validate the palette if it should not have changed (the
 * non-transform case).*/","-2.    }
-1. }
/* Utility to validate the palette if it should not have changed (the
 * non-transform case).

 /*Utility to validate the palette if it should not have changed (the
 * non-transform case).*/

1.  */
2. static void
3. standard_palette_valida",Useful
"/*By passing a 'standard_display' the progressive callbacks can be used
 * directly by the sequential code, the functions suffixed ""_imp"" are the
 * implementations, the functions without the suffix are the callbacks.
 *
 * The code for the info callback is split into two because this callback calls
 * png_read_update_info or png_start_read_image and what gets called depends on
 * whether the info needs updating (we want to test both calls in pngvalid.)*/","-8.       while (--i >= 0)
-7.          if (palette[i].red != dp->palette[i].red ||
-6.             palette[i].green != dp->palette[i].green ||
-5.             palette[i].blue != dp->palette[i].blue ||
-4.             palette[i].alpha != dp->palette[i].al",Useful
"/*Record (but don't check at present) the input sBIT according to the colour
    * type information.*/","-10.    if (png_get_interlace_type(pp, pi) != dp->interlace_type)
-9.       png_error(pp, ""validate: interlacing changed"");
-8.    if (png_get_compression_type(pp, pi) != PNG_COMPRESSION_TYPE_BASE)
-7.       png_error(pp, ""validate: compression type chang",Useful
"/*All 8 bits in tRNS for a palette image are significant - see the
          * spec.*/","-6.          {
-5.             if (sBIT->gray == 0 || sBIT->gray > dp->bit_depth)
-4.                sBIT_invalid = 1;
-3.             else
-2.                dp->blue_sBIT = dp->green_sBIT = dp->red_sBIT = sBIT->gray;
-1.          }
         /* All 8 bit",Useful
"/*Important: this is validating the value *before* any transforms have been
    * put in place.  It doesn't matter for the standard tests, where there are
    * no transforms, but it does for other tests where rowbytes may change after
    * png_read_update_info.*/","-10.          {
-9.             if (sBIT->alpha == 0 || sBIT->alpha > dp->bit_depth)
-8.                sBIT_invalid = 1;
-7.             else
-6.                dp->alpha_sBIT = sBIT->alpha;
-5.          }
-4.          if (sBIT_invalid)
-3.             p",Useful
"/*Validate the colour type 3 palette (this can be present on other color
    * types.)*/","-2.    if (png_get_rowbytes(pp, pi) != standard_rowsize(pp, dp->id))
-1.       png_error(pp, ""validate: row size changed"");
   /* Validate the colour type 3 palette (this can be present on other color
    * types.)

 /*Validate the colour type 3 palette (",Useful
"/*In any case always check for a transparent color (notice that the
    * colour type 3 case must not give a successful return on the get_tRNS call
    * with these arguments!)*/","nan


 /*In any case always check for a transparent color (notice that the
    * colour type 3 case must not give a successful return on the get_tRNS call
    * with these arguments!)*/

nan
",Useful
"/*Not expected because it should result in the array case
             * above.*/","-10.                trans_color->gray;
-9.             dp->has_tRNS = 1;
-8.             break;
-7.          case 2:
-6.             dp->transparent.red = trans_color->red;
-5.             dp->transparent.green = trans_color->green;
-4.             dp->tr",Useful
"/*Read the number of passes - expected to match the value used when
    * creating the image (interlaced or not).  This has the side effect of
    * turning on interlace handling (if do_interlace is not set.)*/","-7.             png_error(pp, ""validate: unexpected png_get_tRNS result"");
-6.             break;
-5.          default:
-4.             png_error(pp, ""validate: invalid tRNS chunk with alpha image"");
-3.          }
-2.       }
-1.    }
   /* Read the numb",Useful
"/*Caller calls png_read_update_info or png_start_read_image now, then calls
    * part2.*/","-1.    }
   /* Caller calls png_read_update_info or png_start_read_image now, then calls
    * part2.

 /*Caller calls png_read_update_info or png_start_read_image now, then calls
    * part2.*/

1.     */
2. }",Useful
"/*This must be called *after* the png_read_update_info call to get the correct
 * 'rowbytes' value, otherwise png_get_rowbytes will refer to the untransformed
 * image.*/","-1. }
/* This must be called *after* the png_read_update_info call to get the correct
 * 'rowbytes' value, otherwise png_get_rowbytes will refer to the untransformed
 * image.

 /*This must be called *after* the png_read_update_info call to get the correc",Useful
/*handle filler as faked alpha channel*/,"-5.    {
-4.       png_byte ct = png_get_color_type(pp, pi);
-3.       png_byte bd = png_get_bit_depth(pp, pi);
-2.       if (bd >= 8 && (ct == PNG_COLOR_TYPE_RGB || ct == PNG_COLOR_TYPE_GRAY) &&
-1.           dp->filler)

 /*handle filler as faked alpha ",Useful
/*Then ensure there is enough space for the output image(s).*/,"-2.    if (dp->cbRow != (dp->bit_width+7)/8)
-1.       png_error(pp, ""bad png_get_rowbytes calculation"");

 /*Then ensure there is enough space for the output image(s).*/

1.    store_ensure_image(dp->ps, pp, nImages, dp->cbRow, dp->h);
2. }
3. static voi",Useful
"/*Note that the validation routine has the side effect of turning on
    * interlace handling in the subsequent code.*/","-6.    store_ensure_image(dp->ps, pp, nImages, dp->cbRow, dp->h);
-5. }
-4. static void
-3. standard_info_imp(standard_display *dp, png_structp pp, png_infop pi,
-2.     int nImages)
-1. {
   /* Note that the validation routine has the side effect of turn",Useful
"/*And the info callback has to call this (or png_read_update_info - see
    * below in the png_modifier code for that variant.*/","-1.    standard_info_part1(dp, pp, pi);
   /* And the info callback has to call this (or png_read_update_info - see
    * below in the png_modifier code for that variant.

 /*And the info callback has to call this (or png_read_update_info - see
    * belo",Useful
/*For debugging the effect of multiple calls:*/,"-2.    if (dp->use_update_info)
-1.    {

 /*For debugging the effect of multiple calls:*/

1.       int i = dp->use_update_info;
2.       while (i-- > 0)
3.          png_read_update_info(pp, pi);
4.    }
5.    else
6.       png_start_read_image(pp);",Useful
"/*Validate the height, width and rowbytes plus ensure that sufficient buffer
    * exists for decoding the image.*/","-6.       int i = dp->use_update_info;
-5.       while (i-- > 0)
-4.          png_read_update_info(pp, pi);
-3.    }
-2.    else
-1.       png_start_read_image(pp);
   /* Validate the height, width and rowbytes plus ensure that sufficient buffer
    * exi",Useful
"/*Call with nImages==1 because the progressive reader can only produce one
    * image.*/","-7.    standard_info_part2(dp, pp, pi, nImages);
-6. }
-5. static void PNGCBAPI
-4. standard_info(png_structp pp, png_infop pi)
-3. {
-2.    standard_display *dp = voidcast(standard_display*,
-1.       png_get_progressive_ptr(pp));
   /* Call with nImages",Useful
"/*When handling interlacing some rows will be absent in each pass, the
    * callback still gets called, but with a NULL pointer.  This is checked
    * in the 'else' clause below.  We need our own 'cbRow', but we can't call
    * png_get_rowbytes because we got no info structure.*/","-7. }
-6. static void PNGCBAPI
-5. progressive_row(png_structp ppIn, png_bytep new_row, png_uint_32 y, int pass)
-4. {
-3.    png_const_structp pp = ppIn;
-2.    const standard_display *dp = voidcast(standard_display*,
-1.       png_get_progressive_ptr(pp",Useful
"/*In the case where the reader doesn't do the interlace it gives
       * us the y in the sub-image:*/","-3.    if (new_row != NULL)
-2.    {
-1.       png_bytep row;
      /* In the case where the reader doesn't do the interlace it gives
       * us the y in the sub-image:

 /*In the case where the reader doesn't do the interlace it gives
       * us the y ",Useful
"/*wPass may be zero or this row may not be in this pass.
             * png_read_row must not be called in either case.*/","-10.    const png_store*  ps = dp->ps;
-9.    int pass;
-8.    for (pass=0; pass<npasses; ++pass)
-7.    {
-6.       png_uint_32 y;
-5.       png_uint_32 wPass = PNG_PASS_COLS(width, pass);
-4.       for (y=0; y<height; ++y)
-3.       {
-2.          if (d",Useful
"/*Read the row into a pair of temporary buffers, then do the
                * merge here into the output rows.*/","-2.             if (wPass > 0 && PNG_ROW_IN_INTERLACE_PASS(y, pass))
-1.             {
               /* Read the row into a pair of temporary buffers, then do the
                * merge here into the output rows.

 /*Read the row into a pair of temporar",Useful
"/*The following aids (to some extent) error detection - we can
                * see where png_read_row wrote.  Use opposite values in row and
                * display to make this easier.  Don't use 0xff (which is used in
                * the image write code to fill unused bits) or 0 (which is a
                * likely value to overwrite unused bits with).*/","-1.                png_byte row[STANDARD_ROWMAX], display[STANDARD_ROWMAX];
               /* The following aids (to some extent) error detection - we can
                * see where png_read_row wrote.  Use opposite values in row and
                * di",Useful
"/*And finish the read operation (only really necessary if the caller wants
    * to find additional data in png_info from chunks after the last IDAT.)*/","-10.                   deinterlace_row(store_image_row(ps, pp, iDisplay, y), display,
-9.                      dp->pixel_size, dp->w, pass, dp->littleendian);
-8.             }
-7.          }
-6.          else
-5.             png_read_row(pp,
-4.         ",Useful
"/*This exists because prior to 1.5.18 the progressive reader left the
       * png_struct z_stream unreset at the end of the image, so subsequent
       * attempts to use it simply returns Z_STREAM_END.*/","-10. }
-9. static void
-8. standard_text_validate(standard_display *dp, png_const_structp pp,
-7.    png_infop pi, int check_end)
-6. {
-5.    png_textp tp = NULL;
-4.    png_uint_32 num_text = png_get_text(pp, pi, &tp, NULL);
-3.    if (num_text == 2 && ",Useful
"/*The row must be pre-initialized to the magic number here for the size
    * tests to pass:*/","-10. }
-9. #else
-8. #  define standard_text_validate(dp,pp,pi,check_end) ((void)0)
-7. #endif
-6. static void
-5. standard_row_validate(standard_display *dp, png_const_structp pp,
-4.    int iImage, int iDisplay, png_uint_32 y)
-3. {
-2.    int where;
-1",Useful
"/*At the end both the 'row' and 'display' arrays should end up identical.
    * In earlier passes 'row' will be partially filled in, with only the pixels
    * that have been read so far, but 'display' will have those pixels
    * replicated to fill the unread pixels while reading an interlaced image.*/","-2.    memset(std, 178, sizeof std);
-1.    standard_row(pp, std, dp->id, y);
   /* At the end both the 'row' and 'display' arrays should end up identical.
    * In earlier passes 'row' will be partially filled in, with only the pixels
    * that have bee",Useful
/*This avoids false positives if the validation code is never called!*/,"-10. standard_image_validate(standard_display *dp, png_const_structp pp, int iImage,
-9.     int iDisplay)
-8. {
-7.    png_uint_32 y;
-6.    if (iImage >= 0)
-5.       store_image_check(dp->ps, pp, iImage);
-4.    if (iDisplay >= 0)
-3.       store_image",Useful
"/*Validate the image - progressive reading only produces one variant for
    * interlaced images.*/","-9.    dp->ps->validated = 1;
-8. }
-7. static void PNGCBAPI
-6. standard_end(png_structp ppIn, png_infop pi)
-5. {
-4.    png_const_structp pp = ppIn;
-3.    standard_display *dp = voidcast(standard_display*,
-2.       png_get_progressive_ptr(pp));
-1.  ",Useful
"/*Set up the display (stack frame) variables from the arguments to the
    * function and initialize the locals that are filled in later.*/","-6. static void
-5. standard_test(png_store* const psIn, png_uint_32 const id,
-4.    int do_interlace, int use_update_info)
-3. {
-2.    standard_display d;
-1.    context(psIn, fault);
   /* Set up the display (stack frame) variables from the arguments ",Useful
"/*Everything is protected by a Try/Catch.  The functions called also
    * typically have local Try/Catch blocks.*/","-1.    standard_display_init(&d, psIn, id, do_interlace, use_update_info);
   /* Everything is protected by a Try/Catch.  The functions called also
    * typically have local Try/Catch blocks.

 /*Everything is protected by a Try/Catch.  The functions cal",Useful
"/*Get a png_struct for reading the image. This will throw an error if it
       * fails, so we don't need to check the result.*/","-4.    Try
-3.    {
-2.       png_structp pp;
-1.       png_infop pi;
      /* Get a png_struct for reading the image. This will throw an error if it
       * fails, so we don't need to check the result.

 /*Get a png_struct for reading the image. This wi",Useful
/*Introduce the correct read function.*/,"-1.       standard_palette_init(&d);

 /*Introduce the correct read function.*/

1.       if (d.ps->progressive)
2.       {
3.          png_set_progressive_read_fn(pp, &d, standard_info, progressive_row,
4.             standard_end);",Useful
/*Now feed data into the reader until we reach the end:*/,"-4.       if (d.ps->progressive)
-3.       {
-2.          png_set_progressive_read_fn(pp, &d, standard_info, progressive_row,
-1.             standard_end);

 /*Now feed data into the reader until we reach the end:*/

1.          store_progressive_read(d.",Useful
"/*Note that this takes the store, not the display.*/","-4.          store_progressive_read(d.ps, pp, pi);
-3.       }
-2.       else
-1.       {

 /*Note that this takes the store, not the display.*/

1.          png_set_read_fn(pp, d.ps, store_read);",Useful
/*Check the header values:*/,"-1.          png_set_read_fn(pp, d.ps, store_read);

 /*Check the header values:*/

1.          png_read_info(pp, pi);",Useful
"/*The code tests both versions of the images that the sequential
          * reader can produce.*/","-1.          png_read_info(pp, pi);
         /* The code tests both versions of the images that the sequential
          * reader can produce.

 /*The code tests both versions of the images that the sequential
          * reader can produce.*/

1.        ",Useful
"/*Need the total bytes in the image below; we can't get to this point
          * unless the PNG file values have been checked against the expected
          * values.*/","
         /* Need the total bytes in the image below; we can't get to this point
          * unless the PNG file values have been checked against the expected
          * values.



 /*Need the total bytes in the image below; we can't get to this point
          * unless the PNG file values have been checked against the expected
          * values.*/

1.           */
2.          {
3.             sequential_row(&d, pp, pi, 0, 1);",Useful
"/*After the last pass loop over the rows again to check that the
             * image is correct.*/","-2.          {
-1.             sequential_row(&d, pp, pi, 0, 1);
            /* After the last pass loop over the rows again to check that the
             * image is correct.

 /*After the last pass loop over the rows again to check that the
            ",Useful
/*Check for validation.*/,"-6.                standard_image_validate(&d, pp, 0, 1);
-5.             }
-4.             else
-3.                d.ps->validated = 1;
-2.          }
-1.       }

 /*Check for validation.*/

1.       if (!d.ps->validated)
2.          png_error(pp, ""imag",Useful
/*In either case clean up the store.*/,"-3.    }
-2.    Catch(fault)

 /*In either case clean up the store.*/

1.    store_read_reset(d.ps);
2. }
3. static int
4. test_standard(png_modifier* const pm, png_byte const colour_type,
5.     int bdlo, int const bdhi)
6. {
7.    for (; bdlo <= bdhi; +",Useful
"/*Test each colour type over the valid range of bit depths (expressed as
    * log2(bit_depth) in turn, stop as soon as any error is detected.*/","-4. }
-3. static void
-2. perform_standard_test(png_modifier *pm)
-1. {
   /* Test each colour type over the valid range of bit depths (expressed as
    * log2(bit_depth) in turn, stop as soon as any error is detected.

 /*Test each colour type over the v",Useful
"/*Run the tests on each combination.
    *
    * NOTE: on my 32 bit x86 each of the following blocks takes
    * a total of 3.5 seconds if done across every combo of bit depth
    * width and height.  This is a waste of time in practice, hence the
    * hinc and winc stuff:*/","-4. static int
-3. test_size(png_modifier* const pm, png_byte const colour_type,
-2.     int bdlo, int const bdhi)
-1. {
   /* Run the tests on each combination.
    *
    * NOTE: on my 32 bit x86 each of the following blocks takes
    * a total of 3.5 se",Useful
"/*First test all the 'size' images against the sequential
          * reader using libpng to deinterlace (where required.)  This
          * validates the write side of libpng.  There are four possibilities
          * to validate.*/","-10.     * hinc and winc stuff:
-9.     */
-8.    static const png_byte hinc[] = {1, 3, 11, 1, 5};
-7.    static const png_byte winc[] = {1, 9, 5, 7, 1};
-6.    const int save_bdlo = bdlo;
-5.    for (; bdlo <= bdhi; ++bdlo)
-4.    {
-3.       png_uint_32",Useful
"/*Now validate the interlaced read side - do_interlace true,
          * in the progressive case this does actually make a difference
          * to the code used in the non-interlaced case too.*/","-3.             pm->use_update_info);
-2.          if (fail(pm))
-1.             return 0;
         /* Now validate the interlaced read side - do_interlace true,
          * in the progressive case this does actually make a difference
          * to the c",Useful
"/*Now do the tests of libpng interlace handling, after we have made sure
    * that the pngvalid version works:*/","-6.             pm->use_update_info);
-5.          if (fail(pm))
-4.             return 0;
-3. #     endif
-2.       }
-1.    }
   /* Now do the tests of libpng interlace handling, after we have made sure
    * that the pngvalid version works:

 /*Now do ",Useful
"/*Test with pngvalid generated interlaced images first; we have
          * already verify these are ok (unless pngvalid has self-consistent
          * read/write errors, which is unlikely), so this detects errors in the
          * read side first:*/","-6.    for (bdlo = save_bdlo; bdlo <= bdhi; ++bdlo)
-5.    {
-4.       png_uint_32 h, w;
-3.       for (h=1; h<=16; h+=hinc[bdlo]) for (w=1; w<=16; w+=winc[bdlo])
-2.       {
-1. #     ifdef PNG_READ_INTERLACING_SUPPORTED
         /* Test with pngvalid ge",Useful
"/*Test each colour type over the valid range of bit depths (expressed as
    * log2(bit_depth) in turn, stop as soon as any error is detected.*/","-4. }
-3. static void
-2. perform_standard_test(png_modifier *pm)
-1. {
   /* Test each colour type over the valid range of bit depths (expressed as
    * log2(bit_depth) in turn, stop as soon as any error is detected.

 /*Test each colour type over the v",Useful
"/*For the moment don't do the palette test - it's a waste of time when
    * compared to the grayscale test.*/","-4.    if (!test_size(pm, 0, 0, READ_BDHI))
-3.       return;
-2.    if (!test_size(pm, 2, 3, READ_BDHI))
-1.       return;
   /* For the moment don't do the palette test - it's a waste of time when
    * compared to the grayscale test.

 /*For the moment",Useful
"/*A set of tests to validate libpng image transforms.  The possibilities here
 * are legion because the transforms can be combined in a combinatorial
 * fashion.  To deal with this some measure of restraint is required, otherwise
 * the tests would take forever.*/","-1. #ifdef PNG_READ_TRANSFORMS_SUPPORTED
/* A set of tests to validate libpng image transforms.  The possibilities here
 * are legion because the transforms can be combined in a combinatorial
 * fashion.  To deal with this some measure of restraint is req",Useful
/*For non-palette images.*/,"-5. typedef struct image_pixel
-4. {

 /*For non-palette images.*/

111",Useful
/*For a palette image.*/,"-10.  * are legion because the transforms can be combined in a combinatorial
-9.  * fashion.  To deal with this some measure of restraint is required, otherwise
-8.  * the tests would take forever.
-7.  */
-6. typedef struct image_pixel
-5. {

 /*For a pa",Useful
/*Defines bit size in row*/,"-10.  * the tests would take forever.
-9.  */
-8. typedef struct image_pixel
-7. {

 /*Defines bit size in row*/

111",Useful
"/*Alpha at start, not end*/","-10.    /* A local (pngvalid) representation of a PNG pixel, in all its
-9.     * various forms.
-8.     */
-7.    unsigned int red, green, blue, alpha; /* For non-palette images. */
-6.    unsigned int palette_index;           /* For a palette image. */
",Useful
/*Alpha channel inverted*/,"-10.     * various forms.
-9.     */

 /*Alpha channel inverted*/

111",Useful
/*Gray channel inverted*/,"-10.     */

 /*Gray channel inverted*/

111",Useful
"/*For checking the code calculates double precision floating point values
    * along with an error value, accumulated from the transforms.  Because an
    * sBIT setting allows larger error bounds (indeed, by the spec, apparently
    * up to just less than +/-1 in the scaled value) the *lowest* sBIT for each
    * channel is stored.  This sBIT value is folded in to the stored error value
    * at the end of the application of the transforms to the pixel.
    *
    * If sig_bits is set above the red, green, blue and alpha values have been
    * scaled so they only contain the significant bits of the component values.*/","-10.    png_byte     bit_depth;               /* Defines bit size in row */
-9.    png_byte     sample_depth;            /* Scale of samples */
-8.    unsigned int have_tRNS :1;            /* tRNS chunk may need processing */
-7.    unsigned int swap_rgb ",Useful
"/*Initialize the structure for the next pixel - call this before doing any
 * transforms and call it for each pixel since all the fields may need to be
 * reset.*/","-10.       this->greene = 0;
-9.    if (this->blue < bMax)
-8.       this->bluee = this->bluef * DBL_EPSILON;
-7.    else
-6.       this->bluee = 0;
-5.    if (this->alpha < aMax)
-4.       this->alphae = this->alphaf * DBL_EPSILON;
-3.    else
-2.       ",Useful
"/*Initially just set everything to the same number and the alpha to opaque.
    * Note that this currently assumes a simple palette where entry x has colour
    * rgb(x,x,x)!*/","-7. {
-6.    const png_byte sample_depth = (png_byte)(colour_type ==
-5.       PNG_COLOR_TYPE_PALETTE ? 8 : bit_depth);
-4.    const unsigned int max = (1U<<sample_depth)-1;
-3.    const int swap16 = (format != 0 && format->swap16);
-2.    const int littl",Useful
/*This permits the caller to default to the sample value.*/,"-1.    {

 /*This permits the caller to default to the sample value.*/

1.       if (palette != 0)
2.       {
3.          const unsigned int i = this->palette_index;
4.          this->red = palette[i].red;
5.          this->green = palette[i].green;
6.   ",Useful
/*This handles the gray case for 'AG' pixels*/,"-5.    {
-4.       unsigned int i = 0;
-3.       if ((colour_type & 4) != 0 && format != 0 && format->alpha_first)
-2.       {
-1.          this->alpha = this->red;

 /*This handles the gray case for 'AG' pixels*/

1.          this->palette_index = this->",Useful
/*Green is second for both BGR and RGB:*/,"-6.          this->palette_index = this->red = this->green = this->blue =
-5.             sample(row, colour_type, bit_depth, x, 1, swap16, littleendian);
-4.          i = 1;
-3.       }
-2.       if (colour_type & 2)
-1.       {

 /*Green is second for b",Useful
/*grayscale*/,"-10. {
-9.    char number[64];
-8.    sprintf(number, ""%.*f"", precision, d);
-7.    return safecat(buffer, bufsize, pos, number);
-6. }
-5. #endif
-4. static const char invalid[] = ""invalid"";
-3. static const char sep[] = "": "";
-2. static const char *colo",Useful
"/*Calculate the scaled values, these are simply the values divided by
    * 'max' and the error is initialized to the double precision epsilon value
    * from the header file.*/","-8.       {
-7.          if (format == 0 || !format->alpha_first)
-6.              this->alpha = sample(row, colour_type, bit_depth, x, ++i, swap16,
-5.                      littleendian);
-4.          if (format != 0 && format->alpha_inverted)
-3.       ",Useful
"/*Store the input information for use in the transforms - these will
    * modify the information.*/","-5.    image_pixel_setf(this,
-4.       sig_bits ? (1U << format->red_sBIT)-1 : max,
-3.       sig_bits ? (1U << format->green_sBIT)-1 : max,
-2.       sig_bits ? (1U << format->blue_sBIT)-1 : max,
-1.       sig_bits ? (1U << format->alpha_sBIT)-1 : max);",Useful
"/*Convert a palette image to an rgb image.  This necessarily converts the tRNS
 * chunk at the same time, because the tRNS will be in palette form.  The way
 * palette validation works means that the original palette is never updated,
 * instead the image_pixel value from the row contains the RGB of the
 * corresponding palette entry and *this* is updated.  Consequently this routine
 * only needs to change the colour type information.*/","-10.    this->alpha_first = 0;
-9.    this->alpha_inverted = 0;
-8.    this->mono_inverted = 0;
-7.    this->swap16 = 0;
-6.    this->littleendian = 0;
-5.    this->sig_bits = 0;
-4. }
-3. #if defined PNG_READ_EXPAND_SUPPORTED || defined PNG_READ_GRAY_TO_",Useful
"/*The bit depth of the row changes at this point too (notice that this is
       * the row format, not the sample depth, which is separate.)*/","-10. {
-9.    if (this->colour_type == PNG_COLOR_TYPE_PALETTE)
-8.    {
-7.       if (this->have_tRNS)
-6.       {
-5.          this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;
-4.          this->have_tRNS = 0;
-3.       }
-2.       else
-1.          this->c",Useful
"/*Add an alpha channel; this will import the tRNS information because tRNS is
 * not valid in an alpha image.  The bit depth will invariably be set to at
 * least 8 prior to 1.7.0.  Palette images will be converted to alpha (using
 * the above API).  With png_set_background the alpha channel is never expanded
 * but this routine is used by pngvalid to simplify code; 'for_background'
 * records this.*/","-3.       this->bit_depth = 8;
-2.    }
-1. }
/* Add an alpha channel; this will import the tRNS information because tRNS is
 * not valid in an alpha image.  The bit depth will invariably be set to at
 * least 8 prior to 1.7.0.  Palette images will be con",Useful
"/*After 1.7 the expansion of bit depth only happens if there is a
             * tRNS chunk to expand at this point.*/","-10.    if ((this->colour_type & PNG_COLOR_MASK_ALPHA) == 0)
-9.    {
-8.       if (this->colour_type == PNG_COLOR_TYPE_GRAY)
-7.       {
-6. #        if PNG_LIBPNG_VER < 10700
-5.             if (!for_background && this->bit_depth < 8)
-4.               ",Useful
"/*Check the input, original, channel value here against the
             * original tRNS gray chunk valie.*/","-5. #           if PNG_LIBPNG_VER >= 10700
-4.                if (!for_background && this->bit_depth < 8)
-3.                   this->bit_depth = this->sample_depth = 8;
-2. #           endif
-1.             this->have_tRNS = 0;
            /* Check the i",Useful
"/*Again, check the exact input values, not the current transformed
             * value!*/","-10.          }
-9.          else
-8.             this->alphaf = 1;
-7.          this->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA;
-6.       }
-5.       else if (this->colour_type == PNG_COLOR_TYPE_RGB)
-4.       {
-3.          if (this->have_tRNS)
-2.      ",Useful
"/*The error in the alpha is zero and the sBIT value comes from the
       * original sBIT data (actually it will always be the original bit depth).*/","-10.                this->green == display->transparent.green &&
-9.                this->blue == display->transparent.blue)
-8.                this->alphaf = 0;
-7.             else
-6.                this->alphaf = 1;
-5.          }
-4.          else
-3",Useful
/*transforms that need image_pixel_add_alpha*/,"-4.       this->alphae = 0;
-3.       this->alpha_sBIT = display->alpha_sBIT;
-2.    }
-1. }

 /*transforms that need image_pixel_add_alpha*/

1. struct transform_display;
2. typedef struct image_transform
3. {",Useful
/*The global list of transforms; read only.*/,"-1.    int enable;

 /*The global list of transforms; read only.*/

1.    struct image_transform *const list;",Useful
"/*The global count of the number of times this transform has been set on an
    * image.*/","-1.    struct image_transform *const list;
   /* The global count of the number of times this transform has been set on an
    * image.

 /*The global count of the number of times this transform has been set on an
    * image.*/

1.     */
2.    unsigned ",Useful
/*The local count of the number of times this transform has been set.*/,"-1.    unsigned int global_use;

 /*The local count of the number of times this transform has been set.*/

1.    unsigned int local_use;",Useful
"/*The next transform in the list, each transform must call its own next
    * transform after it has processed the pixel successfully.*/","-1.    unsigned int local_use;
   /* The next transform in the list, each transform must call its own next
    * transform after it has processed the pixel successfully.

 /*The next transform in the list, each transform must call its own next
    * trans",Useful
"/*A single transform for the image, expressed as a series of function
    * callbacks and some space for values.
    *
    * First a callback to add any required modifications to the png_modifier;
    * this gets called just before the modifier is set up for read.*/","-1.    const struct image_transform *next;
   /* A single transform for the image, expressed as a series of function
    * callbacks and some space for values.
    *
    * First a callback to add any required modifications to the png_modifier;
    * this ",Useful
/*And a callback to set the transform on the current png_read_struct:*/,"-2.    void (*ini)(const struct image_transform *this,
-1.       struct transform_display *that);
   /* And a callback to set the transform on the current png_read_struct:

 /*And a callback to set the transform on the current png_read_struct:*/

1.     *",Useful
"/*Then a transform that takes an input pixel in one PNG format or another
    * and modifies it by a pngvalid implementation of the transform (thus
    * duplicating the libpng intent without, we hope, duplicating the bugs
    * in the libpng implementation!)  The png_structp is solely to allow error
    * reporting via png_error and png_warning.*/","-2.    void (*set)(const struct image_transform *this,
-1.       struct transform_display *that, png_structp pp, png_infop pi);
   /* Then a transform that takes an input pixel in one PNG format or another
    * and modifies it by a pngvalid implementatio",Useful
"/*Add this transform to the list and return true if the transform is
    * meaningful for this colour type and bit depth - if false then the
    * transform should have no effect on the image so there's not a lot of
    * point running it.*/","-2.    void (*mod)(const struct image_transform *this, image_pixel *that,
-1.       png_const_structp pp, const struct transform_display *display);
   /* Add this transform to the list and return true if the transform is
    * meaningful for this colour t",Useful
"/*Set sRGB, cHRM and gAMA transforms as required by the current encoding.*/","-4.    gama_modification gama_mod;
-3.    chrm_modification chrm_mod;
-2.    srgb_modification srgb_mod;
-1. } transform_display;

 /*Set sRGB, cHRM and gAMA transforms as required by the current encoding.*/

1. static void
2. transform_set_encoding(trans",Useful
"/*Set up the png_modifier '_current' fields then use these to determine how
    * to add appropriate chunks.*/","-3. static void
-2. transform_set_encoding(transform_display *this)
-1. {
   /* Set up the png_modifier '_current' fields then use these to determine how
    * to add appropriate chunks.

 /*Set up the png_modifier '_current' fields then use these to dete",Useful
/*Three functions to end the list:*/,"-6.          gama_modification_init(&this->gama_mod, pm, pm->current_gamma);
-5.          if (pm->current_encoding != 0)
-4.             chrm_modification_init(&this->chrm_mod, pm, pm->current_encoding);
-3.       }
-2.    }
-1. }

 /*Three functions to e",Useful
"/*At the end of the list recalculate the output image pixel value from the
 * double precision values set up by the preceding 'mod' calls:*/","-10. }
-9. static void
-8. image_transform_set_end(const image_transform *this,
-7.    transform_display *that, png_structp pp, png_infop pi)
-6. {
-5.    UNUSED(this)
-4.    UNUSED(that)
-3.    UNUSED(pp)
-2.    UNUSED(pi)
-1. }
/* At the end of the list",Useful
"/*At the end recalculate the digitized red green and blue values according
    * to the current sample_depth of the pixel.
    *
    * The sample value is simply scaled to the maximum, checking for over
    * and underflow (which can both happen for some image transforms,
    * including simple size scaling, though libpng doesn't do that at present.*/","-10. }
-9. static void
-8. image_transform_mod_end(const image_transform *this, image_pixel *that,
-7.     png_const_structp pp, const transform_display *display)
-6. {
-5.    const unsigned int scale = (1U<<that->sample_depth)-1;
-4.    const int sig_bit",Useful
"/*This is a bit bogus; really the above calculation should use the red_sBIT
    * value, not sample_depth, but because libpng does png_set_shift by just
    * shifting the bits we get errors if we don't do it the same way.*/","-1.    that->red = sample_scale(that->redf, scale);
   /* This is a bit bogus; really the above calculation should use the red_sBIT
    * value, not sample_depth, but because libpng does png_set_shift by just
    * shifting the bits we get errors if we do",Useful
"/*The error value is increased, at the end, according to the lowest sBIT
    * value seen.  Common sense tells us that the intermediate integer
    * representations are no more accurate than +/- 0.5 in the integral values,
    * the sBIT allows the implementation to be worse than this.  In addition the
    * PNG specification actually permits any error within the range (-1..+1),
    * but that is ignored here.  Instead the final digitized value is compared,
    * below to the digitized value of the error limits - this has the net effect
    * of allowing (almost) +/-1 in the output value.  It's difficult to see how
    * any algorithm that digitizes intermediate results can be more accurate.*/","-2.    if (sig_bits && that->red_sBIT < that->sample_depth)
-1.       that->red >>= that->sample_depth - that->red_sBIT;
   /* The error value is increased, at the end, according to the lowest sBIT
    * value seen.  Common sense tells us that the interme",Useful
/*Static 'end' structure:*/,"-4.    }
-3.    if (sig_bits && that->alpha_sBIT < that->sample_depth)
-2.       that->alpha >>= that->sample_depth - that->alpha_sBIT;
-1. }

 /*Static 'end' structure:*/

1. static image_transform image_transform_end =
2. {",Useful
/*Update the info structure for these transforms:*/,"-1.    dp->transform_list->set(dp->transform_list, dp, pp, pi);

 /*Update the info structure for these transforms:*/

1.    {
2.       int i = dp->this.use_update_info;",Useful
"/*If png_set_filler is in action then fake the output color type to include
    * an alpha channel where appropriate.*/","-2.    dp->output_colour_type = png_get_color_type(pp, pi);
-1.    dp->output_bit_depth = png_get_bit_depth(pp, pi);
   /* If png_set_filler is in action then fake the output color type to include
    * an alpha channel where appropriate.

 /*If png_set_f",Useful
"/*Validate the combination of colour type and bit depth that we are getting
    * out of libpng; the semantics of something not in the PNG spec are, at
    * best, unclear.*/","-4.    if (dp->output_bit_depth >= 8 &&
-3.        (dp->output_colour_type == PNG_COLOR_TYPE_RGB ||
-2.         dp->output_colour_type == PNG_COLOR_TYPE_GRAY) && dp->this.filler)
-1.        dp->output_colour_type |= 4;
   /* Validate the combination of co",Useful
"/*Use a test pixel to check that the output agrees with what we expect -
    * this avoids running the whole test if the output is unexpected.  This also
    * checks for internal errors.*/","-10.          char message[128];
-9.          size_t pos;
-8.          pos = safecat(message, sizeof message, 0,
-7.             ""invalid final bit depth: colour type("");
-6.          pos = safecatn(message, sizeof message, pos, dp->output_colour_type);
-",Useful
"/*Don't need sBIT here, but it must be set to non-zero to avoid
       * arithmetic overflows.*/","-5.       test_pixel.bit_depth = dp->this.bit_depth;
-4.       if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)
-3.          test_pixel.sample_depth = 8;
-2.       else
-1.          test_pixel.sample_depth = test_pixel.bit_depth;
      /* Don't need ",Useful
/*If both bit depth and colour type are correct check the sample depth.*/,"-10.       }
-9.       if (test_pixel.bit_depth != dp->output_bit_depth)
-8.       {
-7.          char message[128];
-6.          size_t pos = safecat(message, sizeof message, 0, ""bit depth "");
-5.          pos = safecatn(message, sizeof message, pos, dp-",Useful
/*oops - internal error!*/,"-1.       if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE &&

 /*oops - internal error!*/

1.          png_error(pp, ""pngvalid: internal: palette sample depth not 8"");
2.       else if (dp->unpacked && test_pixel.bit_depth != 8)
3.          png_error",Useful
"/*Because unless something has set 'unpacked' or the image is palette
          * mapped we expect the transform to keep sample depth and bit depth
          * the same.*/","-9.          png_error(pp, ""pngvalid: internal: palette sample depth not 8"");
-8.       else if (dp->unpacked && test_pixel.bit_depth != 8)
-7.          png_error(pp, ""pngvalid: internal: bad unpacked pixel depth"");
-6.       else if (!dp->unpacked && tes",Useful
"/*This could be a libpng error too; libpng has not produced what we
          * expect for the output bit depth.*/","-10.           * mapped we expect the transform to keep sample depth and bit depth
-9.           * the same.
-8.           */
-7.          pos = safecatn(message, sizeof message, pos, test_pixel.sample_depth);
-6.          pos = safecat(message, sizeof me",Useful
"/*Compare the scaled, digitzed, values of our local calculation (in+-err)
    * with the digitized values libpng produced;  'sample_depth' is the actual
    * digitization depth of the libpng output colors (the bit depth except for
    * palette images where it is always 8.)  The check on 'err' is to detect
    * internal errors in pngvalid itself.*/","-10. {
-9.    transform_info_imp(voidcast(transform_display*, png_get_progressive_ptr(pp)),
-8.       pp, pi);
-7. }
-6. static void
-5. transform_range_check(png_const_structp pp, unsigned int r, unsigned int g,
-4.    unsigned int b, unsigned int a, uns",Useful
/*Check for row overwrite errors*/,"-10.       PNG_COLOR_TYPE_PALETTE ? 8 : out_bd);
-9.    const png_byte red_sBIT = dp->this.red_sBIT;
-8.    const png_byte green_sBIT = dp->this.green_sBIT;
-7.    const png_byte blue_sBIT = dp->this.blue_sBIT;
-6.    const png_byte alpha_sBIT = dp->this.",Useful
"/*Read the palette corresponding to the output if the output colour type
    * indicates a palette, otherwise set out_palette to garbage.*/","nan


 /*Read the palette corresponding to the output if the output colour type
    * indicates a palette, otherwise set out_palette to garbage.*/

nan
",Useful
"/*Validate that the palette count itself has not changed - this is not
       * expected.*/","-2.    if (out_ct == PNG_COLOR_TYPE_PALETTE)
-1.    {
      /* Validate that the palette count itself has not changed - this is not
       * expected.

 /*Validate that the palette count itself has not changed - this is not
       * expected.*/

1.       ",Useful
"/*use-input-precision means assume that if the input has 8 bit (or less)
       * samples and the output has 16 bit samples the calculations will be done
       * with 8 bit precision, not 16.*/","-10.       int npalette = (-1);
-9.       (void)read_palette(out_palette, &npalette, pp, pi);
-8.       if (npalette != dp->this.npalette)
-7.          png_error(pp, ""unexpected change in palette size"");
-6.       digitization_error = .5;
-5.    }
-4.    ",Useful
"/*Else calculations are at 8 bit precision, and the output actually
       * consists of scaled 8-bit values, so scale .5 in 8 bits to the 16 bits:*/","-10.        * samples and the output has 16 bit samples the calculations will be done
-9.        * with 8 bit precision, not 16.
-8.        */
-7.       if (in_ct == PNG_COLOR_TYPE_PALETTE || in_bd < 16)
-6.          in_sample_depth = 8;
-5.       else
-4",Useful
"/*Go through each original pixel transforming it and comparing with what
       * libpng did to the same pixel.*/","-2.       png_byte std[STANDARD_ROWMAX];
-1.       transform_row(pp, std, in_ct, in_bd, y);
      /* Go through each original pixel transforming it and comparing with what
       * libpng did to the same pixel.

 /*Go through each original pixel transform",Useful
"/*This applies the transforms to the input data, including output
          * format operations which must be used when reading the output
          * pixel that libpng produces.*/","-4.          r = in_pixel.red;
-3.          g = in_pixel.green;
-2.          b = in_pixel.blue;
-1.          a = in_pixel.alpha;
         /* This applies the transforms to the input data, including output
          * format operations which must be used w",Useful
"/*Read the output pixel and compare it to what we got, we don't
          * use the error field here, so no need to update sBIT.  in_pixel
          * says whether we expect libpng to change the output format.*/","-1.          dp->transform_list->mod(dp->transform_list, &in_pixel, pp, dp);
         /* Read the output pixel and compare it to what we got, we don't
          * use the error field here, so no need to update sBIT.  in_pixel
          * says whether we e",Useful
"/*We don't expect changes to the index here even if the bit depth is
          * changed.*/","-2.          image_pixel_init(&out_pixel, pRow, out_ct, out_bd, x, out_palette,
-1.                  &in_pixel);
         /* We don't expect changes to the index here even if the bit depth is
          * changed.

 /*We don't expect changes to the index h",Useful
"/*Check the colours for palette images too - in fact the palette could
          * be separately verified itself in most cases.*/","-6.          if (in_ct == PNG_COLOR_TYPE_PALETTE &&
-5.             out_ct == PNG_COLOR_TYPE_PALETTE)
-4.          {
-3.             if (in_pixel.palette_index != out_pixel.palette_index)
-2.                png_error(pp, ""unexpected transformed palette in",Useful
/*Record that something was actually checked to avoid a false positive.*/,"-10.                dp->pm->limit + 1./(2*((1U<<in_pixel.blue_sBIT)-1)), ""blue"",
-9.                digitization_error);
-8.          if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0 &&
-7.             in_pixel.alpha != out_pixel.alpha)
-6.             transform_",Useful
"/*Make sure the encoding fields are correct and enter the required
       * modifications.*/","-10. {
-9.    transform_display d;
-8.    context(&pmIn->this, fault);
-7.    transform_display_init(&d, pmIn, idIn, transform_listIn);
-6.    Try
-5.    {
-4.       size_t pos = 0;
-3.       png_structp pp;
-2.       png_infop pi;
-1.       char full_nam",Useful
/*Add any modifications required by the transform list.*/,"-1.       transform_set_encoding(&d);

 /*Add any modifications required by the transform list.*/

1.       d.transform_list->ini(d.transform_list, &d);",Useful
"/*Add the color space information, if any, to the name.*/","-1.       d.transform_list->ini(d.transform_list, &d);

 /*Add the color space information, if any, to the name.*/

1.       pos = safecat(full_name, sizeof full_name, pos, name);
2.       pos = safecat_current_encoding(full_name, sizeof full_name, pos, d",Useful
/*Get a png_struct for reading the image.*/,"-4.    Try
-3.    {
-2.       png_structp pp;
-1.       png_infop pi;
      /* Get a png_struct for reading the image. This will throw an error if it

 /*Get a png_struct for reading the image.*/

1.        * fails, so we don't need to check the result.
2",Useful
/*Logging (debugging only)*/,"-3.       pp = set_modifier_for_read(d.pm, &pi, d.this.id, full_name);
-2.       standard_palette_init(&d.this);
-1. #     if 0

 /*Logging (debugging only)*/

1.          {
2.             char buffer[256];
3.             (void)store_message(&d.pm->this, ",Useful
/*Introduce the correct read function.*/,"-1.       standard_palette_init(&d);

 /*Introduce the correct read function.*/

1.       if (d.ps->progressive)
2.       {
3.          png_set_progressive_read_fn(pp, &d, standard_info, progressive_row,
4.             standard_end);",Useful
/*Now feed data into the reader until we reach the end:*/,"-4.       if (d.ps->progressive)
-3.       {
-2.          png_set_progressive_read_fn(pp, &d, standard_info, progressive_row,
-1.             standard_end);

 /*Now feed data into the reader until we reach the end:*/

1.          store_progressive_read(d.",Useful
/*Check the header values:*/,"-1.          png_set_read_fn(pp, d.ps, store_read);

 /*Check the header values:*/

1.          png_read_info(pp, pi);",Useful
/*png_set_palette_to_rgb*/,"-10.     const image_transform **that, png_byte colour_type, png_byte bit_depth)
-9. {
-8.    UNUSED(colour_type)
-7.    UNUSED(bit_depth)
-6.    this->next = *that;
-5.    *that = this;
-4.    return 1;
-3. }
-2. #endif
-1. #ifdef PNG_READ_EXPAND_SUPPORT",Useful
"/*If there was a tRNS chunk that would get expanded and add an alpha
    * channel is_transparent must be updated:*/","-5. static void
-4. image_transform_png_set_tRNS_to_alpha_set(const image_transform *this,
-3.    transform_display *that, png_structp pp, png_infop pi)
-2. {
-1.    png_set_tRNS_to_alpha(pp);
   /* If there was a tRNS chunk that would get expanded and ad",Useful
/*LIBPNG BUG: this always forces palette images to RGB.*/,"-10.    if (that->this.has_tRNS)
-9.       that->this.is_transparent = 1;
-8.    this->next->set(this->next, that, pp, pi);
-7. }
-6. static void
-5. image_transform_png_set_tRNS_to_alpha_mod(const image_transform *this,
-4.    image_pixel *that, png_cons",Useful
"/*This effectively does an 'expand' only if there is some transparency to
    * convert to an alpha channel.*/","-3.    if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
-2.       image_pixel_convert_PLTE(that);
-1. #endif
   /* This effectively does an 'expand' only if there is some transparency to
    * convert to an alpha channel.

 /*This effectively does an 'exp",Useful
/*LIBPNG BUG: otherwise libpng still expands to 8 bits!*/,"-1. #if PNG_LIBPNG_VER < 10700

 /*LIBPNG BUG: otherwise libpng still expands to 8 bits!*/

1.    else
2.    {
3.       if (that->bit_depth < 8)
4.          that->bit_depth =8;
5.       if (that->sample_depth < 8)
6.          that->sample_depth = 8;
7.   ",Useful
"/*We don't know yet whether there will be a tRNS chunk, but we know that
    * this transformation should do nothing if there already is an alpha
    * channel.  In addition, after the bug fix in 1.7.0, there is no longer
    * any action on a palette image.*/","-10. #endif
-9.    this->next->mod(this->next, that, pp, display);
-8. }
-7. static int
-6. image_transform_png_set_tRNS_to_alpha_add(image_transform *this,
-5.     const image_transform **that, png_byte colour_type, png_byte bit_depth)
-4. {
-3.    UNUSE",Useful
/*png_set_gray_to_rgb*/,"-1. #ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED

 /*png_set_gray_to_rgb*/

1. static void
2. image_transform_png_set_gray_to_rgb_set(const image_transform *this,
3.     transform_display *that, png_structp pp, png_infop pi)
4. {
5.    png_set_gray_to_rgb(pp);",Useful
/*NOTE: this doesn't result in tRNS expansion.*/,"-5. static void
-4. image_transform_png_set_gray_to_rgb_set(const image_transform *this,
-3.     transform_display *that, png_structp pp, png_infop pi)
-2. {
-1.    png_set_gray_to_rgb(pp);

 /*NOTE: this doesn't result in tRNS expansion.*/

1.    this->n",Useful
"/*NOTE: we can actually pend the tRNS processing at this point because we
    * can correctly recognize the original pixel value even though we have
    * mapped the one gray channel to the three RGB ones, but in fact libpng
    * doesn't do this, so we don't either.*/","-7.    this->next->set(this->next, that, pp, pi);
-6. }
-5. static void
-4. image_transform_png_set_gray_to_rgb_mod(const image_transform *this,
-3.     image_pixel *that, png_const_structp pp,
-2.     const transform_display *display)
-1. {
   /* NOTE: w",Useful
/*Simply expand the bit depth and alter the colour type as required.*/,"-2.    if ((that->colour_type & PNG_COLOR_MASK_COLOR) == 0 && that->have_tRNS)

 /*Simply expand the bit depth and alter the colour type as required.*/

1.    if (that->colour_type == PNG_COLOR_TYPE_GRAY)
2.    {",Useful
/*RGB images have a bit depth at least equal to '8'*/,"-2.    if (that->colour_type == PNG_COLOR_TYPE_GRAY)
-1.    {

 /*RGB images have a bit depth at least equal to '8'*/

1.       if (that->bit_depth < 8)
2.          that->sample_depth = that->bit_depth = 8;",Useful
"/*And just changing the colour type works here because the green and blue
       * channels are being maintained in lock-step with the red/gray:*/","-2.       if (that->bit_depth < 8)
-1.          that->sample_depth = that->bit_depth = 8;
      /* And just changing the colour type works here because the green and blue
       * channels are being maintained in lock-step with the red/gray:

 /*And just ",Useful
/*PNG_READ_GRAY_TO_RGB_SUPPORTED*/,"-10.    this->sample_depth = sample_depth;
-9.    this->have_tRNS = 0;
-8.    this->swap_rgb = 0;
-7.    this->alpha_first = 0;
-6.    this->alpha_inverted = 0;
-5.    this->mono_inverted = 0;
-4.    this->swap16 = 0;
-3.    this->littleendian = 0;
-2.   ",Useful
/*The general expand case depends on what the colour type is:*/,"-10.    png_set_expand(pp);
-9.    if (that->this.has_tRNS)
-8.       that->this.is_transparent = 1;
-7.    this->next->set(this->next, that, pp, pi);
-6. }
-5. static void
-4. image_transform_png_set_expand_mod(const image_transform *this,
-3.     image_",Useful
/*grayscale*/,"-10. {
-9.    char number[64];
-8.    sprintf(number, ""%.*f"", precision, d);
-7.    return safecat(buffer, bufsize, pos, number);
-6. }
-5. #endif
-4. static const char invalid[] = ""invalid"";
-3. static const char sep[] = "": "";
-2. static const char *colo",Useful
"/*expand' should do nothing for RGBA or GA input - no tRNS and the bit
    * depth is at least 8 already.*/","-9.    this->next->mod(this->next, that, pp, display);
-8. }
-7. static int
-6. image_transform_png_set_expand_add(image_transform *this,
-5.     const image_transform **that, png_byte colour_type, png_byte bit_depth)
-4. {
-3.    UNUSED(bit_depth)
-2.   ",Useful
"/*png_set_expand_gray_1_2_4_to_8
 * Pre 1.7.0 LIBPNG BUG: this just does an 'expand'*/","-1. #ifdef PNG_READ_EXPAND_SUPPORTED
/* png_set_expand_gray_1_2_4_to_8
 * Pre 1.7.0 LIBPNG BUG: this just does an 'expand'

 /*png_set_expand_gray_1_2_4_to_8
 * Pre 1.7.0 LIBPNG BUG: this just does an 'expand'*/

1.  */
2. static void
3. image_transform_p",Useful
/*Only expand grayscale of bit depth less than 8:*/,"-10.    this->next->set(this->next, that, pp, pi);
-9. }
-8. static void
-7. image_transform_png_set_expand_gray_1_2_4_to_8_mod(
-6.     const image_transform *this, image_pixel *that, png_const_structp pp,
-5.     const transform_display *display)
-4. {
",Useful
"/*This should do nothing unless the color type is gray and the bit depth is
    * less than 8:*/","-10. image_transform_png_set_expand_gray_1_2_4_to_8_add(image_transform *this,
-9.     const image_transform **that, png_byte colour_type, png_byte bit_depth)
-8. {
-7. #if PNG_LIBPNG_VER < 10700
-6.    return image_transform_png_set_expand_add(this, that",Useful
"/*Expect expand_16 to expand everything to 16 bits as a result of also
    * causing 'expand' to happen.*/","-10.       if (that->this.has_tRNS)
-9.          that->this.is_transparent = 1;
-8. #  endif
-7.    this->next->set(this->next, that, pp, pi);
-6. }
-5. static void
-4. image_transform_png_set_expand_16_mod(const image_transform *this,
-3.     image_pixel",Useful
/*libpng will limit the gamma table size:*/,"-6. static void
-5. image_transform_png_set_scale_16_set(const image_transform *this,
-4.     transform_display *that, png_structp pp, png_infop pi)
-3. {
-2.    png_set_scale_16(pp);
-1. #  if PNG_LIBPNG_VER < 10700

 /*libpng will limit the gamma table ",Useful
/*libpng will limit the gamma table size:*/,"-6. static void
-5. image_transform_png_set_scale_16_set(const image_transform *this,
-4.     transform_display *that, png_structp pp, png_infop pi)
-3. {
-2.    png_set_scale_16(pp);
-1. #  if PNG_LIBPNG_VER < 10700

 /*libpng will limit the gamma table ",Useful
"/*Prior to 1.5.4 png_set_strip_16 would use an 'accurate' method if this
       * configuration option is set.  From 1.5.4 the flag is never set and the
       * 'scale' API (above) must be used.*/","-10.     image_pixel *that, png_const_structp pp,
-9.     const transform_display *display)
-8. {
-7.    if (that->bit_depth == 16)
-6.    {
-5.       that->sample_depth = that->bit_depth = 8;
-4.       if (that->red_sBIT > 8) that->red_sBIT = 8;
-3.     ",Useful
"/*The strip 16 algorithm drops the low 8 bits rather than calculating
          * 1/257, so we need to adjust the permitted errors appropriately:
          * Notice that this is only relevant prior to the addition of the
          * png_set_scale_16 API in 1.5.4 (but 1.5.4+ always defines the above!)*/","-4. #     ifdef PNG_READ_ACCURATE_SCALE_SUPPORTED
-3. #        if PNG_LIBPNG_VER >= 10504
-2. #           error PNG_READ_ACCURATE_SCALE should not be set
-1. #        endif
         /* The strip 16 algorithm drops the low 8 bits rather than calculating
  ",Useful
"/*png_set_rgb_to_gray(png_structp, int err_action, double red, double green)
 * png_set_rgb_to_gray_fixed(png_structp, int err_action, png_fixed_point red,
 *    png_fixed_point green)
 * png_get_rgb_to_gray_status
 *
 * The 'default' test here uses values known to be used inside libpng prior to
 * 1.7.0:
 *
 *   red:    6968
 *   green: 23434
 *   blue:   2366
 *
 * These values are being retained for compatibility, along with the somewhat
 * broken truncation calculation in the fast-and-inaccurate code path.  Older
 * versions of libpng will fail the accuracy tests below because they use the
 * truncation algorithm everywhere.*/","-1. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
/* png_set_rgb_to_gray(png_structp, int err_action, double red, double green)
 * png_set_rgb_to_gray_fixed(png_structp, int err_action, png_fixed_point red,
 *    png_fixed_point green)
 * png_get_rgb_to_gray_stat",Useful
/*The following are the parameters for png_set_rgb_to_gray:*/,"-10.  *
-9.  * These values are being retained for compatibility, along with the somewhat
-8.  * broken truncation calculation in the fast-and-inaccurate code path.  Older
-7.  * versions of libpng will fail the accuracy tests below because they use the
-",Useful
/*Since we check the encoding this flag must be set:*/,"-10. } data;
-9. #undef image_transform_ini
-8. #define image_transform_ini image_transform_png_set_rgb_to_gray_ini
-7. static void
-6. image_transform_png_set_rgb_to_gray_ini(const image_transform *this,
-5.     transform_display *that)
-4. {
-3.    png_",Useful
"/*If 'e' is not NULL chromaticity information is present and either a cHRM
    * or an sRGB chunk will be inserted.*/","-1.    pm->test_uses_encoding = 1;
   /* If 'e' is not NULL chromaticity information is present and either a cHRM
    * or an sRGB chunk will be inserted.

 /*If 'e' is not NULL chromaticity information is present and either a cHRM
    * or an sRGB chunk ",Useful
/*If not set then the calculations assume linear encoding (implicitly):*/,"-10.          data.red_coefficient = 6968 / 32768.;
-9.          data.green_coefficient = 23434 / 32768.;
-8.          data.blue_coefficient = 2366 / 32768.;
-7. #     else
-6.          data.red_coefficient = .2126;
-5.          data.green_coefficient = .",Useful
"/*The arguments to png_set_rgb_to_gray can override the coefficients implied
    * by the color space encoding.  If doing exhaustive checks do the override
    * in each case, otherwise do it randomly.*/","-2.    if (data.gamma == 0)
-1.       data.gamma = 1;
   /* The arguments to png_set_rgb_to_gray can override the coefficients implied
    * by the color space encoding.  If doing exhaustive checks do the override
    * in each case, otherwise do it rando",Useful
"/*First time in coefficients_overridden is 0, the following sets it to 1,
       * so repeat if it is set.  If a test fails this may mean we subsequently
       * skip a non-override test, ignore that.*/","-2.    if (pm->test_exhaustive)
-1.    {
      /* First time in coefficients_overridden is 0, the following sets it to 1,
       * so repeat if it is set.  If a test fails this may mean we subsequently
       * skip a non-override test, ignore that.

 /*F",Useful
"/*These values override the color encoding defaults, simply use random
       * numbers.*/","-10.        * so repeat if it is set.  If a test fails this may mean we subsequently
-9.        * skip a non-override test, ignore that.
-8.        */
-7.       data.coefficients_overridden = !data.coefficients_overridden;
-6.       pm->repeat = data.coef",Useful
"/*Adjust the error limit in the png_modifier because of the larger errors
    * produced in the digitization during the gamma handling.*/","-7.       pm->encoding_ignored = 1;
-6.    }
-5.    else
-4.    {
-3.       data.red_to_set = -1;
-2.       data.green_to_set = -1;
-1.    }
   /* Adjust the error limit in the png_modifier because of the larger errors
    * produced in the digitization d",Useful
"/*The computations have the form:
          *
          *    r * rc + g * gc + b * bc
          *
          *  Each component of which is +/-1/65535 from the gamma_to_1 table
          *  lookup, resulting in a base error of +/-6.  The gamma_from_1
          *  conversion adds another +/-2 in the 16-bit case and
          *  +/-(1<<(15-PNG_MAX_GAMMA_8)) in the 8-bit case.*/","-3.    {
-2.       if (that->this.bit_depth == 16 || pm->assume_16_bit_calculations)
-1.       {
         /* The computations have the form:
          *
          *    r * rc + g * gc + b * bc
          *
          *  Each component of which is +/-1/65535",Useful
"/*Rounding to 8 bits in the linear space causes massive errors which
          * will trigger the error check in transform_range_check.  Fix that
          * here by taking the gamma encoding into account.
          *
          * When DIGITIZE is set because a pre-1.7 version of libpng is being
          * tested allow a bigger slack.
          *
          * NOTE: this number only affects the internal limit check in pngvalid,
          * it has no effect on the limits applied to the libpng values.*/","-10.                that->max_gamma_8 = PNG_MAX_GAMMA_8;
-9. #        endif
-8.          that->pm->limit += pow(
-7.             (that->this.bit_depth == 16 || that->max_gamma_8 > 14 ?
-6.                8. :
-5.                6. + (1<<(15-that->max_gamm",Useful
"/*With no gamma correction a large error comes from the truncation of the
       * calculation in the 8 bit case, allow for that here.*/","-10.           */
-9. #if DIGITIZE
-8.           that->pm->limit += pow( 2.0/255, data.gamma);
-7. #else
-6.           that->pm->limit += pow( 1.0/255, data.gamma);
-5. #endif
-4.       }
-3.    }
-2.    else
-1.    {
      /* With no gamma correction a l",Useful
"/*no error, no defines in png.h*/","-10.        * calculation in the 8 bit case, allow for that here.
-9.        */
-8.       if (that->this.bit_depth != 16 && !pm->assume_16_bit_calculations)
-7.          that->pm->limit += 4E-3;
-6.    }
-5. }
-4. static void
-3. image_transform_png_set_r",Useful
"/*We have an encoding so a cHRM chunk may have been set; if so then
          * check that the libpng APIs give the correct (X,Y,Z) values within
          * some margin of error for the round trip through the chromaticity
          * form.*/","-9. #  ifdef PNG_FLOATING_POINT_SUPPORTED
-8.       png_set_rgb_to_gray(pp, error_action, data.red_to_set, data.green_to_set);
-7. #  else
-6.       png_set_rgb_to_gray_fixed(pp, error_action, data.red_to_set,
-5.          data.green_to_set);
-4. #  endif",Useful
"/*Expect libpng to return a normalized result, but the original
             * color space encoding may not be normalized.*/","-10. #        endif
-9.          API_type rX, gX, bX;
-8.          API_type rY, gY, bY;
-7.          API_type rZ, gZ, bZ;
-6.          if ((API_function(pp, pi, &rX, &rY, &rZ, &gX, &gY, &gZ, &bX, &bY, &bZ)
-5.                & PNG_INFO_cHRM) != 0)
-4.    ",Useful
"/*Sanity check the pngvalid code - the coefficients should match
             * the normalized Y values of the encoding unless they were
             * overridden.*/","-2.             modifier_current_encoding(that->pm, &o);
-1.             normalize_color_encoding(&o);
            /* Sanity check the pngvalid code - the coefficients should match
             * the normalized Y values of the encoding unless they were
  ",Useful
/*Generate a colour space encoding.*/,"-5.             if (data.red_to_set == -1 && data.green_to_set == -1 &&
-4.                (fabs(o.red.Y - data.red_coefficient) > DBL_EPSILON ||
-3.                fabs(o.green.Y - data.green_coefficient) > DBL_EPSILON ||
-2.                fabs(o.blue.Y",Useful
"/*This should match the original one from the png_modifier, within
             * the range permitted by the libpng fixed point representation.*/","-9.             e.red.X = API_cvt(rX);
-8.             e.red.Y = API_cvt(rY);
-7.             e.red.Z = API_cvt(rZ);
-6.             e.green.X = API_cvt(gX);
-5.             e.green.Y = API_cvt(gY);
-4.             e.green.Z = API_cvt(gZ);
-3.            ",Useful
/*Set to element name with error*/,"-1.             maxe = 0;

 /*Set to element name with error*/

1. #           define CHECK(col,x)\
2.             {\
3.                double err = fabs(o.col.x - e.col.x);\
4.                if (err > maxe)\
5.                {\
6.                   max",Useful
"/*Here in both fixed and floating cases to check the values read
             * from the cHRm chunk.  PNG uses fixed point in the cHRM chunk, so
             * we can't expect better than +/-.5E-5 on the result, allow 1E-5.*/","-10.             }
-9.             CHECK(red,X)
-8.             CHECK(red,Y)
-7.             CHECK(red,Z)
-6.             CHECK(green,X)
-5.             CHECK(green,Y)
-4.             CHECK(green,Z)
-3.             CHECK(blue,X)
-2.             CHECK(blue",Useful
/*Print the color space without the gamma value:*/,"-10.             if (maxe >= 1E-5)
-9.             {
-8.                size_t pos = 0;
-7.                char buffer[256];
-6.                pos = safecat(buffer, sizeof buffer, pos, API_form);
-5.                pos = safecat(buffer, sizeof buffer, po",Useful
/*Image now has RGB channels...*/,"-10.     image_pixel *that, png_const_structp pp,
-9.     const transform_display *display)
-8. {
-7.    if ((that->colour_type & PNG_COLOR_MASK_COLOR) != 0)
-6.    {
-5.       double gray, err;
-4. #     if PNG_LIBPNG_VER < 10700
-3.          if (that->c",Useful
"/*Do this using interval arithmetic, otherwise it is too difficult to
          * handle the errors correctly.
          *
          * To handle the gamma correction work out the upper and lower bounds
          * of the digitized value.  Assume rounding here - normally the values
          * will be identical after this operation if there is only one
          * transform, feel free to delete the png_error checks on this below in
          * the future (this is just me trying to ensure it works!)
          *
          * Interval arithmetic is exact, but to implement it it must be
          * possible to control the floating point implementation rounding mode.
          * This cannot be done in ANSI-C, so instead I reduce the 'lo' values
          * by DBL_EPSILON and increase the 'hi' values by the same.*/","-10.             sample_depth);
-9.          const unsigned int gamma_depth =
-8.             (sample_depth == 16 ?
-7.                display->max_gamma_8 :
-6.                (pm->assume_16_bit_calculations ?
-5.                   display->max_gamma_8 :",Useful
"/*If a gamma calculation is done it is done using lookup tables of
             * precision gamma_depth, so the already digitized value above may
             * need to be further digitized here.*/","-5.          isgray = r==g && g==b;
-4.          if (data.gamma != 1)
-3.          {
-2.             const double power = 1/data.gamma;
-1.             const double abse = .5/(sample_depth == 16 ? 65535 : 255);
            /* If a gamma calculation is don",Useful
"/*Now calculate the actual gray values.  Although the error in the
          * coefficients depends on whether they were specified on the command
          * line (in which case truncation to 15 bits happened) or not (rounding
          * was used) the maximum error in an individual coefficient is always
          * 2/32768, because even in the rounding case the requirement that
          * coefficients add up to 32768 can cause a larger rounding error.
          *
          * The only time when rounding doesn't occur in 1.5.5 and later is when
          * the non-gamma code path is used for less than 16 bit data.*/","-10.             r = pow(r, power);
-9.             rlo = DD(pow(rlo, power)-abse, calc_depth, 1);
-8.             rhi = DU(pow(rhi, power)+abse, calc_depth, 1);
-7.             g = pow(g, power);
-6.             glo = DD(pow(glo, power)-abse, calc_depth,",Useful
"/*Now the error can be calculated.
          *
          * If r==g==b because there is no overall gamma correction libpng
          * currently preserves the original value.*/","-7.             }
-6.             gray = pow(gray, power);
-5.             graylo = DD(pow(graylo, power), sample_depth, 1);
-4.             grayhi = DU(pow(grayhi, power), sample_depth, 1);
-3.          }
-2. #        undef DD
-1. #        undef DU
     ",Useful
"/*The true gray case involves no math in earlier versions (not
             * true, there was some if gamma correction was happening too.)*/","-8.       {
-7.          double r = that->redf;
-6.          double re = that->rede;
-5.          double g = that->greenf;
-4.          double ge = that->greene;
-3.          double b = that->bluef;
-2.          double be = that->bluee;
-1. #        if PN",Useful
"/*There is no need to do the conversions to and from linear space,
             * so the calculation should be a lot more accurate.  There is a
             * built in error in the coefficients because they only have 15 bits
             * and are adjusted to make sure they add up to 32768.  This
             * involves a integer calculation with truncation of the form:
             *
             *     ((int)(coefficient * 100000) * 32768)/100000
             *
             * This is done to the red and green coefficients (the ones
             * provided to the API) then blue is calculated from them so the
             * result adds up to 32768.  In the worst case this can result in
             * a -1 error in red and green and a +2 error in blue.  Consequently
             * the worst case in the calculation below is 2/32768 error.
             *
             * TODO: consider fixing this in libpng by rounding the calculation
             * limiting the error to 1/32768.
             *
             * Handling this by adding 2/32768 here avoids needing to increase
             * the global error limits to take this into account.)*/","-2.          if (data.gamma == 1)
-1.          {
            /* There is no need to do the conversions to and from linear space,
             * so the calculation should be a lot more accurate.  There is a
             * built in error in the coefficients",Useful
"/*The calculation happens in linear space, and this produces much
             * wider errors in the encoded space.  These are handled here by
             * factoring the errors in to the calculation.  There are two table
             * lookups in the calculation and each introduces a quantization
             * error defined by the table size.*/","-10.              * Handling this by adding 2/32768 here avoids needing to increase
-9.              * the global error limits to take this into account.)
-8.              */
-7.             gray = r * data.red_coefficient + g * data.green_coefficient +
-",Useful
"/*Work out the lower and upper bounds for the gray value in the
             * encoded space, then work out an average and error.  Remove the
             * previously added input quantization error at this point.*/","-10.             double g1 = 1/data.gamma;
-9.             rhi = r + re + in_qe; if (rhi > 1) rhi = 1;
-8.             r -= re + in_qe; if (r < 0) r = 0;
-7.             ghi = g + ge + in_qe; if (ghi > 1) ghi = 1;
-6.             g -= ge + in_qe; if (g < ",Useful
"/*Validate that the error is within limits (this has caused
             * problems before, it's much easier to detect them here.)*/","-10.                grayhi = 1;
-9.             else
-8.                grayhi = pow(grayhi, data.gamma) * (1+DBL_EPSILON);
-7.             err = (grayhi - gray) / 2;
-6.             gray = (grayhi + gray) / 2;
-5.             if (err <= in_qe)
-4.       ",Useful
/*And remove the colour bit in the type:*/,"-5.       if (that->red_sBIT > that->green_sBIT)
-4.          that->red_sBIT = that->green_sBIT;
-3.       if (that->red_sBIT > that->blue_sBIT)
-2.          that->red_sBIT = that->blue_sBIT;
-1.       that->blue_sBIT = that->green_sBIT = that->red_sBIT;
",Useful
/*PNG_READ_RGB_TO_GRAY_SUPPORTED*/,"-7. static png_uint_16
-6. random_u16(void)
-5. {
-4.    unsigned char b2[2];
-3.    randomize(b2, sizeof b2);
-2.    return png_get_uint_16(b2);
-1. }
#if defined PNG_READ_RGB_TO_GRAY_SUPPORTED ||\

 /*PNG_READ_RGB_TO_GRAY_SUPPORTED*/

1.     defined PNG",Useful
"/*png_set_background(png_structp, png_const_color_16p background_color,
 *    int background_gamma_code, int need_expand, double background_gamma)
 * png_set_background_fixed(png_structp, png_const_color_16p background_color,
 *    int background_gamma_code, int need_expand,
 *    png_fixed_point background_gamma)
 *
 * This ignores the gamma (at present.)*/","-1. #ifdef PNG_READ_BACKGROUND_SUPPORTED
/* png_set_background(png_structp, png_const_color_16p background_color,
 *    int background_gamma_code, int need_expand, double background_gamma)
 * png_set_background_fixed(png_structp, png_const_color_16p backg",Useful
/*8 bytes - 64 bits - the biggest pixel*/,"-10.  *
-9.  * This ignores the gamma (at present.)
-8. */
-7. #define data ITDATA(background)
-6. static image_pixel data;
-5. static void
-4. image_transform_png_set_background_set(const image_transform *this,
-3.     transform_display *that, png_struct",Useful
"/*We need a background colour, because we don't know exactly what transforms
    * have been set we have to supply the colour in the original file format and
    * so we need to know what that is!  The background colour is stored in the
    * transform_display.*/","-2.    int expand;
-1.    png_color_16 back;
   /* We need a background colour, because we don't know exactly what transforms
    * have been set we have to supply the colour in the original file format and
    * so we need to know what that is!  The back",Useful
"/*Read the random value, for colour type 3 the background colour is actually
    * expressed as a 24bit rgb, not an index.*/","-1.    R8(random_bytes);
   /* Read the random value, for colour type 3 the background colour is actually
    * expressed as a 24bit rgb, not an index.

 /*Read the random value, for colour type 3 the background colour is actually
    * expressed as a 24b",Useful
/*passing in an RGB not a pixel index*/,"-5.    colour_type = that->this.colour_type;
-4.    if (colour_type == 3)
-3.    {
-2.       colour_type = PNG_COLOR_TYPE_RGB;
-1.       bit_depth = 8;

 /*passing in an RGB not a pixel index*/

111",Useful
"/*Extract the background colour from this image_pixel, but make sure the
    * unused fields of 'back' are garbage.*/","
   /* Extract the background colour from this image_pixel, but make sure the
    * unused fields of 'back' are garbage.



 /*Extract the background colour from this image_pixel, but make sure the
    * unused fields of 'back' are garbage.*/

1.     */
2.    R8(back);
3.    if (colour_type & PNG_COLOR_MASK_COLOR)
4.    {
5.       back.red = (png_uint_16)data.red;
6.       back.green = (png_uint_16)data.green;
7.       back.blue = (png_uint_16)data.blue;
8.    }
9.    else
10.       back.gray = (png_uint_16)data.red;",Useful
/*Check for tRNS first:*/,"-10. #else
-9.    png_set_background_fixed(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);
-8. #endif
-7.    this->next->set(this->next, that, pp, pi);
-6. }
-5. static void
-4. image_transform_png_set_background_mod(const image_transform *this,
-3.    ",Useful
/*This is only necessary if the alpha value is less than 1.*/,"-2.    if (that->have_tRNS && that->colour_type != PNG_COLOR_TYPE_PALETTE)

 /*This is only necessary if the alpha value is less than 1.*/

1.    if (that->alphaf < 1)
2.    {",Useful
/*Now we do the background calculation without any gamma correction.*/,"-2.    if (that->alphaf < 1)
-1.    {

 /*Now we do the background calculation without any gamma correction.*/

1.       if (that->alphaf <= 0)
2.       {
3.          that->redf = data.redf;
4.          that->greenf = data.greenf;
5.          that->bluef ",Useful
/*Remove the alpha type and set the alpha (not in that order.)*/,"-10.          that->redf = that->redf * that->alphaf + data.redf * alf;
-9.          that->rede = that->rede * that->alphaf + data.rede * alf +
-8.             DBL_EPSILON;
-7.          that->greenf = that->greenf * that->alphaf + data.greenf * alf;
-6.  ",Useful
/*PNG_COLOR_TYPE_PALETTE is not changed*/,"-7.       that->alphaf = 1;
-6.       that->alphae = 0;
-5.    }
-4.    if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)
-3.       that->colour_type = PNG_COLOR_TYPE_RGB;
-2.    else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-1.       that->co",Useful
"/*png_set_quantize(png_structp, png_colorp palette, int num_palette,
 *    int maximum_colors, png_const_uint_16p histogram, int full_quantize)
 *
 * Very difficult to validate this!*/","/* png_set_quantize(png_structp, png_colorp palette, int num_palette,
 *    int maximum_colors, png_const_uint_16p histogram, int full_quantize)
 *
 * Very difficult to validate this!

 /*png_set_quantize(png_structp, png_colorp palette, int num_palette,
 *    int maximum_colors, png_const_uint_16p histogram, int full_quantize)
 *
 * Very difficult to validate this!*/

1.  */",Useful
"/*The data layout transforms are handled by swapping our own channel data,
 * necessarily these need to happen at the end of the transform list because the
 * semantic of the channels changes after these are executed.  Some of these,
 * like set_shift and set_packing, can't be done at present because they change
 * the layout of the data at the sub-sample level so sample() won't get the
 * right answer.*/","
/* The data layout transforms are handled by swapping our own channel data,
 * necessarily these need to happen at the end of the transform list because the
 * semantic of the channels changes after these are executed.  Some of these,
 * like set_shift and set_packing, can't be done at present because they change
 * the layout of the data at the sub-sample level so sample() won't get the
 * right answer.



 /*The data layout transforms are handled by swapping our own channel data,
 * necessarily these need to happen at the end of the transform list because the
 * semantic of the channels changes after these are executed.  Some of these,
 * like set_shift and set_packing, can't be done at present because they change
 * the layout of the data at the sub-sample level so sample() won't get the
 * right answer.*/

1.  */",Useful
"/*Invert the alpha channel
 *
 *  png_set_invert_alpha(png_structrp png_ptr)*/","-1. #ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
/* Invert the alpha channel
 *
 *  png_set_invert_alpha(png_structrp png_ptr)

 /*Invert the alpha channel
 *
 *  png_set_invert_alpha(png_structrp png_ptr)*/

1.  */
2. static void
3. image_transform_png_set_inv",Useful
/*Only has an effect on pixels with alpha:*/,"-10.       that->alpha_inverted = 1;
-9.    this->next->mod(this->next, that, pp, display);
-8. }
-7. static int
-6. image_transform_png_set_invert_alpha_add(image_transform *this,
-5.     const image_transform **that, png_byte colour_type, png_byte bit_d",Useful
"/*Swap R,G,B channels to order B,G,R.
 *
 *  png_set_bgr(png_structrp png_ptr)
 *
 * This only has an effect on RGB and RGBA pixels.*/","-1. #ifdef PNG_READ_BGR_SUPPORTED
/* Swap R,G,B channels to order B,G,R.
 *
 *  png_set_bgr(png_structrp png_ptr)
 *
 * This only has an effect on RGB and RGBA pixels.

 /*Swap R,G,B channels to order B,G,R.
 *
 *  png_set_bgr(png_structrp png_ptr)
 *
 * ",Useful
"/*Put the alpha channel first.
 *
 *  png_set_swap_alpha(png_structrp png_ptr)
 *
 * This only has an effect on GA and RGBA pixels.*/","-1. #ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
/* Put the alpha channel first.
 *
 *  png_set_swap_alpha(png_structrp png_ptr)
 *
 * This only has an effect on GA and RGBA pixels.

 /*Put the alpha channel first.
 *
 *  png_set_swap_alpha(png_structrp png_ptr)
",Useful
"/*Add a filler byte to 8-bit Gray or 24-bit RGB images.
 *
 *  png_set_filler, (png_structp png_ptr, png_uint_32 filler, int flags));
 *
 * Flags:
 *
 *  PNG_FILLER_BEFORE
 *  PNG_FILLER_AFTER*/","-1. #ifdef PNG_READ_FILLER_SUPPORTED
/* Add a filler byte to 8-bit Gray or 24-bit RGB images.
 *
 *  png_set_filler, (png_structp png_ptr, png_uint_32 filler, int flags));
 *
 * Flags:
 *
 *  PNG_FILLER_BEFORE
 *  PNG_FILLER_AFTER

 /*Add a filler byte to",Useful
"/*Need a random choice for 'before' and 'after' as well as for the
    * filler.  The 'filler' value has all 32 bits set, but only bit_depth
    * will be used.  At this point we don't know bit_depth.*/","-10. #define data ITDATA(filler)
-9. static struct
-8. {
-7.    png_uint_32 filler;
-6.    int         flags;
-5. } data;
-4. static void
-3. image_transform_png_set_filler_set(const image_transform *this,
-2.     transform_display *that, png_structp pp, ",Useful
"/*The standard display handling stuff also needs to know that
    * there is a filler, so set that here.*/","-3.    data.filler = random_u32();
-2.    data.flags = random_choice();
-1.    png_set_filler(pp, data.filler, data.flags);
   /* The standard display handling stuff also needs to know that
    * there is a filler, so set that here.

 /*The standard displ",Useful
"/*The filler has been stored in the alpha channel, we must record
       * that this has been done for the checking later on, the color
       * type is faked to have an alpha channel, but libpng won't report
       * this; the app has to know the extra channel is there and this
       * was recording in standard_display::filler above.*/","-10.     const transform_display *display)
-9. {
-8.    if (that->bit_depth >= 8 &&
-7.        (that->colour_type == PNG_COLOR_TYPE_RGB ||
-6.         that->colour_type == PNG_COLOR_TYPE_GRAY))
-5.    {
-4.       const unsigned int max = (1U << that->bit_",Useful
/*Add an alpha byte to 8-bit Gray or 24-bit RGB images.*/,"-10.    this->next = *that;
-9.    *that = this;
-8.    return bit_depth >= 8 && (colour_type == PNG_COLOR_TYPE_RGB ||
-7.            colour_type == PNG_COLOR_TYPE_GRAY);
-6. }
-5. #undef data
-4. IT(filler);
-3. #undef PT
-2. #define PT ITSTRUCT(filler)
",Useful
"/*Need a random choice for 'before' and 'after' as well as for the
    * filler.  The 'filler' value has all 32 bits set, but only bit_depth
    * will be used.  At this point we don't know bit_depth.*/","-10. #define data ITDATA(filler)
-9. static struct
-8. {
-7.    png_uint_32 filler;
-6.    int         flags;
-5. } data;
-4. static void
-3. image_transform_png_set_filler_set(const image_transform *this,
-2.     transform_display *that, png_structp pp, ",Useful
"/*Use 1 byte per pixel in 1, 2, or 4-bit depth files.
 *
 *  png_set_packing(png_structrp png_ptr)
 *
 * This should only affect grayscale and palette images with less than 8 bits
 * per pixel.*/","-1. #ifdef PNG_READ_PACK_SUPPORTED
/* Use 1 byte per pixel in 1, 2, or 4-bit depth files.
 *
 *  png_set_packing(png_structrp png_ptr)
 *
 * This should only affect grayscale and palette images with less than 8 bits
 * per pixel.

 /*Use 1 byte per pixel ",Useful
"/*The general expand case depends on what the colour type is,
    * low bit-depth pixel values are unpacked into bytes without
    * scaling, so sample_depth is not changed.*/","-10. {
-9.    png_set_packing(pp);
-8.    that->unpacked = 1;
-7.    this->next->set(this->next, that, pp, pi);
-6. }
-5. static void
-4. image_transform_png_set_packing_mod(const image_transform *this,
-3.     image_pixel *that, png_const_structp pp,
-2.",Useful
/*grayscale or palette*/,"-10. }
-9. static void
-8. image_transform_png_set_packing_mod(const image_transform *this,
-7.     image_pixel *that, png_const_structp pp,
-6.     const transform_display *display)
-5. {

 /*grayscale or palette*/

1.       that->bit_depth = 8;
2.    th",Useful
/*Nothing should happen unless the bit depth is less than 8:*/,"-10.       that->bit_depth = 8;
-9.    this->next->mod(this->next, that, pp, display);
-8. }
-7. static int
-6. image_transform_png_set_packing_add(image_transform *this,
-5.     const image_transform **that, png_byte colour_type, png_byte bit_depth)
-4. ",Useful
"/*Swap pixels packed into bytes; reverses the order on screen so that
 * the high order bits correspond to the rightmost pixels.
 *
 *  png_set_packswap(png_structrp png_ptr)*/","-1. #ifdef PNG_READ_PACKSWAP_SUPPORTED
/* Swap pixels packed into bytes; reverses the order on screen so that
 * the high order bits correspond to the rightmost pixels.
 *
 *  png_set_packswap(png_structrp png_ptr)

 /*Swap pixels packed into bytes; rever",Useful
"/*Invert the gray channel
 *
 *  png_set_invert_mono(png_structrp png_ptr)*/","-1. #ifdef PNG_READ_INVERT_MONO_SUPPORTED
/* Invert the gray channel
 *
 *  png_set_invert_mono(png_structrp png_ptr)

 /*Invert the gray channel
 *
 *  png_set_invert_mono(png_structrp png_ptr)*/

1.  */
2. static void
3. image_transform_png_set_invert_m",Useful
"/*png_set_shift(png_structp, png_const_color_8p true_bits)
 *
 * The output pixels will be shifted by the given true_bits
 * values.*/","-1. #ifdef PNG_READ_SHIFT_SUPPORTED
/* png_set_shift(png_structp, png_const_color_8p true_bits)
 *
 * The output pixels will be shifted by the given true_bits
 * values.

 /*png_set_shift(png_structp, png_const_color_8p true_bits)
 *
 * The output pixels ",Useful
"/*Get a random set of shifts.  The shifts need to do something
    * to test the transform, so they are limited to the bit depth
    * of the input image.  Notice that in the following the 'gray'
    * field is randomized independently.  This acts as a check that
    * libpng does use the correct field.*/","-10.  *
-9.  * The output pixels will be shifted by the given true_bits
-8.  * values.
-7.  */
-6. #define data ITDATA(shift)
-5. static png_color_8 data;
-4. static void
-3. image_transform_png_set_shift_set(const image_transform *this,
-2.     transform",Useful
"/*Copy the correct values into the sBIT fields, libpng does not do
    * anything to palette data:*/","-8.    png_set_shift(pp, &data);
-7.    this->next->set(this->next, that, pp, pi);
-6. }
-5. static void
-4. image_transform_png_set_shift_mod(const image_transform *this,
-3.     image_pixel *that, png_const_structp pp,
-2.     const transform_display *d",Useful
"/*The sBIT fields are reset to the values previously sent to
        * png_set_shift according to the colour type.
        * does.*/","-3.    if (that->colour_type != PNG_COLOR_TYPE_PALETTE)
-2.    {
-1.        that->sig_bits = 1;
       /* The sBIT fields are reset to the values previously sent to
        * png_set_shift according to the colour type.
        * does.

 /*The sBIT fields ",Useful
/*RGB channels*/,"-10.     image_pixel *that, png_const_structp pp,
-9.     const transform_display *display)
-8. {
-7.    if ((that->colour_type & PNG_COLOR_MASK_COLOR) != 0)
-6.    {
-5.       double gray, err;
-4. #     if PNG_LIBPNG_VER < 10700
-3.          if (that->c",Useful
/*This may just be 'end' if all the transforms are disabled!*/,"-10. static int
-9. image_transform_png_set_@_add(image_transform *this,
-8.     const image_transform **that, png_byte colour_type, png_byte bit_depth)
-7. {
-6.    this->next = *that;
-5.    *that = this;
-4.    return 1;
-3. }
-2. IT(@);
-1. #endif

 /",Useful
"/*Everything starts out enabled, so if we see an 'enable' disabled
    * everything else the first time round.*/","-4. static image_transform *const image_transform_first = &PT;
-3. static void
-2. transform_enable(const char *name)
-1. {
   /* Everything starts out enabled, so if we see an 'enable' disabled
    * everything else the first time round.

 /*Everything s",Useful
"/*This can only happen if we every have more than 32 transforms (excluding
    * the end) in the list.*/","-10. {
-9.    image_transform *next = image_transform_first;
-8.    int count = 0;
-7.    while (next != &image_transform_end)
-6.    {
-5.       next->local_use = 0;
-4.       next->next = 0;
-3.       next = next->list;
-2.       ++count;
-1.    }
   /*",Useful
"/*Test the list to see if there is any point contining, given a current
    * counter and a 'max' value.*/","-5.    if (count > 32) abort();
-4. }
-3. static int
-2. image_transform_test_counter(png_uint_32 counter, unsigned int max)
-1. {
   /* Test the list to see if there is any point contining, given a current
    * counter and a 'max' value.

 /*Test the li",Useful
/*For max 0 or 1 continue until the counter overflows:*/,"-3.    image_transform *next = image_transform_first;
-2.    while (next != &image_transform_end)
-1.    {

 /*For max 0 or 1 continue until the counter overflows:*/

1.       counter >>= 1;",Useful
/*Continue if any entry hasn't reacked the max.*/,"-1.       counter >>= 1;

 /*Continue if any entry hasn't reacked the max.*/

1.       if (max > 1 && next->local_use < max)
2.          return 1;
3.       next = next->list;
4.    }
5.    return max <= 1 && counter == 0;
6. }
7. static png_uint_32
8. ima",Useful
"/*Find the next counter value, if the counter is zero this is the start
       * of the list.  This routine always returns the current counter (not the
       * next) so it returns 0 at the end and expects 0 at the beginning.*/","-3.    {
-2.       png_uint_32 mask;
-1.       image_transform *list;
      /* Find the next counter value, if the counter is zero this is the start
       * of the list.  This routine always returns the current counter (not the
       * next) so it retur",Useful
"/*Now add all these items, if possible*/","-8.       {
-7.          switch (max)
-6.          {
-5.             case 0:  ++counter; break;
-4.             case 1:  counter <<= 1; break;
-3.             default: counter = random_32(); break;
-2.          }
-1.       }

 /*Now add all these items, i",Useful
/*Go through the whole list adding anything that the counter selects:*/,"-3.       *this = &image_transform_end;
-2.       list = image_transform_first;
-1.       mask = 1;

 /*Go through the whole list adding anything that the counter selects:*/

1.       while (list != &image_transform_end)
2.       {
3.          if ((counte",Useful
"/*Added, so add to the name too.*/","-2.             if (list->add(list, this, colour_type, bit_depth) || max == 0)
-1.             {

 /*Added, so add to the name too.*/

1.                *pos = safecat(name, sizeof_name, *pos, "" +"");
2.                *pos = safecat(name, sizeof_name, *po",Useful
/*Now if anything was added we have something to do.*/,"-6.                list->local_use = max;
-5.             }
-4.          }
-3.          mask <<= 1;
-2.          list = list->list;
-1.       }

 /*Now if anything was added we have something to do.*/

1.       if (*this != &image_transform_end)
2.       ",Useful
/*The command line can change this to checking interlaced images.*/,"-3.             name, sizeof name, &pos, colour_type, bit_depth);
-2.          if (counter == 0)
-1.             break;

 /*The command line can change this to checking interlaced images.*/

1.          do
2.          {
3.             pm->repeat = 0;
4.  ",Useful
"/*If requested strip 16 to 8 bits - this is handled automagically below
    * because the output bit depth is read from the library.  Note that there
    * are interactions with sBIT but, internally, libpng makes sbit at most
    * PNG_MAX_GAMMA_8 prior to 1.7 when doing the following.*/","-1.    standard_info_part1(&dp->this, pp, pi);
   /* If requested strip 16 to 8 bits - this is handled automagically below
    * because the output bit depth is read from the library.  Note that there
    * are interactions with sBIT but, internally, libp",Useful
"/*This tests the alpha mode handling, if supported.*/","-10.    if (dp->expand16)
-9. #     ifdef PNG_READ_EXPAND_16_SUPPORTED
-8.          png_set_expand_16(pp);
-7. #     else
-6.          png_error(pp, ""expand16 (8 to 16 bit conversion) not supported"");
-5. #     endif
-4.    if (dp->do_background >= ALPHA_",Useful
"/*The gamma value is the output gamma, and is in the standard,
          * non-inverted, representation.  It provides a default for the PNG file
          * gamma, but since the file has a gAMA chunk this does not matter.*/","-1.          int mode = dp->do_background - ALPHA_MODE_OFFSET;
         /* The gamma value is the output gamma, and is in the standard,
          * non-inverted, represenation.  It provides a default for the PNG file
          * gamma, but since the file ",Useful
"/*However, for the standard Porter-Duff algorithm the output defaults
          * to be linear, so if the test requires non-linear output it must be
          * corrected here.*/","-10.           */
-9.          const double sg = dp->screen_gamma;
-8. #        ifndef PNG_FLOATING_POINT_SUPPORTED
-7.             const png_fixed_point g = fix(sg);
-6. #        endif
-5. #        ifdef PNG_FLOATING_POINT_SUPPORTED
-4.             png_s",Useful
/*Set up gamma processing.*/,"-10.                png_set_gamma_fixed(pp, g, f);
-9. #           endif
-8.          }
-7.       }
-6. #     else
-5.          png_error(pp, ""alpha mode handling not supported"");
-4. #     endif
-3.    }
-2.    else
-1.    {

 /*Set up gamma processing.*",Useful
/*NOTE: this assumes the caller provided the correct background gamma!*/,"-10. #     else
-9.       {
-8.          png_fixed_point s = fix(dp->screen_gamma);
-7.          png_fixed_point f = fix(dp->file_gamma);
-6.          png_set_gamma_fixed(pp, s, f);
-5.       }
-4. #     endif
-3.       if (dp->do_background)
-2.       {
",Useful
"/*Validate a single component value - the routine gets the input and output
 * sample values as unscaled PNG component values along with a cache of all the
 * information required to validate the values.*/","-7. }
-6. static void PNGCBAPI
-5. gamma_info(png_structp pp, png_infop pi)
-4. {
-3.    gamma_info_imp(voidcast(gamma_display*, png_get_progressive_ptr(pp)), pp,
-2.       pi);
-1. }
/* Validate a single component value - the routine gets the input and o",Useful
"/*Linear background value, red or gray.*/","-2.    double screen_gamma;

 /*Linear background value, red or gray.*/

1.    double background_green;
2.    double background_blue;
3.    double maxabs;
4.    double maxpc;
5.    double maxcalc;
6.    double maxout;",Useful
/*Total including quantization error*/,"-6.    double background_green;
-5.    double background_blue;
-4.    double maxabs;
-3.    double maxpc;
-2.    double maxcalc;
-1.    double maxout;

 /*Total including quantization error*/

1.    double outlog;
2.    int    outquant;
3. }
4. validate_i",Useful
"/*This mimics the libpng threshold test, '0' is used to prevent gamma
    * correction in the validation test.*/","-10.    {
-9.       vi->sbit = dp->sbit;
-8.       vi->isbit_shift = in_depth - dp->sbit;
-7.    }
-6.    else
-5.    {
-4.       vi->sbit = (png_byte)in_depth;
-3.       vi->isbit_shift = 0;
-2.    }
-1.    vi->sbit_max = (1U << vi->sbit)-1;
   /* This m",Useful
/*Caller must at least put the gray value into the red channel*/,"-10.    if ((dp->this.colour_type & PNG_COLOR_MASK_ALPHA) != 0 ||
-9.       (dp->this.colour_type == 3 && dp->this.is_transparent) ||
-8.       ((dp->this.colour_type == 0 || dp->this.colour_type == 2) &&
-7.        dp->this.has_tRNS))
-6.    {
-5.       ",Useful
"/*libpng doesn't do this optimization, if we do pngvalid will fail.*/","-4.          r = dp->background_color.red; r /= outmax;
-3.          g = dp->background_color.green; g /= outmax;
-2.          b = dp->background_color.blue; b /= outmax;
-1. #     if 0
         /* libpng doesn't do this optimization, if we do pngvalid wi",Useful
"/*This function handles composition of a single non-alpha component.  The
 * argument is the input sample value, in the range 0..1, and the alpha value.
 * The result is the composed, linear, input sample.  If alpha is less than zero
 * this is the alpha component and the function should not be called!*/","-10.    if (vi->do_background == 0)
-9.       vi->background_red = vi->background_green = vi->background_blue = 0;
-8.    vi->gamma_correction = 1/(dp->file_gamma*dp->screen_gamma);
-7.    if (fabs(vi->gamma_correction-1) < PNG_GAMMA_THRESHOLD)
-6.       ",Useful
"/*The components are premultiplied in either case and the output is
          * gamma encoded (to get standard Porter-Duff we expect the output
          * gamma to be set to 1.0!)*/","-10.                   *compose = 1;
-9.             }
-8.             else
-7.                input_sample = background;
-6.          }
-5.          break;
-4. #endif
-3. #ifdef PNG_READ_ALPHA_MODE_SUPPORTED
-2.       case ALPHA_MODE_OFFSET + PNG_ALPHA_S",Useful
"/*The optimization is that the partial-alpha entries are linear
          * while the opaque pixels are gamma encoded, but this only affects the
          * output encoding.*/","-1.       case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:
         /* The optimization is that the partial-alpha entries are linear
          * while the opaque pixels are gamma encoded, but this only affects the
          * output encoding.

 /*The optimiz",Useful
"/*Standard cases where no compositing is done (so the component
          * value is already correct.)*/","-10.                input_sample *= alpha;
-9.                if (compose != NULL)
-8.                   *compose = 1;
-7.             }
-6.             else
-5.                input_sample = 0;
-4.          }
-3.          break;
-2. #endif
-1.       defa",Useful
"/*This API returns the encoded *input* component, in the range 0..1*/","-7.          UNUSED(alpha)
-6.          UNUSED(background)
-5.          UNUSED(compose)
-4.          break;
-3.    }
-2.    return input_sample;
-1. }

 /*This API returns the encoded *input* component, in the range 0..1*/

1. static double
2. gamma_compo",Useful
/*<0 for the alpha channel itself*/,"-3. static double
-2. gamma_component_validate(const char *name, const validate_info *vi,
-1.     const unsigned int id, const unsigned int od,

 /*<0 for the alpha channel itself*/

111",Useful
"/*First check on the 'perfect' result obtained from the digitized input
    * value, id, and compare this against the actual digitized result, 'od'.
    * 'i' is the input result in the range 0..1:*/","-6. {
-5.    const unsigned int isbit = id >> vi->isbit_shift;
-4.    const unsigned int sbit_max = vi->sbit_max;
-3.    const unsigned int outmax = vi->outmax;
-2.    const int do_background = vi->do_background;
-1.    double i;
   /* First check on the ",Useful
"/*Check for the fast route: if we don't do any background composition or if
    * this is the alpha channel ('alpha' < 0) or if the pixel is opaque then
    * just use the gamma_correction field to correct to the final output gamma.*/","-1.    i = isbit; i /= sbit_max;
   /* Check for the fast route: if we don't do any background composition or if
    * this is the alpha channel ('alpha' < 0) or if the pixel is opaque then
    * just use the gamma_correction field to correct to the final",Useful
/*alpha channel*/,"-10.    if (*bit_depth == 0)
-9.    {
-8.       *colour_type = 0;
-7.       if (low_depth_gray)
-6.          *bit_depth = 1;
-5.       else
-4.          *bit_depth = 8;
-3.       *palette_number = 0;
-2.       return 1;
-1.    }

 /*alpha channel*/

111",Useful
"/*Then get the gamma corrected version of 'i' and compare to 'od', any
       * error less than .5 is insignificant - just quantization of the output
       * value to the nearest digital value (nevertheless the error is still
       * recorded - it's interesting ;-)*/","-5. #ifdef PNG_READ_ALPHA_MODE_SUPPORTED
-4.       && do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN
-3. #endif
-2.       ))
-1.    {
      /* Then get the gamma corrected version of 'i' and compare to 'od', any
       * error less than .5 is insig",Useful
"/*alpha less than 0 indicates the alpha channel, which is always linear*/","-2.       double encoded_sample = i;
-1.       double encoded_error;
      /* alpha less than 0 indicates the alpha channel, which is always linear

 /*alpha less than 0 indicates the alpha channel, which is always linear*/

1.        */
2.       if (alph",Useful
/*The slow route - attempt to do linear calculations.*/,"-10.        */
-9.       if (alpha >= 0 && vi->gamma_correction > 0)
-8.          encoded_sample = pow(encoded_sample, vi->gamma_correction);
-7.       encoded_sample *= outmax;
-6.       encoded_error = fabs(od-encoded_sample);
-5.       if (encoded_erro",Useful
"/*There may be an error, or background processing is required, so calculate
    * the actual sample values - unencoded light intensity values.  Note that in
    * practice these are not completely unencoded because they include a
    * 'viewing correction' to decrease or (normally) increase the perceptual
    * contrast of the image.  There's nothing we can do about this - we don't
    * know what it is - so assume the unencoded value is perceptually linear.*/","
   /* There may be an error, or background processing is required, so calculate
    * the actual sample values - unencoded light intensity values.  Note that in
    * practice these are not completely unencoded because they include a
    * 'viewing correction' to decrease or (normally) increase the perceptual
    * contrast of the image.  There's nothing we can do about this - we don't
    * know what it is - so assume the unencoded value is perceptually linear.



 /*There may be an error, or background processing is required, so calculate
    * the actual sample values - unencoded light intensity values.  Note that in
    * practice these are not completely unencoded because they include a
    * 'viewing correction' to decrease or (normally) increase the perceptual
    * contrast of the image.  There's nothing we can do about this - we don't
    * know what it is - so assume the unencoded value is perceptually linear.*/

1.     */
2.    {",Useful
/*Set to one if composition done*/,"-2.       double output, error, encoded_sample, encoded_error;
-1.       double es_lo, es_hi;

 /*Set to one if composition done*/

111",Useful
/*Set if encoded to screen gamma*/,"-3.       double output, error, encoded_sample, encoded_error;
-2.       double es_lo, es_hi;

 /*Set if encoded to screen gamma*/

111",Useful
/*Check maximum error values*/,"-4.       double output, error, encoded_sample, encoded_error;
-3.       double es_lo, es_hi;

 /*Check maximum error values*/

111",Useful
/*Reason test passes (or 0 for fail)*/,"-5.       double output, error, encoded_sample, encoded_error;
-4.       double es_lo, es_hi;

 /*Reason test passes (or 0 for fail)*/

111",Useful
"/*Convert to linear light (with the above caveat.)  The alpha channel is
       * already linear.*/","
      /* Convert to linear light (with the above caveat.)  The alpha channel is
       * already linear.



 /*Convert to linear light (with the above caveat.)  The alpha channel is
       * already linear.*/

1.        */
2.       if (alpha >= 0)
3.       {
4.          int tcompose;
5.          if (vi->file_inverse > 0)
6.             input_sample = pow(input_sample, vi->file_inverse);",Useful
/*Handle the compose processing:*/,"-5.       if (alpha >= 0)
-4.       {
-3.          int tcompose;
-2.          if (vi->file_inverse > 0)
-1.             input_sample = pow(input_sample, vi->file_inverse);

 /*Handle the compose processing:*/

1.          tcompose = 0;
2.          input_s",Useful
"/*And similarly for the output value, but we need to check the background
       * handling to linearize it correctly.*/","-6.          tcompose = 0;
-5.          input_sample = gamma_component_compose(do_background, input_sample,
-4.             alpha, background, &tcompose);
-3.          if (tcompose)
-2.             compose = 1;
-1.       }
      /* And similarly for the o",Useful
/*The alpha channel*/,"
      /* Convert to linear light (with the above caveat.)  The alpha channel is



 /*The alpha channel*/

1.        * already linear.
2.        */
3.       if (alpha >= 0)
4.       {
5.          int tcompose;
6.          if (vi->file_inverse > 0)
7.             input_sample = pow(input_sample, vi->file_inverse);",Useful
"/*In all other cases the output alpha channel is linear already,
             * don't log errors here, they are much larger in linear data.*/","-5.       {
-4. #ifdef PNG_READ_ALPHA_MODE_SUPPORTED
-3.          if (do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN)
-2. #endif
-1.          {
            /* In all other cases the output alpha channel is linear already,
             * don't log e",Useful
/*the optimized case - linear output*/,"-2.       {
-1.          if (do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED &&

 /*the optimized case - linear output*/

1.          {
2.             if (alpha > 0) log_max_error = 0;
3.             output_is_encoded = 0;
4.          }
5.       ",Useful
"/*Calculate (or recalculate) the encoded_sample value and repeat the
       * check above (unnecessary if we took the fast route, but harmless.)*/","-8.          {
-7.             if (alpha > 0) log_max_error = 0;
-6.             output_is_encoded = 0;
-5.          }
-4.       }
-3. #endif
-2.       if (output_is_encoded)
-1.          output = pow(output, vi->screen_gamma);
      /* Calculate (or reca",Useful
"/*Don't log errors in the alpha channel, or the 'optimized' case,
       * neither are significant to the overall perception.*/","-5.       encoded_sample = input_sample;
-4.       if (output_is_encoded)
-3.          encoded_sample = pow(encoded_sample, vi->screen_inverse);
-2.       encoded_sample *= outmax;
-1.       encoded_error = fabs(od-encoded_sample);
      /* Don't log erro",Useful
"/*Test passed but error is bigger than the log limit, record why the
          * test passed:*/","-6.       if (log_max_error && encoded_error > vi->dp->maxerrout)
-5.          vi->dp->maxerrout = encoded_error;
-4.       if (encoded_error < vi->maxout_total)
-3.       {
-2.          if (encoded_error < vi->outlog)
-1.             return i;
         /",Useful
"/*i: the original input value in the range 0..1
       *
       * pngvalid calculations:
       *  input_sample: linear result; i linearized and composed, range 0..1
       *  encoded_sample: encoded result; input_sample scaled to output bit depth
       *
       * libpng calculations:
       *  output: linear result; od scaled to 0..1 and linearized
       *  od: encoded result from libpng*/","-2.          pass = ""less than maxout:\n"";
-1.       }
      /* i: the original input value in the range 0..1
       *
       * pngvalid calculations:
       *  input_sample: linear result; i linearized and composed, range 0..1
       *  encoded_sample: e",Useful
"/*Now we have the numbers for real errors, both absolute values as as a
       * percentage of the correct value (output):*/","
      /* Now we have the numbers for real errors, both absolute values as as a
       * percentage of the correct value (output):



 /*Now we have the numbers for real errors, both absolute values as as a
       * percentage of the correct value (output):*/

1.        */
2.       error = fabs(input_sample-output);
3.       if (log_max_error && error > vi->dp->maxerrabs)
4.          vi->dp->maxerrabs = error;",Useful
"/*The following is an attempt to ignore the tendency of quantization to
       * dominate the percentage errors for lower result values:*/","-3.       error = fabs(input_sample-output);
-2.       if (log_max_error && error > vi->dp->maxerrabs)
-1.          vi->dp->maxerrabs = error;
      /* The following is an attempt to ignore the tendency of quantization to
       * dominate the percentage ",Useful
"/*Now calculate the digitization limits for 'encoded_sample' using the
       * 'max' values.  Note that maxout is in the encoded space but maxpc and
       * maxabs are in linear light space.
       *
       * First find the maximum error in linear light space, range 0..1:*/","-6.       if (log_max_error && input_sample > .5)
-5.       {
-4.          double percentage_error = error/input_sample;
-3.          if (percentage_error > vi->dp->maxerrpc)
-2.             vi->dp->maxerrpc = percentage_error;
-1.       }
      /* Now ca",Useful
"/*If 'compose' is true the composition was done in linear space using
          * integer arithmetic.  This introduces an extra error of +/- 0.5 (at
          * least) in the integer space used.  'maxcalc' records this, taking
          * into account the possibility that even for 16 bit output 8 bit space
          * may have been used.*/","-3.       {
-2.          double tmp = input_sample * vi->maxpc;
-1.          if (tmp < vi->maxabs) tmp = vi->maxabs;
         /* If 'compose' is true the composition was done in linear space using
          * integer arithmetic.  This introduces an extra ",Useful
"/*The 'maxout' value refers to the encoded result, to compare with
          * this encode input_sample adjusted by the maximum error (tmp) above.*/","-1.          if (compose && tmp < vi->maxcalc) tmp = vi->maxcalc;
         /* The 'maxout' value refers to the encoded result, to compare with
          * this encode input_sample adjusted by the maximum error (tmp) above.

 /*The 'maxout' value refers to",Useful
"/*The primary test is that the final encoded value returned by the
       * library should be between the two limits (inclusive) that were
       * calculated above.*/","-10.             double high_value = input_sample+tmp;
-9.             if (output_is_encoded)
-8.                high_value = pow(high_value, vi->screen_inverse);
-7.             high_value *= outmax;
-6.             if (high_value > es_hi) es_hi = high_v",Useful
"/*There has been an error in processing, or we need to log this
          * value.*/","-6.          if (encoded_error < vi->outlog)
-5.             return i;
-4.          if (pass == 0)
-3.             pass = ""within digitization limits:\n"";
-2.       }
-1.       {
         /* There has been an error in processing, or we need to log this
  ",Useful
"/*pass is set at this point if either of the tests above would have
          * passed.  Don't do these additional tests here - just log the
          * original [es_lo..es_hi] values.*/","-1.          double is_lo, is_hi;
         /* pass is set at this point if either of the tests above would have
          * passed.  Don't do these additional tests here - just log the
          * original [es_lo..es_hi] values.

 /*pass is set at this po",Useful
"/*Ok, something is wrong - this actually happens in current libpng
             * 16-to-8 processing.  Assume that the input value (id, adjusted
             * for sbit) can be anywhere between value-.5 and value+.5 - quite a
             * large range if sbit is low.
             *
             * NOTE: at present because the libpng gamma table stuff has been
             * changed to use a rounding algorithm to correct errors in 8-bit
             * calculations the precise sbit calculation (a shift) has been
             * lost.  This can result in up to a +/-1 error in the presence of
             * an sbit less than the bit depth.*/","-2.          if (pass == 0 && vi->use_input_precision && vi->dp->sbit)
-1.          {
            /* Ok, something is wrong - this actually happens in current libpng
             * 16-to-8 processing.  Assume that the input value (id, adjusted
           ",Useful
"/*One last chance.  If this is an alpha channel and the 16to8
             * option has been used and 'inaccurate' scaling is used then the
             * bit reduction is obtained by simply using the top 8 bits of the
             * value.
             *
             * This is only done for older libpng versions when the 'inaccurate'
             * (chop) method of scaling was used.*/","-10.                tmp = pow(tmp, vi->screen_inverse);
-9.             is_hi = floor(outmax * tmp + vi->maxout_total);
-8.             if (is_hi > outmax)
-7.                is_hi = outmax;
-6.             if (!(od < is_lo || od > is_hi))
-5.            ",Useful
"/*This may be required for other components in the future,
                   * but at present the presence of gamma correction effectively
                   * prevents the errors in the component scaling (I don't quite
                   * understand why, but since it's better this way I care not
                   * to ask, JB 20110419.)*/","-2. #           ifndef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
-1. #              if PNG_LIBPNG_VER < 10504
                  /* This may be required for other components in the future,
                   * but at present the presence of gamma correctio",Useful
"/*Attempt to output a meaningful error/warning message: the message
          * output depends on the background/composite operation being performed
          * because this changes what parameters were actually used above.*/","-1.             is_lo = es_lo, is_hi = es_hi;
         /* Attempt to output a meaningful error/warning message: the message
          * output depends on the background/composite operation being performed
          * because this changes what parameters w",Useful
"/*Need either 1/255 or 1/65535 precision here; 3 or 6 decimal
             * places.  Just use outmax to work out which.*/","-2.          {
-1.             size_t pos = 0;
            /* Need either 1/255 or 1/65535 precision here; 3 or 6 decimal
             * places.  Just use outmax to work out which.

 /*Need either 1/255 or 1/65535 precision here; 3 or 6 decimal
          ",Useful
"/*Set up the various flags, the output_is_encoded flag above
             * is also used below.  do_compose is just a double check.*/","-5.             int precision = (outmax >= 1000 ? 6 : 3);
-4.             int use_input=1, use_background=0, do_compose=0;
-3.             char msg[256];
-2.             if (pass != 0)
-1.                pos = safecat(msg, sizeof msg, pos, ""\n\t"");
      ",Useful
/*Check the 'compose' flag*/,"-6.                do_compose = (alpha > 0 && alpha < 1);
-5.                use_input = (alpha != 0);
-4.                break;
-3.             default:
-2.                break;
-1.             }

 /*Check the 'compose' flag*/

1.             if (compos",Useful
/*sBIT has reduced the precision of the input:*/,"-3.             {
-2.                if (isbit != id)
-1.                {

 /*sBIT has reduced the precision of the input:*/

1.                   pos = safecat(msg, sizeof msg, pos, "", sbit("");
2.                   pos = safecatn(msg, sizeof msg, pos, v",Useful
"/*A component may have been multiplied (in linear space) by the
             * alpha value, 'compose' says whether this is relevant.*/","-3.                pos = safecatn(msg, sizeof msg, pos, vi->sbit_max);
-2.             }
-1.             pos = safecat(msg, sizeof msg, pos, "")"");
            /* A component may have been multiplied (in linear space) by the
             * alpha value, 'co",Useful
"/*If any form of composition is being done report our
                * calculated linear value here (the code above doesn't record
                * the input value before composition is performed, so what
                * gets reported is the value after composition.)*/","-2.             if (compose || pass != 0)
-1.             {
               /* If any form of composition is being done report our
                * calculated linear value here (the code above doesn't record
                * the input value before compos",Useful
"/*Now record the *linear* background value if it was used
                * (this function is not passed the original, non-linear,
                * value but it is contained in the test name.)*/","-10.                   if (vi->file_inverse > 0)
-9.                   {
-8.                      pos = safecat(msg, sizeof msg, pos, ""^"");
-7.                      pos = safecatd(msg, sizeof msg, pos, vi->file_inverse, 2);
-6.                   }
-5.    ",Useful
"/*Report the calculated value (input_sample) and the linearized
             * libpng value (output) unless this is just a component gamma
             * correction.*/","-10.                 */
-9.                if (use_background)
-8.                {
-7.                   pos = safecat(msg, sizeof msg, pos, use_input ? ""+"" : "" "");
-6.                   pos = safecat(msg, sizeof msg, pos, ""(background)"");
-5.           ",Useful
"/*Finally report the output gamma encoding, if any.*/","-10.              * correction.
-9.              */
-8.             if (compose || alpha < 0 || pass != 0)
-7.             {
-6.                pos = safecat(msg, sizeof msg, pos,
-5.                   pass != 0 ? "" =\n\t"" : "" = "");
-4.                pos",Useful
"/*This is the non-composition case, the internal linear
                * values are irrelevant (though the log below will reveal
                * them.)  Output a much shorter warning/error message and report
                * the overall gamma correction.*/","-1.                   pos = safecat(msg, sizeof msg, pos, ""\n\t[overall:"");
               /* This is the non-composition case, the internal linear
                * values are irrelevant (though the log below will reveal
                * them.)  Output ",Useful
/*Get some constants derived from the input and output file formats:*/,"-10.                store_verbose(&vi->dp->pm->this, vi->pp, pass, msg);
-9.          }
-8.       }
-7.    }
-6.    return i;
-5. }
-4. static void
-3. gamma_image_validate(gamma_display *dp, png_const_structp pp,
-2.    png_infop pi)
-1. {

 /*Get some c",Useful
"/*There are three sources of error, firstly the quantization in the
    * file encoding, determined by sbit and/or the file depth, secondly
    * the output (screen) gamma and thirdly the output file encoding.
    *
    * Since this API receives the screen and file gamma in double
    * precision it is possible to calculate an exact answer given an input
    * pixel value.  Therefore we assume that the *input* value is exact -
    * sample/maxsample - calculate the corresponding gamma corrected
    * output to the limits of double precision arithmetic and compare with
    * what libpng returns.
    *
    * Since the library must quantize the output to 8 or 16 bits there is
    * a fundamental limit on the accuracy of the output of +/-.5 - this
    * quantization limit is included in addition to the other limits
    * specified by the parameters to the API.  (Effectively, add .5
    * everywhere.)
    *
    * The behavior of the 'sbit' parameter is defined by section 12.5
    * (sample depth scaling) of the PNG spec.  That section forces the
    * decoder to assume that the PNG values have been scaled if sBIT is
    * present:
    *
    *     png-sample = floor( input-sample * (max-out/max-in) + .5);
    *
    * This means that only a subset of the possible PNG values should
    * appear in the input. However, the spec allows the encoder to use a
    * variety of approximations to the above and doesn't require any
    * restriction of the values produced.
    *
    * Nevertheless the spec requires that the upper 'sBIT' bits of the
    * value stored in a PNG file be the original sample bits.
    * Consequently the code below simply scales the top sbit bits by
    * (1<<sbit)-1 to obtain an original sample value.
    *
    * Because there is limited precision in the input it is arguable that
    * an acceptable result is any valid result from input-.5 to input+.5.
    * The basic tests below do not do this, however if 'use_input_precision'
    * is set a subsequent test is performed above.*/","-10. {
-9.    /* Get some constants derived from the input and output file formats: */
-8.    const png_store* const ps = dp->this.ps;
-7.    const png_byte in_ct = dp->this.colour_type;
-6.    const png_byte in_bd = dp->this.bit_depth;
-5.    const png_u",Useful
/*Check for row overwrite errors*/,"-10.       PNG_COLOR_TYPE_PALETTE ? 8 : out_bd);
-9.    const png_byte red_sBIT = dp->this.red_sBIT;
-8.    const png_byte green_sBIT = dp->this.green_sBIT;
-7.    const png_byte blue_sBIT = dp->this.blue_sBIT;
-6.    const png_byte alpha_sBIT = dp->this.",Useful
"/*Supply the input and output sample depths here - 8 for an indexed image,
    * otherwise the bit depth.*/","-1.    store_image_check(dp->this.ps, pp, 0);
   /* Supply the input and output sample depths here - 8 for an indexed image,
    * otherwise the bit depth.

 /*Supply the input and output sample depths here - 8 for an indexed image,
    * otherwise the bi",Useful
"/*TODO: FIX THIS: MAJOR BUG!  If the transformations all happen inside
    * the palette there is no way of finding out, because libpng fails to
    * update the palette on png_read_update_info.  Indeed, libpng doesn't
    * even do the required work until much later, when it doesn't have any
    * info pointer.  Oops.  For the moment 'processing' is turned off if
    * out_ct is palette.*/","-4.    init_validate_info(&vi, dp, pp, in_ct==3?8:in_bd, out_ct==3?8:out_bd);
-3.    processing = (vi.gamma_correction > 0 && !dp->threshold_test)
-2.       || in_bd != out_bd || in_ct != out_ct || vi.do_background;
-1.    process_tRNS = dp->this.has_tRNS",Useful
/*Record the palette index for index images.*/,"-10.    {
-9.       png_const_bytep pRow = store_image_row(ps, pp, 0, y);
-8.       png_byte std[STANDARD_ROWMAX];
-7.       transform_row(pp, std, in_ct, in_bd, y);
-6.       if (processing)
-5.       {
-4.          unsigned int x;
-3.          for (x=0;",Useful
"/*Handle input alpha - png_set_background will cause the output
             * alpha to disappear so there is nothing to check.*/","-4.             const unsigned int in_index =
-3.                in_ct == 3 ? sample(std, 3, in_bd, x, 0, 0, 0) : 256;
-2.             const unsigned int out_index =
-1.                out_ct == 3 ? sample(std, 3, out_bd, x, 0, 0, 0) : 256;
            /*",Useful
"/*This is a copy of the calculation of 'i' above in order to
                   * have the alpha value to use in the background calculation.*/","-1.                {
                  /* This is a copy of the calculation of 'i' above in order to
                   * have the alpha value to use in the background calculation.

 /*This is a copy of the calculation of 'i' above in order to
           ",Useful
"/*alpha needs to be set appropriately for this pixel, it is
                * currently 1 and needs to be 0 for an input pixel which matches
                * the values in tRNS.*/","-6.                   alpha = input_alpha >> vi.isbit_shift;
-5.                   alpha /= vi.sbit_max;
-4.                }
-3.             }
-2.             else if (process_tRNS)
-1.             {
               /* alpha needs to be set appropriately ",Useful
/*Handle grayscale or RGB components.*/,"-10.                          sample(std, in_ct, in_bd, x, 1, 0, 0) ==
-9.                            dp->this.transparent.green &&
-8.                          sample(std, in_ct, in_bd, x, 2, 0, 0) ==
-7.                            dp->this.transparent.b",Useful
/*grayscale*/,"-10. {
-9.    char number[64];
-8.    sprintf(number, ""%.*f"", precision, d);
-7.    return safecat(buffer, bufsize, pos, number);
-6. }
-5. #endif
-4. static const char invalid[] = ""invalid"";
-3. static const char sep[] = "": "";
-2. static const char *colo",Useful
/*RGB or palette*/,"-4.                (void)gamma_component_validate(""gray"", &vi,
-3.                   sample(std, in_ct, in_bd, x, 0, 0, 0),
-2.                   sample(pRow, out_ct, out_bd, x, 0, 0, 0),

 /*RGB or palette*/

1.             {
2.                (void)gamm",Useful
"/*A single test run checking a gamma transformation.
 *
 * maxabs: maximum absolute error as a fraction
 * maxout: maximum output error in the output units
 * maxpc:  maximum percentage error (as a percentage)*/","-10. static void PNGCBAPI
-9. gamma_end(png_structp ppIn, png_infop pi)
-8. {
-7.    png_const_structp pp = ppIn;
-6.    gamma_display *dp = voidcast(gamma_display*, png_get_progressive_ptr(pp));
-5.    if (!dp->this.speed)
-4.       gamma_image_validate(",Useful
"/*Make an appropriate modifier to set the PNG file gamma to the
       * given gamma value and the sBIT chunk to the given precision.*/","-1.       d.pm->current_gamma = d.file_gamma;
      /* Make an appropriate modifier to set the PNG file gamma to the
       * given gamma value and the sBIT chunk to the given precision.

 /*Make an appropriate modifier to set the PNG file gamma to the
  ",Useful
/*Get a png_struct for reading the image.*/,"-4.    Try
-3.    {
-2.       png_structp pp;
-1.       png_infop pi;
      /* Get a png_struct for reading the image. This will throw an error if it

 /*Get a png_struct for reading the image.*/

1.        * fails, so we don't need to check the result.
2",Useful
/*Introduce the correct read function.*/,"-1.       standard_palette_init(&d);

 /*Introduce the correct read function.*/

1.       if (d.ps->progressive)
2.       {
3.          png_set_progressive_read_fn(pp, &d, standard_info, progressive_row,
4.             standard_end);",Useful
/*Now feed data into the reader until we reach the end:*/,"-4.       if (d.ps->progressive)
-3.       {
-2.          png_set_progressive_read_fn(pp, &d, standard_info, progressive_row,
-1.             standard_end);

 /*Now feed data into the reader until we reach the end:*/

1.          store_progressive_read(d.",Useful
/*Check the header values:*/,"-1.          png_set_read_fn(pp, d.ps, store_read);

 /*Check the header values:*/

1.          png_read_info(pp, pi);",Useful
/*Log the summary values too.*/,"-10.          if (!d.this.speed)
-9.             gamma_image_validate(&d, pp, pi);
-8.          else
-7.             d.this.ps->validated = 1;
-6.       }
-5.       modifier_reset(d.pm);
-4.       if (d.pm->log && !d.threshold_test && !d.this.speed)
-3.  ",Useful
/*no background gamma*/,"-10.    size_t pos = 0;
-9.    char name[64];
-8.    pos = safecat(name, sizeof name, pos, ""threshold "");
-7.    pos = safecatd(name, sizeof name, pos, file_gamma, 3);
-6.    pos = safecat(name, sizeof name, pos, ""/"");
-5.    pos = safecatd(name, sizeof n",Useful
"/*Don't test more than one instance of each palette - it's pointless, in
    * fact this test is somewhat excessive since libpng doesn't make this
    * decision based on colour type or bit depth!
    *
    * CHANGED: now test two palettes and, as a side effect, images with and
    * without tRNS.*/","-7. }
-6. static void
-5. perform_gamma_threshold_tests(png_modifier *pm)
-4. {
-3.    png_byte colour_type = 0;
-2.    png_byte bit_depth = 0;
-1.    unsigned int palette_number = 0;
   /* Don't test more than one instance of each palette - it's pointles",Useful
"/*There's little point testing the interlacing vs non-interlacing,
          * but this can be set from the command line.*/","-10.     * CHANGED: now test two palettes and, as a side effect, images with and
-9.     * without tRNS.
-8.     */
-7.    while (next_format(&colour_type, &bit_depth, &palette_number,
-6.                       pm->test_lbg_gamma_threshold, pm->test_tRNS)",Useful
"/*The only interesting cases are colour and grayscale, alpha is ignored here
    * for overall speed.  Only bit depths where sbit is less than the bit depth
    * are tested.*/","-8.             if (fail(pm))
-7.                return;
-6.          }
-5.    }
-4. }
-3. static void perform_gamma_sbit_tests(png_modifier *pm)
-2. {
-1.    png_byte sbit;
   /* The only interesting cases are colour and grayscale, alpha is ignored here
",Useful
"/*Note that this requires a 16 bit source image but produces 8 bit output, so
 * we only need the 16bit write support, but the 16 bit images are only
 * generated if DO_16BIT is defined.*/","-7.                if (fail(pm))
-6.                   return;
-5.             }
-4.          }
-3.       }
-2.    }
-1. }
/* Note that this requires a 16 bit source image but produces 8 bit output, so
 * we only need the 16bit write support, but the 16 b",Useful
"/*Include the alpha cases here. Note that sbit matches the internal value
    * used by the library - otherwise we will get spurious errors from the
    * internal sbit style approximation.
    *
    * The threshold test is here because otherwise the 16 to 8 conversion will
    * proceed *without* gamma correction, and the tests above will fail (but not
    * by much) - this could be fixed, it only appears with the -g option.*/","-10. static void perform_gamma_scale16_tests(png_modifier *pm)
-9. {
-8. #  ifndef PNG_MAX_GAMMA_8
-7. #     define PNG_MAX_GAMMA_8 11
-6. #  endif
-5. #  if defined PNG_MAX_GAMMA_8 || PNG_LIBPNG_VER < 10700
-4. #     define SBIT_16_TO_8 PNG_MAX_GAMMA_8
-",Useful
/*Make up a name and get an appropriate background gamma value.*/,"-10.    const int interlace_type, const double file_gamma,
-9.    const double screen_gamma,
-8.    const int use_input_precision, const int do_background,
-7.    const int expand_16)
-6. {
-5.    size_t pos = 0;
-4.    png_const_charp base;
-3.    double",Useful
"/*This tests the handling of a unique value, the math is such that the
          * value tends to be <1, but is neither screen nor file (even if they
          * match!)*/","-10.       case PNG_BACKGROUND_GAMMA_SCREEN:
-9.          base = "" bckg(Screen):"";
-8.          bg = 1/screen_gamma;
-7.          break;
-6.       case PNG_BACKGROUND_GAMMA_FILE:
-5.          base = "" bckg(File):"";
-4.          bg = file_gamma;
-3.       ",Useful
"/*Use random background values - the background is always presented in the
    * output space (8 or 16 bit components).*/","-3.          break;
-2. #endif
-1.    }
   /* Use random background values - the background is always presented in the
    * output space (8 or 16 bit components).

 /*Use random background values - the background is always presented in the
    * output s",Useful
"/*In earlier libpng versions, those where DIGITIZE is set, any background
       * gamma correction in the expand16 case was done using 8-bit gamma
       * correction tables, resulting in larger errors.  To cope with those
       * cases use a 16-bit background value which will handle this gamma
       * correction.*/","-10.     * output space (8 or 16 bit components).
-9.     */
-8.    if (expand_16 || bit_depth == 16)
-7.    {
-6.       png_uint_32 r = random_32();
-5.       background.red = (png_uint_16)r;
-4.       background.green = (png_uint_16)(r >> 16);
-3.      ",Useful
"/*The background values will be looked up in an 8-bit table to do
             * the gamma correction, so only select values which are an exact
             * match for the 8-bit table entries:*/","-10.        * gamma correction in the expand16 case was done using 8-bit gamma
-9.        * correction tables, resulting in larger errors.  To cope with those
-8.        * cases use a 16-bit background value which will handle this gamma
-7.        * corre",Useful
"/*Because, currently, png_set_background is always called with
       * 'need_expand' false in this case and because the gamma test itself
       * doesn't cause an expand to 8-bit for lower bit depths the colour must
       * be reduced to the correct range.*/","-2.    if (!(colour_type & PNG_COLOR_MASK_COLOR))
-1.    {
      /* Because, currently, png_set_background is always called with
       * 'need_expand' false in this case and because the gamma test itself
       * doesn't cause an expand to 8-bit for lowe",Useful
"/*Grayscale input, we do not convert to RGB (TBD), so we must set the
       * background to gray - else libpng seems to fail.*/","-2.       if (bit_depth < 8)
-1.          background.gray &= (png_uint_16)((1U << bit_depth)-1);
      /* Grayscale input, we do not convert to RGB (TBD), so we must set the
       * background to gray - else libpng seems to fail.

 /*Grayscale input, we ",Useful
/*Include the background color and gamma in the name:*/,"-10.        */
-9.       background.red = background.green = background.blue = background.gray;
-8.    }
-7.    pos = safecat(name, sizeof name, pos, ""gamma "");
-6.    pos = safecatd(name, sizeof name, pos, file_gamma, 3);
-5.    pos = safecat(name, sizeo",Useful
/*This assumes no expand gray->rgb - the current code won't handle that!*/,"-1.       pos = safecat(name, sizeof name, pos, ""("");
      /* This assumes no expand gray->rgb - the current code won't handle that!

 /*This assumes no expand gray->rgb - the current code won't handle that!*/

1.        */
2.       if (colour_type & PNG",Useful
"/*Skip the non-alpha cases - there is no setting of a transparency colour at
    * present.
    *
    * TODO: incorrect; the palette case sets tRNS and, now RGB and gray do,
    * however the palette case fails miserably so is commented out below.*/","-8. }
-7. static void
-6. perform_gamma_composition_tests(png_modifier *pm, int do_background,
-5.    int expand_16)
-4. {
-3.    png_byte colour_type = 0;
-2.    png_byte bit_depth = 0;
-1.    unsigned int palette_number = 0;
   /* Skip the non-alpha cas",Useful
/*READ_BACKGROUND || READ_ALPHA_MODE*/,"-10.       for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)
-9.       {
-8.          gamma_composition_test(pm, colour_type, bit_depth, palette_number,
-7.             pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],
-6.           ",Useful
/*Save certain values for the temporary overrides below.*/,"-10.          print_one("" indexed:    "", pm->error_indexed);
-9.    }
-8.    print_one(""16 bit gray: "", pm->error_gray_16);
-7.    print_one(""16 bit color:"", pm->error_color_16);
-6.    fflush(stdout);
-5. }
-4. static void
-3. perform_gamma_test(png_modi",Useful
"/*TODO: remove this.  Necessary because the current libpng
       * implementation works in 8 bits:*/","-10.          printf(""value (always an integer) and the ideal value from the\n"");
-9.          printf(""libpng specification (typically not an integer).\n\n"");
-8.          printf(""Expect this value to be less than .5 for 8 bit formats,\n"");
-7.          p",Useful
/*The sbit tests produce much larger errors:*/,"-3.       if (fail(pm))
-2.          return;
-1.    }

 /*The sbit tests produce much larger errors:*/

1.    if (pm->test_gamma_sbit)
2.    {
3.       init_gamma_errors(pm);
4.       perform_gamma_sbit_tests(pm);
5.       if (summary)",Useful
"/*TODO: remove this.  Necessary because the current libpng
       * implementation works in 8 bits:*/","-10.          printf(""value (always an integer) and the ideal value from the\n"");
-9.          printf(""libpng specification (typically not an integer).\n\n"");
-8.          printf(""Expect this value to be less than .5 for 8 bit formats,\n"");
-7.          p",Useful
"/*TODO: remove this.  Necessary because the current libpng
       * implementation works in 8 bits:*/","-10.          printf(""value (always an integer) and the ideal value from the\n"");
-9.          printf(""libpng specification (typically not an integer).\n\n"");
-8.          printf(""Expect this value to be less than .5 for 8 bit formats,\n"");
-7.          p",Useful
"/*This is copied verbatim from the specification, it is simply the pass
 * number in which each pixel in each 8x8 tile appears.  The array must
 * be indexed adam7[y][x] and notice that the pass numbers are based at
 * 1, not 0 - the base libpng uses.*/","/* This is copied verbatim from the specification, it is simply the pass
 * number in which each pixel in each 8x8 tile appears.  The array must
 * be indexed adam7[y][x] and notice that the pass numbers are based at
 * 1, not 0 - the base libpng uses.

 /*This is copied verbatim from the specification, it is simply the pass
 * number in which each pixel in each 8x8 tile appears.  The array must
 * be indexed adam7[y][x] and notice that the pass numbers are based at
 * 1, not 0 - the base libpng uses.*/

1.  */
2. static const
3. png_byte adam7[8][8] =
4. {
5.    { 1,6,4,6,2,6,4,6 },
6.    { 7,7,7,7,7,7,7,7 },
7.    { 5,6,5,6,5,6,5,6 },
8.    { 7,7,7,7,7,7,7,7 },
9.    { 3,6,4,6,3,6,4,6 },
10.    { 7,7,7,7,7,7,7,7 },",Useful
"/*This routine validates all the interlace support macros in png.h for
 * a variety of valid PNG widths and heights.  It uses a number of similarly
 * named internal routines that feed off the above array.*/","-10. {
-9.    { 1,6,4,6,2,6,4,6 },
-8.    { 7,7,7,7,7,7,7,7 },
-7.    { 5,6,5,6,5,6,5,6 },
-6.    { 7,7,7,7,7,7,7,7 },
-5.    { 3,6,4,6,3,6,4,6 },
-4.    { 7,7,7,7,7,7,7,7 },
-3.    { 5,6,5,6,5,6,5,6 },
-2.    { 7,7,7,7,7,7,7,7 }
-1. };
/* This routine va",Useful
/*error - more than one 'inc' value!*/,"-10.    {
-9.       if (base == (-1))
-8.          base = y;
-7.       else if (base == y)
-6.          {}
-5.       else if (inc == y-base)
-4.          base=y;
-3.       else if (inc == 8)
-2.          inc = y-base, base=y;
-1.       else if (inc != y-b",Useful
/*error - no row in pass!*/,"-1.    }

 /*error - no row in pass!*/

111",Useful
/*error - more than one 'inc' value!*/,"-10.    {
-9.       if (base == (-1))
-8.          base = y;
-7.       else if (base == y)
-6.          {}
-5.       else if (inc == y-base)
-4.          base=y;
-3.       else if (inc == 8)
-2.          inc = y-base, base=y;
-1.       else if (inc != y-b",Useful
/*error - no row in pass!*/,"-1.    }

 /*error - no row in pass!*/

111",Useful
/*By examination of the array:*/,"-5.    return (inc << 8) + 0xfd;
-4. }
-3. static png_uint_32
-2. png_row_from_pass_row(png_uint_32 yIn, int pass)
-1. {

 /*By examination of the array:*/

1.    switch (pass)
2.    {
3. case 0: return yIn * 8;
4. case 1: return yIn * 8;
5. case 2: retur",Useful
/*By examination of the array:*/,"-5.    return (inc << 8) + 0xfd;
-4. }
-3. static png_uint_32
-2. png_row_from_pass_row(png_uint_32 yIn, int pass)
-1. {

 /*By examination of the array:*/

1.    switch (pass)
2.    {
3. case 0: return yIn * 8;
4. case 1: return yIn * 8;
5. case 2: retur",Useful
"/*The macros to validate, first those that depend only on pass:
    *
    * PNG_PASS_START_ROW(pass)
    * PNG_PASS_START_COL(pass)
    * PNG_PASS_ROW_SHIFT(pass)
    * PNG_PASS_COL_SHIFT(pass)*/","-6.    }
-5.    return cols;
-4. }
-3. static void
-2. perform_interlace_macro_validation(void)
-1. {
   /* The macros to validate, first those that depend only on pass:
    *
    * PNG_PASS_START_ROW(pass)
    * PNG_PASS_START_COL(pass)
    * PNG_PASS_RO",Useful
"/*Macros that depend on the image or sub-image height too:
       *
       * PNG_PASS_ROWS(height, pass)
       * PNG_PASS_COLS(width, pass)
       * PNG_ROW_FROM_PASS_ROW(yIn, pass)
       * PNG_COL_FROM_PASS_COL(xIn, pass)
       * PNG_ROW_IN_INTERLACE_PASS(y, pass)
       * PNG_COL_IN_INTERLACE_PASS(x, pass)*/","-10.          fprintf(stderr, ""PNG_PASS_ROW_SHIFT(%d) = %u != %x\n"", pass, m, f);
-9.          exit(99);
-8.       }
-7.       m = PNG_PASS_COL_SHIFT(pass);
-6.       f = png_pass_col_shift(pass);
-5.       if (m != f)
-4.       {
-3.          fprintf(std",Useful
"/*The first two tests overflow if the pass row or column is outside
          * the possible range for a 32-bit result.  In fact the values should
          * never be outside the range for a 31-bit result, but checking for 32
          * bits here ensures that if an app uses a bogus pass row or column
          * (just so long as it fits in a 32 bit integer) it won't get a
          * possibly dangerous overflow.*/",#NAME?,Useful
/*First the base 0 stuff:*/,"-10.        */
-9.       for (v=0;;)
-8.       {

 /*First the base 0 stuff:*/

1.          if (v < png_pass_rows(0xFFFFFFFFU, pass))
2.          {
3.             m = PNG_ROW_FROM_PASS_ROW(v, pass);
4.             f = png_row_from_pass_row(v, pass);
5.   ",Useful
/*Then the base 1 stuff:*/,"-10.             exit(99);
-9.          }
-8.          m = PNG_COL_IN_INTERLACE_PASS(v, pass);
-7.          f = png_col_in_interlace_pass(v, pass);
-6.          if (m != f)
-5.          {
-4.             fprintf(stderr, ""PNG_COL_IN_INTERLACE_PASS(%u, %d) ",Useful
"/*Move to the next v - the stepping algorithm starts skipping
          * values above 1024.*/","-10.             exit(99);
-9.          }
-8.          m = PNG_PASS_COLS(v, pass);
-7.          f = png_pass_cols(v, pass);
-6.          if (m != f)
-5.          {
-4.             fprintf(stderr, ""PNG_PASS_COLS(%u, %d) = %u != %x\n"",
-3.                v,",Useful
"/*Test color encodings. These values are back-calculated from the published
 * chromaticities.  The values are accurate to about 14 decimal places; 15 are
 * given.  These values are much more accurate than the ones given in the spec,
 * which typically don't exceed 4 decimal places.  This allows testing of the
 * libpng code to its theoretical accuracy of 4 decimal places.  (If pngvalid
 * used the published errors the 'slack' permitted would have to be +/-.5E-4 or
 * more.)
 *
 * The png_modifier code assumes that encodings[0] is sRGB and treats it
 * specially: do not change the first entry in this list!*/","-10.          {
-9.             if (v == PNG_UINT_31_MAX)
-8.                break;
-7.             v = (v << 1) ^ v;
-6.             if (v >= PNG_UINT_31_MAX)
-5.                v = PNG_UINT_31_MAX-1;
-4.          }
-3.       }
-2.    }
-1. }
/* Test col",Useful
/*approximate: uses 1.8 power law compared to sRGB 2.4*/,"-10.  * specially: do not change the first entry in this list!
-9.  */
-8. static const color_encoding test_encodings[] =
-7. {

 /*approximate: uses 1.8 power law compared to sRGB 2.4*/

111",Useful
/*Fake encoding which selects just the green channel*/,"-10. /* Adobe RGB (1998) */
-9. /*gamma:*/ { 1/(2+51./256),
-8. /*red:  */ { 0.576669042910131, 0.297344975250536, 0.027031361386412 },
-7. /*green:*/ { 0.185558237906546, 0.627363566255466, 0.070688852535827 },
-6. /*blue: */ { 0.188228646234995, 0.07529",Useful
"/*signal handler
 *
 * This attempts to trap signals and escape without crashing.  It needs a
 * context pointer so that it can throw an exception (call longjmp) to recover
 * from the condition; this is handled by making the png_modifier used by 'main'
 * into a global variable.*/","-10. /*gamma:*/ { 1/(2+51./256),
-9. /*red:  */ { 0.716500716779386, 0.258728243040113, 0.000000000000000 },
-8. /*green:*/ { 0.101020574397477, 0.724682314948566, 0.051211818965388 },
-7. /*blue: */ { 0.146774385252705, 0.016589442011321, 0.7738927835450",Useful
"/*And finally throw an exception so we can keep going, unless this is
    * SIGTERM in which case stop now.*/","
   /* And finally throw an exception so we can keep going, unless this is
    * SIGTERM in which case stop now.



 /*And finally throw an exception so we can keep going, unless this is
    * SIGTERM in which case stop now.*/

1.     */
2.    if (signum != SIGTERM)
3.    {
4.       struct exception_context *the_exception_context =
5.          &pm.this.exception_context;
6.       Throw &pm.this;
7.    }
8.    else
9.       exit(1);
10. }",Useful
/*Print the error summary at the end*/,"-2. int main(int argc, char **argv)
-1. {

 /*Print the error summary at the end*/

111",Useful
/*Print memory statistics at the end*/,"-3. int main(int argc, char **argv)
-2. {

 /*Print memory statistics at the end*/

111",Useful
/*Create the given output file on success:*/,"-4. int main(int argc, char **argv)
-3. {

 /*Create the given output file on success:*/

1.    const char *touch = NULL;",Useful
"/*This is an array of standard gamma values (believe it or not I've seen
    * every one of these mentioned somewhere.)
    *
    * In the following list the most useful values are first!*/","-1.    const char *touch = NULL;
   /* This is an array of standard gamma values (believe it or not I've seen
    * every one of these mentioned somewhere.)
    *
    * In the following list the most useful values are first!

 /*This is an array of standa",Useful
/*This records the command and arguments:*/,"-2.    static double
-1.       gammas[]={2.2, 1.0, 2.2/1.45, 1.8, 1.5, 2.4, 2.5, 2.62, 2.9};

 /*This records the command and arguments:*/

1.    size_t cp = 0;
2.    char command[1024];
3.    anon_context(&pm.this);
4.    gnu_volatile(summary)
5.    gnu_",Useful
"/*Add appropriate signal handlers, just the ANSI specified ones:*/","-6.    size_t cp = 0;
-5.    char command[1024];
-4.    anon_context(&pm.this);
-3.    gnu_volatile(summary)
-2.    gnu_volatile(memstats)
-1.    gnu_volatile(touch)

 /*Add appropriate signal handlers, just the ANSI specified ones:*/

1.    signal(SIGABR",Useful
"/*Only required to enable FP exceptions on platforms where they start off
    * disabled; this is not necessary but if it is not done pngvalid will likely
    * end up ignoring FP conditions that other platforms fault.*/","-7.    signal(SIGABRT, signal_handler);
-6.    signal(SIGFPE, signal_handler);
-5.    signal(SIGILL, signal_handler);
-4.    signal(SIGINT, signal_handler);
-3.    signal(SIGSEGV, signal_handler);
-2.    signal(SIGTERM, signal_handler);
-1. #ifdef HAVE_FE",Useful
"/*Preallocate the image buffer, because we know how big it needs to be,
    * note that, for testing purposes, it is deliberately mis-aligned by tag
    * bytes either side.  All rows have an additional five bytes of padding for
    * overwrite checking.*/","-3.    feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);
-2. #endif
-1.    modifier_init(&pm);
   /* Preallocate the image buffer, because we know how big it needs to be,
    * note that, for testing purposes, it is deliberately mis-aligned by tag
",Useful
"/*Don't give argv[0], it's normally some horrible libtool string:*/","-1.    store_ensure_image(&pm.this, NULL, 2, TRANSFORM_ROWMAX, TRANSFORM_HEIGHTMAX);

 /*Don't give argv[0], it's normally some horrible libtool string:*/

1.    cp = safecat(command, sizeof command, cp, ""pngvalid"");",Useful
/*Default to error on warning:*/,"-1.    cp = safecat(command, sizeof command, cp, ""pngvalid"");

 /*Default to error on warning:*/

1.    pm.this.treat_warnings_as_errors = 1;",Useful
"/*Default assume_16_bit_calculations appropriately; this tells the checking
    * code that 16-bit arithmetic is used for 8-bit samples when it would make a
    * difference.*/","-1.    pm.this.treat_warnings_as_errors = 1;
   /* Default assume_16_bit_calculations appropriately; this tells the checking
    * code that 16-bit arithmetic is used for 8-bit samples when it would make a
    * difference.

 /*Default assume_16_bit_calcu",Useful
"/*Currently 16 bit expansion happens at the end of the pipeline, so the
    * calculations are done in the input bit depth not the output.
    *
    * TODO: fix this*/","-1.    pm.assume_16_bit_calculations = PNG_LIBPNG_VER >= 10700;
   /* Currently 16 bit expansion happens at the end of the pipeline, so the
    * calculations are done in the input bit depth not the output.
    *
    * TODO: fix this

 /*Currently 16 bit ",Useful
"/*Low bit depth gray images don't do well in the gamma tests, until
    * this is fixed turn them off for some gamma cases:*/","
   /* Low bit depth gray images don't do well in the gamma tests, until
    * this is fixed turn them off for some gamma cases:



 /*Low bit depth gray images don't do well in the gamma tests, until
    * this is fixed turn them off for some gamma cases:*/

1.     */
2. #  ifdef PNG_WRITE_tRNS_SUPPORTED
3.       pm.test_tRNS = 1;
4. #  endif
5.    pm.test_lbg = PNG_LIBPNG_VER >= 10600;
6.    pm.test_lbg_gamma_threshold = 1;
7.    pm.test_lbg_gamma_transform = PNG_LIBPNG_VER >= 10600;
8.    pm.test_lbg_gamma_sbit = 1;
9.    pm.test_lbg_gamma_composition = PNG_LIBPNG_VER >= 10700;",Useful
"/*The following allows results to pass if they correspond to anything in the
    * transformed range [input-.5,input+.5]; this is is required because of the
    * way libpng treates the 16_TO_8 flag when building the gamma tables in
    * releases up to 1.6.0.
    *
    * TODO: review this*/","-3. #  else
-2.       pm.sbitlow = 1U;
-1. #  endif
   /* The following allows results to pass if they correspond to anything in the
    * transformed range [input-.5,input+.5]; this is is required because of the
    * way libpng treates the 16_TO_8 flag ",Useful
"/*Some default values (set the behavior for 'make check' here).
    * These values simply control the maximum error permitted in the gamma
    * transformations.  The practical limits for human perception are described
    * below (the setting for maxpc16), however for 8 bit encodings it isn't
    * possible to meet the accepted capabilities of human vision - i.e. 8 bit
    * images can never be good enough, regardless of encoding.*/","/* Some default values (set the behavior for 'make check' here).
    * These values simply control the maximum error permitted in the gamma
    * transformations.  The practial limits for human perception are described
    * below (the setting for maxpc16), however for 8 bit encodings it isn't
    * possible to meet the accepted capabilities of human vision - i.e. 8 bit
    * images can never be good enough, regardless of encoding.

 /*Some default values (set the behavior for 'make check' here).
    * These values simply control the maximum error permitted in the gamma
    * transformations.  The practical limits for human perception are described
    * below (the setting for maxpc16), however for 8 bit encodings it isn't
    * possible to meet the accepted capabilities of human vision - i.e. 8 bit
    * images can never be good enough, regardless of encoding.*/

1.     */",Useful
/*Arithmetic error in *encoded* value*/,"-10.     */
-9.    pm.use_input_precision_16to8 = 1U;

 /*Arithmetic error in *encoded* value*/

111",Useful
/*+/-1 in 8 bits for compose errors*/,"-10.    pm.use_input_precision_sbit = 1U; /* because libpng now rounds sBIT */
-9.    /* Some default values (set the behavior for 'make check' here).
-8.     * These values simply control the maximum error permitted in the gamma
-7.     * transformations",Useful
/*Error in *encoded* value*/,"-10.     * These values simply control the maximum error permitted in the gamma
-9.     * transformations.  The practial limits for human perception are described
-8.     * below (the setting for maxpc16), however for 8 bit encodings it isn't
-7.     * po",Useful
/*+/-1 in 16 bits for compose errors*/,"-10.     * below (the setting for maxpc16), however for 8 bit encodings it isn't
-9.     * possible to meet the accepted capabilities of human vision - i.e. 8 bit
-8.     * images can never be good enough, regardless of encoding.
-7.     */

 /*+/-1 in 16",Useful
"/*NOTE: this is a reasonable perceptual limit. We assume that humans can
    * perceive light level differences of 1% over a 100:1 range, so we need to
    * maintain 1 in 10000 accuracy (in linear light space), which is what the
    * following guarantees.  It also allows significantly higher errors at
    * higher 16 bit values, which is important for performance.  The actual
    * maximum 16 bit error is about +/-1.9 in the fixed point implementation but
    * this is only allowed for values >38149 by the following:*/","-5. #  if PNG_LIBPNG_VER < 10700
-4.       pm.maxcalcG = 1./((1<<PNG_MAX_GAMMA_8)-1);
-3. #  else
-2.       pm.maxcalcG = 1./((1<<16)-1);
-1. #  endif
   /* NOTE: this is a reasonable perceptual limit. We assume that humans can
    * perceive light level ",Useful
/*Set if the argument has an argument.*/,"-2.    while (--argc >= 1)
-1.    {

 /*Set if the argument has an argument.*/

111",Useful
/*Record each argument for posterity:*/,"-3.    while (--argc >= 1)
-2.    {

 /*Record each argument for posterity:*/

1.       cp = safecat(command, sizeof command, cp, "" "");
2.       cp = safecat(command, sizeof command, cp, *++argv);
3.       if (strcmp(*argv, ""-v"") == 0)
4.          pm.this",Useful
/*Just do two gamma tests here (2.2 and linear) for speed:*/,"-2.       else if (strcmp(*argv, ""--gamma"") == 0)
-1.          {

 /*Just do two gamma tests here (2.2 and linear) for speed:*/

1.          pm.ngamma_tests = 2U;
2.          pm.test_gamma_threshold = 1;
3.          pm.test_gamma_transform = 1;
4.        ",Useful
"/*If pngvalid is run with no arguments default to a reasonable set of the
    * tests.*/","-5.       {
-4.          cp = safecat(command, sizeof command, cp, "" "");
-3.          cp = safecat(command, sizeof command, cp, *argv);
-2.       }
-1.    }
   /* If pngvalid is run with no arguments default to a reasonable set of the
    * tests.

 /*If ",Useful
"/*Make this do all the tests done in the test shell scripts with the same
       * parameters, where possible.  The limitation is that all the progressive
       * read and interlace stuff has to be done in separate runs, so only the
       * basic 'standard' and 'size' tests are done.*/","-3.    if (pm.test_standard == 0 && pm.test_size == 0 && pm.test_transform == 0 &&
-2.       pm.ngamma_tests == 0)
-1.    {
      /* Make this do all the tests done in the test shell scripts with the same
       * parameters, where possible.  The limitati",Useful
/*Make useful base images*/,"-9.       pm.test_gamma_threshold = 0;
-8.       pm.test_gamma_transform = 0;
-7.       pm.test_gamma_sbit = 0;
-6.       pm.test_gamma_scale16 = 0;
-5.       pm.test_gamma_background = 0;
-4.       pm.test_gamma_alpha_mode = 0;
-3.    }
-2.    Try
-1.   ",Useful
"/*Do this here to provoke memory corruption errors in memory not directly
    * allocated by libpng - not a complete test, but better than nothing.*/","-10.       printf(""Allocated memory statistics (in bytes):\n""
-9.          ""\tread  %lu maximum single, %lu peak, %lu total\n""
-8.          ""\twrite %lu maximum single, %lu peak, %lu total\n"",
-7.          (unsigned long)pm.this.read_memory_pool.max_max,
",Useful
"/*Error exit if there are any errors, and maybe if there are any
    * warnings.*/","-1.    store_delete(&pm.this);
   /* Error exit if there are any errors, and maybe if there are any
    * warnings.

 /*Error exit if there are any errors, and maybe if there are any
    * warnings.*/

1.     */
2.    if (pm.this.nerrors || (pm.this.treat",Useful
/*This is required because some very minimal configurations do not use it:*/,"-10.             fprintf(stderr, ""%s: write failed\n"", touch);
-9.             exit(1);
-8.          }
-7.       }
-6.       else
-5.       {
-4.          fprintf(stderr, ""%s: open failed\n"", touch);
-3.          exit(1);
-2.       }
-1.    }
   /* This i",Useful
"/*Read one character (inchar), also return octet (c), break if EOF*/","-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will ",Useful
/*Update length bytes*/,"-1.          break;

 /*Update length bytes*/

1.       buf[0] = (unsigned char)((length >> 24) & 0xffU);
2.       buf[1] = (unsigned char)((length >> 16) & 0xffU);
3.       buf[2] = (unsigned char)((length >>  8) & 0xffU);
4.       buf[3] = (unsigned cha",Useful
"/*Write the fixed iTXt chunk (length, name, data, crc)*/","-4.       buf[0] = (unsigned char)((length >> 24) & 0xffU);
-3.       buf[1] = (unsigned char)((length >> 16) & 0xffU);
-2.       buf[2] = (unsigned char)((length >>  8) & 0xffU);
-1.       buf[3] = (unsigned char)((length      ) & 0xffU);

 /*Write the f",Useful
/*Copy bytes that were already read (length and chunk name)*/,"-1.          break;

 /*Copy bytes that were already read (length and chunk name)*/

1.       for (i=0; i<8; i++)
2.          putchar(buf[i]);",Useful
"/*Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
 * row_info bit depth should be 8 (one pixel per byte).  The channels
 * should be 1 (this only happens on grayscale and paletted images).*/","-10.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
-9.  *
-8.  * This code is released under the libpng license.
-7.  * For conditions of distribution and use, see the disclaimer
-6.  * and license in png.h
-5.  */
-4. #incl",Useful
"/*This need not be an internal error - if the app calls
    * png_set_unknown_chunks on a read pointer it must get the location right.*/","-3.       location = (png_byte)(png_ptr->mode &
-2.           (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT));
-1.    }
   /* This need not be an internal error - if the app calls
    * png_set_unknown_chunks on a read pointer it must get the location right",Useful
"/*Now reduce the location to the top-most set bit by removing each least
    * significant bit in turn.*/","-2.    if (location == 0)
-1.       png_error(png_ptr, ""invalid location in png_set_unknown_chunks"");
   /* Now reduce the location to the top-most set bit by removing each least
    * significant bit in turn.

 /*Now reduce the location to the top-most s",Useful
"/*The cast is safe because 'location' is a bit mask and only the low four
    * bits are significant.*/","-2.    while (location != (location & -location))
-1.       location &= ~(location & -location);
   /* The cast is safe because 'location' is a bit mask and only the low four
    * bits are significant.

 /*The cast is safe because 'location' is a bit mas",Useful
"/*Check for the failure cases where support has been disabled at compile
    * time.  This code is hardly ever compiled - it's here because
    * STORE_UNKNOWN_CHUNKS is set by both read and write code (compiling in this
    * code) but may be meaningless if the read or write handling of unknown
    * chunks is not compiled in.*/","-10.    return (png_byte)location;
-9. }
-8. void PNGAPI
-7. png_set_unknown_chunks(png_const_structrp png_ptr,
-6.     png_inforp info_ptr, png_const_unknown_chunkp unknowns, int num_unknowns)
-5. {
-4.    png_unknown_chunkp np;
-3.    if (png_ptr == NUL",Useful
"/*These increments are skipped on out-of-memory for the data - the
       * unknown chunk entry gets overwritten if the png_chunk_report returns.
       * This is correct in the read case (the chunk is just dropped.)*/","-5.             continue;
-4.          }
-3.          memcpy(np->data, unknowns->data, unknowns->size);
-2.          np->size = unknowns->size;
-1.       }
      /* These increments are skipped on out-of-memory for the data - the
       * unknown chunk en",Useful
"/*Utility function: update the 'keep' state of a chunk if it is already in
    * the list, otherwise add it to the list.*/","-10.       return 0;
-9.    png_ptr->mng_features_permitted = mng_features & PNG_ALL_MNG_FEATURES;
-8.    return png_ptr->mng_features_permitted;
-7. }
-6. #endif
-5. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-4. static unsigned int
-3. add_one_chunk(png_byt",Useful
"/*Prior to 1.6.0 this was silently ignored, now it is an app_error
          * which can be switched off.*/","-3.    {
-2.       if (chunk_list == NULL)
-1.       {
         /* Prior to 1.6.0 this was silently ignored, now it is an app_error
          * which can be switched off.

 /*Prior to 1.6.0 this was silently ignored, now it is an app_error
          * whi",Useful
"/*If these chunks are being reset to the default then no more memory is
    * required because add_one_chunk above doesn't extend the list if the 'keep'
    * parameter is the default.*/","-5.    if (num_chunks + old_num_chunks > UINT_MAX/5)
-4.    {
-3.       png_app_error(png_ptr, ""png_set_keep_unknown_chunks: too many chunks"");
-2.       return;
-1.    }
   /* If these chunks are being reset to the default then no more memory is
    * re",Useful
"/*Add the new chunks together with each one's handling code.  If the chunk
    * already exists the code is updated, otherwise the chunk is added to the
    * end.  (In libpng 1.6.0 order no longer matters because this code enforces
    * the earlier convention that the last setting is the one that is used.)*/","-10.    {
-9.       new_list = png_voidcast(png_bytep, png_malloc(png_ptr,
-8.           5 * (num_chunks + old_num_chunks)));
-7.       if (old_num_chunks > 0)
-6.          memcpy(new_list, png_ptr->chunk_list, 5*old_num_chunks);
-5.    }
-4.    else if (",Useful
/*Now remove any spurious 'default' entries.*/,"-10.    if (new_list != NULL)
-9.    {
-8.       png_const_bytep inlist;
-7.       png_bytep outlist;
-6.       unsigned int i;
-5.       for (i=0; i<num_chunks; ++i)
-4.       {
-3.          old_num_chunks = add_one_chunk(new_list, old_num_chunks,
-2.   ",Useful
/*This means the application has removed all the specialized handling.*/,"-10.       for (i=0, inlist=outlist=new_list; i<old_num_chunks; ++i, inlist += 5)
-9.       {
-8.          if (inlist[4])
-7.          {
-6.             if (outlist != inlist)
-5.                memcpy(outlist, inlist, 5);
-4.             outlist += 5;
-3",Useful
"/*Some compilers complain that this is always false.  However, it
       * can be true when integer overflow happens.*/","-10. #  ifdef PNG_WRITE_SUPPORTED
-9.    if ((png_ptr->mode & PNG_IS_READ_STRUCT) == 0)
-8.    {
-7.       if (png_ptr->zowner != 0)
-6.       {
-5.          png_warning(png_ptr,
-4.              ""Compression buffer size cannot be changed because it is in",Useful
"/*Whether to report invalid palette index; added at libng-1.5.10.
    * It is possible for an indexed (color-type==3) PNG file to contain
    * pixels with invalid (out-of-range) indexes if the PLTE chunk has
    * fewer entries than the image's bit-depth would allow. We recover
    * from this gracefully by filling any incomplete palette with zeros
    * (opaque black).  By default, when this occurs libpng will issue
    * a benign error.  This API can be used to override that behavior.*/","-1. #ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
   /* Whether to report invalid palette index; added at libng-1.5.10.
    * It is possible for an indexed (color-type==3) PNG file to contain
    * pixels with invalid (out-of-range) indexes if the PLTE chu",Useful
"/*Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,
 * and if invalid, correct the keyword rather than discarding the entire
 * chunk.  The PNG 1.0 specification requires keywords 1-79 characters in
 * length, forbids leading or trailing whitespace, multiple internal spaces,
 * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.
 *
 * The 'new_key' buffer must be 80 characters in size (for the keyword plus a
 * trailing '\0').  If this routine returns 0 then there was no keyword, or a
 * valid one could not be generated, and the caller must png_error.*/","-10. {
-9.    png_debug(1, ""in png_set_check_for_invalid_index"");
-8.    if (allowed > 0)
-7.       png_ptr->num_palette_max = 0;
-6.    else
-5.       png_ptr->num_palette_max = -1;
-4. }
-3. #endif
-2. #if defined(PNG_TEXT_SUPPORTED) || defined(PNG_pCAL",Useful
"/*A space or an invalid character when one wasn't seen immediately
          * before; output just a space.*/","-5.       {
-4.          *new_key++ = ch; ++key_len; space = 0;
-3.       }
-2.       else if (space == 0)
-1.       {
         /* A space or an invalid character when one wasn't seen immediately
          * before; output just a space.

 /*A space or an ",Useful
"/*just skip it, record the first error*/","-4.          if (ch != 32)
-3.             bad_character = ch;
-2.       }
-1.       else if (bad_character == 0)

 /*just skip it, record the first error*/

1.    }",Useful
"/*The following casts work because a PNG 4 byte integer only has a valid
       * range of 0..2^31-1; otherwise the cast might overflow.*/","-10. {
-9. #ifdef PNG_READ_pHYs_SUPPORTED
-8.    if (png_ptr != NULL && info_ptr != NULL &&
-7.        (info_ptr->valid & PNG_INFO_pHYs) != 0 &&
-6.        info_ptr->x_pixels_per_unit > 0 && info_ptr->y_pixels_per_unit > 0 &&
-5.        info_ptr->x_pixels",Useful
"/*The argument is a PNG unsigned integer, so it is not permitted
    * to be bigger than 2^31.*/","-10.    t1001 = ppm + (ppm >> 3);   /* .1001 */
-9.    t1101 = t1001 + (ppm >> 1); /* .1101 */
-8.    ppm >>= 20;                 /* .000000000000000000001 */
-7.    t1101 += t1101 >> 15;       /* .1101000000000001101 */
-6.    t1001 >>= 11;              ",Useful
"/*Convert from meters * 1,000,000 to inches * 100,000, meters to
    * inches is simply *(100/2.54), so we want *(10/2.54) == 500/127.
    * Notice that this can overflow - a warning is output and 0 is
    * returned.*/","nan


 /*Convert from meters * 1,000,000 to inches * 100,000, meters to
    * inches is simply *(100/2.54), so we want *(10/2.54) == 500/127.
    * Notice that this can overflow - a warning is output and 0 is
    * returned.*/

nan
",Useful
"/*To avoid the overflow do the conversion directly in floating
    * point.*/","-10.     png_const_inforp info_ptr)
-9. {
-8.    return png_fixed_inches_from_microns(png_ptr,
-7.        png_get_y_offset_microns(png_ptr, info_ptr));
-6. }
-5. #endif
-4. #ifdef PNG_FLOATING_POINT_SUPPORTED
-3. float PNGAPI
-2. png_get_x_offset_inches(p",Useful
"/*To avoid the overflow do the conversion directly in floating
    * point.*/","-10.     png_const_inforp info_ptr)
-9. {
-8.    return png_fixed_inches_from_microns(png_ptr,
-7.        png_get_y_offset_microns(png_ptr, info_ptr));
-6. }
-5. #endif
-4. #ifdef PNG_FLOATING_POINT_SUPPORTED
-3. float PNGAPI
-2. png_get_x_offset_inches(p",Useful
"/*png_get_channels really belongs in here, too, but it's been around longer*/","-10.          {
-9.             if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);
-8.             if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);
-7.          }
-6.       }
-5.    }
-4.    return (retval);
-3. }

 /*png_get",Useful
"/*The XYZ APIs were added in 1.5.5 to take advantage of the code added at the
 * same time to correct the rgb grayscale coefficient defaults obtained from the
 * cHRM chunk in 1.5.4*/","-10.        background != NULL)
-9.    {
-8.       png_debug1(1, ""in %s retrieval function"", ""bKGD"");
-7.       *background = &(info_ptr->background);
-6.       return (PNG_INFO_bKGD);
-5.    }
-4.    return (0);
-3. }
-2. #endif
-1. #ifdef PNG_cHRM_SUPPO",Useful
"/*Quiet API change: this code used to only return the end points if a cHRM
    * chunk was present, but the end points can also come from iCCP or sRGB
    * chunks, so in 1.6.0 the png_get_ APIs return the end points regardless and
    * the png_set_ APIs merely check that set end points are mutually
    * consistent.*/","-6. #  ifdef PNG_FLOATING_POINT_SUPPORTED
-5. png_uint_32 PNGAPI
-4. png_get_cHRM(png_const_structrp png_ptr, png_const_inforp info_ptr,
-3.     double *white_x, double *white_y, double *red_x, double *red_y,
-2.     double *green_x, double *green_y, doub",Useful
"/*This is redundant if we can be sure that the info_ptr values were all
    * assigned in png_set_IHDR().  We do the check anyhow in case an
    * application has ignored our advice not to mess with the members
    * of info_ptr directly.*/","-10.    if (bit_depth != NULL)
-9.        *bit_depth = info_ptr->bit_depth;
-8.    if (color_type != NULL)
-7.        *color_type = info_ptr->color_type;
-6.    if (compression_type != NULL)
-5.       *compression_type = info_ptr->compression_type;
-4.   ",Useful
"/*TODO: make this work without FP support; the API is currently eliminated
       * if neither floating point APIs nor internal floating point arithmetic
       * are enabled.*/","-10. #    if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || \
-9.          defined(PNG_FLOATING_POINT_SUPPORTED)
-8. png_uint_32 PNGAPI
-7. png_get_sCAL_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,
-6.     int *unit, png_fixed_point *width,",Useful
/*if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)*/,"-10.       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-9.       {
-8.          if (trans_alpha != NULL)
-7.          {
-6.             *trans_alpha = info_ptr->trans_alpha;
-5.             retval |= PNG_INFO_tRNS;
-4.          }
-3.          if (",Useful
"/*These functions were added to libpng 1.2.6 and were enabled
 * by default in libpng-1.4.0*/","-10. #else
-9.       return PNG_IDAT_READ_SIZE;
-8. #endif
-7.    }
-6. #ifdef PNG_WRITE_SUPPORTED
-5.    else
-4.       return png_ptr->zbuffer_size;
-3. #endif
-2. }
-1. #ifdef PNG_SET_USER_LIMITS_SUPPORTED

 /*These functions were added to libpng 1.2.6",Useful
"/*This is used to fix the error:
    *
    * pngfix.c:
    * In function 'zlib_advance':
    * pngfix.c:181:13: error: assuming signed overflow does not
    *   occur when simplifying conditional to constant [-Werror=strict-overflow]*/","-10.  */
-9. #include <stdlib.h>
-8. #include <stdio.h>
-7. #include <string.h>
-6. #include <ctype.h>
-5. #include <limits.h>
-4. #include <errno.h>
-3. #include <assert.h>
-2. #define implies(x,y) assert(!(x) || (y))
-1. #ifdef __GNUC__
   /* This is us",Useful
"/*Define the following to use this program against your installed libpng,
 * rather than the one being built here:*/","-10.     * pngfix.c:
-9.     * In function 'zlib_advance':
-8.     * pngfix.c:181:13: error: assuming signed overflow does not
-7.     *   occur when simplifying conditional to constant [-Werror=strict-overflow]
-6.     */
-5. #  define FIX_GCC volatile
-",Useful
"/*zlib.h defines the structure z_stream, an instance of which is included
 * in this structure and is required for decompressing the LZ compressed
 * data in PNG files.*/","-7. #  error ""pngfix will not work with libpng prior to 1.6.3""
-6. #endif
-5. #ifdef PNG_SETJMP_SUPPORTED
-4. #include <setjmp.h>
-3. #if defined(PNG_READ_SUPPORTED) && defined(PNG_EASY_ACCESS_SUPPORTED) &&\
-2.    (defined(PNG_READ_DEINTERLACE_SUPPORTED)",Useful
/*We must ensure that zlib uses 'const' in declarations.*/,"-1. #ifndef ZLIB_CONST

 /*We must ensure that zlib uses 'const' in declarations.*/

1. #  define ZLIB_CONST
2. #endif
3. #include <zlib.h>
4. #ifdef const",Useful
"/*zlib.h has mediocre z_const use before 1.2.6, this stuff is for compatibility
 * with older builds.*/","-2. #  undef const
-1. #endif
/* zlib.h has mediocre z_const use before 1.2.6, this stuff is for compatibility
 * with older builds.

 /*zlib.h has mediocre z_const use before 1.2.6, this stuff is for compatibility
 * with older builds.*/

1.  */
2. #if Z",Useful
/*The 8-byte signature as a pair of 32-bit quantities*/,"-10. #define png_sBIT PNG_U32(115,  66,  73,  84)
-9. #define png_sCAL PNG_U32(115,  67,  65,  76)
-8. #define png_sPLT PNG_U32(115,  80,  76,  84)
-7. #define png_sRGB PNG_U32(115,  82,  71,  66)
-6. #define png_sTER PNG_U32(115,  84,  69,  82)
-5. #defi",Useful
/*Fix ups for builds with limited read support*/,"-1. #define SAFE_TO_COPY(chunk) (((chunk) & PNG_U32(0,0,0,32)) != 0)

 /*Fix ups for builds with limited read support*/

1. #ifndef PNG_ERROR_TEXT_SUPPORTED
2. #  define png_error(a,b) png_err(a)
3. #endif",Useful
"/*UNREACHED is a value to cause an assert to fail. Because of the way the
 * assert macro is written the string ""UNREACHED"" is produced in the error
 * message.*/","
/* UNREACHED is a value to cause an assert to fail. Because of the way the
 * assert macro is written the string ""UNREACHED"" is produced in the error
 * message.



 /*UNREACHED is a value to cause an assert to fail. Because of the way the
 * assert macro is written the string ""UNREACHED"" is produced in the error
 * message.*/

1.  */
2. #define UNREACHED 0
3. /* 80-bit number handling - a PNG image can be up to (2^31-1)x(2^31-1) 8-byte
4.  * (16-bit RGBA) pixels in size; that's less than 2^65 bytes or 2^68 bits, so
5.  * arithmetic of 80-bit numbers is sufficient.  This representation uses an
6.  * arbitrary length array of png_uint_16 digits (0..65535).  The representation
7.  * is little endian.
8.  *
9.  * The arithmetic functions take zero to two uarb values together with the
10.  * number of digits in those values and write the result to the given uarb",Useful
"/*80-bit number handling - a PNG image can be up to (2^31-1)x(2^31-1) 8-byte
 * (16-bit RGBA) pixels in size; that's less than 2^65 bytes or 2^68 bits, so
 * arithmetic of 80-bit numbers is sufficient.  This representation uses an
 * arbitrary length array of png_uint_16 digits (0..65535).  The representation
 * is little endian.
 *
 * The arithmetic functions take zero to two uarb values together with the
 * number of digits in those values and write the result to the given uarb
 * (always the first argument) returning the number of digits in the result.
 * If the result is negative the return value is also negative (this would
 * normally be an error).*/","-1. #define UNREACHED 0
/* 80-bit number handling - a PNG image can be up to (2^31-1)x(2^31-1) 8-byte
 * (16-bit RGBA) pixels in size; that's less than 2^65 bytes or 2^68 bits, so
 * arithmetic of 80-bit numbers is sufficient.  This representation uses an",Useful
"/*IMPORTANT: only apply this to an array, applied to a pointer the result
    * will typically be '2', which is not useful.*/","-3. typedef png_uint_16p uarb;
-2. typedef png_const_uint_16p uarbc;
-1. #define UDIGITS(unum) ((sizeof unum)/(sizeof (udigit))
   /* IMPORTANT: only apply this to an array, applied to a pointer the result
    * will typically be '2', which is not useful.",Useful
"/*Set (initialize) 'result' to 'val'.  The size required for 'result' must
    * be determined by the caller from a knowledge of the maximum for 'val'.*/","-2. static int
-1. uarb_set(uarb result, png_alloc_size_t val)
   /* Set (initialize) 'result' to 'val'.  The size required for 'result' must
    * be determined by the caller from a knowledge of the maximum for 'val'.

 /*Set (initialize) 'result' to 'va",Useful
"/*Copy a uarb, may reduce the digit count*/","-10.    int ndigits = 0;
-9.    while (val > 0)
-8.    {
-7.       result[ndigits++] = (png_uint_16)(val & 0xffff);
-6.       val >>= 16;
-5.    }
-4.    return ndigits;
-3. }
-2. static int
-1. uarb_copy(uarb to, uarb from, int idigits)

 /*Copy a uarb, ",Useful
"/*This is a signed 32-bit add, except that to avoid overflow the value added
    * or subtracted must be no more than 2^31-65536.  A negative result
    * indicates a negative number (which is an error below).  The size of
    * 'num' should be max(in_digits+1,2) for arbitrary 'add' but can be just
    * in_digits+1 if add is known to be in the range -65535..65535.*/","-9. {
-8.    int d, odigits;
-7.    for (d=odigits=0; d<idigits; ++d)
-6.       if ((to[d] = from[d]) != 0)
-5.          odigits = d+1;
-4.    return odigits;
-3. }
-2. static int
-1. uarb_inc(uarb num, int in_digits, png_int_32 add)
   /* This is a signe",Useful
"/*Primitive one-digit multiply - 'val' must be 0..65535. Note that this
    * primitive is a multiply and accumulate - the result of *num * val is added
    * to *acc.
    *
    * This is a one-digit multiply, so the product may be up to one digit longer
    * than 'num', however the add to 'acc' means that the caller must ensure
    * that 'acc' is at least one digit longer than this *and* at least one digit
    * longer than the current length of 'acc'.  (Or the caller must otherwise
    * ensure 'adigits' is adequate from knowledge of the values.)*/","-10.    if (in_digits > 0)
-9.    {
-8.       in_digits = uarb_inc(num, in_digits, add & 0xffff);
-7.       return uarb_inc(num+1, in_digits-1, add >> 16)+1;
-6.    }
-5.    return uarb_set(num, add);
-4. }
-3. static int
-2. uarb_mult_digit(uarb acc, int",Useful
"/*The digits in *acc, *num and val are in the range 0..65535, so the
    * result below is at most (65535*65535)+2*65635 = 65535*(65535+2), which is
    * exactly 0xffffffff.*/","-10.     * primitive is a multiply and accumulate - the result of *num * val is added
-9.     * to *acc.
-8.     *
-7.     * This is a one-digit multiply, so the product may be up to one digit longer
-6.     * than 'num', however the add to 'acc' means th",Useful
"/*So carry is 0 and all the input digits have been consumed. This means
       * that it is possible to skip any remaining digits in acc.*/","-10.       int out_digits = 0;
-9.       while (out_digits < n_digits || carry > 0)
-8.       {
-7.          if (out_digits < a_digits)
-6.             carry += acc[out_digits];
-5.          if (out_digits < n_digits)
-4.             carry += (png_uint_32",Useful
"/*calculate acc += num * val, 'val' may be any 32-bit value, 'acc' and 'num'
    * may be any value, returns the number of digits in 'acc'.*/","-7.       if (out_digits > a_digits)
-6.          return out_digits;
-5.    }
-4.    return a_digits;
-3. }
-2. static int
-1. uarb_mult32(uarb acc, int a_digits, uarb num, int n_digits, png_uint_32 val)
   /* calculate acc += num * val, 'val' may be any ",Useful
"/*Shift inout right by right_shift bits, right_shift must be in the range
    * 1..15*/","-6.       assert(a_digits > 0);
-5.    }
-4.    return a_digits;
-3. }
-2. static int
-1. uarb_shift(uarb inout, int ndigits, unsigned int right_shift)
   /* Shift inout right by right_shift bits, right_shift must be in the range
    * 1..15

 /*Shift ino",Useful
/*Bottom bits to top bits of carry*/,"-7. {
-6.    FIX_GCC int i = ndigits;
-5.    png_uint_16 carry = 0;
-4.    assert(right_shift >= 1 && right_shift <= 15);
-3.    while (--i >= 0)
-2.    {
-1.       png_uint_16 temp = (png_uint_16)(carry | (inout[i] >> right_shift));

 /*Bottom bits to to",Useful
/*Return true if the uarb is equal to 'val'*/,"-2. static int
-1. uarb_eq32(uarb num, int digits, png_uint_32 val)

 /*Return true if the uarb is equal to 'val'*/

1. {
2.    switch (digits)
3.    {
4.       case 0:  return val == 0;
5.       case 1:  return val == num[0];
6.       case 2:  return (va",Useful
/*Print 'num' as a hexadecimal number (easier than decimal!)*/,"-10.    {
-9.       case 0:  return val == 0;
-8.       case 1:  return val == num[0];
-7.       case 2:  return (val & 0xffff) == num[0] && (val >> 16) == num[1];
-6.       default: return 0;
-5.    }
-4. }
-3. #endif
-2. static void
-1. uarb_printx(uarb",Useful
"/*Prints 'num' as a decimal if it will fit in an unsigned long, else as a
    * hexadecimal number.  Notice that the results vary for images over 4GByte
    * in a system dependent way, and the hexadecimal form doesn't work very well
    * in awk script input.
    *
    *
    * TODO: write uarb_div10*/","-4.          fputs(""0x0"", out);
-3. }
-2. static void
-1. uarb_print(uarb num, int digits, FILE *out)
   /* Prints 'num' as a decimal if it will fit in an unsigned long, else as a
    * hexadecimal number.  Notice that the results vary for images over 4GB",Useful
"/*Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick
 * ""Algorithms"") but it comes from the 'feedback taps' table in Horowitz and
 * Hill, ""The Art of Electronics"" (Pseudo-Random Bit Sequences and Noise
 * Generation.)
 *
 * (Copied from contrib/libtests/pngvalid.c)*/","-10.    if (digits * sizeof (udigit) > sizeof (unsigned long))
-9.       uarb_printx(num, digits, out);
-8.    else
-7.    {
-6.       unsigned long n = 0;
-5.       while (digits > 0)
-4.          n = (n << 16) + num[--digits];
-3.       fprintf(out, ""%l",Useful
"/*There are thirty-three bits; the next bit in the sequence is bit-33 XOR
    * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.*/","-10.  * Hill, ""The Art of Electronics"" (Pseudo-Random Bit Sequences and Noise
-9.  * Generation.)
-8.  *
-7.  * (Copied from contrib/libtests/pngvalid.c)
-6.  */
-5. static void
-4. make_random_bytes(png_uint_32* seed, void* pv, size_t size)
-3. {
-2.    ",Useful
/*First generate 8 new bits then shift them in at the end.*/,"-3.    size_t i;
-2.    for (i=0; i<size; ++i)
-1.    {

 /*First generate 8 new bits then shift them in at the end.*/

1.       png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;
2.       u1 <<= 8;
3.       u1 |= u0 >> 24;
4.       u",Useful
/*Clear an object to a random value.*/,"-10.       png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;
-9.       u1 <<= 8;
-8.       u1 |= u0 >> 24;
-7.       u0 <<= 8;
-6.       u0 |= u;
-5.       *bytes++ = (png_byte)u;
-4.    }
-3.    seed[0] = u0;
-2.    seed[1] = u1;
-1",Useful
"/*Copied from unreleased 1.7 code.
 *
 * CRC checking uses a local pre-built implementation of the Ethernet CRC32.
 * This is to avoid a function call to the zlib DLL and to optimize the
 * byte-by-byte case.*/","-7. static void
-6. clear(void *pv, size_t size)
-5. {
-4.    static png_uint_32 clear_seed[2] = { 0x12345678, 0x9abcdef0 };
-3.    make_random_bytes(clear_seed, pv, size);
-2. }
-1. #define CLEAR(object) clear(&(object), sizeof (object))
/* Copied from u",Useful
"/*The CRC calculated here *IS* conditioned, the corresponding value used by
 * zlib and the result value is obtained by XORing with CRC_INIT, which is also
 * the first value that must be passed in (for the first byte) to crc_one_byte.*/","-10.    0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
-9.    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
-8.    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
-7.    0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc",Useful
"/*This is an alternative to the algorithm used in zlib, which requires four
    * separate tables to parallelize the four byte operations, it only works for
    * a CRC of the first four bytes of the stream, but this is what happens in
    * the parser below where length+chunk-name is read and chunk-name used to
    * initialize the CRC.  Notice that the calculation here avoids repeated
    * conditioning (xor with 0xffffffff) by storing the conditioned value.*/","-10.  */
-9. #define CRC_INIT 0xffffffff
-8. static png_uint_32
-7. crc_one_byte(png_uint_32 crc, int b)
-6. {
-5.    return crc_table[(crc ^ b) & 0xff] ^ (crc >> 8);
-4. }
-3. static png_uint_32
-2. crc_init_4(png_uint_32 value)
-1. {
   /* This is an al",Useful
"/*Bit whacking approach to chunk name validation that is intended to avoid
    * branches.  The cost is that it uses a lot of 32-bit constants, which might
    * be bad on some architectures.*/","-10.     * initialize the CRC.  Notice that the calculation here avoids repeated
-9.     * conditioning (xor with 0xffffffff) by storing the conditioned value.
-8.     */
-7.    png_uint_32 crc = crc_table[(~value >> 24)] ^ 0xffffff;
-6.    crc = crc_tabl",Useful
"/*Remove bit 5 from all but the reserved byte; this means every
    * 8-bit unit must be in the range 65-90 to be valid.  So bit 5
    * must be zero, bit 6 must be set and bit 7 zero.*/","-2. {
-1.    png_uint_32 t;
   /* Remove bit 5 from all but the reserved byte; this means every
    * 8-bit unit must be in the range 65-90 to be valid.  So bit 5
    * must be zero, bit 6 must be set and bit 7 zero.

 /*Remove bit 5 from all but the rese",Useful
"/*Subtract 65 for each 8-bit quantity, this must not overflow
    * and each byte must then be in the range 0-25.*/","-2.    c &= ~PNG_U32(32,32,0,32);
-1.    t = (c & ~0x1f1f1f1f) ^ 0x40404040;
   /* Subtract 65 for each 8-bit quantity, this must not overflow
    * and each byte must then be in the range 0-25.

 /*Subtract 65 for each 8-bit quantity, this must not overf",Useful
"/*Subtract 26, handling the overflow which should set the top
    * three bits of each byte.*/","-2.    c -= PNG_U32(65,65,65,65);
-1.    t |=c ;
   /* Subtract 26, handling the overflow which should set the top
    * three bits of each byte.

 /*Subtract 26, handling the overflow which should set the top
    * three bits of each byte.*/

1.     */
2",Useful
"/*Information about a sequence of IDAT chunks, the chunks have been re-synced
 * using sync_stream below and the new lengths are recorded here.  Because the
 * number of chunks is unlimited this is handled using a linked list of these
 * structures.*/","
/* Information about a sequence of IDAT chunks, the chunks have been re-synced
 * using sync_stream below and the new lengths are recorded here.  Because the
 * number of chunks is unlimited this is handled using a linked list of these
 * structures.



 /*Information about a sequence of IDAT chunks, the chunks have been re-synced
 * using sync_stream below and the new lengths are recorded here.  Because the
 * number of chunks is unlimited this is handled using a linked list of these
 * structures.*/

1.  */
2. struct IDAT_list
3. {",Useful
/*Linked list*/,"-2. struct IDAT_list
-1. {

 /*Linked list*/

111",Useful
/*Actual length of the array below*/,"-3. struct IDAT_list
-2. {

 /*Actual length of the array below*/

111",Useful
/*Return the size in bytes of an IDAT_list of the given length.*/,"-10. };
-9. static void
-8. IDAT_list_init(struct IDAT_list *list)
-7. {
-6.    CLEAR(*list);
-5.    list->next = NULL;
-4.    list->length = IDAT_INIT_LENGTH;
-3. }
-2. static size_t
-1. IDAT_list_size(struct IDAT_list *list, unsigned int length)

 /*Ret",Useful
/*Use the previous cached value if available.*/,"-10.    {
-9.       struct IDAT_list *next = list->next;
-8.       clear(list, IDAT_list_size(list, 0));
-7.       free(list);
-6.       list = next;
-5.    }
-4. }
-3. static struct IDAT_list *
-2. IDAT_list_extend(struct IDAT_list *tail)
-1. {

 /*Use t",Useful
"/*Insert a new, malloc'ed, block of IDAT information buffers, this
       * one twice as large as the previous one:*/","-3.    struct IDAT_list *next = tail->next;
-2.    if (next == NULL)
-1.    {
      /* Insert a new, malloc'ed, block of IDAT information buffers, this
       * one twice as large as the previous one:

 /*Insert a new, malloc'ed, block of IDAT information",Useful
/*PUBLIC GLOBAL VARIABLES: OWNER INITIALIZE*/,"-2. struct global
-1. {

 /*PUBLIC GLOBAL VARIABLES: OWNER INITIALIZE*/

111",Useful
/*print file errors to stderr*/,"-3. struct global
-2. {

 /*print file errors to stderr*/

111",Useful
/*write error (this terminates the read)*/,"-10. #     define SKIP_TRANSFORM 4    /* Chunks only used in transforms */
-9. #     define SKIP_COLOR     5    /* Everything but tRNS, sBIT, gAMA and sRGB */
-8. #     define SKIP_ALL       6    /* Everything but tRNS and sBIT */
-7.    png_uint_32    id",Useful
/*PUBLIC GLOBAL VARIABLES: USED INTERNALLY BY IDAT READ CODE*/,"-10. #     define SKIP_ALL       6    /* Everything but tRNS and sBIT */
-9.    png_uint_32    idat_max;         /* 0 to perform no re-chunking */
-8.    int            status_code;      /* Accumulated status code */
-7. #     define TOO_FAR_BACK   0x01 /",Useful
"/*The structure is shared across all uses of this global control
       * structure to avoid reallocation between IDAT streams.*/","-10.    int            status_code;      /* Accumulated status code */
-9. #     define TOO_FAR_BACK   0x01 /* found a too-far-back error */
-8. #     define CRC_ERROR      0x02 /* fixed an invalid CRC */
-7. #     define STREAM_ERROR   0x04 /* damaged PN",Useful
"/*Return true if this chunk is to be skipped according to the --strip
    * option.  This code needs to recognize all known ancillary chunks in order
    * to handle the --strip=unsafe option.*/","-7.    global->optimize_zlib = 0;
-6.    global->skip          = SKIP_NONE;
-5.    global->status_code   = 0;
-4.    IDAT_list_init(&global->idat_cache);
-3. }
-2. static int
-1. skip_chunk_type(const struct global *global, png_uint_32 type)
   /* Return ",Useful
"/*Chunks that are treated as, effectively, critical because they affect
       * correct interpretation of the pixel values:*/","-4.    if (CRITICAL(type))
-3.       return 0;
-2.    switch (type)
-1.    {
      /* Chunks that are treated as, effectively, critical because they affect
       * correct interpretation of the pixel values:

 /*Chunks that are treated as, effectively, c",Useful
"/*Chunks that specify gamma encoding which should therefore only be
       * removed if the user insists:*/","nan


 /*Chunks that specify gamma encoding which should therefore only be
       * removed if the user insists:*/

nan
",Useful
"/*Chunks that affect color interpretation - not used by libpng and rarely
       * used by applications, but technically still required for correct
       * interpretation of the image data:*/","-4.       case png_gAMA: case png_sRGB:
-3.          if (global->skip >= SKIP_ALL)
-2.             return 1;
-1.          return 0;
      /* Chunks that affect color interpretation - not used by libpng and rarely
       * used by applications, but technic",Useful
"/*Other chunks that are used by libpng in image transformations (as
       * opposed to known chunks that have get/set APIs but are not otherwise
       * used.)*/","-4.       case png_cHRM: case png_iCCP:
-3.          if (global->skip >= SKIP_COLOR)
-2.             return 1;
-1.          return 0;
      /* Other chunks that are used by libpng in image transformations (as
       * opposed to known chunks that have get",Useful
"/*All other chunks that libpng knows about and affect neither image
       * interpretation nor libpng transforms - chunks that are effectively
       * unused by libpng even though libpng might recognize and store them.*/","-4.       case png_bKGD:
-3.          if (global->skip >= SKIP_TRANSFORM)
-2.             return 1;
-1.          return 0;
      /* All other chunks that libpng knows about and affect neither image
       * interpretation nor libpng transforms - chunks th",Useful
"/*Chunks that libpng does not know about (notice that this depends on the
       * list above including all known chunks!)  The decision here depends on
       * whether the safe-to-copy bit is set in the chunk type.*/","-6.       case png_fRAc: case png_gIFg: case png_gIFt: case png_gIFx: case png_hIST:
-5.       case png_iTXt: case png_oFFs: case png_pCAL: case png_pHYs: case png_sCAL:
-4.       case png_sPLT: case png_sTER: case png_tEXt: case png_tIME: case png_zTXt:
",Useful
/*PUBLIC PER-FILE VARIABLES: CALLER INITIALIZE*/,"-1.    struct global *global;

 /*PUBLIC PER-FILE VARIABLES: CALLER INITIALIZE*/

1.    const char *   file_name;",Useful
/*PUBLIC PER-FILE VARIABLES: SET BY PNG READ CODE*/,"-2.    const char *   file_name;

 /*PUBLIC PER-FILE VARIABLES: SET BY PNG READ CODE*/

111",Useful
/*Set to a bit mask of the following:*/,"-4.    const char *   file_name;

 /*Set to a bit mask of the following:*/

111",Useful
/*Records a read error errno*/,"-5.    const char *   file_name;

 /*Records a read error errno*/

111",Useful
/*Records a write error errno*/,"-6.    const char *   file_name;

 /*Records a write error errno*/

111",Useful
/*PROTECTED PER-FILE VARIABLES: USED BY THE READ CODE*/,"-9.    png_uint_32    width;
-8.    png_uint_32    height;
-7.    png_byte       bit_depth;
-6.    png_byte       color_type;
-5.    png_byte       compression_method;
-4.    png_byte       filter_method;
-3.    png_byte       interlace_method;
-2.    udi",Useful
/*If a new one is being written*/,"-10.    png_uint_32    height;
-9.    png_byte       bit_depth;
-8.    png_byte       color_type;
-7.    png_byte       compression_method;
-6.    png_byte       filter_method;
-5.    png_byte       interlace_method;
-4.    udigit         image_bytes[5];
",Useful
/*Set while reading a PNG*/,"-10.    png_byte       bit_depth;
-9.    png_byte       color_type;
-8.    png_byte       compression_method;
-7.    png_byte       filter_method;
-6.    png_byte       interlace_method;
-5.    udigit         image_bytes[5];
-4.    int            image_di",Useful
"/*The following variables are used during reading to record the length, type
    * and data position of the *next* chunk or, right at the start, the
    * signature (in length,type).
    *
    * When a chunk control structure is instantiated these values are copied
    * into the structure and can then be overritten with the data for the next
    * chunk.*/","
   /* The following variables are used during reading to record the length, type
    * and data position of the *next* chunk or, right at the start, the
    * signature (in length,type).
    *
    * When a chunk control structure is instantiated these values are copied
    * into the structure and can then be overritten with the data for the next
    * chunk.



 /*The following variables are used during reading to record the length, type
    * and data position of the *next* chunk or, right at the start, the
    * signature (in length,type).
    *
    * When a chunk control structure is instantiated these values are copied
    * into the structure and can then be overritten with the data for the next
    * chunk.*/

1.     */",Useful
/*Position of first byte of chunk data*/,"-10.    jmp_buf        jmpbuf;        /* Set while reading a PNG */
-9.    /* PROTECTED CHUNK SPECIFIC VARIABLES: USED BY CHUNK CODE */
-8.    /* The following variables are used during reading to record the length, type
-7.     * and data position of the",Useful
/*First word (length or signature start)*/,"-10.    /* PROTECTED CHUNK SPECIFIC VARIABLES: USED BY CHUNK CODE */
-9.    /* The following variables are used during reading to record the length, type
-8.     * and data position of the *next* chunk or, right at the start, the
-7.     * signature (in l",Useful
/*Second word (type or signature end)*/,"-10.    /* The following variables are used during reading to record the length, type
-9.     * and data position of the *next* chunk or, right at the start, the
-8.     * signature (in length,type).
-7.     *
-6.     * When a chunk control structure is i",Useful
"/*These counts are maintained by the read and write routines below and are
    * reset by the chunk handling code.  They record the total number of bytes
    * read or written for the chunk, including the header (length,type) bytes.*/","
   /* These counts are maintained by the read and write routines below and are
    * reset by the chunk handling code.  They record the total number of bytes
    * read or written for the chunk, including the header (length,type) bytes.



 /*These counts are maintained by the read and write routines below and are
    * reset by the chunk handling code.  They record the total number of bytes
    * read or written for the chunk, including the header (length,type) bytes.*/

1.     */",Useful
/*Count of bytes read (in the chunk)*/,"-10.     * chunk.
-9.     */

 /*Count of bytes read (in the chunk)*/

111",Useful
/*Count of bytes written (in the chunk)*/,"-10.     */

 /*Count of bytes written (in the chunk)*/

111",Useful
"/*Two pointers used to enable clean-up in the event of fatal errors and to
    * hold state about the parser process (only one of each at present.)*/","-10.    /* These counts are maintained by the read and write routines below and are
-9.     * reset by the chunk handling code.  They record the total number of bytes
-8.     * read or written for the chunk, including the header (length,type) bytes.
-7.  ",Useful
"/*Interface to allocate a new chunk or IDAT control structure.  The result
    * is returned by setting one or other of the above variables.  Note that the
    * relevant initializer is called by the allocator function.  The alloc_ptr
    * is used only by the implementation of the allocate function.*/","-2.    struct chunk * chunk;
-1.    struct IDAT *  idat;
   /* Interface to allocate a new chunk or IDAT control structure.  The result
    * is returned by setting one or other of the above variables.  Note that the
    * relevant initializer is called b",Useful
/*error in write*/,"-7. };

 /*error in write*/

111",Useful
"/*Print a string with spaces replaced by '_' and non-printing characters by
    * an octal escape.*/","-10. /* Valid longjmp (stop) codes are: */
-9. #define LIBPNG_WARNING_CODE   1 /* generic png_error */
-8. #define LIBPNG_ERROR_CODE     2 /* generic png_error */
-7. #define ZLIB_ERROR_CODE       3 /* generic zlib error */
-6. #define INVALID_ERROR_CODE ",Useful
"/*Generic error message routine, takes a 'stop' code but can be used
    * elsewhere.  Always outputs a message.*/","-10.       case ZLIB_ERROR_CODE:       return ""zlib"";
-9.       case INVALID_ERROR_CODE:    return ""invalid"";
-8.       case READ_ERROR_CODE:       return ""read"";
-7.       case WRITE_ERROR_CODE:      return ""write"";
-6.       case UNEXPECTED_ERROR_CODE: ",Useful
"/*If either of the chunk pointers are set end them here, the IDAT structure
    * must be deallocated first as it may deallocate the chunk structure.*/","-10.          strerror(err));
-9.    else
-8.       fprintf(stderr, ""%s: %s %s\n"", file->file_name, reason, what);
-7. }
-6. static void chunk_end(struct chunk **);
-5. static void IDAT_end(struct IDAT **);
-4. static int
-3. file_end(struct file *file)
-",Useful
"/*NOTE: this is bitwise |, all the following functions must execute and
       * must succeed.*/","-10.     */
-9.    if (file->idat != NULL)
-8.       IDAT_end(&file->idat);
-7.    if (file->chunk != NULL)
-6.       chunk_end(&file->chunk);
-5.    rc = file->status_code;
-4.    if (file->file != NULL)
-3.       (void)fclose(file->file);
-2.    if (fil",Useful
/*status code: non-zero on read or write error*/,"-2.    file->global->status_code |= rc;
-1.    CLEAR(*file);

 /*status code: non-zero on read or write error*/

1. }
2. static int
3. file_init(struct file *file, struct global *global, const char *file_name,
4.    const char *out_name, void *alloc_ptr, ",Useful
"/*Initialize a file control structure.  This will open the given files as
    * well.  The status code returned is 0 on success, non zero (using the flags
    * above) on a file open error.*/","-4. }
-3. static int
-2. file_init(struct file *file, struct global *global, const char *file_name,
-1.    const char *out_name, void *alloc_ptr, void (*alloc)(struct file*,int))
   /* Initialize a file control structure.  This will open the given files a",Useful
/*jmpbuf is garbage: must be set by read_png*/,"-10. {
-9.    CLEAR(*file);
-8.    file->global = global;
-7.    file->file_name = file_name;
-6.    file->out_name = out_name;
-5.    file->status_code = 0;
-4.    file->read_errno = 0;
-3.    file->write_errno = 0;
-2.    file->file = NULL;
-1.    file-",Useful
/*Like emit_error but checks the global 'errors' flag*/,"-10.          file->write_errno = errno;
-9.          file->status_code |= WRITE_ERROR;
-8.          perror(out_name);
-7.          return WRITE_ERROR;
-6.       }
-5.    }
-4.    return 0;
-3. }
-2. static void
-1. log_error(struct file *file, int code, ",Useful
"/*In fact because chunk::chunk_type is validated prior to any call to this
    * function it will always return a-zA-Z, but the extra codes are just there
    * to help in finding internal (programming) errors.  Note that the code only
    * ever considers the low 7 bits of the value (so it is not necessary for the
    * type_name function to mask of the byte.)*/","-7. {
-6.    if (file->global->errors)
-5.       emit_error(file, code, what);
-4. }
-3. static char
-2. type_char(png_uint_32 v)
-1. {
   /* In fact because chunk::chunk_type is validated prior to any call to this
    * function it will always return a-z",Useful
"/*Return control when a PNG file cannot be read. This outputs an 'ERR'
    * summary line too.*/","-10. }
-9. static void
-8. type_sep(FILE *out)
-7. {
-6.    putc(':', out);
-5.    putc(' ', out);
-4. }
-3. static png_uint_32 current_type(struct file *file, int code);
-2. PNG_NORETURN static void
-1. stop(struct file *file, int code, const char *what)",Useful
"/*The chunk being read is typically identified by file->chunk or, if this is
    * NULL, by file->type.  This may be wrong if libpng reads ahead, but this
    * only happens with IDAT where libpng reads the header then jumps around
    * finding errors in the previous chunks.  We know that is happening because
    * we are at the start of the IDAT (i.e. no IDAT data has yet been written.)
    *
    * SUMMARY FORMAT (stop):
    *
    * IDAT ERR status code read-errno write-errno message file
    *
    * 'uncompressed' will be 0 if there was a problem in the IHDR.  The errno
    * values are emit_string(strerror(errno)).*/","-2. {
-1.    log_error(file, code, what);
   /* The chunk being read is typically identified by file->chunk or, if this is
    * NULL, by file->type.  This may be wrong if libpng reads ahead, but this
    * only happens with IDAT where libpng reads the he",Useful
"/*Input file positioning - we jump around in the input file while reading
 * stuff, these wrappers deal with the error handling.*/","-10.    if (file->global->errors)
-9.    {
-8.       fputs(file->file_name, stderr);
-7.       type_sep(stderr);
-6.       type_name(type, stderr);
-5.       type_sep(stderr);
-4.       fputs(what, stderr);
-3.       putc('\n', stderr);
-2.    }
-1. }
/* ",Useful
"/*Get the current position and store it in 'data_pos'.  The corresponding
    * setpos() function is chunk specific because it uses the copy of the
    * position for the specific chunk.*/","-10. file_setpos(struct file *file, const fpos_t *pos)
-9. {
-8.    if (fsetpos(file->file, pos))
-7.    {
-6.       perror(file->file_name);
-5.       stop(file, READ_ERROR_CODE, ""fsetpos"");
-4.    }
-3. }
-2. static void
-1. getpos(struct file *file)
  ",Useful
"/*Read utility - read a single byte, returns a value in the range 0..255 or EOF
 * on a read error.  In the latter case status_code and read_errno are updated
 * appropriately.*/","-3. {
-2.    file_getpos(file, &file->data_pos);
-1. }
/* Read utility - read a single byte, returns a value in the range 0..255 or EOF
 * on a read error.  In the latter case status_code and read_errno are updated
 * appropriately.

 /*Read utility - rea",Useful
/*out of range character*/,"-10. {
-9.    int ch = getc(file->file);
-8.    if (ch >= 0 && ch <= 255)
-7.    {
-6.       ++(file->read_count);
-5.       return ch;
-4.    }
-3.    else if (ch != EOF)
-2.    {
-1.       file->status_code |= INTERNAL_ERROR;

 /*out of range character*",Useful
/*This is very unexpected; an error message is always output:*/,"-10.    int ch = getc(file->file);
-9.    if (ch >= 0 && ch <= 255)
-8.    {
-7.       ++(file->read_count);
-6.       return ch;
-5.    }
-4.    else if (ch != EOF)
-3.    {
-2.       file->status_code |= INTERNAL_ERROR;

 /*This is very unexpected; an e",Useful
"/*Interrupted, try again*/","-3.       emit_error(file, UNEXPECTED_ERROR_CODE, ""file read"");
-2.    }
-1. #  ifdef EINTR

 /*Interrupted, try again*/

1.       {
2.          errno = 0;
3.          return read_byte(file);
4.       }
5. #  endif
6.    else
7.    {",Useful
"/*An error, it doesn't really matter what the error is but it gets
       * recorded anyway.*/","-7.       {
-6.          errno = 0;
-5.          return read_byte(file);
-4.       }
-3. #  endif
-2.    else
-1.    {
      /* An error, it doesn't really matter what the error is but it gets
       * recorded anyway.

 /*An error, it doesn't really matt",Useful
"/*I.e. a regular EOF, no error*/","-3.       if (ferror(file->file))
-2.          file->read_errno = errno;
-1.       else if (feof(file->file))

 /*I.e. a regular EOF, no error*/

111",Useful
"/*TRUNCATED' is used for all cases of failure to read a byte, because of
    * the way libpng works a byte read is never attempted unless the byte is
    * expected to be there, so EOF should not occur.*/","-2.          file->read_errno = EDOM;
-1.    }
   /* 'TRUNCATED' is used for all cases of failure to read a byte, because of
    * the way libpng works a byte read is never attempted unless the byte is
    * expected to be there, so EOF should not occur.
",Useful
"/*Read a byte when an error is not expected to happen because the byte has
    * been read before without error.*/","-5.    file->status_code |= TRUNCATED;
-4.    return EOF;
-3. }
-2. static png_byte
-1. reread_byte(struct file *file)
   /* Read a byte when an error is not expected to happen because the byte has
    * been read before without error.

 /*Read a byte whe",Useful
"/*Skip exactly 12 bytes in the input stream - used to skip a CRC and chunk
    * header that has been read before.*/","-9. {
-8.    png_uint_32 result = 0;
-7.    int i = 0;
-6.    while (++i <= 4)
-5.       result = (result << 8) + reread_byte(file);
-4.    return result;
-3. }
-2. static void
-1. skip_12(struct file *file)
   /* Skip exactly 12 bytes in the input stream",Useful
/*Since the chunks were read before this shouldn't fail:*/,"-1. {

 /*Since the chunks were read before this shouldn't fail:*/

1.    if (fseek(file->file, 12, SEEK_CUR) != 0)
2.    {
3.       if (errno != 0)
4.          file->read_errno = errno;
5.       stop(file, UNEXPECTED_ERROR_CODE, ""reskip"");
6.    }
7. }
8",Useful
"/*Write one byte to the output - this causes a fatal error if the write
    * fails and the read of this PNG file immediately terminates.  Just
    * increments the write count if there is no output file.*/","-9.    if (fseek(file->file, 12, SEEK_CUR) != 0)
-8.    {
-7.       if (errno != 0)
-6.          file->read_errno = errno;
-5.       stop(file, UNEXPECTED_ERROR_CODE, ""reskip"");
-4.    }
-3. }
-2. static void
-1. write_byte(struct file *file, int b)
   /*",Useful
"/*Read four bytes, returns the number of bytes read successfully and, if all
    * four bytes are read, assigns the result to *pu.*/","-2. static unsigned int
-1. read_4(struct file *file, png_uint_32 *pu)
   /* Read four bytes, returns the number of bytes read successfully and, if all
    * four bytes are read, assigns the result to *pu.

 /*Read four bytes, returns the number of bytes ",Useful
/*CRC handling - read but calculate the CRC while doing so.*/,"-10.    do
-9.    {
-8.       int ch = read_byte(file);
-7.       if (ch == EOF)
-6.          return i;
-5.       val = (val << 8) + ch;
-4.    } while (++i < 4);
-3.    *pu = val;
-2.    return i;
-1. }

 /*CRC handling - read but calculate the CRC while",Useful
"/*Reads 'length' bytes and updates the CRC, returns true on success, false
    * if the input is truncated.*/","-2. static int
-1. crc_read_many(struct file *file, png_uint_32 length)
   /* Reads 'length' bytes and updates the CRC, returns true on success, false
    * if the input is truncated.

 /*Reads 'length' bytes and updates the CRC, returns true on success, ",Useful
"/*Interlacing makes the image larger because of the replication of
          * both the filter byte and the padding to a byte boundary.*/","-10.       stop_invalid(file, ""IHDR: width"");
-9.    else if (file->height < 1 || file->height > 0x7fffffff)
-8.       stop_invalid(file, ""IHDR: height"");
-7.    else if (file->compression_method != 0)
-6.       stop_invalid(file, ""IHDR: compression metho",Useful
"/*PER-CHUNK CONTROL STRUCTURE
 * This structure is instantiated for each chunk, except for the IDAT chunks
 * where one chunk control structure is used for the whole of a single stream of
 * IDAT chunks (see the IDAT control structure below).*/","-10.             file->image_digits = uarb_mult32(file->image_bytes, 0,
-9.                row_bytes, digits, file->height);
-8.          }
-7.          break;
-6.       default:
-5.          stop_invalid(file, ""IHDR: interlace method"");
-4.    }
-3.    a",Useful
/*PUBLIC IDAT INFORMATION: SET BY THE ZLIB CODE*/,"-2.    struct file *         file;
-1.    struct global *       global;

 /*PUBLIC IDAT INFORMATION: SET BY THE ZLIB CODE*/

1.    udigit         uncompressed_bytes[5];
2.    int            uncompressed_digits;
3.    udigit         compressed_bytes[5];
4.",Useful
/*PUBLIC PER-CHUNK INFORMATION: USED BY CHUNK READ CODE*/,"-4.    udigit         uncompressed_bytes[5];
-3.    int            uncompressed_digits;
-2.    udigit         compressed_bytes[5];
-1.    int            compressed_digits;

 /*PUBLIC PER-CHUNK INFORMATION: USED BY CHUNK READ CODE*/

111",Useful
"/*This information is filled in by chunk_init from the data in the file
    * control structure, but chunk_length may be changed later.*/","
   /* This information is filled in by chunk_init from the data in the file
    * control structure, but chunk_length may be changed later.



 /*This information is filled in by chunk_init from the data in the file
    * control structure, but chunk_length may be changed later.*/

1.     */",Useful
/*Position of first byte of chunk data*/,"-10.    jmp_buf        jmpbuf;        /* Set while reading a PNG */
-9.    /* PROTECTED CHUNK SPECIFIC VARIABLES: USED BY CHUNK CODE */
-8.    /* The following variables are used during reading to record the length, type
-7.     * and data position of the",Useful
/*PUBLIC PER-CHUNK INFORMATION: FOR THE CHUNK WRITE CODE*/,"-10.    int            uncompressed_digits;
-9.    udigit         compressed_bytes[5];
-8.    int            compressed_digits;

 /*PUBLIC PER-CHUNK INFORMATION: FOR THE CHUNK WRITE CODE*/

111",Useful
/*Number of bytes left to change*/,"-10.    /* PUBLIC PER-CHUNK INFORMATION: USED BY CHUNK READ CODE */
-9.    /* This information is filled in by chunk_init from the data in the file
-8.     * control structure, but chunk_length may be changed later.
-7.     */
-6.    fpos_t         chunk_",Useful
/*Buffer of new byte values*/,"-10.    /* This information is filled in by chunk_init from the data in the file
-9.     * control structure, but chunk_length may be changed later.
-8.     */
-7.    fpos_t         chunk_data_pos;    /* Position of first byte of chunk data */
-6.    png_",Useful
"/*When a chunk is initialized the file length/type/pos are copied into the
    * corresponding chunk fields and the new chunk is registered in the file
    * structure.  There can only be one chunk at a time.
    *
    * NOTE: this routine must onely be called from the file alloc routine!*/","-10. }
-9. static void
-8. chunk_end(struct chunk **chunk_var)
-7. {
-6.    struct chunk *chunk = *chunk_var;
-5.    *chunk_var = NULL;
-4.    CLEAR(*chunk);
-3. }
-2. static void
-1. chunk_init(struct chunk * const chunk, struct file * const file)
   /* ",Useful
"/*Compresssed/uncompressed size information (from the zlib control structure
    * that is used to check the compressed data in a chunk.)*/","-10.     * NOTE: this routine must onely be called from the file alloc routine!
-9.     */
-8. {
-7.    assert(file->chunk == NULL);
-6.    CLEAR(*chunk);
-5.    chunk->file = file;
-4.    chunk->global = file->global;
-3.    chunk->chunk_data_pos = file-",Useful
"/*This may return png_IDAT for errors detected (late) in the header; that
    * includes any inter-chunk consistency check that libpng performs.  Assume
    * that if the chunk_type is png_IDAT and the file write count is 8 this is
    * what is happening.*/","-1. {
   /* This may return png_IDAT for errors detected (late) in the header; that
    * includes any inter-chunk consistency check that libpng performs.  Assume
    * that if the chunk_type is png_IDAT and the file write count is 8 this is
    * what is",Useful
"/*This is probably wrong for the excess IDATs case, because then libpng
       * whines about too many of them (apparently in some cases erroneously)
       * when the header is read.*/","-3.    if (file->chunk != NULL)
-2.    {
-1.       png_uint_32 type = file->chunk->chunk_type;
      /* This is probably wrong for the excess IDATs case, because then libpng
       * whines about too many of them (apparently in some cases erroneously)
   ",Useful
"/*Reset the position to 'chunk_data_pos' - the start of the data for this
    * chunk.  As a side effect the read_count in the file is reset to 8, just
    * after the length/type header.*/","-7.       return type;
-6.    }
-5.    else
-4.       return file->type;
-3. }
-2. static void
-1. setpos(struct chunk *chunk)
   /* Reset the position to 'chunk_data_pos' - the start of the data for this
    * chunk.  As a side effect the read_count in t",Useful
"/*Specific chunk handling - called for each chunk header, all special chunk
 * processing is initiated in these functions.*/","-4. {
-3.    chunk->file->read_count = 8;
-2.    file_setpos(chunk->file, &chunk->chunk_data_pos);
-1. }
/* Specific chunk handling - called for each chunk header, all special chunk
 * processing is initiated in these functions.

 /*Specific chunk handlin",Useful
"/*The next functions handle special processing for those chunks with LZ data,
 * the data is identified and checked for validity.  If there are problems which
 * cannot be corrected the routines return false, otherwise true (although
 * modification to the zlib header may be required.)
 *
 * The compressed data is in zlib format (RFC1950) and consequently has a
 * minimum length of 7 bytes.*/","/* The next functions handle special processing for those chunks with LZ data,
 * the data is identified and checked for validity.  If there are problems which
 * cannot be corrected the routines return false, otherwise true (although
 * modification to the zlib header may be required.)
 *
 * The compressed data is in zlib format (RFC1950) and consequently has a
 * minimum length of 7 bytes.

 /*The next functions handle special processing for those chunks with LZ data,
 * the data is identified and checked for validity.  If there are problems which
 * cannot be corrected the routines return false, otherwise true (although
 * modification to the zlib header may be required.)
 *
 * The compressed data is in zlib format (RFC1950) and consequently has a
 * minimum length of 7 bytes.*/

1.  */
2. static int zlib_check(struct file *file, png_uint_32 offset);
3. static int
4. process_zTXt_iCCP(struct file *file)",Useful
"/*zTXt and iCCP have exactly the same form - keyword, null, compression
    * method then compressed data.*/","-10.  * the data is identified and checked for validity.  If there are problems which
-9.  * cannot be corrected the routines return false, otherwise true (although
-8.  * modification to the zlib header may be required.)
-7.  *
-6.  * The compressed data",Useful
/*Skip the language tag (null terminated).*/,"-3.          --length;
-2.          ++index;

 /*Skip the language tag (null terminated).*/

1.          while (length >= 9)
2.          {
3.             --length;
4.             ++index;",Useful
/*Ran out of bytes in the compressed case.*/,"-4.                      return zlib_check(file, index);
-3.                }
-2.             }
-1.          }

 /*Ran out of bytes in the compressed case.*/

1.          break;
2.       }
3.    }
4.    log_error(file, INVALID_ERROR_CODE, ""iTXt chunk leng",Useful
/*PROTECTED IDAT INFORMATION: SET BY THE IDAT READ CODE*/,"-2.    struct file *         file;
-1.    struct global *       global;

 /*PROTECTED IDAT INFORMATION: SET BY THE IDAT READ CODE*/

111",Useful
/*PROTECTED IDAT INFORMATION: USED BY THE IDAT WRITE CODE*/,"-5.    struct file *         file;
-4.    struct global *       global;

 /*PROTECTED IDAT INFORMATION: USED BY THE IDAT WRITE CODE*/

111",Useful
/*Index of *next* input byte to write*/,"-8.    struct file *         file;
-7.    struct global *       global;

 /*Index of *next* input byte to write*/

111",Useful
"/*Regardless of why the IDAT was killed set the state back to CHUNKS (it may
    * already be CHUNKS because the state isn't changed until process_IDAT
    * returns; a stop will cause IDAT_end to be entered in state CHUNKS!)*/","-10.  */
-9. static void
-8. IDAT_end(struct IDAT **idat_var)
-7. {
-6.    struct IDAT *idat = *idat_var;
-5.    struct file *file = idat->file;
-4.    *idat_var = NULL;
-3.    CLEAR(*idat);
-2.    assert(file->chunk != NULL);
-1.    chunk_end(&file->chun",Useful
"/*When the chunk is png_IDAT instantiate an IDAT control structure in place
    * of a chunk control structure.  The IDAT will instantiate a chunk control
    * structure using the file alloc routine.
    *
    * NOTE: this routine must only be called from the file alloc routine!*/","-4.    file->state = STATE_CHUNKS;
-3. }
-2. static void
-1. IDAT_init(struct IDAT * const idat, struct file * const file)
   /* When the chunk is png_IDAT instantiate an IDAT control structure in place
    * of a chunk control structure.  The IDAT will i",Useful
"/*Initialize the tail to the pre-allocated buffer and set the count to 0
    * (empty.)*/","-10.     * structure using the file alloc routine.
-9.     *
-8.     * NOTE: this routine must only be called from the file alloc routine!
-7.     */
-6. {
-5.    assert(file->chunk == NULL);
-4.    assert(file->idat == NULL);
-3.    CLEAR(*idat);
-2.    ",Useful
"/*Now the chunk.  The allocator calls the initializer of the new chunk and
    * stores the result in file->chunk:*/","-2.    idat->global->idat_cache.count = 0;
-1.    idat->idat_list_head = idat->idat_list_tail = &idat->global->idat_cache;
   /* Now the chunk.  The allocator calls the initializer of the new chunk and
    * stores the result in file->chunk:

 /*Now the c",Useful
"/*And store this for cleanup (and to check for double alloc or failure to
    * free.)*/","-1.    assert(file->chunk != NULL);
   /* And store this for cleanup (and to check for double alloc or failure to
    * free.)

 /*And store this for cleanup (and to check for double alloc or failure to
    * free.)*/

1.     */
2.    file->idat = idat;
3",Useful
"/*Return the length for the next IDAT chunk, taking into account
    * rechunking.*/","-4.    file->idat = idat;
-3. }
-2. static png_uint_32
-1. rechunk_length(struct IDAT *idat, int start)
   /* Return the length for the next IDAT chunk, taking into account
    * rechunking.

 /*Return the length for the next IDAT chunk, taking into accou",Useful
"/*Otherwise rechunk_length is called at the end of a chunk for the length
       * of the next one.*/","
      /* Otherwise rechunk_length is called at the end of a chunk for the length
       * of the next one.



 /*Otherwise rechunk_length is called at the end of a chunk for the length
       * of the next one.*/

1.        */
2.       cur = idat->idat_cur;
3.       count = idat->idat_count;
4.       assert(idat->idat_index == idat->idat_length &&
5.          idat->idat_length == cur->lengths[count]);",Useful
/*Return length of the *next* chunk*/,"-4.       cur = idat->idat_cur;
-3.       count = idat->idat_count;
-2.       assert(idat->idat_index == idat->idat_length &&
-1.          idat->idat_length == cur->lengths[count]);

 /*Return length of the *next* chunk*/

1.       if (++count < cur->coun",Useful
"/*The chunk size is the lesser of file->idat_max and the number
       * of remaining bytes.*/","-1.    {
      /* The chunk size is the lesser of file->idat_max and the number
       * of remaining bytes.

 /*The chunk size is the lesser of file->idat_max and the number
       * of remaining bytes.*/

1.        */
2.       png_uint_32 have = idat->i",Useful
"/*Add up the remaining bytes.  This can't overflow because the
             * individual lengths are always <= 0x7fffffff, so when we add two
             * of them overflow is not possible.*/","-2.          do
-1.          {
            /* Add up the remaining bytes.  This can't overflow because the
             * individual lengths are always <= 0x7fffffff, so when we add two
             * of them overflow is not possible.

 /*Add up the remai",Useful
/*If this was the end return the count of the available bytes*/,"-6.                for (; j < cur->count; ++j)
-5.                {
-4.                   have += cur->lengths[j];
-3.                   if (len <= have)
-2.                      return len;
-1.                }

 /*If this was the end return the count of",Useful
"/*Process the IDAT stream, this is the more complex than the preceding
    * cases because the compressed data is spread across multiple IDAT chunks
    * (typically).  Rechunking of the data is not handled here; all this
    * function does is establish whether the zlib header needs to be modified.
    *
    * Initially the function returns false, indicating that the chunk should not
    * be written.  It does this until the last IDAT chunk is passed in, then it
    * checks the zlib data and returns true.
    *
    * It does not return false on a fatal error; it calls stop instead.
    *
    * The caller must have an instantiated (IDAT) control structure and it must
    * have extent over the whole read of the IDAT stream.  For a PNG this means
    * the whole PNG read, for MNG it could have lesser extent.*/","-10.                j = 0;
-9.             }
-8.          }
-7.          while (len > have);
-6.       }
-5.       return len;
-4.    }
-3. }
-2. static int
-1. process_IDAT(struct file *file)
   /* Process the IDAT stream, this is the more complex than t",Useful
"/*We need to first check the entire sequence of IDAT chunks to ensure the
    * stream is in sync.  Do this by building a list of all the chunks and
    * recording the length of each because the length may have been fixed up by
    * sync_stream below.
    *
    * At the end of the list of chunks, where the type of the next chunk is not
    * png_IDAT, process the whole stream using the list data to check validity
    * then return control to the start and rewrite everything.*/","-10.     *
-9.     * It does not return false on a fatal error; it calls stop instead.
-8.     *
-7.     * The caller must have an instantiated (IDAT) control structure and it must
-6.     * have extent over the whole read of the IDAT stream.  For a PNG t",Useful
/*Move to the next block*/,"-10.     * At the end of the list of chunks, where the type of the next chunk is not
-9.     * png_IDAT, process the whole stream using the list data to check validity
-8.     * then return control to the start and rewrite everything.
-7.     */
-6.    li",Useful
/*And fill in the next IDAT information buffer.*/,"-3.       list->count = 0;
-2.       file->idat->idat_list_tail = list;
-1.    }

 /*And fill in the next IDAT information buffer.*/

1.    list->lengths[(list->count)++] = file->chunk->chunk_length;",Useful
"/*The type of the next chunk was recorded in the file control structure by
    * the caller, if this is png_IDAT return 'skip' to the caller.*/","-1.    list->lengths[(list->count)++] = file->chunk->chunk_length;
   /* The type of the next chunk was recorded in the file control structure by
    * the caller, if this is png_IDAT return 'skip' to the caller.

 /*The type of the next chunk was recorde",Useful
"/*This is the final IDAT chunk, so run the tests to check for the too far
    * back error and possibly optimize the window bits.  This means going back
    * to the start of the first chunk data, which is stored in the original
    * chunk allocation.*/","
   /* This is the final IDAT chunk, so run the tests to check for the too far
    * back error and possibly optimize the window bits.  This means going back
    * to the start of the first chunk data, which is stored in the original
    * chunk allocation.



 /*This is the final IDAT chunk, so run the tests to check for the too far
    * back error and possibly optimize the window bits.  This means going back
    * to the start of the first chunk data, which is stored in the original
    * chunk allocation.*/

1.     */
2.    setpos(file->chunk);
3.    if (zlib_check(file, 0))
4.    {
5.       struct IDAT *idat;
6.       int cmp;",Useful
"/*The IDAT stream was successfully uncompressed; see whether it
       * contained the correct number of bytes of image data.*/","-5.    setpos(file->chunk);
-4.    if (zlib_check(file, 0))
-3.    {
-2.       struct IDAT *idat;
-1.       int cmp;
      /* The IDAT stream was successfully uncompressed; see whether it
       * contained the correct number of bytes of image data.

 /*T",Useful
"/*Return the stream to the start of the first IDAT chunk; the length
       * is set in the write case below but the input chunk variables must be
       * set (once) here:*/","-6.       cmp = uarb_cmp(file->image_bytes, file->image_digits,
-5.          file->chunk->uncompressed_bytes, file->chunk->uncompressed_digits);
-4.       if (cmp < 0)
-3.          type_message(file, png_IDAT, ""extra uncompressed data"");
-2.       else if",Useful
/*Count of chunks read in current list*/,"-4.       setpos(file->chunk);
-3.       idat = file->idat;
-2.       idat->idat_cur = idat->idat_list_head;
-1.       idat->idat_length = idat->idat_cur->lengths[0];

 /*Count of chunks read in current list*/

111",Useful
/*Update the chunk length to the correct value for the IDAT chunk:*/,"-6.       setpos(file->chunk);
-5.       idat = file->idat;
-4.       idat->idat_cur = idat->idat_list_head;
-3.       idat->idat_length = idat->idat_cur->lengths[0];

 /*Update the chunk length to the correct value for the IDAT chunk:*/

111",Useful
/*Change the state to writing IDAT chunks*/,"-10.        * set (once) here:
-9.        */
-8.       setpos(file->chunk);
-7.       idat = file->idat;
-6.       idat->idat_cur = idat->idat_list_head;
-5.       idat->idat_length = idat->idat_cur->lengths[0];

 /*Change the state to writing IDAT chunks",Useful
/*GLOBAL ZLIB INFORMATION: SET BY THE CALLER*/,"-3.    struct chunk * chunk;
-2.    struct file *  file;
-1.    struct global *global;

 /*GLOBAL ZLIB INFORMATION: SET BY THE CALLER*/

1.    png_uint_32    rewrite_offset;",Useful
/*GLOBAL ZLIB INFORMATION: SET BY THE ZLIB READ CODE*/,"-1.    png_uint_32    rewrite_offset;

 /*GLOBAL ZLIB INFORMATION: SET BY THE ZLIB READ CODE*/

1.    udigit         compressed_bytes[5];
2.    int            compressed_digits;
3.    udigit         uncompressed_bytes[5];
4.    int            uncompressed",Useful
/*Set on a checksum error*/,"-6.    udigit         compressed_bytes[5];
-5.    int            compressed_digits;
-4.    udigit         uncompressed_bytes[5];
-3.    int            uncompressed_digits;

 /*Set on a checksum error*/

111",Useful
/*Return a string for the zlib return code*/,"-10.       case 0:  return ""supfast"";
-9.       case 1:  return ""stdfast"";
-8.       case 2:  return ""default"";
-7.       case 3:  return ""maximum"";
-6.       default: assert(UNREACHED);
-5.    }
-4.    return ""COMPILER BUG"";
-3. }
-2. static const char *",Useful
"/*Output the summary line now; this ensures a summary line always gets
    * output regardless of the manner of exit.*/","-10.       fputs(zlib->file->file_name, stderr);
-9.       type_sep(stderr);
-8.       type_name(zlib->chunk->chunk_type, stderr);
-7.       fprintf(stderr, "": %szlib error: %d (%s) (%s)\n"",
-6.          unexpected ? ""unexpected "" : """", zlib->rc, zlib_rc(",Useful
"/*SUMMARY FORMAT (for a successful zlib inflate):
          *
          * IDAT reason flevel file-bits ok-bits compressed uncompressed file*/","
         /* SUMMARY FORMAT (for a successful zlib inflate):
          *
          * IDAT reason flevel file-bits ok-bits compressed uncompressed file



 /*SUMMARY FORMAT (for a successful zlib inflate):
          *
          * IDAT reason flevel file-bits ok-bits compressed uncompressed file*/

1.           */
2.          type_name(zlib->chunk->chunk_type, stdout);
3.          printf("" %s %s %d %d "", reason, zlib_flevel(zlib), zlib->file_bits,
4.             zlib->ok_bits);
5.          uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout);
6.          putc(' ', stdout);
7.          uarb_print(zlib->uncompressed_bytes, zlib->uncompressed_digits,
8.             stdout);
9.          putc(' ', stdout);
10.          fputs(zlib->file->file_name, stdout);",Useful
"/*This is a zlib read error; the chunk will be skipped.  For an IDAT
          * stream this will also cause a fatal read error (via stop()).
          *
          * SUMMARY FORMAT:
          *
          * IDAT SKP flevel file-bits z-rc compressed message file
          *
          * z-rc is the zlib failure code; message is the error message with
          * spaces replaced by '-'.  The compressed byte count indicates where
          * in the zlib stream the error occurred.*/","-10.          uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout);
-9.          putc(' ', stdout);
-8.          uarb_print(zlib->uncompressed_bytes, zlib->uncompressed_digits,
-7.             stdout);
-6.          putc(' ', stdout);
-5.   ",Useful
/*Initialize a zlib_control; the result is true/false*/,"-7.       return 0;
-6.    }
-5.    return 1;
-4. }
-3. static int
-2. zlib_init(struct zlib *zlib, struct IDAT *idat, struct chunk *chunk,
-1.    int window_bits, png_uint_32 offset)

 /*Initialize a zlib_control; the result is true/false*/

1. {
2.    C",Useful
"/*These values are sticky across reset (in addition to the stuff in the
    * first block, which is actually constant.)*/","-9.    zlib->z.next_in = Z_NULL;
-8.    zlib->z.avail_in = 0;
-7.    zlib->z.zalloc = Z_NULL;
-6.    zlib->z.zfree = Z_NULL;
-5.    zlib->z.opaque = Z_NULL;
-4.    zlib->state = -1;
-3.    zlib->window_bits = window_bits;
-2.    zlib->compressed_digits = ",Useful
/*set when a checksum error is detected*/,"-2.    zlib->file_bits = 24;

 /*set when a checksum error is detected*/

111",Useful
"/*0' means use the header; inflateInit2 should always succeed because it
    * does nothing apart from allocating the internal zstate.*/","/* '0' means use the header; inflateInit2 should always succeed because it
    * does nothing apart from allocating the internal zstate.

 /*0' means use the header; inflateInit2 should always succeed because it
    * does nothing apart from allocating the internal zstate.*/

1.     */
2.    zlib->rc = inflateInit2(&zlib->z, 0);
3.    if (zlib->rc != Z_OK)
4.    {",Useful
/*Return the zlib stream window bits required for data of the given size.*/,"-5.       return 1;
-4.    }
-3. }
-2. static int
-1. max_window_bits(uarbc size, int ndigits)

 /*Return the zlib stream window bits required for data of the given size.*/

1. {
2.    png_uint_16 cb;
3.    if (ndigits > 1)
4.       return 15;
5.    cb = ",Useful
"/*Read nbytes compressed bytes; the stream will be initialized if required.
    * Bytes are always being reread and errors are fatal.  The return code is as
    * follows:
    *
    *    -1: saw the ""too far back"" error
    *     0: ok, keep going
    *     1: saw Z_STREAM_END (zlib->extra_bytes indicates too much data)
    *     2: a zlib error that cannot be corrected (error message already
    *        output if required.)*/","-10.    if (cb >  8192) return 14;
-9.    if (cb >  4096) return 13;
-8.    if (cb >  2048) return 12;
-7.    if (cb >  1024) return 11;
-6.    if (cb >   512) return 10;
-5.    if (cb >   256) return  9;
-4.    return 8;
-3. }
-2. static int
-1. zlib_adv",Useful
/*first header byte*/,"-10.    struct file *file = zlib->file;
-9.    assert(state >= 0);
-8.    while (in_bytes < nbytes && endrc == ZLIB_OK)
-7.    {
-6.       png_uint_32 out_bytes;
-5.       int flush;
-4.       png_byte bIn = reread_byte(file);
-3.       png_byte bOut;
-2.",Useful
"/*Check against the existing value - it may not need to be
                * changed.  Note that a bogus file_bits is allowed through once,
                * to see if it works, but the window_bits value is set to 15,
                * the maximum.*/","-4.             {
-3.                int file_bits = 8+(bIn >> 4);
-2.                int new_bits = zlib->window_bits;
-1.                zlib->file_bits = file_bits;
               /* Check against the existing value - it may not need to be
            ",Useful
/*second header byte*/,"-5.                   bIn = (png_byte)((bIn & 0xf) + ((new_bits-8) << 4));
-4.             }
-3.             zlib->header[0] = bIn;
-2.             zlib->state = state = 1;
-1.             break;

 /*second header byte*/

1.             {",Useful
"/*The checksum calculation, on the first 11 bits:*/","-2.             {

 /*The checksum calculation, on the first 11 bits:*/

1.                b2 += 0x1f - ((zlib->header[0] << 8) + b2) % 0x1f;",Useful
/*Update the checksum byte if required:*/,"-1.                b2 += 0x1f - ((zlib->header[0] << 8) + b2) % 0x1f;

 /*Update the checksum byte if required:*/

1.                if (bIn != b2)
2.                {",Useful
"/*If the first byte wasn't changed this indicates an error in
                   * the checksum calculation; signal this by setting 'cksum'.*/","-2.                if (bIn != b2)
-1.                {
                  /* If the first byte wasn't changed this indicates an error in
                   * the checksum calculation; signal this by setting 'cksum'.

 /*If the first byte wasn't changed thi",Useful
"/*For some streams, perhaps only those compressed with 'superfast
       * compression' (which results in a lot of copying) Z_BUF_ERROR can happen
       * immediately after all output has been flushed on the next input byte.
       * This is handled below when Z_BUF_ERROR is detected by adding an output
       * byte.*/","-2.             break;
-1.       }
      /* For some streams, perhaps only those compressed with 'superfast
       * compression' (which results in a lot of copying) Z_BUF_ERROR can happen
       * immediately after all output has been flushed on the next",Useful
"/*Initially use Z_NO_FLUSH in an attempt to persuade zlib to look at this
       * byte without confusing what is going on with output.*/","
      /* Initially use Z_NO_FLUSH in an attempt to persuade zlib to look at this
       * byte without confusing what is going on with output.



 /*Initially use Z_NO_FLUSH in an attempt to persuade zlib to look at this
       * byte without confusing what is going on with output.*/

1.        */
2.       flush = Z_NO_FLUSH;
3.       out_bytes = 0;",Useful
"/*NOTE: expression 3 is only evaluated on 'continue', because of the
       * 'break' at the end of this loop below.*/","nan


 /*NOTE: expression 3 is only evaluated on 'continue', because of the
       * 'break' at the end of this loop below.*/

nan
",Useful
/*Try another output byte.*/,"-10.          zlib->z.next_out = &bOut,
-9.          zlib->z.avail_out = 1,
-8.          ++out_bytes)
-7.       {
-6.          zlib->rc = inflate(&zlib->z, flush);
-5.          out_bytes -= zlib->z.avail_out;
-4.          switch (zlib->rc)
-3.          {
",Useful
/*Try another input byte*/,"-1.                if (zlib->z.avail_in == 0)

 /*Try another input byte*/

111",Useful
"/*Both avail_out and avail_in are 1 yet zlib returned a code
                * indicating no progress was possible.  This is unexpected.*/","/* Both avail_out and avail_in are 1 yet zlib returned a code
                * indicating no progress was possible.  This is unexpected.

 /*Both avail_out and avail_in are 1 yet zlib returned a code
                * indicating no progress was possible.  This is unexpected.*/

1.                 */",Useful
"/*Control gets here when further output is not possible; endrc may
          * still be ZLIB_OK if more input is required.*/","
         /* Control gets here when further output is not possible; endrc may
          * still be ZLIB_OK if more input is required.



 /*Control gets here when further output is not possible; endrc may
          * still be ZLIB_OK if more input is required.*/

1.           */
2.          break;",Useful
/*for (output bytes)*/,"-1.          break;

 /*for (output bytes)*/

111",Useful
"/*The extra bytes in the chunk are handled now by adjusting the chunk
       * length to exclude them; the zlib data is always stored at the end of
       * the PNG chunk (although clearly this is not necessary.)  zlib_advance
       * has already output a warning message.*/","-10.             return ZLIB_OK;
-9.          list = list->next;
-8.       }
-7.    }
-6.    else
-5.    {
-4.       struct chunk *chunk = zlib->chunk;
-3.       int rc;
-2.       assert(zlib->rewrite_offset < chunk->chunk_length);
-1.       rc = zlib_adv",Useful
/*global function; not a member function*/,"-4.       chunk->chunk_length -= zlib->extra_bytes;
-3.       return rc;
-2.    }
-1. }

 /*global function; not a member function*/

1. zlib_check(struct file *file, png_uint_32 offset)
2.    /* Check the stream of zlib compressed data in either idat (if",Useful
"/*Check the stream of zlib compressed data in either idat (if given) or (if
    * not) chunk.  In fact it is zlib_run that handles the difference in reading
    * a single chunk and a list of IDAT chunks.
    *
    * In either case the input file must be positioned at the first byte of zlib
    * compressed data (the first header byte).
    *
    * The return value is true on success, including the case where the zlib
    * header may need to be rewritten, and false on an unrecoverable error.
    *
    * In the case of IDAT chunks 'offset' should be 0.*/","-1. zlib_check(struct file *file, png_uint_32 offset)
   /* Check the stream of zlib compressed data in either idat (if given) or (if
    * not) chunk.  In fact it is zlib_run that handles the difference in reading
    * a single chunk and a list of IDAT ",Useful
/*Record the start of the LZ data to allow a re-read.*/,"-10.     * compressed data (the first header byte).
-9.     *
-8.     * The return value is true on success, including the case where the zlib
-7.     * header may need to be rewritten, and false on an unrecoverable error.
-6.     *
-5.     * In the case ",Useful
"/*cksum is set if there is an error in the zlib header checksum
             * calculation in the original file (and this may be the only reason
             * a rewrite is required).  We can't rely on the file window bits in
             * this case, so do the optimization anyway.*/","-10.                 * not requested.
-9.                 */
-8.                zlib_end(&zlib);
-7.                return 1;
-6.             }
-5.             max_bits = max_window_bits(zlib.uncompressed_bytes,
-4.                zlib.uncompressed_digits",Useful
"/*Unrecoverable error; skip the chunk; a zlib_message has already
             * been output.*/","-1.          default:
            /* Unrecoverable error; skip the chunk; a zlib_message has already
             * been output.

 /*Unrecoverable error; skip the chunk; a zlib_message has already
             * been output.*/

1.              */
2.      ",Useful
"/*Optimize window bits or fix a too-far-back error.  min_bits and
       * max_bits have been set appropriately, ok_bits records the bit value
       * known to work.*/","-3.             zlib_end(&zlib);
-2.             return 0;
-1.       }
      /* Optimize window bits or fix a too-far-back error.  min_bits and
       * max_bits have been set appropriately, ok_bits records the bit value
       * known to work.

 /*Optimi",Useful
"/*This happens when the stream really is damaged and it
                      * contains a distance code that addresses bytes before
                      * the start of the uncompressed data.*/","-10.          if (zlib_reset(&zlib, test_bits))
-9.          {
-8.             file_setpos(file, &start_pos);
-7.             rc = zlib_run(&zlib);
-6.             switch (rc)
-5.             {
-4.                case ZLIB_TOO_FAR_BACK:
-3.               ",Useful
"/*A fatal error; this happens if a too-far-back error was
                   * hiding a more serious error, zlib_advance has already
                   * output a zlib_message.*/","-3.                   max_bits = test_bits;
-2.                   break;
-1.                default:
                  /* A fatal error; this happens if a too-far-back error was
                   * hiding a more serious error, zlib_advance has already
  ",Useful
"/*The strategy here is to run a regular libpng PNG file read but examine the
 * input data (from the file) before passing it to libpng so as to be aware of
 * the state we expect libpng to be in.  Warning and error callbacks are also
 * intercepted so that they can be quieted and interpreted.  Interpretation
 * depends on a somewhat risky string match for known error messages; let us
 * hope that this can be fixed in the next version of libpng.
 *
 * The control structure is pointed to by the libpng error pointer.  It contains
 * that set of structures which must persist across multiple read callbacks,
 * which is pretty much everything except the 'zlib' control structure.
 *
 * The file structure is instantiated in the caller of the per-file routine, but
 * the per-file routine contains the chunk and IDAT control structures.*/","
/* The strategy here is to run a regular libpng PNG file read but examine the
 * input data (from the file) before passing it to libpng so as to be aware of
 * the state we expect libpng to be in.  Warning and error callbacks are also
 * intercepted so that they can be quieted and interpreted.  Interpretation
 * depends on a somewhat risky string match for known error messages; let us
 * hope that this can be fixed in the next version of libpng.
 *
 * The control structure is pointed to by the libpng error pointer.  It contains
 * that set of structures which must persist across multiple read callbacks,
 * which is pretty much everything except the 'zlib' control structure.
 *
 * The file structure is instantiated in the caller of the per-file routine, but
 * the per-file routine contains the chunk and IDAT control structures.



 /*The strategy here is to run a regular libpng PNG file read but examine the
 * input data (from the file) before passing it to libpng so as to be aware of
 * the state we expect libpng to be in.  Warning and error callbacks are also
 * intercepted so that they can be quieted and interpreted.  Interpretation
 * depends on a somewhat risky string match for known error messages; let us
 * hope that this can be fixed in the next version of libpng.
 *
 * The control structure is pointed to by the libpng error pointer.  It contains
 * that set of structures which must persist across multiple read callbacks,
 * which is pretty much everything except the 'zlib' control structure.
 *
 * The file structure is instantiated in the caller of the per-file routine, but
 * the per-file routine contains the chunk and IDAT control structures.*/

1.  */
2. /* The three routines read_chunk, process_chunk and sync_stream can only be
3.  * called via a call to read_chunk and only exit at a return from process_chunk.
4.  * These routines could have been written as one confusing large routine,
5.  * instead this code relies on the compiler to do tail call elimination.  The
6.  * possible calls are as follows:
7.  *
8.  * read_chunk
9.  *    -> sync_stream
10.  *       -> process_chunk",Useful
"/*The three routines read_chunk, process_chunk and sync_stream can only be
 * called via a call to read_chunk and only exit at a return from process_chunk.
 * These routines could have been written as one confusing large routine,
 * instead this code relies on the compiler to do tail call elimination.  The
 * possible calls are as follows:
 *
 * read_chunk
 *    -> sync_stream
 *       -> process_chunk
 *    -> process_chunk
 *       -> read_chunk
 *       returns*/","-10.  * depends on a somewhat risky string match for known error messages; let us
-9.  * hope that this can be fixed in the next version of libpng.
-8.  *
-7.  * The control structure is pointed to by the libpng error pointer.  It contains
-6.  * that set",Useful
"/*Called when the chunk data has been read, next_length and next_type
    * will be set for the next chunk (or 0 if this is IEND).
    *
    * When this routine returns, chunk_length and chunk_type will be set for the
    * next chunk to write because if a chunk is skipped this return calls back
    * to read_chunk.*/","-10.  *    -> sync_stream
-9.  *       -> process_chunk
-8.  *    -> process_chunk
-7.  *       -> read_chunk
-6.  *       returns
-5.  */
-4. static void read_chunk(struct file *file);
-3. static void
-2. process_chunk(struct file *file, png_uint_32 file",Useful
"/*The basic structure seems correct but the CRC may not match, in this
    * case assume that it is simply a bad CRC, either wrongly calculated or
    * because of damaged stream data.*/","-10.     */
-9. {
-8.    const png_uint_32 type = file->type;
-7.    if (file->global->verbose > 1)
-6.    {
-5.       fputs(""  "", stderr);
-4.       type_name(file->type, stderr);
-3.       fprintf(stderr, "" %lu 0x%.8x 0x%.8x\n"", (unsigned long)file->len",Useful
"/*The behavior is set by the 'skip' setting; if it is anything other
       * than SKIP_BAD_CRC ignore the bad CRC and return the chunk, with a
       * corrected CRC and possibly processed, to libpng.  Otherwise skip the
       * chunk, which will result in a fatal error if the chunk is critical.*/","-2.    if ((file->crc ^ 0xffffffff) != file_crc)
-1.    {
      /* The behavior is set by the 'skip' setting; if it is anything other
       * than SKIP_BAD_CRC ignore the bad CRC and return the chunk, with a
       * corrected CRC and possibly processed,",Useful
"/*Check for other 'skip' cases and handle these; these only apply to
    * ancillary chunks (and not tRNS, which should probably have been a critical
    * chunk.)*/","-3.          goto skip_chunk;
-2.       }
-1.    }
   /* Check for other 'skip' cases and handle these; these only apply to
    * ancillary chunks (and not tRNS, which should probably have been a critical
    * chunk.)

 /*Check for other 'skip' cases and",Useful
"/*The chunk may still be skipped if problems are detected in the LZ data,
    * however the LZ data check requires a chunk.  Handle this by instantiating
    * a chunk unless an IDAT is already instantiated (IDAT control structures
    * instantiate their own chunk.)*/","-2.    if (skip_chunk_type(file->global, type))
-1.       goto skip_chunk;
   /* The chunk may still be skipped if problems are detected in the LZ data,
    * however the LZ data check requires a chunk.  Handle this by instantiating
    * a chunk unless a",Useful
/*The chunk length must be updated for process_IDAT*/,"-2.    else
-1.    {

 /*The chunk length must be updated for process_IDAT*/

1.       assert(file->chunk != NULL);
2.       assert(file->chunk->chunk_type == png_IDAT);
3.       file->chunk->chunk_length = file->length;
4.    }",Useful
"/*Record the 'next' information too, now that the original values for
    * this chunk have been copied.  Notice that the IDAT chunks only make a
    * copy of the position of the first chunk, this is fine - process_IDAT does
    * not need the position of this chunk.*/","-4.       assert(file->chunk != NULL);
-3.       assert(file->chunk->chunk_type == png_IDAT);
-2.       file->chunk->chunk_length = file->length;
-1.    }
   /* Record the 'next' information too, now that the original values for
    * this chunk have been",Useful
"/*Do per-type processing, note that if this code does not return from the
    * function the chunk will be skipped.  The rewrite is cancelled here so that
    * it can be set in the per-chunk processing.*/","-3.    file->length = next_length;
-2.    file->type = next_type;
-1.    getpos(file);
   /* Do per-type processing, note that if this code does not return from the
    * function the chunk will be skipped.  The rewrite is cancelled here so that
    * it ",Useful
"/*Read this now and update the control structure with the information
          * it contains.  The header is validated completely to ensure this is a
          * PNG.*/","-10.     * function the chunk will be skipped.  The rewrite is cancelled here so that
-9.     * it can be set in the per-chunk processing.
-8.     */
-7.    file->chunk->rewrite_length = 0;
-6.    file->chunk->rewrite_offset = 0;
-5.    switch (type)
-4. ",Useful
/*Read all the IHDR information and validate it.*/,"-4.          {
-3.             struct chunk *chunk = file->chunk;
-2.             if (chunk->chunk_length != 13)
-1.                stop_invalid(file, ""IHDR length"");

 /*Read all the IHDR information and validate it.*/

1.             setpos(chunk);
2.  ",Useful
"/*This validates all the fields, and calls stop_invalid if
             * there is a problem.*/","-8.             setpos(chunk);
-7.             file->width = reread_4(file);
-6.             file->height = reread_4(file);
-5.             file->bit_depth = reread_byte(file);
-4.             file->color_type = reread_byte(file);
-3.             file->co",Useful
/*Ancillary chunks that require further processing:*/,"-3.             calc_image_size(file);
-2.          }
-1.          return;

 /*Ancillary chunks that require further processing:*/

1.       case png_zTXt: case png_iCCP:
2.          if (process_zTXt_iCCP(file))
3.             return;
4.          chunk_en",Useful
"/*Control reaches this point if the chunk must be skipped.  For chunks other
    * than IDAT this means that the zlib compressed data is fatally damanged and
    * the chunk will not be passed to libpng.  For IDAT it means that the end of
    * the IDAT stream has not yet been reached and we must handle the next
    * (IDAT) chunk.  If the LZ data in an IDAT stream cannot be read 'stop' must
    * be used to halt parsing of the PNG.*/","-3.          assert(next_type == png_IDAT);
-2.          break;
-1.    }
   /* Control reaches this point if the chunk must be skipped.  For chunks other
    * than IDAT this means that the zlib compressed data is fatally damanged and
    * the chunk will",Useful
"/*This is the generic code to skip the current chunk; simply jump to the
    * next one.*/","-2.    read_chunk(file);
-1.    return;
   /* This is the generic code to skip the current chunk; simply jump to the
    * next one.

 /*This is the generic code to skip the current chunk; simply jump to the
    * next one.*/

1.     */
2. skip_chunk:
3. ",Useful
/*Read a 32-bit value from an 8-byte circular buffer (used only below).*/,"-10.     * next one.
-9.     */
-8. skip_chunk:
-7.    file->length = next_length;
-6.    file->type = next_type;
-5.    getpos(file);
-4.    read_chunk(file);
-3. }
-2. static png_uint_32
-1. get32(png_bytep buffer, int offset)
   /* Read a 32-bit value ",Useful
"/*The stream seems to be messed up, attempt to resync from the current chunk
    * header.  Executes stop on a fatal error, otherwise calls process_chunk.*/","-10.     */
-9. {
-8.    return
-7.       (buffer[ offset    & 7] << 24) +
-6.       (buffer[(offset+1) & 7] << 16) +
-5.       (buffer[(offset+2) & 7] <<  8) +
-4.       (buffer[(offset+3) & 7]      );
-3. }
-2. static void
-1. sync_stream(struct file *f",Useful
/*Return to the start of the chunk data*/,"-10.     */
-9. {
-8.    png_uint_32 file_crc;
-7.    file->status_code |= STREAM_ERROR;
-6.    if (file->global->verbose)
-5.    {
-4.       fputs("" SYNC "", stderr);
-3.       type_name(file->type, stderr);
-2.       putc('\n', stderr);
-1.    }

 /*Retu",Useful
"/*Ignore the recorded chunk length, proceed through the data looking for
       * a leading sequence of bytes that match the CRC in the following four
       * bytes.  Each time a match is found check the next 8 bytes for a valid
       * length, chunk-type pair.*/","-1.    {
      /* Ignore the recorded chunk length, proceed through the data looking for
       * a leading sequence of bytes that match the CRC in the following four
       * bytes.  Each time a match is found check the next 8 bytes for a valid
       * ",Useful
"/*A match on the CRC; for IEND this is sufficient, but for anything
             * else expect a following chunk header.*/","-10.       png_uint_32 length;
-9.       png_uint_32 type = file->type;
-8.       png_uint_32 crc = crc_init_4(type);
-7.       png_byte buffer[8];
-6.       unsigned int nread = 0, nused = 0;
-5.       for (length=0; length <= 0x7fffffff; ++length)
-4.  ",Useful
/*Examine the 8 bytes for a valid chunk header.*/,"-2.                nread -= nused & ~7;

 /*Examine the 8 bytes for a valid chunk header.*/

1.                {
2.                   png_uint_32 next_length = get32(buffer, nused);
3.                   if (next_length < 0x7fffffff)
4.                   {",Useful
"/*This catches up with the circular buffer which gets filled above
          * while checking a chunk header.  This code is slightly tricky - if
          * the chunk_type is IEND the buffer will never be used, if it is not
          * the code will always read ahead exactly 8 bytes and pass this on to
          * process_chunk.  So the invariant that IEND leaves the file position
          * after the IEND CRC and other chunk leave it after the *next* chunk
          * header is not broken.*/","-3.                }
-2.             }
-1.          }
         /* This catches up with the circular buffer which gets filled above
          * while checking a chunk header.  This code is slightly tricky - if
          * the chunk_type is IEND the buffer ",Useful
"/*Control gets to here if when 0x7fffffff bytes (plus 8) have been read,
       * ok, treat this as a damaged stream too:*/","-10.          {
-9.             ch = read_byte(file);
-8.             if (ch == EOF)
-7.                goto truncated;
-6.          }
-5.          else
-4.             ch = buffer[(++nused) & 7];
-3.          crc = crc_one_byte(crc, file_crc >> 24);
-2. ",Useful
"/*On entry file::data_pos must be set to the position of the first byte
    * of the chunk data *and* the input file must be at this position.  This
    * routine (via process_chunk) instantiates a chunk or IDAT control structure
    * based on file::length and file::type and also resets these fields and
    * file::data_pos for the chunk after this one.  For an IDAT chunk the whole
    * stream of IDATs will be read, until something other than an IDAT is
    * encountered, and the file fields will be set for the chunk after the end
    * of the stream of IDATs.
    *
    * For IEND the file::type field will be set to 0, and nothing beyond the end
    * of the IEND chunk will have been read.*/","-6.    }
-5. truncated:
-4.    stop(file, READ_ERROR_CODE, ""damaged PNG stream"");
-3. }
-2. static void
-1. read_chunk(struct file *file)
   /* On entry file::data_pos must be set to the position of the first byte
    * of the chunk data *and* the input f",Useful
"/*After IEND file::type is set to 0, if libpng attempts to read
    * more data at this point this is a bug in libpng.*/","-10.     * stream of IDATs will be read, until something other than an IDAT is
-9.     * encountered, and the file fields will be set for the chunk after the end
-8.     * of the stream of IDATs.
-7.     *
-6.     * For IEND the file::type field will be s",Useful
"/*Start the read_crc calculation with the chunk type, then read to the end
    * of the chunk data (without processing it in any way) to check that it is
    * all there and calculate the CRC.*/","-10.     * more data at this point this is a bug in libpng.
-9.     */
-8.    if (type == 0)
-7.       stop(file, UNEXPECTED_ERROR_CODE, ""read beyond IEND"");
-6.    if (file->global->verbose > 2)
-5.    {
-4.       fputs(""   "", stderr);
-3.       type_nam",Useful
/*do not read beyond IEND*/,"-3.       unsigned int nread = read_4(file, &file_crc);
-2.       if (nread == 4)
-1.       {

 /*do not read beyond IEND*/

1.          {
2.             png_uint_32 next_length;
3.             nread += read_4(file, &next_length);
4.             if (nread",Useful
"/*Adjust the read count back to the correct value for this
                   * chunk.*/","-9.          {
-8.             png_uint_32 next_length;
-7.             nread += read_4(file, &next_length);
-6.             if (nread == 8 && next_length <= 0x7fffffff)
-5.             {
-4.                png_uint_32 next_type;
-3.                nread ",Useful
"/*Control gets to here if the stream seems invalid or damaged in some
    * way.  Either there was a problem reading all the expected data (this
    * chunk's data, its CRC and the length and type of the next chunk) or the
    * next chunk length/type are invalid.  Notice that the cases that end up
    * here all correspond to cases that would otherwise terminate the read of
    * the PNG file.*/","nan


 /*Control gets to here if the stream seems invalid or damaged in some
    * way.  Either there was a problem reading all the expected data (this
    * chunk's data, its CRC and the length and type of the next chunk) or the
    * next chunk length/type are invalid.  Notice that the cases that end up
    * here all correspond to cases that would otherwise terminate the read of
    * the PNG file.*/

nan
",Useful
/*This returns a file* from a png_struct in an implementation specific way.*/,"-2.    sync_stream(file);
-1. }

 /*This returns a file* from a png_struct in an implementation specific way.*/

1. static struct file *get_control(png_const_structrp png_ptr);
2. static void PNGCBAPI
3. error_handler(png_structp png_ptr, png_const_charp ",Useful
"/*Read callback - this is where the work gets done to check the stream before
 * passing it to libpng*/","-10. {
-9.    stop(get_control(png_ptr),  LIBPNG_ERROR_CODE, message);
-8. }
-7. static void PNGCBAPI
-6. warning_handler(png_structp png_ptr, png_const_charp message)
-5. {
-4.    struct file *file = get_control(png_ptr);
-3.    if (file->global->warning",Useful
/*Return 'count' bytes to libpng in 'buffer'*/,"-2. static void PNGCBAPI
-1. read_callback(png_structp png_ptr, png_bytep buffer, size_t count)

 /*Return 'count' bytes to libpng in 'buffer'*/

1. {
2.    struct file *file = get_control(png_ptr);",Useful
"/*The callback always reads ahead by 8 bytes - the signature or chunk header
    * - these bytes are stored in chunk_length and chunk_type.  This block is
    * executed once for the signature and once for the first chunk right at the
    * start.*/","-2.    if (count == 0)
-1.       stop(file, UNEXPECTED_ERROR_CODE, ""read callback for 0 bytes"");
   /* The callback always reads ahead by 8 bytes - the signature or chunk header
    * - these bytes are stored in chunk_length and chunk_type.  This block is",Useful
"/*Else write it (this is the initialization of write_count, prior to
          * this it contains CLEAR garbage.)*/","-10.          (void)read_4(file, &file->type);
-9.       if (file->read_count < 8)
-8.       {
-7.          assert((file->status_code & TRUNCATED) != 0);
-6.          stop(file, READ_ERROR_CODE, ""not a PNG (too short)"");
-5.       }
-4.       if (file->st",Useful
"/*The first chunk must be a well formed IHDR (this could be relaxed to
          * use the checks in process_chunk, but that seems unnecessary.)*/","-5.          file->write_count = 0;
-4.       }
-3.       else
-2.       {
-1.          assert(file->state == STATE_CHUNKS);
         /* The first chunk must be a well formed IHDR (this could be relaxed to
          * use the checks in process_chunk, but ",Useful
/*The position of the data must be stored too*/,"-2.          if (file->length != 13 || file->type != png_IHDR)
-1.             stop(file, LIBPNG_ERROR_CODE, ""not a PNG (IHDR)"");

 /*The position of the data must be stored too*/

1.          getpos(file);
2.       }
3.    }",Useful
"/*Retrieve previous state (because the read callbacks are made pretty much
    * byte-by-byte in the sequential reader prior to 1.7).*/","-3.          getpos(file);
-2.       }
-1.    }
   /* Retrieve previous state (because the read callbacks are made pretty much
    * byte-by-byte in the sequential reader prior to 1.7).

 /*Retrieve previous state (because the read callbacks are made pret",Useful
"/*This is the signature case; for IDAT and other chunks these values will
       * be overwritten when read_chunk is called below.*/","-10.     * byte-by-byte in the sequential reader prior to 1.7).
-9.     */
-8.    chunk = file->chunk;
-7.    if (chunk != NULL)
-6.    {
-5.       length = chunk->chunk_length;
-4.       type = chunk->chunk_type;
-3.    }
-2.    else
-1.    {
      /* Th",Useful
"/*Complete the read of a chunk; as a side effect this also instantiates
       * a chunk control structure and sets the file length/type/data_pos fields
       * for the *NEXT* chunk header.
       *
       * NOTE: at an IDAT any following IDAT chunks will also be read and the
       * next_ fields will refer to the chunk after the last IDAT.
       *
       * NOTE: read_chunk only returns when it has read a chunk that must now be
       * written.*/","-6.       length = file->length;
-5.       type = file->type;
-4.    }
-3.    do
-2.    {
-1.       png_uint_32 b;
      /* Complete the read of a chunk; as a side effect this also instantiates
       * a chunk control structure and sets the file length/t",Useful
/*And start writing the new chunk.*/,"-2.          length = chunk->chunk_length;
-1.          type = chunk->chunk_type;

 /*And start writing the new chunk.*/

1.          file->write_count = 0;
2.       }",Useful
"/*The chunk_ fields describe a chunk that must be written, or hold the
       * signature.  Write the header first.  In the signature case this
       * rewrites the signature.*/","-2.          file->write_count = 0;
-1.       }
      /* The chunk_ fields describe a chunk that must be written, or hold the
       * signature.  Write the header first.  In the signature case this
       * rewrites the signature.

 /*The chunk_ fields d",Useful
"/*The header has been written.  If this is really the signature
             * that's all that is required and we can go to normal chunk
             * processing.*/","-10.       {
-9.          case 0: b = length >> 24; break;
-8.          case 1: b = length >> 16; break;
-7.          case 2: b = length >>  8; break;
-6.          case 3: b = length      ; break;
-5.          case 4: b = type >> 24; break;
-4.          c",Useful
"/*The signature has been written, the tail call to read_callback
                * below (it's just a goto to the start with a decent compiler)
                * will read the IHDR header ahead and validate it.*/","-2.             if (file->state == STATE_SIGNATURE)
-1.             {
               /* The signature has been written, the tail call to read_callback
                * below (it's just a goto to the start with a decent compiler)
                * will re",Useful
"/*Set up for write, notice that repositioning the input stream
                * is only necessary if something is to be read from it.  Also
                * notice that for the IDAT stream this must only happen once -
                * on the first IDAT - to get back to the start of the list and
                * this is done inside process_IDAT:*/","-6.                read_callback(png_ptr, buffer, count);
-5.                return;
-4.             }
-3.             else
-2.             {
-1.                assert(chunk != NULL);
               /* Set up for write, notice that repositioning the input",Useful
"/*NOTE: the arithmetic below overflows and gives a large positive
             * png_uint_32 value until the whole chunk data has been written.*/","-2.          default:
-1.             assert(chunk != NULL);
            /* NOTE: the arithmetic below overflows and gives a large positive
             * png_uint_32 value until the whole chunk data has been written.

 /*NOTE: the arithmetic below overfl",Useful
"/*Write the chunk data, normally this just comes from
                * the file.  The only exception is for that part of a
                * chunk which is zlib data and which must be rewritten,
                * and IDAT chunks which can be completely
                * reconstructed.*/","-2.             switch (file->write_count - length)
-1.             {
               /* Write the chunk data, normally this just comes from
                * the file.  The only exception is for that part of a
                * chunk which is zlib data an",Useful
"/*Read an IDAT byte from the input stream of IDAT chunks.
                      * Because the IDAT stream can be re-chunked this stream is
                      * held in the struct IDAT members.  The chunk members, in
                      * particular chunk_length (and therefore the length local)
                      * refer to the output chunk.*/","-10.                 * the file.  The only exception is for that part of a
-9.                 * chunk which is zlib data and which must be rewritten,
-8.                 * and IDAT chunks which can be completely
-7.                 * reconstructed.
-6.  ",Useful
"/*This is an internal error - read beyond the end of
                            * the pre-calculated stream.*/","-1.                            cur = cur->next;
                           /* This is an internal error - read beyond the end of
                            * the pre-calculated stream.

 /*This is an internal error - read beyond the end of
              ",Useful
"/*Zero length IDAT chunks are permitted, so the length
                         * here may be 0.*/","-7.                            if (cur == NULL || cur->count == 0)
-6.                               stop(file, UNEXPECTED_ERROR_CODE,
-5.                                  ""read beyond end of IDAT"");
-4.                            idat->idat_count = 0;
-3",Useful
/*And skip 12 bytes to the next chunk data*/,"-1.                         idat->idat_length = cur->lengths[idat->idat_count];

 /*And skip 12 bytes to the next chunk data*/

1.                         skip_12(file);
2.                      }",Useful
"/*The index is always that of the next byte, the rest of
                      * the information is always the current IDAT chunk and the
                      * current list.*/","-2.                         skip_12(file);
-1.                      }
                     /* The index is always that of the next byte, the rest of
                      * the information is always the current IDAT chunk and the
                      * c",Useful
/*If the byte must be rewritten handle that here*/,"-1.                   b = reread_byte(file);

 /*If the byte must be rewritten handle that here*/

1.                   if (chunk->rewrite_length > 0)
2.                   {
3.                      if (chunk->rewrite_offset > 0)
4.                        ",Useful
"/*The IDAT stream is written without a call to read_chunk
                   * until the end is reached.  rechunk_length() calculates the
                   * length of the output chunks.  Control gets to this point at
                   * the end of an *output* chunk - the length calculated by
                   * rechunk_length.  If this corresponds to the end of the
                   * input stream stop writing IDAT chunks, otherwise continue.*/","-8.                   b = chunk->write_crc;
-7.                   if (file->global->verbose > 2)
-6.                   {
-5.                      fputs(""   "", stderr);
-4.                      type_name(type, stderr);
-3.                      fprintf(stde",Useful
"/*Write another IDAT chunk.  Call rechunk_length to
                      * calculate the length required.*/",#NAME?,Useful
"/*Entered at the end of a non-IDAT chunk and at the end of
                      * the IDAT stream.  The rewrite should have been cleared.*/","-3.                   }
-2.                   else
-1.                   {
                     /* Entered at the end of a non-IDAT chunk and at the end of
                      * the IDAT stream.  The rewrite should have been cleared.

 /*Entered at the ",Useful
"/*This is the last byte so reset chunk_read for the next
                      * chunk and move the input file to the position after the
                      * *next* chunk header if required.*/","-2.                      if (chunk->rewrite_length > 0 || chunk->rewrite_offset > 0)
-1.                         stop(file, UNEXPECTED_ERROR_CODE, ""pending rewrite"");
                     /* This is the last byte so reset chunk_read for the next
         ",Useful
"/*Bundle the file and an uninitialized chunk and IDAT control structure
 * together to allow implementation of the chunk/IDAT allocate routine.*/","-3.    }
-2.    while (count > 0);
-1. }
/* Bundle the file and an uninitialized chunk and IDAT control structure
 * together to allow implementation of the chunk/IDAT allocate routine.

 /*Bundle the file and an uninitialized chunk and IDAT control struc",Useful
"/*This just returns the (file*).  The chunk and idat control structures
    * don't always exist.*/","-10.    struct IDAT  idat;
-9. };
-8. static int
-7. control_end(struct control *control)
-6. {
-5.    return file_end(&control->file);
-4. }
-3. static struct file *
-2. get_control(png_const_structrp png_ptr)
-1. {
   /* This just returns the (file*).  ",Useful
"/*This wraps file_init(&control::file) and simply returns the result from
    * file_init.*/","-8.    {
-7.       assert(file->chunk == NULL);
-6.       chunk_init(&control->chunk, file);
-5.    }
-4. }
-3. static int
-2. control_init(struct control *control, struct global *global,
-1.    const char *file_name, const char *out_name)
   /* This wrap",Useful
"/*Read a PNG, return 0 on success else an error (status) code; a bit mask as
    * defined for file::status_code as above.*/","-6. {
-5.    return file_init(&control->file, global, file_name, out_name, control,
-4.       allocate);
-3. }
-2. static int
-1. read_png(struct control *control)
   /* Read a PNG, return 0 on success else an error (status) code; a bit mask as
    * defi",Useful
"/*Remove any limits on the size of PNG files that can be read,
          * without this we may reject files based on built-in safety
          * limits.*/","-8.       log_error(&control->file, LIBPNG_ERROR_CODE, ""OOM allocating png_struct"");
-7.       control->file.status_code |= INTERNAL_ERROR;
-6.       return LIBPNG_ERROR_CODE;
-5.    }
-4.    rc = setjmp(control->file.jmpbuf);
-3.    if (rc == 0)
-2.    {",Useful
"/*NOTE: this skips asking libpng to return either version of
            * the image row, but libpng still reads the rows.*/","-10.          fprintf(stderr, "" INFO\n"");
-9.       png_read_info(png_ptr, info_ptr);
-8.       {
-7.         png_uint_32 height = png_get_image_height(png_ptr, info_ptr);
-6.         int passes = png_set_interlace_handling(png_ptr);
-5.         int pass;",Useful
/*Make sure to read to the end of the file:*/,"-6.            while (y-- > 0)
-5.               png_read_row(png_ptr, NULL, NULL);
-4.         }
-3.       }
-2.       if (control->file.global->verbose)
-1.          fprintf(stderr, "" END\n"");

 /*Make sure to read to the end of the file:*/

1.       pn",Useful
"/*Although control_init can return a failure code the structure is always
    * initialized, so control_end can be used to accumulate any status codes.*/","-10.    return rc;
-9. }
-8. static int
-7. one_file(struct global *global, const char *file_name, const char *out_name)
-6. {
-5.    int rc;
-4.    struct control control;
-3.    if (global->verbose)
-2.       fprintf(stderr, ""FILE %s -> %s\n"", file_name",Useful
"/*ANSI C-90 limits strings to 509 characters, so use a string array:*/","-10.     */
-9.    rc = control_init(&control, global, file_name, out_name);
-8.    if (rc == 0)
-7.       rc = read_png(&control);
-6.    rc |= control_end(&control);
-5.    return rc;
-4. }
-3. static void
-2. usage(const char *prog)
-1. {

 /*ANSI C-90",Useful
/*The caller can turn off the warning by passing NULL.*/,"-5. png_get_fixed_point(png_structrp png_ptr, png_const_bytep buf)
-4. {
-3.    png_uint_32 uval = png_get_uint_32(buf);
-2.    if (uval <= PNG_UINT_31_MAX)

 /*The caller can turn off the warning by passing NULL.*/

1.    if (png_ptr != NULL)
2.       pn",Useful
"/*NOTE: the read macros will obscure these definitions, so that if
 * PNG_USE_READ_MACROS is set the library will not use them internally,
 * but the APIs will still be available externally.
 *
 * The parentheses around ""PNGAPI function_name"" in the following three
 * functions are necessary because they allow the macros to co-exist with
 * these (unused but exported) functions.*/","-6.    if (png_ptr != NULL)
-5.       png_warning(png_ptr, ""PNG fixed point integer out of range"");
-4.    return PNG_FIXED_ERROR;
-3. }
-2. #endif
-1. #ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED
/* NOTE: the read macros will obscure these definitions, so tha",Useful
"/*The following has to be safe; this function only gets called on PNG data
    * and if we get here that data is invalid.  0 is the most safe value and
    * if not then an attacker would surely just generate a PNG with 0 instead.*/","-1.       return -(png_int_32)uval;
   /* The following has to be safe; this function only gets called on PNG data
    * and if we get here that data is invalid.  0 is the most safe value and
    * if not then an attacker would surely just generate a PNG ",Useful
"/*Read the chunk header (length + type name).
 * Put the type name into png_ptr->chunk_name, and return the length.*/","-10.    {
-9.       if (num_checked < 4 &&
-8.           png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))
-7.          png_error(png_ptr, ""Not a PNG file"");
-6.       else
-5.          png_error(png_ptr, ""PNG file corrupted by ASCII conver",Useful
"/*Read the length and the chunk name.
    * This must be performed in a single I/O call.*/","-7. png_read_chunk_header(png_structrp png_ptr)
-6. {
-5.    png_byte buf[8];
-4.    png_uint_32 length;
-3. #ifdef PNG_IO_STATE_SUPPORTED
-2.    png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;
-1. #endif
   /* Read the length and the chunk name.
 ",Useful
/*Check to see if chunk name is valid.*/,"-2.    png_reset_crc(png_ptr);
-1.    png_calculate_crc(png_ptr, buf + 4, 4);

 /*Check to see if chunk name is valid.*/

1.    png_check_chunk_name(png_ptr, png_ptr->chunk_name);",Useful
/*Check for too-large chunk length*/,"-1.    png_check_chunk_name(png_ptr, png_ptr->chunk_name);

 /*Check for too-large chunk length*/

1.    png_check_chunk_length(png_ptr, length);
2. #ifdef PNG_IO_STATE_SUPPORTED
3.    png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;
4. #endif
5.  ",Useful
"/*Optionally skip data and then check the CRC.  Depending on whether we
 * are reading an ancillary or critical chunk, and how the program has set
 * things up, we may calculate the CRC on the data and print a message.
 * Returns '1' if there was a CRC error, '0' otherwise.*/","-7. png_crc_read(png_structrp png_ptr, png_bytep buf, png_uint_32 length)
-6. {
-5.    if (png_ptr == NULL)
-4.       return;
-3.    png_read_data(png_ptr, buf, length);
-2.    png_calculate_crc(png_ptr, buf, length);
-1. }
/* Optionally skip data and the",Useful
"/*The size of the local buffer for inflate is a good guess as to a
    * reasonable size to use for buffering reads from the application.*/","-2. png_crc_finish(png_structrp png_ptr, png_uint_32 skip)
-1. {
   /* The size of the local buffer for inflate is a good guess as to a
    * reasonable size to use for buffering reads from the application.

 /*The size of the local buffer for inflate is ",Useful
"/*Compare the CRC stored in the PNG file with that calculated by libpng from
 * the data it has read thus far.*/","-10.           (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE) != 0)
-9.       {
-8.          png_chunk_warning(png_ptr, ""CRC error"");
-7.       }
-6.       else
-5.          png_chunk_error(png_ptr, ""CRC error"");
-4.       return (1);
-3.    }
-2.    return",Useful
"/*Manage the read buffer; this simply reallocates the buffer if it is not small
 * enough (or if it is not allocated).  The routine returns a pointer to the
 * buffer; if an error occurs and 'warn' is set the routine returns NULL, else
 * it will call png_error (via png_malloc) on failure.  (warn == 2 means
 * 'silent').*/","-10.       crc = png_get_uint_32(crc_bytes);
-9.       return ((int)(crc != png_ptr->crc));
-8.    }
-7.    else
-6.       return (0);
-5. }
-4. #if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||\
-3.     defined(PNG_READ_pCAL_SUP",Useful
"/*png_inflate_claim: claim the zstream for some nefarious purpose that involves
 * decompression.  Returns Z_OK on success, else a zlib error code.  It checks
 * the owner but, in final release builds, just issues a warning if some other
 * chunk apparently owns the stream.  Prior to release it does a png_error.*/","
/* png_inflate_claim: claim the zstream for some nefarious purpose that involves
 * decompression.  Returns Z_OK on success, else a zlib error code.  It checks
 * the owner but, in final release builds, just issues a warning if some other
 * chunk apparently owns the stream.  Prior to release it does a png_error.



 /*png_inflate_claim: claim the zstream for some nefarious purpose that involves
 * decompression.  Returns Z_OK on success, else a zlib error code.  It checks
 * the owner but, in final release builds, just issues a warning if some other
 * chunk apparently owns the stream.  Prior to release it does a png_error.*/

1.  */
2. static int
3. png_inflate_claim(png_structrp png_ptr, png_uint_32 owner)
4. {
5.    if (png_ptr->zowner != 0)
6.    {
7.       char msg[64];
8.       PNG_STRING_FROM_CHUNK(msg, png_ptr->zowner);
9.       /* So the message that results is ""<chunk> using zstream""; this is an
10.        * internal error, but is very useful for debugging.  i18n requirements",Useful
"/*So the message that results is ""<chunk> using zstream""; this is an
       * internal error, but is very useful for debugging.  i18n requirements
       * are minimal.*/","-10.  * the owner but, in final release builds, just issues a warning if some other
-9.  * chunk apparently owns the stream.  Prior to release it does a png_error.
-8.  */
-7. static int
-6. png_inflate_claim(png_structrp png_ptr, png_uint_32 owner)
-5. {",Useful
"/*Implementation note: unlike 'png_deflate_claim' this internal function
    * does not take the size of the data as an argument.  Some efficiency could
    * be gained by using this when it is known *if* the zlib stream itself does
    * not record the number; however, this is an illusion: the original writer
    * of the PNG may have selected a lower window size, and we really must
    * follow that because, for systems with with limited capabilities, we
    * would otherwise reject the application's attempts to use a smaller window
    * size (zlib doesn't have an interface to say ""this or lower""!).
    *
    * inflateReset2 was added to zlib 1.2.4; before this the window could not be
    * reset, therefore it is necessary to always allocate the maximum window
    * size with earlier zlibs just in case later compressed chunks need it.*/","-10.        * are minimal.
-9.        */
-8.       (void)png_safecat(msg, (sizeof msg), 4, "" using zstream"");
-7. #if PNG_RELEASE_BUILD
-6.       png_chunk_warning(png_ptr, msg);
-5.       png_ptr->zowner = 0;
-4. #else
-3.       png_chunk_error(png_ptr, ",Useful
/*zlib return code*/,"-10.     * of the PNG may have selected a lower window size, and we really must
-9.     * follow that because, for systems with with limited capabilities, we
-8.     * would otherwise reject the application's attempts to use a smaller window
-7.     * siz",Useful
"/*Set this for safety, just in case the previous owner left pointers to
       * memory allocations.*/","
      /* Set this for safety, just in case the previous owner left pointers to
       * memory allocations.



 /*Set this for safety, just in case the previous owner left pointers to
       * memory allocations.*/

1.        */
2.       png_ptr->zstream.next_in = NULL;
3.       png_ptr->zstream.avail_in = 0;
4.       png_ptr->zstream.next_out = NULL;
5.       png_ptr->zstream.avail_out = 0;
6.       if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
7.       {
8. #if ZLIB_VERNUM >= 0x1240
9.          ret = inflateReset2(&png_ptr->zstream, window_bits);
10. #else",Useful
/*Turn off validation of the ADLER32 checksum in IDAT chunks*/,"-10.          ret = inflateInit2(&png_ptr->zstream, window_bits);
-9. #else
-8.          ret = inflateInit(&png_ptr->zstream);
-7. #endif
-6.          if (ret == Z_OK)
-5.             png_ptr->flags |= PNG_FLAG_ZSTREAM_INITIALIZED;
-4.       }
-3. #if ZLI",Useful
"/*Handle the start of the inflate stream if we called inflateInit2(strm,0);
 * in this case some zlib versions skip validation of the CINFO field and, in
 * certain circumstances, libpng may end up displaying an invalid image, in
 * contrast to implementations that call zlib in the normal way (e.g. libpng
 * 1.5).*/","-10.          png_ptr->zowner = owner;
-9.       else
-8.          png_zstream_error(png_ptr, ret);
-7.       return ret;
-6.    }
-5. #ifdef window_bits
-4. # undef window_bits
-3. #endif
-2. }
-1. #if ZLIB_VERNUM >= 0x1240
/* Handle the start of the inf",Useful
"/*png_inflate now returns zlib error codes including Z_OK and Z_STREAM_END to
 * allow the caller to do multiple calls if required.  If the 'finish' flag is
 * set Z_FINISH will be passed to the final inflate() call and Z_STREAM_END must
 * be returned or there has been a problem, otherwise Z_SYNC_FLUSH is used and
 * Z_OK or Z_STREAM_END will be returned on success.
 *
 * The input and output sizes are updated to the actual amounts of data consumed
 * or written, not the amount available (as in a z_stream).  The data pointers
 * are not changed, so the next input is (data+input_size) and the next
 * available output is (output+output_size).*/","-2. #ifdef PNG_READ_COMPRESSED_TEXT_SUPPORTED
-1. #if defined(PNG_READ_zTXt_SUPPORTED) || defined (PNG_READ_iTXt_SUPPORTED)
/* png_inflate now returns zlib error codes including Z_OK and Z_STREAM_END to
 * allow the caller to do multiple calls if required",Useful
/*avail_in and avail_out are set below from 'size'*/,"-1.       png_ptr->zstream.next_in = PNGZ_INPUT_CAST(input);

 /*avail_in and avail_out are set below from 'size'*/

1.       png_ptr->zstream.avail_in = 0;
2.       png_ptr->zstream.avail_out = 0;",Useful
"/*Read directly into the output if it is available (this is set to
       * a local buffer below if output is NULL).*/","-2.       png_ptr->zstream.avail_in = 0;
-1.       png_ptr->zstream.avail_out = 0;
      /* Read directly into the output if it is available (this is set to
       * a local buffer below if output is NULL).

 /*Read directly into the output if it is avail",Useful
"/*The setting of 'avail_in' used to be outside the loop; by setting it
          * inside it is possible to chunk the input to zlib and simply rely on
          * zlib to advance the 'next_in' pointer.  This allows arbitrary
          * amounts of data to be passed through zlib at the unavoidable cost of
          * requiring a window save (memcpy of up to 32768 output bytes)
          * every ZLIB_IO_MAX input bytes.*/","/* The setting of 'avail_in' used to be outside the loop; by setting it
          * inside it is possible to chunk the input to zlib and simply rely on
          * zlib to advance the 'next_in' pointer.  This allows arbitrary
          * amounts of data to be passed through zlib at the unavoidable cost of
          * requiring a window save (memcpy of up to 32768 output bytes)
          * every ZLIB_IO_MAX input bytes.

 /*The setting of 'avail_in' used to be outside the loop; by setting it
          * inside it is possible to chunk the input to zlib and simply rely on
          * zlib to advance the 'next_in' pointer.  This allows arbitrary
          * amounts of data to be passed through zlib at the unavoidable cost of
          * requiring a window save (memcpy of up to 32768 output bytes)
          * every ZLIB_IO_MAX input bytes.*/

1.           */",Useful
/*not written last time*/,"-3.          avail_in -= avail;
-2.          png_ptr->zstream.avail_in = avail;

 /*not written last time*/

111",Useful
"/*Reset the output buffer each time round if output is NULL and
             * make available the full buffer, up to 'remaining_space'*/","-2.          if (output == NULL)
-1.          {
            /* Reset the output buffer each time round if output is NULL and
             * make available the full buffer, up to 'remaining_space'

 /*Reset the output buffer each time round if output is NU",Useful
"/*In fact 'avail_out' may be 0 at this point, that happens at the end
          * of the read when the final LZ end code was not passed at the end of
          * the previous chunk of input data.  Tell zlib if we have reached the
          * end of the output buffer.*/","/* In fact 'avail_out' may be 0 at this point, that happens at the end
          * of the read when the final LZ end code was not passed at the end of
          * the previous chunk of input data.  Tell zlib if we have reached the
          * end of the output buffer.

 /*In fact 'avail_out' may be 0 at this point, that happens at the end
          * of the read when the final LZ end code was not passed at the end of
          * the previous chunk of input data.  Tell zlib if we have reached the
          * end of the output buffer.*/

1.           */
2.          ret = PNG_INFLATE(png_ptr, avail_out > 0 ? Z_NO_FLUSH :
3.              (finish ? Z_FINISH : Z_SYNC_FLUSH));
4.       } while (ret == Z_OK);",Useful
/*For safety kill the local buffer pointer now*/,"-3.          ret = PNG_INFLATE(png_ptr, avail_out > 0 ? Z_NO_FLUSH :
-2.              (finish ? Z_FINISH : Z_SYNC_FLUSH));
-1.       } while (ret == Z_OK);

 /*For safety kill the local buffer pointer now*/

1.       if (output == NULL)
2.          png_pt",Useful
/*Claw back the 'size' and 'remaining_space' byte counts.*/,"-2.       if (output == NULL)
-1.          png_ptr->zstream.next_out = NULL;

 /*Claw back the 'size' and 'remaining_space' byte counts.*/

1.       avail_in += png_ptr->zstream.avail_in;
2.       avail_out += png_ptr->zstream.avail_out;",Useful
"/*Update the input and output sizes; the updated values are the amount
       * consumed or written, effectively the inverse of what zlib uses.*/","-2.       avail_in += png_ptr->zstream.avail_in;
-1.       avail_out += png_ptr->zstream.avail_out;
      /* Update the input and output sizes; the updated values are the amount
       * consumed or written, effectively the inverse of what zlib uses.

 /*",Useful
"/*This is a bad internal error.  The recovery assigns to the zstream msg
       * pointer, which is not owned by the caller, but this is safe; it's only
       * used on errors!*/","-5.       png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2.    else
-1.    {
      /* This is a bad internal error.  The recovery assigns to the zstream msg
       * pointer, which is not owned by the caller, but this is safe; it's only
",Useful
"/** Decompress trailing data in a chunk.  The assumption is that read_buffer
 * points at an allocated area holding the contents of a chunk with a
 * trailing compressed part.  What we get back is an allocated area
 * holding the original prefix part and an uncompressed version of the
 * trailing part (the malloc area passed in is freed).*/","-5.       png_ptr->zstream.msg = PNGZ_MSG_CAST(""zstream unclaimed"");
-4.       return Z_STREAM_ERROR;
-3.    }
-2. }
-1. /*
 * Decompress trailing data in a chunk.  The assumption is that read_buffer
 * points at an allocated area holding the contents of ",Useful
/*must be initialized to the maximum!*/,"-3. static int
-2. png_decompress_chunk(png_structrp png_ptr,
-1.     png_uint_32 chunklength, png_uint_32 prefix_size,

 /*must be initialized to the maximum!*/

111",Useful
/*add a '\0' to the end of the uncompressed data*/,#NAME?,Useful
"/*TODO: implement different limits for different types of chunk.
    *
    * The caller supplies *newlength set to the maximum length of the
    * uncompressed data, but this routine allocates space for the prefix and
    * maybe a '\0' terminator too.  We have to assume that 'prefix_size' is
    * limited only by the maximum chunk size.*/","-1. {
   /* TODO: implement different limits for different types of chunk.
    *
    * The caller supplies *newlength set to the maximum length of the
    * uncompressed data, but this routine allocates space for the prefix and
    * maybe a '\0' terminat",Useful
"/*Use 'inflateReset' here, not 'inflateReset2' because this
             * preserves the previously decided window size (otherwise it would
             * be necessary to store the previous window size.)  In practice
             * this doesn't matter anyway, because png_inflate will call inflate
             * with Z_FINISH in almost all cases, so the window will not be
             * maintained.*/","-2.          if (ret == Z_STREAM_END)
-1.          {
            /* Use 'inflateReset' here, not 'inflateReset2' because this
             * preserves the previously decided window size (otherwise it would
             * be necessary to store the previous",Useful
"/*The size changed on the second read, there can be no
                         * guarantee that anything is correct at this point.
                         * The 'msg' pointer has been set to ""unexpected end of
                         * LZ stream"", which is fine, but return an error code
                         * that the caller won't accept.*/","-4.                         }
-3.                      }
-2.                      else
-1.                      {
                        /* The size changed on the second read, there can be no
                         * guarantee that anything is correct",Useful
"/*Free the text pointer (this is the old read_buffer on
                   * success)*/","
                  /* Free the text pointer (this is the old read_buffer on
                   * success)



 /*Free the text pointer (this is the old read_buffer on
                   * success)*/

1.                    */
2.                   png_free(png_ptr, text);",Useful
"/*This really is very benign, but it's still an error because
                   * the extra space may otherwise be used as a Trojan Horse.*/","-1.                   png_free(png_ptr, text);
                  /* This really is very benign, but it's still an error because
                   * the extra space may otherwise be used as a Trojan Horse.

 /*This really is very benign, but it's still an",Useful
/*Out of memory allocating the buffer*/,"-6.                   if (ret == Z_STREAM_END &&
-5.                       chunklength - prefix_size != lzsize)
-4.                      png_chunk_benign_error(png_ptr, ""extra compressed data"");
-3.                }
-2.                else
-1.            ",Useful
"/*inflateReset failed, store the error message*/","-6.                   ret = Z_MEM_ERROR;
-5.                   png_zstream_error(png_ptr, Z_MEM_ERROR);
-4.                }
-3.             }
-2.             else
-1.             {

 /*inflateReset failed, store the error message*/

111",Useful
"/*Perform a partial read and decompress, producing 'avail_out' bytes and
 * reading from the current chunk as required.*/","-1. #ifdef PNG_READ_iCCP_SUPPORTED
/* Perform a partial read and decompress, producing 'avail_out' bytes and
 * reading from the current chunk as required.

 /*Perform a partial read and decompress, producing 'avail_out' bytes and
 * reading from the curr",Useful
"/*Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all
          * the available output is produced; this allows reading of truncated
          * streams.*/","-10.             png_ptr->zstream.avail_in = read_size;
-9.          }
-8.          if (png_ptr->zstream.avail_out == 0)
-7.          {
-6.             uInt avail = ZLIB_IO_MAX;
-5.             if (avail > *out_size)
-4.                avail = (uInt)*out_",Useful
/*Ensure the error message pointer is always set:*/,"-6.          ret = PNG_INFLATE(png_ptr, *chunk_bytes > 0 ?
-5.              Z_NO_FLUSH : (finish ? Z_FINISH : Z_SYNC_FLUSH));
-4.       }
-3.       while (ret == Z_OK && (*out_size > 0 || png_ptr->zstream.avail_out > 0));
-2.       *out_size += png_ptr->z",Useful
"/*Moved to before the 'after IDAT' check below because otherwise duplicate
    * PLTE chunks are potentially ignored (the spec says there shall not be more
    * than one PLTE, the error is not treated as benign, so this check trumps
    * the requirement that PLTE appears before IDAT.)*/","-10. png_handle_PLTE(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
-9. {
-8.    png_color palette[PNG_MAX_PALETTE_LENGTH];
-7.    int max_palette_length, num, i;
-6. #ifdef PNG_POINTER_INDEXING_SUPPORTED
-5.    png_colorp pal_ptr;
-4. #en",Useful
"/*This is benign because the non-benign error happened before, when an
       * IDAT was encountered in a color-mapped image with no PLTE.*/","-4.    else if ((png_ptr->mode & PNG_HAVE_PLTE) != 0)
-3.       png_chunk_error(png_ptr, ""duplicate"");
-2.    else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
-1.    {
      /* This is benign because the non-benign error happened before, when an
       * ID",Useful
"/*If the palette has 256 or fewer entries but is too large for the bit
    * depth, we don't issue an error, to preserve the behavior of previous
    * libpng versions. We silently truncate the unused extra palette entries
    * here.*/","-1.    num = (int)length / 3;
   /* If the palette has 256 or fewer entries but is too large for the bit
    * depth, we don't issue an error, to preserve the behavior of previous
    * libpng versions. We silently truncate the unused extra palette entrie",Useful
"/*If we actually need the PLTE chunk (ie for a paletted image), we do
    * whatever the normal CRC configuration tells us.  However, if we
    * have an RGB image, the PLTE can be considered ancillary, so
    * we will act as though it is.*/","-5.       palette[i].red = buf[0];
-4.       palette[i].green = buf[1];
-3.       palette[i].blue = buf[2];
-2.    }
-1. #endif
   /* If we actually need the PLTE chunk (ie for a paletted image), we do
    * whatever the normal CRC configuration tells us.",Useful
"/*If we don't want to use the data from an ancillary chunk,
       * we have two options: an error abort, or a warning and we
       * ignore the data in this chunk (which should be OK, since
       * it's considered ancillary for a RGB or RGBA image).
       *
       * IMPLEMENTATION NOTE: this is only here because png_crc_finish uses the
       * chunk type to determine whether to check the ancillary or the critical
       * flags.*/","-1.    {
      /* If we don't want to use the data from an ancillary chunk,
       * we have two options: an error abort, or a warning and we
       * ignore the data in this chunk (which should be OK, since
       * it's considered ancillary for a RGB or",Useful
"/*TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its
    * own copy of the palette.  This has the side effect that when png_start_row
    * is called (this happens after any call to png_read_update_info) the
    * info_ptr palette gets changed.  This is extremely unexpected and
    * confusing.
    *
    * Fix this by not sharing the palette in this way.*/","-4.       else if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0)
-3.          png_chunk_warning(png_ptr, ""CRC error"");
-2.    }
-1. #endif
   /* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its
    * own copy of the palet",Useful
"/*The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before
    * IDAT.  Prior to 1.6.0 this was not checked; instead the code merely
    * checked the apparent validity of a tRNS chunk inserted before PLTE on a
    * palette PNG.  1.6.0 attempts to rigorously follow the standard and
    * therefore does a benign error if the erroneous condition is detected *and*
    * cancels the tRNS if the benign error returns.  The alternative is to
    * amend the standard since it would be rather hypocritical of the standards
    * maintainers to ignore it.*/","-1.    png_set_PLTE(png_ptr, info_ptr, palette, num);
   /* The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before
    * IDAT.  Prior to 1.6.0 this was not checked; instead the code merely
    * checked the apparent validity of a tRNS c",Useful
"/*Cancel this because otherwise it would be used if the transforms
       * require it.  Don't cancel the 'valid' flag because this would prevent
       * detection of duplicate chunks.*/","-10.     * palette PNG.  1.6.0 attempts to rigorously follow the standard and
-9.     * therefore does a benign error if the erroneous condition is detected *and*
-8.     * cancels the tRNS if the benign error returns.  The alternative is to
-7.     * ame",Useful
/*If a colorspace error has already been output skip this chunk*/,"-10.        xy.redx   == PNG_FIXED_ERROR ||
-9.        xy.redy   == PNG_FIXED_ERROR ||
-8.        xy.greenx == PNG_FIXED_ERROR ||
-7.        xy.greeny == PNG_FIXED_ERROR ||
-6.        xy.bluex  == PNG_FIXED_ERROR ||
-5.        xy.bluey  == PNG_FIXED_ERROR",Useful
/*If a colorspace error has already been output skip this chunk*/,"-10.        xy.redx   == PNG_FIXED_ERROR ||
-9.        xy.redy   == PNG_FIXED_ERROR ||
-8.        xy.greenx == PNG_FIXED_ERROR ||
-7.        xy.greeny == PNG_FIXED_ERROR ||
-6.        xy.bluex  == PNG_FIXED_ERROR ||
-5.        xy.bluey  == PNG_FIXED_ERROR",Useful
"/*error message output, or no error*/","-1. {

 /*error message output, or no error*/

111",Useful
"/*Consistent with all the above colorspace handling an obviously *invalid*
    * chunk is just ignored, so does not invalidate the color space.  An
    * alternative is to set the 'invalid' flags at the start of this routine
    * and only clear them in they were not set before and all the tests pass.*/","-9.    png_debug(1, ""in png_handle_iCCP"");
-8.    if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
-7.       png_chunk_error(png_ptr, ""missing IHDR"");
-6.    else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)
-5.    {
-4.       png_crc_finish(png_ptr",Useful
"/*The keyword must be at least one character and there is a
    * terminator (0) byte and the compression method byte, and the
    * 'zlib' datastream is at least 11 bytes.*/","/* The keyword must be at least one character and there is a
    * terminator (0) byte and the compression method byte, and the
    * 'zlib' datastream is at least 11 bytes.

 /*The keyword must be at least one character and there is a
    * terminator (0) byte and the compression method byte, and the
    * 'zlib' datastream is at least 11 bytes.*/

1.     */
2.    if (length < 14)
3.    {
4.       png_crc_finish(png_ptr, length);
5.       png_chunk_benign_error(png_ptr, ""too short"");
6.       return;
7.    }",Useful
/*If a colorspace error has already been output skip this chunk*/,"-10.        xy.redx   == PNG_FIXED_ERROR ||
-9.        xy.redy   == PNG_FIXED_ERROR ||
-8.        xy.greenx == PNG_FIXED_ERROR ||
-7.        xy.greeny == PNG_FIXED_ERROR ||
-6.        xy.bluex  == PNG_FIXED_ERROR ||
-5.        xy.bluey  == PNG_FIXED_ERROR",Useful
"/*Find the keyword; the keyword plus separator and compression method
       * bytes can be at most 81 characters long.*/","-4.    if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) == 0)
-3.    {
-2.       uInt read_length, keyword_length;
-1.       char keyword[81];
      /* Find the keyword; the keyword plus separator and compression method
       * bytes can be a",Useful
"/*The minimum 'zlib' stream is assumed to be just the 2 byte header,
       * 5 bytes minimum 'deflate' stream, and the 4 byte checksum.*/","-4.       if (read_length > length)
-3.          read_length = (uInt)length;
-2.       png_crc_read(png_ptr, (png_bytep)keyword, read_length);
-1.       length -= read_length;
      /* The minimum 'zlib' stream is assumed to be just the 2 byte header,
   ",Useful
/*TODO: make the keyword checking common*/,"-10.       if (length < 11)
-9.       {
-8.          png_crc_finish(png_ptr, length);
-7.          png_chunk_benign_error(png_ptr, ""too short"");
-6.          return;
-5.       }
-4.       keyword_length = 0;
-3.       while (keyword_length < 80 && keyword",Useful
"/*We only understand '0' compression - deflate - so if we get a
          * different value we can't safely decode the chunk.*/","-2.       if (keyword_length >= 1 && keyword_length <= 79)
-1.       {
         /* We only understand '0' compression - deflate - so if we get a
          * different value we can't safely decode the chunk.

 /*We only understand '0' compression - deflate",Useful
/*We have the ICC profile header; do the basic header checks.*/,"-2.                if (size == 0)
-1.                {
                  /* We have the ICC profile header; do the basic header checks.

 /*We have the ICC profile header; do the basic header checks.*/

1.                    */
2.                   const ",Useful
"/*The length is apparently ok, so we can check the 132
                      * byte header.*/","-5.                   const png_uint_32 profile_length =
-4.                      png_get_uint_32(profile_header);
-3.                   if (png_icc_check_length(png_ptr, &png_ptr->colorspace,
-2.                       keyword, profile_length) != 0)
-1.  ",Useful
"/*Now read the tag table; a variable size buffer is
                         * needed at this point, allocate one for the whole
                         * profile.  The header check has already validated
                         * that none of this stuff will overflow.*/","-4.                      if (png_icc_check_header(png_ptr, &png_ptr->colorspace,
-3.                          keyword, profile_length, profile_header,
-2.                          png_ptr->color_type) != 0)
-1.                      {
                     ",Useful
"/*Still expect a buffer error because we expect
                            * there to be some tag data!*/","-8.                         if (profile != NULL)
-7.                         {
-6.                            memcpy(profile, profile_header,
-5.                                (sizeof profile_header));
-4.                            size = 12 * tag_count",Useful
"/*The profile has been validated for basic
                                  * security issues, so read the whole thing in.*/","-6.                            if (size == 0)
-5.                            {
-4.                               if (png_icc_check_tag_table(png_ptr,
-3.                                   &png_ptr->colorspace, keyword, profile_length,
-2.                 ",Useful
"/*else the profile remains in the read
                                     * buffer which gets reused for subsequent
                                     * chunks.*/","-10.                                           info_ptr->free_me |= PNG_FREE_ICCP;
-9.                                           info_ptr->valid |= PNG_INFO_iCCP;
-8.                                        }
-7.                                        else",Useful
/*Note: this does not properly handle chunks that are > 64K under DOS*/,"-1. png_handle_sPLT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)

 /*Note: this does not properly handle chunks that are > 64K under DOS*/

1. {
2.    png_bytep entry_start, buffer;
3.    png_sPLT_t new_palette;
4.    png_sPLT_entryp pp;",Useful
"/*WARNING: this may break if size_t is less than 32 bits; it is assumed
    * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a
    * potential breakage point if the types in pngconf.h aren't exactly right.*/","-6.    if (buffer == NULL)
-5.    {
-4.       png_crc_finish(png_ptr, length);
-3.       png_chunk_benign_error(png_ptr, ""out of memory"");
-2.       return;
-1.    }
   /* WARNING: this may break if size_t is less than 32 bits; it is assumed
    * that th",Useful
/*Empty loop to find end of name*/,"-5.    png_crc_read(png_ptr, buffer, length);
-4.    if (png_crc_finish(png_ptr, skip) != 0)
-3.       return;
-2.    buffer[length] = 0;
-1.    for (entry_start = buffer; *entry_start; entry_start++)

 /*Empty loop to find end of name*/

1.    ++entry_st",Useful
"/*TODO: this is a horrible side effect in the palette case because the
    * png_struct ends up with a pointer to the tRNS buffer owned by the
    * png_info.  Fix this.*/","-10.    {
-9.       png_crc_finish(png_ptr, length);
-8.       png_chunk_benign_error(png_ptr, ""invalid with alpha channel"");
-7.       return;
-6.    }
-5.    if (png_crc_finish(png_ptr, 0) != 0)
-4.    {
-3.       png_ptr->num_trans = 0;
-2.       retur",Useful
"/*We convert the index value into RGB components so that we can allow
    * arbitrary RGB values for background when we have transparency, and
    * so it is easy to determine the RGB values of the background color
    * from the info_ptr struct.*/","-10.       truelen = 2;
-9.    if (length != truelen)
-8.    {
-7.       png_crc_finish(png_ptr, length);
-6.       png_chunk_benign_error(png_ptr, ""invalid"");
-5.       return;
-4.    }
-3.    png_crc_read(png_ptr, buf, truelen);
-2.    if (png_crc_finis",Useful
/*Null terminate the last string*/,"-9.    if (buffer == NULL)
-8.    {
-7.       png_crc_finish(png_ptr, length);
-6.       png_chunk_benign_error(png_ptr, ""out of memory"");
-5.       return;
-4.    }
-3.    png_crc_read(png_ptr, buffer, length);
-2.    if (png_crc_finish(png_ptr, 0) != 0)",Useful
"/*We need to have at least 12 bytes after the purpose string
    * in order to get the parameter information.*/","-1.    endptr = buffer + length;
   /* We need to have at least 12 bytes after the purpose string
    * in order to get the parameter information.

 /*We need to have at least 12 bytes after the purpose string
    * in order to get the parameter informati",Useful
"/*Check that we have the right number of parameters for known
    * equation types.*/","-10.       png_chunk_benign_error(png_ptr, ""invalid"");
-9.       return;
-8.    }
-7.    png_debug(3, ""Reading pCAL X0, X1, type, nparams, and units"");
-6.    X0 = png_get_int_32((png_bytep)buf+1);
-5.    X1 = png_get_int_32((png_bytep)buf+5);
-4.    type",Useful
/*Empty loop to move past the units string.*/,"-10.        (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))
-9.    {
-8.       png_chunk_benign_error(png_ptr, ""invalid parameter count"");
-7.       return;
-6.    }
-5.    else if (type >= PNG_EQUATION_LAST)
-4.    {
-3.       png_chunk_benign_error(p",Useful
/*Get pointers to the start of each parameter string.*/,"-8.    png_debug(3, ""Allocating pCAL parameters array"");
-7.    params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,
-6.        nparams * (sizeof (png_charp))));
-5.    if (params == NULL)
-4.    {
-3.       png_chunk_benign_error(png_ptr, ""out of m",Useful
/*Skip the null string terminator from previous parameter.*/,"-2.    for (i = 0; i < nparams; i++)
-1.    {

 /*Skip the null string terminator from previous parameter.*/

1.       png_debug1(3, ""Reading pCAL parameter %d"", i);
2.       for (params[i] = (png_charp)buf; buf <= endptr && *buf != 0; buf++)",Useful
/*Empty loop to move past each parameter string*/,"-2.       png_debug1(3, ""Reading pCAL parameter %d"", i);
-1.       for (params[i] = (png_charp)buf; buf <= endptr && *buf != 0; buf++)

 /*Empty loop to move past each parameter string*/

111",Useful
/*Make sure we haven't run out of data yet*/,"-3.       png_debug1(3, ""Reading pCAL parameter %d"", i);
-2.       for (params[i] = (png_charp)buf; buf <= endptr && *buf != 0; buf++)

 /*Make sure we haven't run out of data yet*/

1.       if (buf > endptr)
2.       {
3.          png_free(png_ptr, para",Useful
"/*Need unit type, width, \0, height: minimum 4 bytes*/","-10.       png_crc_finish(png_ptr, length);
-9.       png_chunk_benign_error(png_ptr, ""out of place"");
-8.       return;
-7.    }
-6.    else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL) != 0)
-5.    {
-4.       png_crc_finish(png_ptr, length",Useful
/*Null terminate the last string*/,"-9.    if (buffer == NULL)
-8.    {
-7.       png_crc_finish(png_ptr, length);
-6.       png_chunk_benign_error(png_ptr, ""out of memory"");
-5.       return;
-4.    }
-3.    png_crc_read(png_ptr, buffer, length);
-2.    if (png_crc_finish(png_ptr, 0) != 0)",Useful
"/*Validate the ASCII numbers, need two ASCII numbers separated by
    * a '\0' and they need to fit exactly in the chunk data.*/","-5.    if (buffer[0] != 1 && buffer[0] != 2)
-4.    {
-3.       png_chunk_benign_error(png_ptr, ""invalid unit"");
-2.       return;
-1.    }
   /* Validate the ASCII numbers, need two ASCII numbers separated by
    * a '\0' and they need to fit exactly in ",Useful
/*Note: this does not properly handle chunks that are > 64K under DOS*/,"-1. png_handle_sPLT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)

 /*Note: this does not properly handle chunks that are > 64K under DOS*/

1. {
2.    png_bytep entry_start, buffer;
3.    png_sPLT_t new_palette;
4.    png_sPLT_entryp pp;",Useful
/*Empty loop to find end of key*/,"-10.    {
-9.       png_chunk_benign_error(png_ptr, ""out of memory"");
-8.       return;
-7.    }
-6.    png_crc_read(png_ptr, buffer, length);
-5.    if (png_crc_finish(png_ptr, skip) != 0)
-4.       return;
-3.    key = (png_charp)buffer;
-2.    key[leng",Useful
/*Note: this does not correctly handle chunks that are > 64K under DOS*/,"-10.    text_info.lang = NULL;
-9.    text_info.lang_key = NULL;
-8.    text_info.itxt_length = 0;
-7.    text_info.text = text;
-6.    text_info.text_length = strlen(text);
-5.    if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) != 0)
-4.       png_w",Useful
"/*Note, ""length"" is sufficient here; we won't be adding
    * a null terminator later.*/","-10.          png_crc_finish(png_ptr, length);
-9.          png_chunk_benign_error(png_ptr, ""no space in chunk cache"");
-8.          return;
-7.       }
-6.    }
-5. #endif
-4.    if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
-3.       png_chunk_error(png_ptr",Useful
/*Empty loop to find end of name*/,"-5.    png_crc_read(png_ptr, buffer, length);
-4.    if (png_crc_finish(png_ptr, skip) != 0)
-3.       return;
-2.    buffer[length] = 0;
-1.    for (entry_start = buffer; *entry_start; entry_start++)

 /*Empty loop to find end of name*/

1.    ++entry_st",Useful
"/*zTXt must have some LZ data after the keyword, although it may expand to
    * zero bytes; we need a '\0' at the end of the keyword, the compression type
    * then the LZ data:*/","-2.    if (keyword_length > 79 || keyword_length < 1)
-1.       errmsg = ""bad keyword"";
   /* zTXt must have some LZ data after the keyword, although it may expand to
    * zero bytes; we need a '\0' at the end of the keyword, the compression type
    * t",Useful
"/*TODO: at present png_decompress_chunk imposes a single application
       * level memory limit, this should be split to different values for iCCP
       * and text chunks.*/","-10.     * zero bytes; we need a '\0' at the end of the keyword, the compression type
-9.     * then the LZ data:
-8.     */
-7.    else if (keyword_length + 3 > length)
-6.       errmsg = ""truncated"";
-5.    else if (buffer[keyword_length+1] != PNG_COMPR",Useful
"/*It worked; png_ptr->read_buffer now looks like a tEXt chunk
             * except for the extra compression type byte and the fact that
             * it isn't necessarily '\0' terminated.*/","-6.       {
-5.          png_text text;
-4.          if (png_ptr->read_buffer == NULL)
-3.            errmsg=""Read failure in png_handle_zTXt"";
-2.          else
-1.          {
            /* It worked; png_ptr->read_buffer now looks like a tEXt chunk
   ",Useful
/*Note: this does not correctly handle chunks that are > 64K under DOS*/,"-10.    text_info.lang = NULL;
-9.    text_info.lang_key = NULL;
-8.    text_info.itxt_length = 0;
-7.    text_info.text = text;
-6.    text_info.text_length = strlen(text);
-5.    if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) != 0)
-4.       png_w",Useful
/*Perform a basic check on the keyword length here.*/,"-4.    for (prefix_length=0;
-3.       prefix_length < length && buffer[prefix_length] != 0;
-2.       ++prefix_length)

 /*Perform a basic check on the keyword length here.*/

1.    if (prefix_length > 79 || prefix_length < 1)
2.       errmsg = ""bad keyw",Useful
"/*Expect keyword, compression flag, compression type, language, translated
    * keyword (both may be empty but are 0 terminated) then the text, which may
    * be empty.*/","-2.    if (prefix_length > 79 || prefix_length < 1)
-1.       errmsg = ""bad keyword"";
   /* Expect keyword, compression flag, compression type, language, translated
    * keyword (both may be empty but are 0 terminated) then the text, which may
    * be e",Useful
"/*WARNING: the length may be invalid here, this is checked below.*/","-5.       prefix_length += 3;
-4.       language_offset = prefix_length;
-3.       for (; prefix_length < length && buffer[prefix_length] != 0;
-2.          ++prefix_length)

 /*WARNING: the length may be invalid here, this is checked below.*/

1.       t",Useful
"/*prefix_length should now be at the trailing '\0' of the translated
       * keyword, but it may already be over the end.  None of this arithmetic
       * can overflow because chunks are at most 2^31 bytes long, but on 16-bit
       * systems the available allocation may overflow.*/","/* prefix_length should now be at the trailing '\0' of the translated
       * keyword, but it may already be over the end.  None of this arithmetic
       * can overflow because chunks are at most 2^31 bytes long, but on 16-bit
       * systems the available allocation may overflow.

 /*prefix_length should now be at the trailing '\0' of the translated
       * keyword, but it may already be over the end.  None of this arithmetic
       * can overflow because chunks are at most 2^31 bytes long, but on 16-bit
       * systems the available allocation may overflow.*/

1.        */
2.       ++prefix_length;
3.       if (compressed == 0 && prefix_length <= length)
4.          uncompressed_length = length - prefix_length;
5.       else if (compressed != 0 && prefix_length < length)
6.       {
7.          uncompressed_length = PNG_SIZE_MAX;
8.          /* TODO: at present png_decompress_chunk imposes a single application
9.           * level memory limit, this should be split to different values for
10.           * iCCP and text chunks.",Useful
"/*TODO: at present png_decompress_chunk imposes a single application
          * level memory limit, this should be split to different values for
          * iCCP and text chunks.*/","-10.        * keyword, but it may already be over the end.  None of this arithmetic
-9.        * can overflow because chunks are at most 2^31 bytes long, but on 16-bit
-8.        * systems the available allocation may overflow.
-7.        */
-6.       ++p",Useful
/*Utility function for png_handle_unknown; set up png_ptr::unknown_chunk*/,"-10.             errmsg = ""insufficient memory"";
-9.       }
-8.    }
-7.    else
-6.       errmsg = ""bad compression info"";
-5.    if (errmsg != NULL)
-4.       png_chunk_benign_error(png_ptr, errmsg);
-3. }
-2. #endif
-1. #ifdef PNG_READ_UNKNOWN_CHUNKS_",Useful
"/*mode' is a flag array, only the bottom four bits matter here*/","-10.       limit = png_ptr->user_chunk_malloc_max;
-9. #  elif PNG_USER_CHUNK_MALLOC_MAX > 0
-8.    if (PNG_USER_CHUNK_MALLOC_MAX < limit)
-7.       limit = PNG_USER_CHUNK_MALLOC_MAX;
-6. #  endif
-5.    if (length <= limit)
-4.    {
-3.       PNG_CSTRING",Useful
"/*NOTE: this code is based on the code in libpng-1.4.12 except for fixing
    * the bug which meant that setting a non-default behavior for a specific
    * chunk would be ignored (the default was always used unless a user
    * callback was installed).
    *
    * 'keep' is the value from the png_chunk_unknown_handling, the setting for
    * this specific chunk_name, if PNG_HANDLE_AS_UNKNOWN_SUPPORTED, if not it
    * will always be PNG_HANDLE_CHUNK_AS_DEFAULT and it needs to be set here.
    * This is just an optimization to avoid multiple calls to the lookup
    * function.*/","-2.    png_debug(1, ""in png_handle_unknown"");
-1. #ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
   /* NOTE: this code is based on the code in libpng-1.4.12 except for fixing
    * the bug which meant that setting a non-default behavior for a specific
    * chu",Useful
"/*One of the following methods will read the chunk or skip it (at least one
    * of these is always defined because this is the only way to switch on
    * PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)*/",#NAME?,Useful
"/*The user callback takes precedence over the chunk keep value, but the
    * keep value is still required to validate a save of a critical chunk.*/","-1. #  ifdef PNG_READ_USER_CHUNKS_SUPPORTED
   /* The user callback takes precedence over the chunk keep value, but the
    * keep value is still required to validate a save of a critical chunk.

 /*The user callback takes precedence over the chunk keep v",Useful
"/*ret is:
          * negative: An error occurred; png_chunk_error will be called.
          *     zero: The chunk was not handled, the chunk will be discarded
          *           unless png_set_keep_unknown_chunks has been used to set
          *           a 'keep' behavior for this particular chunk, in which
          *           case that will be used.  A critical chunk will cause an
          *           error at this point unless it is to be saved.
          * positive: The chunk was handled, libpng will ignore/discard it.*/","-2.          int ret = (*(png_ptr->read_user_chunk_fn))(png_ptr,
-1.              &png_ptr->unknown_chunk);
         /* ret is:
          * negative: An error occurred; png_chunk_error will be called.
          *     zero: The chunk was not handled, the c",Useful
"/*If the keep value is 'default' or 'never' override it, but
             * still error out on critical chunks unless the keep value is
             * 'always'  While this is weird it is the behavior in 1.4.12.
             * A possible improvement would be to obey the value set for the
             * chunk, but this would be an API change that would probably
             * damage some applications.
             *
             * The png_app_warning below catches the case that matters, where
             * the application has not set specific save or ignore for this
             * chunk or global save or ignore.*/","-10.           *           unless png_set_keep_unknown_chunks has been used to set
-9.           *           a 'keep' behavior for this particular chunk, in which
-8.           *           case that will be used.  A critical chunk will cause an
-7.       ",Useful
"/*keep is currently just the per-chunk setting, if there was no
       * setting change it to the global default now (not that this may
       * still be AS_DEFAULT) then obtain the cache of the chunk if required,
       * if not simply skip the chunk.*/","-2. #  ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
-1.    {
      /* keep is currently just the per-chunk setting, if there was no
       * setting change it to the global default now (not that this may
       * still be AS_DEFAULT) then obtain the cache of t",Useful
"/*If here there is no read callback pointer set and no support is
       * compiled in to just save the unknown chunks, so simply skip this
       * chunk.  If 'keep' is something other than AS_DEFAULT or NEVER then
       * the app has erroneously asked for unknown chunk saving when there
       * is no support.*/","-10.             keep = PNG_HANDLE_CHUNK_NEVER;
-9.       }
-8.       else
-7.          png_crc_finish(png_ptr, length);
-6.    }
-5. #  else
-4. #     ifndef PNG_READ_USER_CHUNKS_SUPPORTED
-3. #        error no method to support READ_UNKNOWN_CHUNKS
-2. #",Useful
"/*Now store the chunk in the chunk list if appropriate, and if the limits
    * permit it.*/","-10.        * chunk.  If 'keep' is something other than AS_DEFAULT or NEVER then
-9.        * the app has erroneously asked for unknown chunk saving when there
-8.        * is no support.
-7.        */
-6.       if (keep > PNG_HANDLE_CHUNK_NEVER)
-5.     ",Useful
"/*NOTE: prior to 1.6.0 this case resulted in an unknown critical
             * chunk being skipped, now there will be a hard error below.*/","-1.          case 1:
            /* NOTE: prior to 1.6.0 this case resulted in an unknown critical
             * chunk being skipped, now there will be a hard error below.

 /*NOTE: prior to 1.6.0 this case resulted in an unknown critical
             * ",Useful
"/*Here when the limit isn't reached or when limits are compiled
             * out; store the chunk.*/","
            /* Here when the limit isn't reached or when limits are compiled
             * out; store the chunk.



 /*Here when the limit isn't reached or when limits are compiled
             * out; store the chunk.*/

1.              */
2.             png_set_unknown_chunks(png_ptr, info_ptr,
3.                 &png_ptr->unknown_chunk, 1);
4.             handled = 1;
5. #  ifdef PNG_USER_LIMITS_SUPPORTED
6.             break;
7.       }
8. #  endif
9.    }",Useful
/*no store support: the chunk must be handled by the user callback*/,"-10.              * out; store the chunk.
-9.              */
-8.             png_set_unknown_chunks(png_ptr, info_ptr,
-7.                 &png_ptr->unknown_chunk, 1);
-6.             handled = 1;
-5. #  ifdef PNG_USER_LIMITS_SUPPORTED
-4.             br",Useful
"/*Regardless of the error handling below the cached data (if any) can be
    * freed now.  Notice that the data is not freed if there is a png_error, but
    * it will be freed by destroy_read_struct.*/","-2.    PNG_UNUSED(info_ptr)
-1. #  endif
   /* Regardless of the error handling below the cached data (if any) can be
    * freed now.  Notice that the data is not freed if there is a png_error, but
    * it will be freed by destroy_read_struct.

 /*Regar",Useful
/*Check for unhandled critical chunks*/,"-4.    png_crc_finish(png_ptr, length);
-3.    PNG_UNUSED(info_ptr)
-2.    PNG_UNUSED(keep)

 /*Check for unhandled critical chunks*/

1.    if (handled == 0 && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))
2.       png_chunk_error(png_ptr, ""unhandled critical",Useful
"/*This function is called to verify that a chunk name is valid.
 * This function can't have the ""critical chunk check"" incorporated
 * into it, since in the future we will need to be able to call user
 * functions to handle unknown critical chunks after we check that
 * the chunk name itself is valid.*/","-3.    if (handled == 0 && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))
-2.       png_chunk_error(png_ptr, ""unhandled critical chunk"");
-1. }
/* This function is called to verify that a chunk name is valid.
 * This function can't have the ""critical chunk chec",Useful
"/*Bit hacking: the test for an invalid byte in the 4 byte chunk name is:
 *
 * ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))*/","/* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:
 *
 * ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))

 /*Bit hacking: the test for an invalid byte in the 4 byte chunk name is:
 *
 * ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))*/

1.  */",Useful
"/*Combines the row recently read in with the existing pixels in the row.  This
 * routine takes care of alpha and transparency if requested.  This routine also
 * handles the two methods of progressive display of interlaced images,
 * depending on the 'display' value; if 'display' is true then the whole row
 * (dp) is filled from the start by replicating the available pixels.  If
 * 'display' is false only those pixels present in the pass are filled in.*/","-10.       idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;
-9.       limit = limit < idat_limit? idat_limit : limit;
-8.    }
-7.    if (length > limit)
-6.    {
-5.       png_debug2(0,"" length = %lu, limit = %lu"",
-4.          (uns",Useful
"/*Added in 1.5.6: it should not be possible to enter this routine until at
    * least one row has been read from the PNG data and transformed.*/","-10. png_combine_row(png_const_structrp png_ptr, png_bytep dp, int display)
-9. {
-8.    unsigned int pixel_depth = png_ptr->transformed_pixel_depth;
-7.    png_const_bytep sp = png_ptr->row_buf + 1;
-6.    png_alloc_size_t row_width = png_ptr->width;
-5.",Useful
"/*Added in 1.5.4: the pixel depth should match the information returned by
    * any call to png_read_update_info at this point.  Do not continue if we got
    * this wrong.*/","-2.    if (pixel_depth == 0)
-1.       png_error(png_ptr, ""internal row logic error"");
   /* Added in 1.5.4: the pixel depth should match the information returned by
    * any call to png_read_update_info at this point.  Do not continue if we got
    * th",Useful
"/*Preserve the last byte in cases where only part of it will be overwritten,
    * the multiply below may overflow, we don't care because ANSI-C guarantees
    * we get the low bits.*/","-2.    if (row_width == 0)
-1.       png_error(png_ptr, ""internal row width error"");
   /* Preserve the last byte in cases where only part of it will be overwritten,
    * the multiply below may overflow, we don't care because ANSI-C guarantees
    * we g",Useful
"/*For non-interlaced images this reduces to a memcpy(). A memcpy()
    * will also happen if interlacing isn't supported or if the application
    * does not call png_set_interlace_handling().  In the latter cases the
    * caller just gets a sequence of the unexpanded rows from each interlace
    * pass.*/","-1.    }
   /* For non-interlaced images this reduces to a memcpy(). A memcpy()
    * will also happen if interlacing isn't supported or if the application
    * does not call png_set_interlace_handling().  In the latter cases the
    * caller just gets a",Useful
"/*The following copies everything for 'display' on passes 0, 2 and 4.*/","-4. #ifdef PNG_READ_INTERLACING_SUPPORTED
-3.    if (png_ptr->interlaced != 0 &&
-2.        (png_ptr->transformations & PNG_INTERLACE) != 0 &&
-1.        pass < 6 && (display == 0 ||

 /*The following copies everything for 'display' on passes 0, 2 and 4.*",Useful
"/*Narrow images may have no bits in a pass; the caller should handle
       * this, but this test is cheap:*/","-2.        (display == 1 && (pass & 1) != 0)))
-1.    {
      /* Narrow images may have no bits in a pass; the caller should handle
       * this, but this test is cheap:

 /*Narrow images may have no bits in a pass; the caller should handle
       * this",Useful
"/*For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit
          * into 32 bits, then a single loop over the bytes using the four byte
          * values in the 32-bit mask can be used.  For the 'display' option the
          * expanded mask may also not require any masking within a byte.  To
          * make this work the PACKSWAP option must be taken into account - it
          * simply requires the pixels to be reversed in each byte.
          *
          * The 'regular' case requires a mask for each of the first 6 passes,
          * the 'display' case does a copy for the even passes in the range
          * 0..6.  This has already been handled in the test above.
          *
          * The masks are arranged as four bytes with the first byte to use in
          * the lowest bits (little-endian) regardless of the order (PACKSWAP or
          * not) of the pixels in each byte.
          *
          * NOTE: the whole of this logic depends on the caller of this function
          * only calling it on rows appropriate to the pass.  This function only
          * understands the 'x' logic; the 'y' logic is handled by the caller.
          *
          * The following defines allow generation of compile time constant bit
          * masks for each pixel depth and each possibility of swapped or not
          * swapped bytes.  Pass 'p' is in the range 0..6; 'x', a pixel index,
          * is in the range 0..7; and the result is 1 if the pixel is to be
          * copied in the pass, 0 if not.  'S' is for the sparkle method, 'B'
          * for the block method.
          *
          * With some compilers a compile time expression of the general form:
          *
          *    (shift >= 32) ? (a >> (shift-32)) : (b >> shift)
          *
          * Produces warnings with values of 'shift' in the range 33 to 63
          * because the right hand side of the ?: expression is evaluated by
          * the compiler even though it isn't used.  Microsoft Visual C (various
          * versions) and the Intel C compiler are known to do this.  To avoid
          * this the following macros are used in 1.5.6.  This is a temporary
          * solution to avoid destabilizing the code during the release process.*/","-10.        /* The following copies everything for 'display' on passes 0, 2 and 4. */
-9.        (display == 1 && (pass & 1) != 0)))
-8.    {
-7.       /* Narrow images may have no bits in a pass; the caller should handle
-6.        * this, but this test ",Useful
"/*Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is
          * little endian - the first pixel is at bit 0 - however the extra
          * parameter 's' can be set to cause the mask position to be swapped
          * within each byte, to match the PNG format.  This is done by XOR of
          * the shift with 7, 6 or 4 for bit depths 1, 2 and 4.*/","-10. #           define PNG_LSR(x,s) ((x)>>((s) & 0x1f))
-9. #           define PNG_LSL(x,s) ((x)<<((s) & 0x1f))
-8. #        else
-7. #           define PNG_LSR(x,s) ((x)>>(s))
-6. #           define PNG_LSL(x,s) ((x)<<(s))
-5. #        endif
-4. #      ",Useful
/*Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.*/,"-2. #        define PIXEL_MASK(p,x,d,s) \
-1.             (PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))
         /* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.

 /*Hence generate the appropriate 'block' or 'sparkle' p",Useful
"/*Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp
          * cases the result needs replicating, for the 4-bpp case the above
          * generates a full 32 bits.*/","-2. #        define S_MASKx(p,x,d,s) (S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
-1. #        define B_MASKx(p,x,d,s) (B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
         /* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp
          * cases the result ne",Useful
"/*Utility macros to construct all the masks for a depth/swap
          * combination.  The 's' parameter says whether the format is PNG
          * (big endian bytes) or not.  Only the three odd-numbered passes are
          * required for the display/block algorithm.*/","-10.           * generates a full 32 bits.
-9.           */
-8. #        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
-7. #        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
-6.             S_MASKx(p",Useful
"/*Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
          * then pass:*/","-4. #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
-3.             S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
-2. #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
-1. #        define DEPTH_INDEX",Useful
/*Little-endian byte masks for PACKSWAP*/,"-1.          {

 /*Little-endian byte masks for PACKSWAP*/

1.             { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },",Useful
/*Normal (big-endian byte) masks - PNG format*/,"-1.             { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },

 /*Normal (big-endian byte) masks - PNG format*/

1.             { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }
2.          };",Useful
/*Little-endian byte masks for PACKSWAP*/,"-1.          {

 /*Little-endian byte masks for PACKSWAP*/

1.             { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },",Useful
/*Normal (big-endian byte) masks - PNG format*/,"-1.             { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },

 /*Normal (big-endian byte) masks - PNG format*/

1.             { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }
2.          };",Useful
"/*This is the runtime alternative: it seems unlikely that this will
          * ever be either smaller or faster than the compile time approach.*/","
         /* This is the runtime alternative: it seems unlikely that this will
          * ever be either smaller or faster than the compile time approach.



 /*This is the runtime alternative: it seems unlikely that this will
          * ever be either smaller or faster than the compile time approach.*/

1.           */
2. #        define MASK(pass,depth,display,png)\
3.             ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))",Useful
"/*Use the appropriate mask to copy the required bits.  In some cases
          * the byte mask will be 0 or 0xff; optimize these cases.  row_width is
          * the number of pixels, but the code copies bytes, so it is necessary
          * to special case the end.*/","/* Use the appropriate mask to copy the required bits.  In some cases
          * the byte mask will be 0 or 0xff; optimize these cases.  row_width is
          * the number of pixels, but the code copies bytes, so it is necessary
          * to special case the end.

 /*Use the appropriate mask to copy the required bits.  In some cases
          * the byte mask will be 0 or 0xff; optimize these cases.  row_width is
          * the number of pixels, but the code copies bytes, so it is necessary
          * to special case the end.*/

1.           */
2.          png_uint_32 pixels_per_byte = 8 / pixel_depth;
3.          png_uint_32 mask;
4. #        ifdef PNG_READ_PACKSWAP_SUPPORTED
5.          if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
6.             mask = MASK(pass, pixel_depth, display, 0);
7.          else
8. #        endif
9.          mask = MASK(pass, pixel_depth, display, 1);
10.          for (;;)",Useful
"/*NOTE: this may overwrite the last byte with garbage if the image
             * is not an exact number of bytes wide; libpng has always done
             * this.*/","-6.             {
-5.                if (m != 0xff)
-4.                   *dp = (png_byte)((*dp & ~m) | (*sp & m));
-3.                else
-2.                   *dp = *sp;
-1.             }
            /* NOTE: this may overwrite the last byte with garba",Useful
/*May need to restore part of the last byte*/,"-1.             if (row_width <= pixels_per_byte)

 /*May need to restore part of the last byte*/

1.             row_width -= pixels_per_byte;
2.             ++dp;
3.             ++sp;
4.          }
5.       }",Useful
"/*Regardless of pass number the Adam 7 interlace always results in a
          * fixed number of pixels to copy then to skip.  There may be a
          * different number of pixels to skip at the start though.*/","-1.          row_width *= pixel_depth;
         /* Regardless of pass number the Adam 7 interlace always results in a
          * fixed number of pixels to copy then to skip.  There may be a
          * different number of pixels to skip at the start thou",Useful
"/*When doing the 'block' algorithm the pixel in the pass gets
             * replicated to adjacent pixels.  This is why the even (0,2,4,6)
             * passes are skipped above - the entire expanded row is copied.*/","-2.          if (display != 0)
-1.          {
            /* When doing the 'block' algorithm the pixel in the pass gets
             * replicated to adjacent pixels.  This is why the even (0,2,4,6)
             * passes are skipped above - the entire exp",Useful
/*In Adam7 there is a constant offset between where the pixels go.*/,"-1.             bytes_to_copy = pixel_depth;

 /*In Adam7 there is a constant offset between where the pixels go.*/

1.          bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;",Useful
"/*And simply copy these bytes.  Some optimization is possible here,
          * depending on the value of 'bytes_to_copy'.  Special case the low
          * byte counts, which we know to be frequent.
          *
          * Notice that these cases all 'return' rather than 'break' - this
          * avoids an unnecessary test on whether to restore the last byte
          * below.*/","-1.          bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;
         /* And simply copy these bytes.  Some optimization is possible here,
          * depending on the value of 'bytes_to_copy'.  Special case the low
          * byte counts, which",Useful
"/*There is a possibility of a partial copy at the end here; this
                * slows the code down somewhat.*/","-10.                for (;;)
-9.                {
-8.                   *dp = *sp;
-7.                   if (row_width <= bytes_to_jump)
-6.                      return;
-5.                   dp += bytes_to_jump;
-4.                   sp += bytes_to_jump;",Useful
/*And there can only be one byte left at this point:*/,"-10.                do
-9.                {
-8.                   dp[0] = sp[0]; dp[1] = sp[1];
-7.                   if (row_width <= bytes_to_jump)
-6.                      return;
-5.                   sp += bytes_to_jump;
-4.                   dp += b",Useful
"/*This can only be the RGB case, so each copy is exactly one
                * pixel and it is not necessary to check for a partial copy.*/","-3.                *dp = *sp;
-2.                return;
-1.             case 3:
               /* This can only be the RGB case, so each copy is exactly one
                * pixel and it is not necessary to check for a partial copy.

 /*This can only be",Useful
"/*Check for double byte alignment and, if possible, use a
                * 16-bit copy.  Don't attempt this for narrow images - ones that
                * are less than an interlace panel wide.  Don't attempt it for
                * wide bytes_to_copy either - use the memcpy there.*/","-10.                {
-9.                   dp[0] = sp[0]; dp[1] = sp[1]; dp[2] = sp[2];
-8.                   if (row_width <= bytes_to_jump)
-7.                      return;
-6.                   sp += bytes_to_jump;
-5.                   dp += bytes_to",Useful
"/*Everything is aligned for png_uint_16 copies, but try for
                   * png_uint_32 first.*/","-5.                    png_isaligned(dp, png_uint_16) &&
-4.                    png_isaligned(sp, png_uint_16) &&
-3.                    bytes_to_copy % (sizeof (png_uint_16)) == 0 &&
-2.                    bytes_to_jump % (sizeof (png_uint_16)) == 0)
-1.",Useful
"/*Get to here when the row_width truncates the final copy.
                      * There will be 1-3 bytes left to copy, so don't try the
                      * 16-bit loop below.*/","-10.                            c -= (sizeof (png_uint_32));
-9.                         }
-8.                         while (c > 0);
-7.                         if (row_width <= bytes_to_jump)
-6.                            return;
-5.                   ",Useful
"/*Else do it in 16-bit quantities, but only if the size is
                   * not too large.*/","-10.                       * There will be 1-3 bytes left to copy, so don't try the
-9.                       * 16-bit loop below.
-8.                       */
-7.                      dp = (png_bytep)dp32;
-6.                      sp = (png_const_bytep)s",Useful
"/*End of row - 1 byte left, bytes_to_copy > row_width:*/","-10.                            c -= (sizeof (png_uint_16));
-9.                         }
-8.                         while (c > 0);
-7.                         if (row_width <= bytes_to_jump)
-6.                            return;
-5.                   ",Useful
"/*If here then the switch above wasn't used so just memcpy the whole row
    * from the temporary row buffer (notice that this overwrites the end of the
    * destination row if it is a partial byte.)*/","
   /* If here then the switch above wasn't used so just memcpy the whole row
    * from the temporary row buffer (notice that this overwrites the end of the
    * destination row if it is a partial byte.)



 /*If here then the switch above wasn't used so just memcpy the whole row
    * from the temporary row buffer (notice that this overwrites the end of the
    * destination row if it is a partial byte.)*/

1.     */
2.    memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));",Useful
/*Restore the overwritten bits from the last byte if necessary.*/,"-1.    memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));

 /*Restore the overwritten bits from the last byte if necessary.*/

1.    if (end_ptr != NULL)
2.       *end_ptr = (png_byte)((end_byte & end_mask) | (*end_ptr & ~end_mask));
3. }
4. #ifdef PNG",Useful
/*Offset to next interlace block*/,"-2. {

 /*Offset to next interlace block*/

1.    static PNG_CONST unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
2.    png_debug(1, ""in png_do_read_interlace"");
3.    if (row != NULL && row_info != NULL)
4.    {
5.       png_uint_32 final_width;
6",Useful
/*From previous iteration or start*/,"-3.    while (row < rp_end)
-2.    {
-1.       int b, pa, pb, pc, p;

 /*From previous iteration or start*/

1.       b = *prev_row++;
2.       p = b - c;
3.       pc = a - c;
4. #ifdef PNG_USE_ABS
5.       pa = abs(p);
6.       pb = abs(pc);
7.       pc ",Useful
"/*Calculate the current pixel in a, and move the previous row pixel to c
       * for the next time round the loop*/","-5.       if (pb < pa)
-4.       {
-3.          pa = pb; a = b;
-2.       }
-1.       if (pc < pa) a = c;
      /* Calculate the current pixel in a, and move the previous row pixel to c
       * for the next time round the loop

 /*Calculate the current p",Useful
"/*Process the first pixel in the row completely (this is the same as 'up'
    * because there is only one candidate predictor for the first row).*/","-10.       a += *row;
-9.       *row++ = (png_byte)a;
-8.    }
-7. }
-6. static void
-5. png_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info, png_bytep row,
-4.     png_const_bytep prev_row)
-3. {
-2.    unsigned int bpp = (row_info->pixel_de",Useful
"/*This function is called once for every PNG image (except for PNG images
    * that only use PNG_FILTER_VALUE_NONE for all rows) to set the
    * implementations required to reverse the filtering of PNG rows.  Reversing
    * the filter is the first transformation performed on the row data.  It is
    * performed in place, therefore an implementation can be selected based on
    * the image pixel format.  If the implementation depends on image width then
    * take care to ensure that it works correctly if the image is interlaced -
    * interlacing causes the actual row width to vary.*/","-10.       {
-9.          pa = pb; a = b;
-8.       }
-7.       if (pc < pa) a = c;
-6.       a += *row;
-5.       *row++ = (png_byte)a;
-4.    }
-3. }
-2. static void
-1. png_init_filter_functions(png_structrp pp)
   /* This function is called once for e",Useful
"/*To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to
    * call to install hardware optimizations for the above functions; simply
    * replace whatever elements of the pp->read_filter[] array with a hardware
    * specific (or, for that matter, generic) optimization.
    *
    * To see an example of this examine what configure.ac does when
    * --enable-arm-neon is specified on the command line.*/","-10.    pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub;
-9.    pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up;
-8.    pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg;
-7.    if (bpp == 1)
-6.       pp-",Useful
"/*OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define
    * PNG_FILTER_OPTIMIZATIONS to a function that overrides the generic
    * implementations.  See png_init_filter_functions above.*/","-3. png_read_filter_row(png_structrp pp, png_row_infop row_info, png_bytep row,
-2.     png_const_bytep prev_row, int filter)
-1. {
   /* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define
    * PNG_FILTER_OPTIMIZATIONS to a function that override",Useful
/*Loop reading IDATs and decompressing the result into output[avail_out]*/,"-3. png_read_IDAT_data(png_structrp png_ptr, png_bytep output,
-2.     png_alloc_size_t avail_out)
-1. {

 /*Loop reading IDATs and decompressing the result into output[avail_out]*/

1.    png_ptr->zstream.next_out = output;",Useful
"/*This is an error even in the 'check' case because the code just
             * consumed a non-IDAT header.*/","-10.       int ret;
-9.       png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];
-8.       if (png_ptr->zstream.avail_in == 0)
-7.       {
-6.          uInt avail_in;
-5.          png_bytep buffer;
-4.          while (png_ptr->idat_size == 0)
-3.          {
-2.      ",Useful
"/*A PNG with a gradually increasing IDAT size will defeat this attempt
          * to minimize memory usage by causing lots of re-allocs, but
          * realistically doing IDAT_read_size re-allocs is not likely to be a
          * big problem.*/","-6.             if (png_ptr->chunk_name != png_IDAT)
-5.                png_error(png_ptr, ""Not enough image data"");
-4.          }
-3.          avail_in = png_ptr->IDAT_read_size;
-2.          if (avail_in > png_ptr->idat_size)
-1.             avail_in =",Useful
"/*after last row, checking for end*/","-7.       {
-6.          uInt out = ZLIB_IO_MAX;
-5.          if (out > avail_out)
-4.             out = (uInt)avail_out;
-3.          avail_out -= out;
-2.          png_ptr->zstream.avail_out = out;
-1.       }

 /*after last row, checking for end*/

1. ",Useful
"/*Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the
       * process.  If the LZ stream is truncated the sequential reader will
       * terminally damage the stream, above, by reading the chunk header of the
       * following chunk (it then exits with png_error).
       *
       * TODO: deal more elegantly with truncated IDAT lists.*/","-4.       {
-3.          png_ptr->zstream.next_out = tmpbuf;
-2.          png_ptr->zstream.avail_out = (sizeof tmpbuf);
-1.       }
      /* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the
       * process.  If the LZ stream is trunc",Useful
/*Do this for safety; we won't read any more into this row.*/,"-4.          avail_out += (sizeof tmpbuf) - png_ptr->zstream.avail_out;
-3.       png_ptr->zstream.avail_out = 0;
-2.       if (ret == Z_STREAM_END)
-1.       {

 /*Do this for safety; we won't read any more into this row.*/

1.          png_ptr->zstream.",Useful
"/*The stream ended before the image; this is the same as too few IDATs so
       * should be handled the same way.*/","-8.          {
-7.             png_chunk_benign_error(png_ptr, png_ptr->zstream.msg);
-6.             return;
-5.          }
-4.       }
-3.    } while (avail_out > 0);
-2.    if (avail_out > 0)
-1.    {
      /* The stream ended before the image; this is",Useful
/*the deflate stream contained extra data*/,"-2.       if (output != NULL)
-1.          png_error(png_ptr, ""Not enough image data"");

 /*the deflate stream contained extra data*/

1.          png_chunk_benign_error(png_ptr, ""Too much image data"");
2.    }
3. }",Useful
"/*We don't need any more data and the stream should have ended, however the
    * LZ end code may actually not have been processed.  In this case we must
    * read it otherwise stray unread IDAT data or, more likely, an IDAT chunk
    * may still remain to be consumed.*/","-2. png_read_finish_IDAT(png_structrp png_ptr)
-1. {
   /* We don't need any more data and the stream should have ended, however the
    * LZ end code may actually not have been processed.  In this case we must
    * read it otherwise stray unread IDAT da",Useful
"/*The NULL causes png_read_IDAT_data to swallow any remaining bytes in
       * the compressed stream, but the stream may be damaged too, so even after
       * this call we may need to terminate the zstream ownership.*/","-2.    if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)
-1.    {
      /* The NULL causes png_read_IDAT_data to swallow any remaining bytes in
       * the compressed stream, but the stream may be damaged too, so even after
       * this call we may ne",Useful
"/*Now clear everything out for safety; the following may not have been
       * done.*/","
      /* Now clear everything out for safety; the following may not have been
       * done.



 /*Now clear everything out for safety; the following may not have been
       * done.*/

1.        */
2.       if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)
3.       {
4.          png_ptr->mode |= PNG_AFTER_IDAT;
5.          png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;
6.       }
7.    }",Useful
"/*If the zstream has not been released do it now *and* terminate the reading
    * of the final IDAT chunk.*/","-6.       if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)
-5.       {
-4.          png_ptr->mode |= PNG_AFTER_IDAT;
-3.          png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;
-2.       }
-1.    }
   /* If the zstream has not been released do it now *and* ",Useful
/*Always do this; the pointers otherwise point into the read buffer.*/,"-2.    if (png_ptr->zowner == png_IDAT)
-1.    {

 /*Always do this; the pointers otherwise point into the read buffer.*/

1.       png_ptr->zstream.next_in = NULL;
2.       png_ptr->zstream.avail_in = 0;",Useful
"/*The slightly weird semantics of the sequential IDAT reading is that we
       * are always in or at the end of an IDAT chunk, so we always need to do a
       * crc_finish here.  If idat_size is non-zero we also need to read the
       * spurious bytes at the end of the chunk now.*/","-1.       png_ptr->zowner = 0;
      /* The slightly weird semantics of the sequential IDAT reading is that we
       * are always in or at the end of an IDAT chunk, so we always need to do a
       * crc_finish here.  If idat_size is non-zero we also nee",Useful
/*Offset to next interlace block*/,"-2. {

 /*Offset to next interlace block*/

1.    static PNG_CONST unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
2.    png_debug(1, ""in png_do_read_interlace"");
3.    if (row != NULL && row_info != NULL)
4.    {
5.       png_uint_32 final_width;
6",Useful
/*Start of interlace block in the y direction*/,"-1.    static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

 /*Start of interlace block in the y direction*/

1.    static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};",Useful
/*Offset to next interlace block in the y direction*/,"-1.    static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

 /*Offset to next interlace block in the y direction*/

1.    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
2.    png_debug(1, ""in png_read_finish_row"");
3",Useful
"/*TO DO: don't do this if prev_row isn't needed (requires
       * read-ahead of the next row's filter byte.*/","-8.    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-7.    png_debug(1, ""in png_read_finish_row"");
-6.    png_ptr->row_number++;
-5.    if (png_ptr->row_number < png_ptr->num_rows)
-4.       return;
-3.    if (png_ptr->interlaced !=",Useful
/*Offset to next interlace block*/,"-2. {

 /*Offset to next interlace block*/

1.    static PNG_CONST unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
2.    png_debug(1, ""in png_do_read_interlace"");
3.    if (row != NULL && row_info != NULL)
4.    {
5.       png_uint_32 final_width;
6",Useful
/*Start of interlace block in the y direction*/,"-1.    static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

 /*Start of interlace block in the y direction*/

1.    static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};",Useful
/*Offset to next interlace block in the y direction*/,"-1.    static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

 /*Offset to next interlace block in the y direction*/

1.    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
2.    png_debug(1, ""in png_read_finish_row"");
3",Useful
"/*WARNING: * png_read_transform_info (pngrtran.c) performs a simpler set of
    * calculations to calculate the final pixel depth, then
    * png_do_read_transforms actually does the transforms.  This means that the
    * code which effectively calculates this value is actually repeated in three
    * separate places.  They must all match.  Innocent changes to the order of
    * transformations can and will break libpng in a way that causes memory
    * overwrites.
    *
    * TODO: fix this.*/","-10.           png_pass_inc[png_ptr->pass] - 1 -
-9.           png_pass_start[png_ptr->pass]) /
-8.           png_pass_inc[png_ptr->pass];
-7.    }
-6.    else
-5.    {
-4.       png_ptr->num_rows = png_ptr->height;
-3.       png_ptr->iwidth = png_ptr->wi",Useful
"/*In fact it is an error if it isn't supported, but checking is
       * the safe way.*/","-10.             max_pixel_depth *= 4;
-9.             max_pixel_depth /= 3;
-8.          }
-7.       }
-6.    }
-5. #endif
-4. #ifdef PNG_READ_EXPAND_16_SUPPORTED
-3.    if ((png_ptr->transformations & PNG_EXPAND_16) != 0)
-2.    {
-1. #  ifdef PNG_READ_",Useful
"/*This value is stored in png_struct and double checked in the row read
    * code.*/","-10. #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \
-9. defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
-8.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-7.    {
-6.       unsigned int user_pixel_depth = png_ptr->user_transform_depth *
-5. ",Useful
"/*Align the width on the next larger 8 pixels.  Mainly used
    * for interlacing*/","/* Align the width on the next larger 8 pixels.  Mainly used
    * for interlacing

 /*Align the width on the next larger 8 pixels.  Mainly used
    * for interlacing*/

1.     */
2.    row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));",Useful
"/*Calculate the maximum bytes needed, adding a byte and a pixel
    * for safety's sake*/","-1.    row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));
   /* Calculate the maximum bytes needed, adding a byte and a pixel
    * for safety's sake

 /*Calculate the maximum bytes needed, adding a byte and a pixel
    * for safety's sake*/

1.     ",Useful
"/*Use 16-byte aligned memory for row_buf with at least 16 bytes
       * of padding before and after row_buf; treat prev_row similarly.
       * NOTE: the alignment is to the start of the pixels, one beyond the start
       * of the buffer, because of the filter byte.  Prior to libpng 1.5.6 this
       * was incorrect; the filter byte was aligned, which had the exact
       * opposite effect of that intended.*/","-10.    {
-9.       png_free(png_ptr, png_ptr->big_row_buf);
-8.       png_free(png_ptr, png_ptr->big_prev_row);
-7.       if (png_ptr->interlaced != 0)
-6.          png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,
-5.              row_bytes + 48);
-",Useful
"/*The sequential reader needs a buffer for IDAT, but the progressive reader
    * does not, so free the read buffer now regardless; the sequential reader
    * reallocates it on demand.*/","-10.    if (png_ptr->rowbytes > (PNG_SIZE_MAX - 1))
-9.       png_error(png_ptr, ""Row has too many bytes to allocate in memory"");
-8.    memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
-7.    png_debug1(3, ""width = %u,"", png_ptr->width);
-6.    png_d",Useful
"/*Finally claim the zstream for the inflate of the IDAT data, use the bits
    * value from the stream (note that this will result in a fatal error if the
    * IDAT stream has a bogus deflate header window_bits value, but this should
    * not be happening any longer!)*/","-10.     * does not, so free the read buffer now regardless; the sequential reader
-9.     * reallocates it on demand.
-8.     */
-7.    if (png_ptr->read_buffer != NULL)
-6.    {
-5.       png_bytep buffer = png_ptr->read_buffer;
-4.       png_ptr->read_",Useful
"/*typedefs, common macros, public prototypes*/","---*/
-4. #include <stdio.h>
-3. #include <stdlib.h>
-2. #include <zlib.h>

 /*typedefs, common macros, public prototypes*/

111",Useful
"/*return value = 0 for success, 1 for bad sig, 2 for bad IHDR, 4 for no mem*/","-10. png_uint_32  width, height;
-9. int  bit_depth, color_type;
-8. uch  *image_data = NULL;
-7. void readpng_version_info(void)
-6. {
-5.     fprintf(stderr, ""   Compiled with libpng %s; using libpng %s.\n"",
-4.       PNG_LIBPNG_VER_STRING, png_libpng_v",Useful
"/*first do a quick check that the file really is a PNG image; could
     * have used slightly more general png_sig_cmp() function instead*/","-3. int readpng_init(FILE *infile, ulg *pWidth, ulg *pHeight)
-2. {
-1.     uch sig[8];

 /*first do a quick check that the file really is a PNG image; could
     * have used slightly more general png_sig_cmp() function instead*/

1.     fread(sig, 1, 8, ",Useful
/*could pass pointers to user-defined error handlers instead of NULLs:*/,"-3.     fread(sig, 1, 8, infile);
-2.     if (png_sig_cmp(sig, 0, 8))

 /*could pass pointers to user-defined error handlers instead of NULLs:*/

1.     png_ptr = png_create_read_struct(png_get_libpng_ver(NULL), NULL, NULL,
2.         NULL);
3.     if (!p",Useful
/*out of memory*/,"-3.     png_ptr = png_create_read_struct(png_get_libpng_ver(NULL), NULL, NULL,
-2.         NULL);
-1.     if (!png_ptr)

 /*out of memory*/

1.     info_ptr = png_create_info_struct(png_ptr);
2.     if (!info_ptr) {
3.         png_destroy_read_struct(&png",Useful
/*out of memory*/,"-3.     png_ptr = png_create_read_struct(png_get_libpng_ver(NULL), NULL, NULL,
-2.         NULL);
-1.     if (!png_ptr)

 /*out of memory*/

1.     info_ptr = png_create_info_struct(png_ptr);
2.     if (!info_ptr) {
3.         png_destroy_read_struct(&png",Useful
"/*we could create a second info struct here (end_info), but it's only
     * useful if we want to keep pre- and post-IDAT chunk info separated
     * (mainly for PNG-aware image editors and converters)*/","-1.     }

 /*we could create a second info struct here (end_info), but it's only
     * useful if we want to keep pre- and post-IDAT chunk info separated
     * (mainly for PNG-aware image editors and converters)*/

111",Useful
"/*setjmp() must be called in every function that calls a PNG-reading
     * libpng function*/","-4.     }

 /*setjmp() must be called in every function that calls a PNG-reading
     * libpng function*/

1.     if (setjmp(png_jmpbuf(png_ptr))) {
2.         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
3.         return 2;
4.     }
5.     png_in",Useful
"/*alternatively, could make separate calls to png_get_image_width(),
     * etc., but want bit_depth and color_type for later [don't care about
     * compression_type and filter_type => NULLs]*/","-7.     if (setjmp(png_jmpbuf(png_ptr))) {
-6.         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
-5.         return 2;
-4.     }
-3.     png_init_io(png_ptr, infile);

 /*alternatively, could make separate calls to png_get_image_width(),
     * ",Useful
"/*returns 0 if succeeds, 1 if fails due to no bKGD chunk, 2 if libpng error;
 * scales values to 8-bit if necessary*/","-2.     return 0;
-1. }

 /*returns 0 if succeeds, 1 if fails due to no bKGD chunk, 2 if libpng error;
 * scales values to 8-bit if necessary*/

1. int readpng_get_bgcolor(uch *red, uch *green, uch *blue)
2. {
3.     png_color_16p pBackground;",Useful
"/*setjmp() must be called in every function that calls a PNG-reading
     * libpng function*/","-4.     }

 /*setjmp() must be called in every function that calls a PNG-reading
     * libpng function*/

1.     if (setjmp(png_jmpbuf(png_ptr))) {
2.         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
3.         return 2;
4.     }
5.     png_in",Useful
"/*it is not obvious from the libpng documentation, but this function
     * takes a pointer to a pointer, and it always returns valid red, green
     * and blue values, regardless of color_type:*/","-6.     if (setjmp(png_jmpbuf(png_ptr))) {
-5.         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
-4.         return 2;
-3.     }
-2.     if (!png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))
-1.         return 1;

 /*it is not obvious from the l",Useful
"/*however, it always returns the raw bKGD data, regardless of any
     * bit-depth transformations, so check depth and adjust if necessary*/","-1.     png_get_bKGD(png_ptr, info_ptr, &pBackground);

 /*however, it always returns the raw bKGD data, regardless of any
     * bit-depth transformations, so check depth and adjust if necessary*/

1.     if (bit_depth == 16) {
2.         *red   = pBackg",Useful
"/*setjmp() must be called in every function that calls a PNG-reading
     * libpng function*/","-4.     }

 /*setjmp() must be called in every function that calls a PNG-reading
     * libpng function*/

1.     if (setjmp(png_jmpbuf(png_ptr))) {
2.         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
3.         return 2;
4.     }
5.     png_in",Useful
"/*expand palette images to RGB, low-bit-depth grayscale images to 8 bits,
     * transparency chunks to full alpha channel; strip 16-bit-per-sample
     * images to 8 bits per sample; and convert grayscale to RGB[A]*/","-8.     if (setjmp(png_jmpbuf(png_ptr))) {
-7.         free(image_data);
-6.         image_data = NULL;
-5.         free(row_pointers);
-4.         row_pointers = NULL;
-3.         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
-2.         return NUL",Useful
"/*unlike the example in the libpng documentation, we have *no* idea where
     * this file may have come from--so if it doesn't have a file gamma, don't
     * do any correction (""do no harm"")*/","-10.     if (bit_depth == 16)
-9. #  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-8.         png_set_scale_16(png_ptr);
-7. #  else
-6.         png_set_strip_16(png_ptr);
-5. #  endif
-4. #endif
-3.     if (color_type == PNG_COLOR_TYPE_GRAY ||
-2.         colo",Useful
"/*all transformations have been registered; now update info_ptr data,
     * get rowbytes and channels, and allocate image memory*/","-2.     if (png_get_gAMA(png_ptr, info_ptr, &gamma))
-1.         png_set_gamma(png_ptr, display_exponent, gamma);

 /*all transformations have been registered; now update info_ptr data,
     * get rowbytes and channels, and allocate image memory*/

1.    ",Useful
/*set the individual row_pointers to point at the correct offsets*/,"-10.         return NULL;
-9.     }
-8.     if ((row_pointers = (png_bytepp)malloc(height*sizeof(png_bytep))) == NULL) {
-7.         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
-6.         free(image_data);
-5.         image_data = NULL;
-4.      ",Useful
"/*and we're done!  (png_read_end() can be omitted if no processing of
     * post-IDAT text/time/etc. is desired)*/","-1.     png_read_image(png_ptr, row_pointers);

 /*and we're done!  (png_read_end() can be omitted if no processing of
     * post-IDAT text/time/etc. is desired)*/

1.     free(row_pointers);
2.     row_pointers = NULL;
3.     png_read_end(png_ptr, NULL)",Useful
"/*Define the following to use this test against your installed libpng, rather
 * than the one being built here:*/","-10.  */
-9. #include <stdarg.h>
-8. #include <stdlib.h>
-7. #include <string.h>
-6. #include <errno.h>
-5. #include <stdio.h>
-4. #include <assert.h>
-3. #if defined(HAVE_CONFIG_H) && !defined(PNG_NO_CONFIG_H)
-2. #  include <config.h>
-1. #endif
/* Defi",Useful
"/*1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:*/","-1. #endif
/* 1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:

 /*1.6.1 added support for the configure test harness, which uses 77 to indicate
",Useful
"/*If a transform is valid on both read and write this implies that if the
 * transform is applied to read it must also be applied on write to produce
 * meaningful data.  This is because these transforms when performed on read
 * produce data with a memory format that does not correspond to a PNG format.
 *
 * Most of these transforms are invertible; after applying the transform on
 * write the result is the original PNG data that would have would have been
 * read if no transform were applied.
 *
 * The exception is _SHIFT, which destroys the low order bits marked as not
 * significant in a PNG with the sBIT chunk.
 *
 * The following table lists, for each transform, the conditions under which it
 * is expected to do anything.  Conditions are defined as follows:
 *
 * 1) Color mask bits required - simply a mask to AND with color_type; one of
 *    these must be present for the transform to fire, except that 0 means
 *    'always'.
 * 2) Color mask bits which must be absent - another mask - none of these must
 *    be present.
 * 3) Bit depths - a mask of component bit depths for the transform to fire.
 * 4) 'read' - the transform works in png_read_png.
 * 5) 'write' - the transform works in png_write_png.
 * 6) PNG_INFO_chunk; a mask of the chunks that must be present for the
 *    transform to fire.  All must be present - the requirement is that
 *    png_get_valid() & mask == mask, so if mask is 0 there is no requirement.
 *
 * The condition refers to the original image state - if multiple transforms are
 * used together it is possible to cause a transform that wouldn't fire on the
 * original image to fire.*/","-10. #  ifdef PNG_INFO_IMAGE_SUPPORTED
-9. #     ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-8. #        define PNG_READ_PNG_SUPPORTED
-7. #     endif /* SEQUENTIAL_READ */
-6. #     ifdef PNG_WRITE_SUPPORTED
-5. #        define PNG_WRITE_PNG_SUPPORTED
-4. #    ",Useful
"/*absent = gray, no alpha*/","-10.    png_uint_32 valid_chunks;
-9. #     define CHUNK_NONE 0
-8. #     define CHUNK_sBIT PNG_INFO_sBIT
-7. #     define CHUNK_tRNS PNG_INFO_tRNS
-6.    png_byte    color_mask_required;
-5.    png_byte    color_mask_absent;
-4. #     define COLOR_MASK_X",Useful
"/*List ALL the PNG_TRANSFORM_ macros here.  Check for support using the READ
    * macros; even if the transform is supported on write it cannot be tested
    * without the read support.*/","-2. } transform_info[] =
-1. {
   /* List ALL the PNG_TRANSFORM_ macros here.  Check for support using the READ
    * macros; even if the transform is supported on write it cannot be tested
    * without the read support.

 /*List ALL the PNG_TRANSFORM_ m",Useful
/*removes the alpha channel if present*/,"-3. #endif
-2. #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-1.    T(STRIP_ALPHA,         NONE, A,   X,  ALL,  R),

 /*removes the alpha channel if present*/

1. #endif
2. #ifdef PNG_WRITE_PACK_SUPPORTED
3. #  define TRANSFORM_RW_PACK TRANSFORM_RW
4. #else
5. # ",Useful
"/*unpacks low-bit-depth components into 1 byte per component on read,
       * reverses this on write.*/","-8. #endif
-7. #ifdef PNG_WRITE_PACK_SUPPORTED
-6. #  define TRANSFORM_RW_PACK TRANSFORM_RW
-5. #else
-4. #  define TRANSFORM_RW_PACK TRANSFORM_R
-3. #endif
-2. #ifdef PNG_READ_PACK_SUPPORTED
-1.    T(PACKING,             NONE, X,   X,  LOW, RW_PACK),
   ",Useful
/*reverses the order of low-bit-depth components packed into a byte*/,"-10.        * reverses this on write.
-9.        */
-8. #endif
-7. #ifdef PNG_WRITE_PACKSWAP_SUPPORTED
-6. #  define TRANSFORM_RW_PACKSWAP TRANSFORM_RW
-5. #else
-4. #  define TRANSFORM_RW_PACKSWAP TRANSFORM_R
-3. #endif
-2. #ifdef PNG_READ_PACKSWAP_SUPPO",Useful
"/*expands PLTE PNG files to RGB (no tRNS) or RGBA (tRNS) *
       * Note that the 'EXPAND' transform does lots of different things:*/","-3. #endif
-2. #ifdef PNG_READ_EXPAND_SUPPORTED
-1.    T(EXPAND,              NONE, P,   X,  ALL,  R),

 /*expands PLTE PNG files to RGB (no tRNS) or RGBA (tRNS) *
       * Note that the 'EXPAND' transform does lots of different things:*/

1.    T(EXPAND,",Useful
"/*expands grayscale PNG files to RGB, or RGBA*/","-1.    T(EXPAND,              NONE, X,   C,  ALL,  R),

 /*expands grayscale PNG files to RGB, or RGBA*/

1.    T(EXPAND,              tRNS, X,   A,  ALL,  R),",Useful
"/*reduces component values to the original range based on the sBIT chunk,
       * this is only partially reversible - the low bits are lost and cannot be
       * recovered on write.  In fact write code replicates the bits to generate
       * new low-order bits.*/","-8. #endif
-7. #ifdef PNG_WRITE_SHIFT_SUPPORTED
-6. #  define TRANSFORM_RW_SHIFT TRANSFORM_RW
-5. #else
-4. #  define TRANSFORM_RW_SHIFT TRANSFORM_R
-3. #endif
-2. #ifdef PNG_READ_SHIFT_SUPPORTED
-1.    T(SHIFT,               sBIT, X,   X,  ALL, RW_SHIFT)",Useful
/*reverses the rgb component values of true-color pixels*/,"-10.        * new low-order bits.
-9.        */
-8. #endif
-7. #ifdef PNG_WRITE_BGR_SUPPORTED
-6. #  define TRANSFORM_RW_BGR TRANSFORM_RW
-5. #else
-4. #  define TRANSFORM_RW_BGR TRANSFORM_R
-3. #endif
-2. #ifdef PNG_READ_BGR_SUPPORTED
-1.    T(BGR,      ",Useful
"/*swaps the alpha channel of RGBA or GA pixels to the front - ARGB or
       * AG, on write reverses the process.*/","-8. #endif
-7. #ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
-6. #  define TRANSFORM_RW_SWAP_ALPHA TRANSFORM_RW
-5. #else
-4. #  define TRANSFORM_RW_SWAP_ALPHA TRANSFORM_R
-3. #endif
-2. #ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
-1.    T(SWAP_ALPHA,          NONE, A, ",Useful
/*converts an alpha channel from 0..1 to 1..0*/,"-8. #endif
-7. #ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
-6. #  define TRANSFORM_RW_INVERT_ALPHA TRANSFORM_RW
-5. #else
-4. #  define TRANSFORM_RW_INVERT_ALPHA TRANSFORM_R
-3. #endif
-2. #ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-1.    T(INVERT_ALPHA,        N",Useful
"/*on write skips a leading filler channel; testing requires data with a
       * filler channel so this is produced from RGBA or GA images by removing
       * the 'alpha' flag from the color type in place.*/","
      /* on write skips a leading filler channel; testing requires data with a
       * filler channel so this is produced from RGBA or GA images by removing
       * the 'alpha' flag from the color type in place.



 /*on write skips a leading filler channel; testing requires data with a
       * filler channel so this is produced from RGBA or GA images by removing
       * the 'alpha' flag from the color type in place.*/

1.        */
2.    T(STRIP_FILLER_AFTER,  NONE, A,   P, TRUE,  W),",Useful
"/*expands grayscale images to RGB, also causes the palette part of
       * 'EXPAND' to happen.  Low bit depth grayscale images are expanded to
       * 8-bits per component and no attempt is made to convert the image to a
       * palette image.  While this transform is partially reversible
       * png_write_png does not currently support this.*/","-3. #endif
-2. #ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-1.    T(GRAY_TO_RGB,         NONE, X,   C,  ALL,  R),
      /* expands grayscale images to RGB, also causes the palette part of
       * 'EXPAND' to happen.  Low bit depth grayscale images are expanded",Useful
"/*The 'palette' side effect mentioned above; a bit bogus but this is the
       * way the libpng code works.*/","-1.    T(GRAY_TO_RGB,         NONE, P,   X,  ALL,  R),
      /* The 'palette' side effect mentioned above; a bit bogus but this is the
       * way the libpng code works.

 /*The 'palette' side effect mentioned above; a bit bogus but this is the
       * ",Useful
"/*expands images to 16-bits per component, as a side effect expands
       * palette images to RGB and expands the tRNS chunk if present, so it can
       * modify 16-bit per component images as well:*/","-3. #endif
-2. #ifdef PNG_READ_EXPAND_16_SUPPORTED
-1.    T(EXPAND_16,           NONE, X,   X,  PAL,  R),
      /* expands images to 16-bits per component, as a side effect expands
       * palette images to RGB and expands the tRNS chunk if present, so i",Useful
"/*side effect of EXPAND_16 - expands the tRNS chunk in an RGB or G 16-bit
       * image.*/","-1.    T(EXPAND_16,           tRNS, X,   A,   16,  R),
      /* side effect of EXPAND_16 - expands the tRNS chunk in an RGB or G 16-bit
       * image.

 /*side effect of EXPAND_16 - expands the tRNS chunk in an RGB or G 16-bit
       * image.*/

111",Useful
"/*Some combinations of options that should be reversible are not; these cases
 * are bugs.*/","-4. #undef T
-3. };
-2. #define ARRAY_SIZE(a) ((sizeof a)/(sizeof a[0]))
-1. #define TTABLE_SIZE ARRAY_SIZE(transform_info)
/* Some combinations of options that should be reversible are not; these cases
 * are bugs.

 /*Some combinations of options that s",Useful
/*non-zero if more than one set bit*/,"-4. };
-3. static int
-2. is_combo(int transforms)
-1. {

 /*non-zero if more than one set bit*/

1. }
2. static int
3. first_transform(int transforms)
4. {",Useful
/*lowest set bit*/,"-4. }
-3. static int
-2. first_transform(int transforms)
-1. {

 /*lowest set bit*/

1. }
2. static int
3. is_bad_combo(int transforms)
4. {
5.    unsigned int i;
6.    for (i=0; i<ARRAY_SIZE(known_bad_combos); ++i)
7.    {
8.       int combo = known_bad_",Useful
"/*The name, if 't' has multiple bits set the name of the lowest set bit is
    * returned.*/","-3. }
-2. static const char *
-1. transform_name(int t)
   /* The name, if 't' has multiple bits set the name of the lowest set bit is
    * returned.

 /*The name, if 't' has multiple bits set the name of the lowest set bit is
    * returned.*/

1.     *",Useful
/*first set bit*/,"-2. {
-1.    unsigned int i;

 /*first set bit*/

1.    for (i=0; i<TTABLE_SIZE; ++i) if (transform_info[i].name != NULL)
2.    {
3.       if ((transform_info[i].transform & t) != 0)
4.          return transform_info[i].name;
5.    }
6.    return ""invalid",Useful
"/*Variables calculated by validate_T below and used to record all the supported
 * transforms.  Need (unsigned int) here because of the places where these
 * values are used (unsigned compares in the 'exhaustive' iterator.)*/","-7.    for (i=0; i<TTABLE_SIZE; ++i) if (transform_info[i].name != NULL)
-6.    {
-5.       if ((transform_info[i].transform & t) != 0)
-4.          return transform_info[i].name;
-3.    }
-2.    return ""invalid transform"";
-1. }
/* Variables calculated b",Useful
/*Validate the above table - this just builds the above values*/,"-3. static unsigned int read_transforms, write_transforms, rw_transforms;
-2. static void
-1. validate_T(void)

 /*Validate the above table - this just builds the above values*/

1. {
2.    unsigned int i;
3.    for (i=0; i<TTABLE_SIZE; ++i) if (transform",Useful
"/*Reversible transforms are those which are supported on both read and
    * write.*/","-9. {
-8.    unsigned int i;
-7.    for (i=0; i<TTABLE_SIZE; ++i) if (transform_info[i].name != NULL)
-6.    {
-5.       if (transform_info[i].when & TRANSFORM_R)
-4.          read_transforms |= transform_info[i].transform;
-3.       if (transform_info[i]",Useful
"/*FILE DATA HANDLING
 *    The original file is cached in memory.  During write the output file is
 *    written to memory.
 *
 *    In both cases the file data is held in a linked list of buffers - not all
 *    of these are in use at any time.*/","-2.    rw_transforms = read_transforms & write_transforms;
-1. }
/* FILE DATA HANDLING
 *    The original file is cached in memory.  During write the output file is
 *    written to memory.
 *
 *    In both cases the file data is held in a linked list of ",Useful
/*next buffer in list*/,"-10.  *    The original file is cached in memory.  During write the output file is
-9.  *    written to memory.
-8.  *
-7.  *    In both cases the file data is held in a linked list of buffers - not all
-6.  *    of these are in use at any time.
-5.  */
-",Useful
/*bytes in the last buffer*/,"-4. };
-3. struct buffer
-2. {

 /*bytes in the last buffer*/

111",Useful
/*current buffer being read*/,"-5. };
-4. struct buffer
-3. {

 /*current buffer being read*/

111",Useful
/*count of bytes read from current*/,"-6. };
-5. struct buffer
-4. {

 /*count of bytes read from current*/

111",Useful
/*Used from libpng callbacks to get the current buffer*/,"-3. #endif
-2. static struct buffer *
-1. get_buffer(png_structp pp)

 /*Used from libpng callbacks to get the current buffer*/

1. {
2.    return (struct buffer*)png_get_io_ptr(pp);
3. }
4. static struct buffer_list *
5. buffer_extend(struct buffer_list ",Useful
"/*Load a buffer from a file; does the equivalent of buffer_start_write.  On a
 * read error returns an errno value, else returns 0.*/","-10. {
-9.    struct buffer_list *add;
-8.    assert(current->next == NULL);
-7.    add = NEW(struct buffer_list);
-6.    if (add == NULL)
-5.       return NULL;
-4.    add->next = NULL;
-3.    current->next = add;
-2.    return add;
-1. }
/* Load a buffe",Useful
/*continuable error - no need to longjmp*/,"-3.    LIBPNG_WARNING,
-2.    APP_WARNING,

 /*continuable error - no need to longjmp*/

111",Useful
/*Skip over known bugs*/,"-7.    INTERNAL_ERROR
-6. } error_level;

 /*Skip over known bugs*/

111",Useful
/*Log skipped bugs*/,"-8.    INTERNAL_ERROR
-7. } error_level;

 /*Log skipped bugs*/

111",Useful
"/*Result masks apply to the result bits in the 'results' field below; these
 * bits are simple 1U<<error_level.  A pass requires either nothing worse than
 * warnings (--relaxes) or nothing worse than information (--strict)*/","-10. } error_level;

 /*Result masks apply to the result bits in the 'results' field below; these
 * bits are simple 1U<<error_level.  A pass requires either nothing worse than
 * warnings (--relaxes) or nothing worse than information (--strict)*/

1.  */",Useful
/*set by the original read*/,"-10. #define RESULT_RELAXED(r)  (((r) & ~((1U<<ERRORS)-1)) == 0)
-9. struct display
-8. {

 /*set by the original read*/

111",Useful
/*Original chunks valid*/,"-10.    jmp_buf        error_return;      /* Where to go to on error */
-9.    const char    *filename;          /* The name of the original file */
-8.    const char    *operation;         /* Operation being performed */
-7.    int            transforms;",Useful
/*Derived information for the original image.*/,"-7.    png_uint_32    width;
-6.    png_uint_32    height;
-5.    int            bit_depth;
-4.    int            color_type;
-3.    int            interlace_method;
-2.    int            compression_method;
-1.    int            filter_method;

 /*Derive",Useful
"/*Used on a read, both the original read and when validating a written
    * image.*/","
   /* Used on a read, both the original read and when validating a written
    * image.



 /*Used on a read, both the original read and when validating a written
    * image.*/

1.     */
2.    png_structp    read_pp;
3.    png_infop      read_ip;
4. #  ifdef PNG_WRITE_PNG_SUPPORTED",Useful
/*Used to write a new image (the original info_ptr is used)*/,"-3.    png_structp    read_pp;
-2.    png_infop      read_ip;
-1. #  ifdef PNG_WRITE_PNG_SUPPORTED

 /*Used to write a new image (the original info_ptr is used)*/

1.       png_structp   write_pp;",Useful
/*Data read from the original file*/,"-1. #  endif

 /*Data read from the original file*/

1. };
2. static void
3. display_init(struct display *dp)",Useful
"/*Call this only once right at the start to initialize the control
    * structure, the (struct buffer) lists are maintained across calls - the
    * memory is not freed.*/","-3. };
-2. static void
-1. display_init(struct display *dp)
   /* Call this only once right at the start to initialize the control
    * structure, the (struct buffer) lists are maintained across calls - the
    * memory is not freed.

 /*Call this only o",Useful
/*reset for next time*/,"-10. {
-9. #  ifdef PNG_WRITE_PNG_SUPPORTED
-8.       display_clean_write(dp);
-7. #  endif
-6.    display_clean_read(dp);
-5.    dp->original_rowbytes = 0;
-4.    dp->original_rows = NULL;
-3.    dp->chunks = 0;
-2.    png_destroy_read_struct(&dp->origin",Useful
/*Release any memory held in the display.*/,"-4. }
-3. static void
-2. display_destroy(struct display *dp)
-1. {

 /*Release any memory held in the display.*/

1. #  ifdef PNG_WRITE_PNG_SUPPORTED
2.       buffer_destroy(&dp->written_file);
3. #  endif
4.    buffer_destroy(&dp->original_file);
5. }
6",Useful
/*The display pointer is always stored in the png_struct error pointer*/,"-7. #  ifdef PNG_WRITE_PNG_SUPPORTED
-6.       buffer_destroy(&dp->written_file);
-5. #  endif
-4.    buffer_destroy(&dp->original_file);
-3. }
-2. static struct display *
-1. get_dp(png_structp pp)

 /*The display pointer is always stored in the png_stru",Useful
"/*Required to quiet GNUC warnings when the compiler sees a stdarg function
    * that calls one of the stdio v APIs.*/","-2. #ifdef __GNUC__
-1. #  define VGATTR __attribute__((__format__ (__printf__,3,4)))
   /* Required to quiet GNUC warnings when the compiler sees a stdarg function
    * that calls one of the stdio v APIs.

 /*Required to quiet GNUC warnings when the com",Useful
"/*level' is as above, fmt is a stdio style format string.  This routine
    * does not return if level is above LIBPNG_WARNING*/","-5. #else
-4. #  define VGATTR
-3. #endif
-2. static void VGATTR
-1. display_log(struct display *dp, error_level level, const char *fmt, ...)
   /* 'level' is as above, fmt is a stdio style format string.  This routine
    * does not return if level is ab",Useful
/*anything unexpected is an internal error:*/,"-10.       switch (level)
-9.       {
-8.          case INFORMATION:    lp = ""information""; break;
-7.          case LIBPNG_WARNING: lp = ""warning(libpng)""; break;
-6.          case APP_WARNING:    lp = ""warning(pngimage)""; break;
-5.          case APP_FA",Useful
/*else do not output any message*/,"-10.          }
-9.          else
-8.             fprintf(stderr, ""(%s)"", transform_name(tr));
-7.       }
-6.       fprintf(stderr, "": "");
-5.       va_start(ap, fmt);
-4.       vfprintf(stderr, fmt, ap);
-3.       va_end(ap);
-2.       fputc('\n', stder",Useful
/*Errors cause this routine to exit to the fail code*/,"-10.          else
-9.             fprintf(stderr, ""(%s)"", transform_name(tr));
-8.       }
-7.       fprintf(stderr, "": "");
-6.       va_start(ap, fmt);
-5.       vfprintf(stderr, fmt, ap);
-4.       va_end(ap);
-3.       fputc('\n', stderr);
-2.    }

 ",Useful
/*error handler callbacks for libpng*/,"-3.    if (level > APP_FAIL || (level > ERRORS && !(dp->options & CONTINUE)))
-2.       longjmp(dp->error_return, level);
-1. }

 /*error handler callbacks for libpng*/

1. static void PNGCBAPI
2. display_warning(png_structp pp, png_const_charp warning)
3",Useful
/*Move to the next buffer:*/,"-4.          break;
-3.       }
-2.       else if (read_count >= sizeof last->buffer)
-1.       {

 /*Move to the next buffer:*/

1.          last = last->next;
2.          read_count = 0;",Useful
/*And do a sanity check (the EOF case is caught above)*/,"-3.          last = last->next;
-2.          read_count = 0;

 /*And do a sanity check (the EOF case is caught above)*/

1.          if (last == NULL)
2.          {
3.             display_log(dp, INTERNAL_ERROR, ""damaged buffer list"");",Useful
"/*This cleans out any previous read and sets operation and transforms to
    * empty.*/","-10. read_function(png_structp pp, png_bytep data, png_size_t size)
-9. {
-8.    buffer_read(get_dp(pp), get_buffer(pp), data, size);
-7. }
-6. static void
-5. read_png(struct display *dp, struct buffer *bp, const char *operation,
-4.    int transforms)
-",Useful
"/*The png_read_png API requires us to make the info struct, but it does the
    * call to png_read_info.*/","-8.    {
-7.       dp->operation = operation;
-6.       dp->transforms = transforms;
-5.    }
-4.    dp->read_pp = pp = png_create_read_struct(PNG_LIBPNG_VER_STRING, dp,
-3.       display_error, display_warning);
-2.    if (pp == NULL)
-1.       display_l",Useful
"/*called once after the first read to update all the info, original_pp and
    * original_ip must have been filled in.*/","-10.       char c = ' ';
-9.       fprintf(stderr, ""%.4x %2d (%3lu bytes):"", transforms, png_get_bit_depth(pp,ip), (unsigned long)rb);
-8.       for (cb=0; cb<rb; ++cb)
-7.          fputc(c, stderr), fprintf(stderr, ""%.2x"", pr[cb]), c='.';
-6.       fputc",Useful
"/*active' transforms are discovered based on the original image format;
    * running one active transform can activate others.  At present the code
    * does not attempt to determine the closure.*/","-8.       display_log(dp, LIBPNG_BUG, ""png_read_png did not set IDAT flag"");
-7.    dp->original_rows = png_get_rows(pp, ip);
-6.    if (dp->original_rows == NULL)
-5.       display_log(dp, LIBPNG_BUG, ""png_read_png did not create row buffers"");
-4.    if",Useful
"/*Some transforms appear multiple times in the table; the 'active' status
       * is the logical OR of these and the inactive status must be adjusted to
       * take this into account.*/","-10.                (transform_info[i].valid_chunks & chunks) != 0) &&
-9.             (transform_info[i].color_mask_required & ct) ==
-8.                transform_info[i].color_mask_required &&
-7.             (transform_info[i].color_mask_absent & ct) =",Useful
/*e' remains set to the name of the last thing changed:*/,"-7.    C(width);
-6.    C(height);
-5.    C(bit_depth);
-4.    C(color_type);
-3.    C(interlace_method);
-2.    C(compression_method);
-1.    C(filter_method);

 /*e' remains set to the name of the last thing changed:*/

1.    if (e)
2.       display_log",Useful
"/*All the chunks from the original PNG should be preserved in the output PNG
    * because the PNG format has not been changed.*/","-2.    if (e)
-1.       display_log(dp, APP_ERROR, ""IHDR changed (%s)"", e);
   /* All the chunks from the original PNG should be preserved in the output PNG
    * because the PNG format has not been changed.

 /*All the chunks from the original PNG should",Useful
"/*NOTE: on 64-bit systems this may trash the top bits of rowbytes,
    * which could lead to weird error messages.*/","-1.    rowbytes = png_get_rowbytes(dp->read_pp, dp->read_ip);
   /* NOTE: on 64-bit systems this may trash the top bits of rowbytes,
    * which could lead to weird error messages.

 /*NOTE: on 64-bit systems this may trash the top bits of rowbytes,
    *",Useful
"/*The rows should be the same too, unless the applied transforms includes
    * the shift transform, in which case low bits may have been lost.*/","-3.    if (rowbytes != dp->original_rowbytes)
-2.       display_log(dp, APP_ERROR, ""PNG rowbytes changed from %lu to %lu"",
-1.          (unsigned long)dp->original_rowbytes, (unsigned long)rowbytes);
   /* The rows should be the same too, unless the appli",Useful
/*mask (if not zero) for the final byte*/,"-2.    {
-1.       png_bytepp rows = png_get_rows(dp->read_pp, dp->read_ip);

 /*mask (if not zero) for the final byte*/

1.       if (bit_depth < 8)
2.       {",Useful
"/*Need the stray bits at the end, this depends only on the low bits
          * of the image width; overflow does not matter.  If the width is an
          * exact multiple of 8 bits this gives a mask of 0, not 0xff.*/","-2.       if (bit_depth < 8)
-1.       {
         /* Need the stray bits at the end, this depends only on the low bits
          * of the image width; overflow does not matter.  If the width is an
          * exact multiple of 8 bits this gives a mask of ",Useful
/*don't keep reporting failed rows on 'continue'*/,"-5.                for (x=0; x<rowbytes-1; ++x) if (row[x] != orig[x])
-4.                   break;
-3.                display_log(dp, APP_FAIL,
-2.                   ""byte(%lu,%lu) changed 0x%.2x -> 0x%.2x"",
-1.                   (unsigned long)x, (unsig",Useful
/*components are up to 8 bytes in size*/,"-8.             }
-7.          }
-6.       }
-5.       else
-4. #     ifdef PNG_sBIT_SUPPORTED
-3.       {
-2.          unsigned long y;

 /*components are up to 8 bytes in size*/

1.          png_byte sig_bits[8];
2.          png_color_8p sBIT;
3.       ",Useful
"/*libpng should catch this; if not there is a security issue
                * because an app (like this one) may overflow an array. In fact
                * libpng doesn't catch this at present.*/","-7.                bpp = 0;
-6.                break;
-5.          }
-4.          {
-3.             int b;
-2.             for (b=0; 8*b<bpp; ++b)
-1.             {
               /* libpng should catch this; if not there is a security issue
             ",Useful
"/*sanity check; this is a grayscale PNG; something is wrong in the
             * code above.*/","-7.                   display_log(dp, LIBPNG_BUG,
-6.                      ""invalid sBIT[%u]  value %d returned for PNG bit depth %d"",
-5.                      b, sig_bits[b], bit_depth);
-4.             }
-3.          }
-2.          if (bpp < 8 && bpp !=",Useful
"/*Convert bpp to bytes; this gives '1' for low-bit depth grayscale,
          * where there are multiple pixels per byte.*/","-8.                b = 0xf & ((0xf << 4) >> sig_bits[0]);
-7.                b |= b << 4;
-6.                sig_bits[0] = (png_byte)b;
-5.                break;
-4.             default:
-3.                display_log(dp, LIBPNG_BUG, ""invalid bit depth %d",Useful
"/*Generic write function used both from the write callback provided to
    * libpng and from the generic read code.*/","-5. }
-4. #ifdef PNG_WRITE_PNG_SUPPORTED
-3. static void
-2. buffer_write(struct display *dp, struct buffer *buffer, png_bytep data,
-1.    png_size_t size)
   /* Generic write function used both from the write callback provided to
    * libpng and from t",Useful
"/*Write the data into the buffer, adding buffers as required*/","-1. {

 /*Write the data into the buffer, adding buffers as required*/

1.    struct buffer_list *last = buffer->last;
2.    size_t end_count = buffer->end_count;
3.    while (size > 0)
4.    {
5.       size_t avail;
6.       if (end_count >= sizeof last-",Useful
/*avoid the need to rewrite every time*/,"-10.       if (end_count >= sizeof last->buffer)
-9.       {
-8.          if (last->next == NULL)
-7.          {
-6.             last = buffer_extend(last);
-5.             if (last == NULL)
-4.                display_log(dp, APP_ERROR, ""out of memory sav",Useful
"/*Clean it on the way out - if control returns to the caller then the
    * written_file contains the required data.*/","
   /* Clean it on the way out - if control returns to the caller then the
    * written_file contains the required data.



 /*Clean it on the way out - if control returns to the caller then the
    * written_file contains the required data.*/

1.     */
2.    display_clean_write(dp);
3. }",Useful
/*Helper to test for a bad combo and log it if it is skipped*/,"-2. static int
-1. skip_transform(struct display *dp, int tr)

 /*Helper to test for a bad combo and log it if it is skipped*/

1. {
2.    if ((dp->options & SKIP_BUGS) != 0 && is_bad_combo(tr))
3.    {",Useful
"/*Log this to stdout if logging is on, otherwise just do an information
       * display_log.*/","-3. {
-2.    if ((dp->options & SKIP_BUGS) != 0 && is_bad_combo(tr))
-1.    {
      /* Log this to stdout if logging is on, otherwise just do an information
       * display_log.

 /*Log this to stdout if logging is on, otherwise just do an information
  ",Useful
"/*First cache the file and update the display original file
    * information for the new file.*/","-4. }
-3. static void
-2. test_one_file(struct display *dp, const char *filename)
-1. {
   /* First cache the file and update the display original file
    * information for the new file.

 /*First cache the file and update the display original file
    *",Useful
"/*First test: if there are options that should be ignored for this file
    * verify that they really are ignored.*/","-4.    dp->operation = ""cache file"";
-3.    dp->transforms = 0;
-2.    display_cache_file(dp, filename);
-1.    update_display(dp);
   /* First test: if there are options that should be ignored for this file
    * verify that they really are ignored.

 /*",Useful
"/*Second test: write the original PNG data out to a new file (to test the
    * write side) then read the result back in and make sure that it hasn't
    * changed.*/","-2.    }
-1. #ifdef PNG_WRITE_PNG_SUPPORTED
   /* Second test: write the original PNG data out to a new file (to test the
    * write side) then read the result back in and make sure that it hasn't
    * changed.

 /*Second test: write the original PNG da",Useful
"/*Third test: the active options.  Test each in turn, or, with the
    * EXHAUSTIVE option, test all possible combinations.*/","-2.       return;
-1. #endif
   /* Third test: the active options.  Test each in turn, or, with the
    * EXHAUSTIVE option, test all possible combinations.

 /*Third test: the active options.  Test each in turn, or, with the
    * EXHAUSTIVE option, test",Useful
"/*Use unsigned int here because the code below to increment through all
       * the possibilities exhaustively has to use a compare and that must be
       * unsigned, because some transforms are negative on a 16-bit system.*/","-1.    {
      /* Use unsigned int here because the code below to increment through all
       * the possibilities exhaustively has to use a compare and that must be
       * unsigned, because some transforms are negative on a 16-bit system.

 /*Use unsig",Useful
"/*If this involved any irreversible transformations then if we write
          * it out with just the reversible transformations and read it in again
          * with the same transforms we should get the same thing.  At present
          * this isn't done - it just seems like a waste of time and it would
          * require two sets of read png_struct/png_info.
          *
          * If there were no irreversible transformations then if we write it
          * out and read it back in again (without the reversible transforms)
          * we should get back to the place where we started.*/","-3.       for (;;)
-2.       {
-1.          read_png(dp, &dp->original_file, ""active transforms"", current);
         /* If this involved any irreversible transformations then if we write
          * it out with just the reversible transformations and read",Useful
"/*All transforms reversible: write the PNG with the transformations
             * reversed, then read it back in with no transformations.  The
             * result should be the same as the original apart from the loss of
             * low order bits because of the SHIFT/sBIT transform.*/","-10.           * this isn't done - it just seems like a waste of time and it would
-9.           * require two sets of read png_struct/png_info.
-8.           *
-7.           * If there were no irreversible transformations then if we write it
-6.         ",Useful
"/*And if this is read back in, because all the transformations were
             * reversible, the result should be the same.*/","-2.             dp->operation = ""reversible transforms"";
-1.             write_png(dp, dp->read_ip, current);
            /* And if this is read back in, because all the transformations were
             * reversible, the result should be the same.

 /*An",Useful
"/*This set of transforms failed.  If a single bit is set - if
                * there is just one transform - don't include this in further
                * 'exhaustive' tests.  Notice that each transform is tested on
                * its own before testing combos in the exhaustive case.*/","-1.             {
               /* This set of transforms failed.  If a single bit is set - if
                * there is just one transform - don't include this in further
                * 'exhaustive' tests.  Notice that each transform is tested on
  ",Useful
"/*skip known bad combos if the relevant option is set; skip
                * combos involving known bad single transforms in all cases.*/","-2.                   goto combo;
-1.                ++next;
            }  /* skip known bad combos if the relevant option is set; skip
                * combos involving known bad single transforms in all cases.

 /*skip known bad combos if the relevant",Useful
/*one at a time*/,"-5.                   || (next & bad_transforms) != 0
-4.                   || skip_transform(dp, next));
-3.             assert((next & read_transforms) == next);
-2.             current = next;
-1.          }

 /*one at a time*/

1.          {
2.       ",Useful
"/*bad_combos identifies the combos that occur in all failing cases;
          * bad_combo_list identifies transforms that do not prevent the
          * failure.*/","-10.          {
-9.             active &= ~current;
-8.             if (active == 0)
-7.                goto combo;
-6.             current = first_transform(active);
-5.          }
-4.       }
-3. combo:
-2.       if (dp->options & FIND_BAD_COMBOS)
-1.  ",Useful
/*For each file on the command line test it with a range of transforms*/,"-6.       display_log(dp, INTERNAL_ERROR, ""unexpected return code %d"", ret);
-5.    return ret;
-4. }
-3. int
-2. main(const int argc, const char * const * const argv)
-1. {

 /*For each file on the command line test it with a range of transforms*/

1.   ",Useful
/*abort on user or internal error*/,"-8.    }
-7.    {
-6.       int i;
-5.       int errors = 0;
-4.       for (i=option_end; i<argc; ++i)
-3.       {
-2.          {
-1.             int ret = do_test(&d, argv[i]);

 /*abort on user or internal error*/

1.                return 99;
2.       ",Useful
"/*Here on any return, including failures, except user/internal issues*/","-2.                return 99;
-1.          }
         /* Here on any return, including failures, except user/internal issues

 /*Here on any return, including failures, except user/internal issues*/

1.           */
2.          {
3.             const int ",Useful
/*Release allocated memory*/,"-10.             {
-9.                int j;
-8.                printf(""%s: pngimage "", pass ? ""PASS"" : ""FAIL"");
-7.                for (j=1; j<option_end; ++j) if (j != ilog)
-6.                   printf(""%s "", argv[j]);
-5.                printf(""%s\n"",",Useful
"/*Write the data to whatever output you are using.  The default routine
 * writes to a file pointer.  Note that this routine sometimes gets called
 * with very small lengths, so you should implement some kind of simple
 * buffering if you are using unbuffered writes.  This should never be asked
 * to write more than 64K on a 16-bit machine.*/",#NAME?,Useful
/*NOTE: write_data_fn must not change the buffer!*/,"-2. png_write_data(png_structrp png_ptr, png_const_bytep data, png_size_t length)
-1. {

 /*NOTE: write_data_fn must not change the buffer!*/

1.    if (png_ptr->write_data_fn != NULL )
2.       (*(png_ptr->write_data_fn))(png_ptr, png_constcast(png_bytep",Useful
"/*This is the function that does the actual writing of data.  If you are
 * not writing to a standard C stream, you should create a replacement
 * write_data function and use it at run time with png_set_write_fn(), rather
 * than changing the library.*/","-7.    if (png_ptr->write_data_fn != NULL )
-6.       (*(png_ptr->write_data_fn))(png_ptr, png_constcast(png_bytep,data),
-5.           length);
-4.    else
-3.       png_error(png_ptr, ""Call to NULL write function"");
-2. }
-1. #ifdef PNG_STDIO_SUPPORTED
",Useful
"/*This function is called to output any data pending writing (normally
 * to disk).  After png_flush is called, there should be no data pending
 * writing in any buffers.*/","-10. png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-9. {
-8.    png_size_t check;
-7.    if (png_ptr == NULL)
-6.       return;
-5.    check = fwrite(data, 1, length, (png_FILE_p)(png_ptr->io_ptr));
-4.    if (check != len",Useful
"/*This function allows the application to supply new output functions for
 * libpng if standard C streams aren't being used.
 *
 * This function takes as its arguments:
 * png_ptr       - pointer to a png output data structure
 * io_ptr        - pointer to user supplied structure containing info about
 *                 the output functions.  May be NULL.
 * write_data_fn - pointer to a new output function that takes as its
 *                 arguments a pointer to a png_struct, a pointer to
 *                 data to be written, and a 32-bit unsigned int that is
 *                 the number of bytes to be written.  The new write
 *                 function should call png_error(png_ptr, ""Error msg"")
 *                 to exit and output any fatal error messages.  May be
 *                 NULL, in which case libpng's default function will
 *                 be used.
 * flush_data_fn - pointer to a new flush function that takes as its
 *                 arguments a pointer to a png_struct.  After a call to
 *                 the flush function, there should be no data in any buffers
 *                 or pending transmission.  If the output method doesn't do
 *                 any buffering of output, a function prototype must still be
 *                 supplied although it doesn't have to do anything.  If
 *                 PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
 *                 time, output_flush_fn will be ignored, although it must be
 *                 supplied for compatibility.  May be NULL, in which case
 *                 libpng's default function will be used, if
 *                 PNG_WRITE_FLUSH_SUPPORTED is defined.  This is not
 *                 a good idea if io_ptr does not point to a standard
 *                 *FILE structure.*/","-10. png_default_flush(png_structp png_ptr)
-9. {
-8.    png_FILE_p io_ptr;
-7.    if (png_ptr == NULL)
-6.       return;
-5.    io_ptr = png_voidcast(png_FILE_p, (png_ptr->io_ptr));
-4.    fflush(io_ptr);
-3. }
-2. #  endif
-1. #endif
/* This function al",Useful
/*It is an error to read while writing a png file*/,"-1. #ifdef PNG_READ_SUPPORTED

 /*It is an error to read while writing a png file*/

1.    if (png_ptr->read_data_fn != NULL)
2.    {
3.       png_ptr->read_data_fn = NULL;
4.       png_warning(png_ptr,
5.           ""Can't set both read_data_fn and write_",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd,",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd,",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd,",Useful
/*READ_INT_FUNCTIONS*/,"-5.    if (png_ptr != NULL)
-4.       png_warning(png_ptr, ""PNG fixed point integer out of range"");
-3.    return PNG_FIXED_ERROR;
-2. }
-1. #endif
#ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED

/*READ_INT_FUNCTIONS*/

 ",Not Useful
/*Put the chunk name into png_ptr->chunk_name.*/,"-2.    png_read_data(png_ptr, buf, 8);
-1.    length = png_get_uint_31(png_ptr, buf);

/*Put the chunk name into png_ptr->chunk_name.*/

1.    png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(buf+4);
2.    png_debug2(0, ""Reading %lx chunk, length = %lu"",
3.   ",Not Useful
/*critical*/,"-8. png_crc_read(png_structrp png_ptr, png_bytep buf, png_uint_32 length)
-7. {
-6.    if (png_ptr == NULL)
-5.       return;
-4.    png_read_data(png_ptr, buf, length);
-3.    png_calculate_crc(png_ptr, buf, length);
-2. }
-1. /* Optionally skip data and",Not Useful
/*READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ*/,"-9.       {
-8.          if (warn != 0)
-7.              png_chunk_warning(png_ptr, ""insufficient memory to read chunk"");
-6.          else
-5.              png_chunk_error(png_ptr, ""insufficient memory to read chunk"");
-4.       }
-3.    }
-2.    return ",Not Useful
/*ZLIB_VERNUM >= 0x1240*/,"#if ZLIB_VERNUM >= 0x1240

/*ZLIB_VERNUM >= 0x1240*/

1.       int window_bits = 0;
2. # if defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_MAXIMUM_INFLATE_WINDOW)
3.       if (((png_ptr->options >> PNG_MAXIMUM_INFLATE_WINDOW) & 3) ==
4.           PNG_OPTION_ON)
5.       {
6.          window_bits = 15;",Not Useful
/*Zlib >= 1.2.4*/,"-10.    {
-9.       if ((*png_ptr->zstream.next_in >> 4) > 7)
-8.       {
-7.          png_ptr->zstream.msg = ""invalid window size (libpng)"";
-6.          return Z_DATA_ERROR;
-5.       }
-4.       png_ptr->zstream_start = 0;
-3.    }
-2.    return inflat",Not Useful
/*safe: < than ZLIB_IO_MAX*/,"-2.          avail = ZLIB_IO_MAX;
-1.          if (avail_in < avail)

/*safe: < than ZLIB_IO_MAX*/

1.          avail_in -= avail;
2.          png_ptr->zstream.avail_in = avail;",Not Useful
/*safe: < ZLIB_IO_MAX*/,"-5.             png_ptr->zstream.next_out = local_buffer;
-4.             if ((sizeof local_buffer) < avail)
-3.                avail = (sizeof local_buffer);
-2.          }
-1.          if (avail_out < avail)

/*safe: < ZLIB_IO_MAX*/

1.          png_ptr",Not Useful
/*zlib inflate call*/,"-2.          png_ptr->zstream.avail_out = avail;
-1.          avail_out -= avail;

/*zlib inflate call*/

 ",Not Useful
/*finish*/,"png_crc_finish(png_structrp png_ptr, png_uint_32 skip)

/*finish*/

1. {",Not Useful
/*finish*/,"png_crc_finish(png_structrp png_ptr, png_uint_32 skip)

/*finish*/

1. {",Not Useful
/*impossible!*/,"-2.          png_ptr->zowner = 0;
-1.       }

/*impossible!*/

1.          ret = PNG_UNEXPECTED_ZLIB_RETURN;
2.       return ret;
3.    }
4.    else
5.    {",Not Useful
/*READ_zTXt || READ_iTXt*/,"-4.       png_zstream_error(png_ptr, Z_MEM_ERROR);
-3.       return Z_MEM_ERROR;
-2.    }
-1. }

/*READ_zTXt || READ_iTXt*/

 ",Not Useful
/*READ_iCCP*/,"-9.    png_read_data(png_ptr, crc_bytes, 4);
-8.    if (need_crc != 0)
-7.    {
-6.       crc = png_get_uint_32(crc_bytes);
-5.       return ((int)(crc != png_ptr->crc));
-4.    }
-3.    else
-2.       return (0);
-1. }
#if defined(PNG_READ_iCCP_SUPPORTED",Not Useful
"/*invalid, png_set_IHDR calls png_error*/","-2.    switch (png_ptr->color_type)
-1.    {

/*invalid, png_set_IHDR calls png_error*/

1.       case PNG_COLOR_TYPE_GRAY:
2.       case PNG_COLOR_TYPE_PALETTE:
3.          png_ptr->channels = 1;
4.          break;
5.       case PNG_COLOR_TYPE_RGB:
6.   ",Not Useful
"/*Otherwise, we (optionally) emit a warning and use the chunk.*/","-10.        * chunk type to determine whether to check the ancillary or the critical
-9.        * flags.
-8.        */
-7.       if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE) == 0)
-6.       {
-5.          if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_",Not Useful
/*prefer cHRM values*/,"-10.       return;
-9.    if ((png_ptr->colorspace.flags & PNG_COLORSPACE_FROM_cHRM) != 0)
-8.    {
-7.       png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;
-6.       png_colorspace_sync(png_ptr, info_ptr);
-5.       png_chunk_benign_error(png_ptr, ",Not Useful
/*READ_sRGB*/,"-3.    png_colorspace_sync(png_ptr, info_ptr);
-2. }
-1. #endif
#ifdef PNG_READ_sRGB_SUPPORTED

/*READ_sRGB*/

 ",Not Useful
/*finish*/,"png_crc_finish(png_structrp png_ptr, png_uint_32 skip)

/*finish*/

1. {",Not Useful
/*steal*/,"-10.                                        info_ptr->iccp_name = png_voidcast(char*,
-9.                                            png_malloc_base(png_ptr,
-8.                                            keyword_length+1));
-7.                           ",Not Useful
/*profile truncated*/,"-1.                            }

/*profile truncated*/

1.                               errmsg = png_ptr->zstream.msg;
2.                         }
3.                         else
4.                            errmsg = ""out of memory"";
5.               ",Not Useful
/*profile truncated*/,"-1.                            }

/*profile truncated*/

1.                               errmsg = png_ptr->zstream.msg;
2.                         }
3.                         else
4.                            errmsg = ""out of memory"";
5.               ",Not Useful
/*png_inflate_claim failed*/,"-2.                png_ptr->zowner = 0;
-1.             }

/*png_inflate_claim failed*/

1.                errmsg = png_ptr->zstream.msg;
2.          }
3.          else",Not Useful
/*or missing*/,"-3.                errmsg = png_ptr->zstream.msg;
-2.          }
-1.          else

/*or missing*/

1.       }
2.       else
3.          errmsg = ""bad keyword"";
4.    }
5.    else
6.       errmsg = ""too many profiles"";",Not Useful
/*READ_iCCP*/,"-9.    png_read_data(png_ptr, crc_bytes, 4);
-8.    if (need_crc != 0)
-7.    {
-6.       crc = png_get_uint_32(crc_bytes);
-5.       return ((int)(crc != png_ptr->crc));
-4.    }
-3.    else
-2.       return (0);
-1. }
#if defined(PNG_READ_iCCP_SUPPORTED",Not Useful
"/*This must fit in a png_uint_32 because it is derived from the original
    * chunk data length.*/","-7.    if (length < 2U || entry_start > buffer + (length - 2U))
-6.    {
-5.       png_warning(png_ptr, ""malformed sPLT chunk"");
-4.       return;
-3.    }
-2.    new_palette.depth = *entry_start++;
-1.    entry_size = (new_palette.depth == 8 ? 6 : 10);
 ",Not Useful
/*READ_sPLT*/,"-10.    if (need_crc != 0)
-9.    {
-8.       crc = png_get_uint_32(crc_bytes);
-7.       return ((int)(crc != png_ptr->crc));
-6.    }
-5.    else
-4.       return (0);
-3. }
-2. #if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||",Not Useful
/*Read the sCAL chunk*/,"-10.          png_chunk_benign_error(png_ptr, ""invalid data"");
-9.          return;
-8.       }
-7.    }
-6.    png_set_pCAL(png_ptr, info_ptr, (png_charp)buffer, X0, X1, type, nparams,
-5.        (png_charp)units, params);
-4.    png_free(png_ptr, params",Not Useful
/*warn*/,"-10. png_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)
-9. {
-8.    png_uint_32 uval = png_get_uint_32(buf);
-7.    if (uval > PNG_UINT_31_MAX)
-6.       png_error(png_ptr, ""PNG unsigned integer out of range"");
-5.    return (uval);
-4. }
-",Not Useful
/*warn*/,"-10. png_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)
-9. {
-8.    png_uint_32 uval = png_get_uint_32(buf);
-7.    if (uval > PNG_UINT_31_MAX)
-6.       png_error(png_ptr, ""PNG unsigned integer out of range"");
-5.    return (uval);
-4. }
-",Not Useful
/*Now the language tag*/,"-10.     */
-9.    else if (prefix_length + 5 > length)
-8.       errmsg = ""truncated"";
-7.    else if (buffer[prefix_length+1] == 0 ||
-6.       (buffer[prefix_length+1] == 1 &&
-5.       buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))
-4.    {
-3",Not Useful
/*SAFE*/,"-10.        png_ptr->user_chunk_malloc_max < limit)
-9.       limit = png_ptr->user_chunk_malloc_max;
-8. #  elif PNG_USER_CHUNK_MALLOC_MAX > 0
-7.    if (PNG_USER_CHUNK_MALLOC_MAX < limit)
-6.       limit = PNG_USER_CHUNK_MALLOC_MAX;
-5. #  endif
-4.    ",Not Useful
/*SAFE*/,"-10.        png_ptr->user_chunk_malloc_max < limit)
-9.       limit = png_ptr->user_chunk_malloc_max;
-8. #  elif PNG_USER_CHUNK_MALLOC_MAX > 0
-7.    if (PNG_USER_CHUNK_MALLOC_MAX < limit)
-6.       limit = PNG_USER_CHUNK_MALLOC_MAX;
-5. #  endif
-4.    ",Not Useful
/*This is benign because we clean up correctly*/,"-6.          png_ptr->unknown_chunk.data = png_voidcast(png_bytep,
-5.              png_malloc_warn(png_ptr, length));
-4.       }
-3.    }
-2.    if (png_ptr->unknown_chunk.data == NULL && length > 0)
-1.    {

/*This is benign because we clean up correc",Not Useful
/*READ_UNKNOWN_CHUNKS*/,"-10.          if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)
-9.             errmsg = ""insufficient memory"";
-8.       }
-7.    }
-6.    else
-5.       errmsg = ""bad compression info"";
-4.    if (errmsg != NULL)
-3.       png_chunk_benign_error(png",Not Useful
/*with keep = PNG_HANDLE_CHUNK_IF_SAFE*/,"-10.              */
-9.             if (keep < PNG_HANDLE_CHUNK_IF_SAFE)
-8.             {
-7. #              ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
-6.                if (png_ptr->unknown_default < PNG_HANDLE_CHUNK_IF_SAFE)
-5.                {
-4.     ",Not Useful
/*Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk*/,"-2.    }
-1.    else

/*Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk*/

 ",Not Useful
/*READ_USER_CHUNKS*/,"
#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED



/*READ_USER_CHUNKS*/

 ",Not Useful
/*FALLTHROUGH*/,"-10.    if (keep == PNG_HANDLE_CHUNK_ALWAYS ||
-9.       (keep == PNG_HANDLE_CHUNK_IF_SAFE &&
-8.        PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))
-7.    {
-6. #     ifdef PNG_USER_LIMITS_SUPPORTED
-5.       switch (png_ptr->user_chunk_cache_max)
-4.    ",Not Useful
/*FALLTHROUGH*/,"-10.    if (keep == PNG_HANDLE_CHUNK_ALWAYS ||
-9.       (keep == PNG_HANDLE_CHUNK_IF_SAFE &&
-8.        PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))
-7.    {
-6. #     ifdef PNG_USER_LIMITS_SUPPORTED
-5.       switch (png_ptr->user_chunk_cache_max)
-4.    ",Not Useful
/*no limit*/,"-2.             --(png_ptr->user_chunk_cache_max);

/*no limit*/

 ",Not Useful
/*USER_LIMITS*/,"-1.    png_alloc_size_t limit = PNG_SIZE_MAX;
# ifdef PNG_SET_USER_LIMITS_SUPPORTED

/*USER_LIMITS*/

1.    if (png_ptr->user_chunk_malloc_max > 0 &&
2.        png_ptr->user_chunk_malloc_max < limit)
3.       limit = png_ptr->user_chunk_malloc_max;
4. # e",Not Useful
/*!PNG_READ_UNKNOWN_CHUNKS_SUPPORTED*/,"-3.    if (png_ptr->unknown_chunk.data != NULL)
-2.       png_free(png_ptr, png_ptr->unknown_chunk.data);
-1.    png_ptr->unknown_chunk.data = NULL;

/*!PNG_READ_UNKNOWN_CHUNKS_SUPPORTED*/

 ",Not Useful
/*!READ_UNKNOWN_CHUNKS*/,"-3.    png_crc_finish(png_ptr, length);
-2.    PNG_UNUSED(info_ptr)
-1.    PNG_UNUSED(keep)

/*!READ_UNKNOWN_CHUNKS*/

 ",Not Useful
/*zlib+deflate overhead*/,"-10.    {
-9.       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
-8.       size_t row_factor =
-7.          (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)
-6.           + 1 + (png_ptr->interlaced? 6: 0));
-5.       if (png_ptr->hei",Not Useful
/*PACKSWAP*/,"-2.       end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;
-1.       end_byte = *end_ptr;
#     ifdef PNG_READ_PACKSWAP_SUPPORTED

/*PACKSWAP*/

1.       if ((png_ptr->transformations & PNG_PACKSWAP) != 0)",Not Useful
/*depth*/,"-4. png_handle_IHDR(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
-3. {
-2.    png_byte buf[13];
-1.    png_uint_32 width, height;
   int bit_depth, color_type, compression_type, filter_type;

/*depth*/

1.    int interlace_type;
2.    pn",Not Useful
/*!PNG_USE_COMPILE_TIME_MASKS*/,"-5.             { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }
-4.          };
-3. #        define MASK(pass,depth,display,png)\
-2.             ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\
-1.                row_mask[png][DEPTH_INDEX(depth)]",Not Useful
/*!USE_COMPILE_TIME_MASKS*/,"-2. #        define MASK(pass,depth,display,png)\
-1.             ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))

/*!USE_COMPILE_TIME_MASKS*/

 ",Not Useful
/*something to copy*/,"-1.             m &= 0xff;

/*something to copy*/

1.             {
2.                if (m != 0xff)
3.                   *dp = (png_byte)((*dp & ~m) | (*sp & m));
4.                else
5.                   *dp = *sp;
6.             }",Not Useful
/*SAFE*/,"-10.        png_ptr->user_chunk_malloc_max < limit)
-9.       limit = png_ptr->user_chunk_malloc_max;
-8. #  elif PNG_USER_CHUNK_MALLOC_MAX > 0
-7.    if (PNG_USER_CHUNK_MALLOC_MAX < limit)
-6.       limit = PNG_USER_CHUNK_MALLOC_MAX;
-5. #  endif
-4.    ",Not Useful
/*ALIGN_TYPE code*/,"-8.                      dp = (png_bytep)dp16;
-7.                      sp = (png_const_bytep)sp16;
-6.                      do
-5.                         *dp++ = *sp++;
-4.                      while (--row_width > 0);
-3.                      return;
-",Not Useful
/*SAFE*/,"-10.        png_ptr->user_chunk_malloc_max < limit)
-9.       limit = png_ptr->user_chunk_malloc_max;
-8. #  elif PNG_USER_CHUNK_MALLOC_MAX > 0
-7.    if (PNG_USER_CHUNK_MALLOC_MAX < limit)
-6.       limit = PNG_USER_CHUNK_MALLOC_MAX;
-5. #  endif
-4.    ",Not Useful
/*READ_INTERLACING*/,"
#ifdef PNG_READ_INTERLACING_SUPPORTED



/*READ_INTERLACING*/

1.    if (png_ptr->interlaced != 0 &&
2.        (png_ptr->transformations & PNG_INTERLACE) != 0 &&
3.        pass < 6 && (display == 0 ||",Not Useful
/*READ_INTERLACING*/,"
#ifdef PNG_READ_INTERLACING_SUPPORTED



/*READ_INTERLACING*/

1.    if (png_ptr->interlaced != 0 &&
2.        (png_ptr->transformations & PNG_INTERLACE) != 0 &&
3.        pass < 6 && (display == 0 ||",Not Useful
/*safety*/,"
      /* Set this for safety, just in case the previous owner left pointers to



/*safety*/

1.        * memory allocations.
2.        */
3.       png_ptr->zstream.next_in = NULL;
4.       png_ptr->zstream.avail_in = 0;
5.       png_ptr->zstream.next_out = NULL;
6.       png_ptr->zstream.avail_out = 0;
7.       if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
8.       {
9. #if ZLIB_VERNUM >= 0x1240
10.          ret = inflateReset2(&png_ptr->zstream, window_bits);",Not Useful
/*SEQUENTIAL_READ*/,"-10.    {
-9.       crc = png_get_uint_32(crc_bytes);
-8.       return ((int)(crc != png_ptr->crc));
-7.    }
-6.    else
-5.       return (0);
-4. }
-3. #if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||\
-2.     defined(PNG_READ",Not Useful
/*bad signature*/,"-2.     fread(sig, 1, 8, infile);
-1.     if (png_sig_cmp(sig, 0, 8))

/*bad signature*/

 ",Not Useful
/*bit_depth == 4*/,"-10.      * bit-depth transformations, so check depth and adjust if necessary */
-9.     if (bit_depth == 16) {
-8.         *red   = pBackground->red   >> 8;
-7.         *green = pBackground->green >> 8;
-6.         *blue  = pBackground->blue  >> 8;
-5.  ",Not Useful
/*display_exponent == LUT_exponent * CRT_exponent*/,"-8.             *red = *green = *blue = (255/15) * pBackground->gray;
-7.     } else {
-6.         *red   = (uch)pBackground->red;
-5.         *green = (uch)pBackground->green;
-4.         *blue  = (uch)pBackground->blue;
-3.     }
-2.     return 0;
-1. }",Not Useful
"/*READ_PNG and WRITE_PNG were not defined, so:*/","-6. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
-5. #  define SKIP 77
-4. #else
-3. #  define SKIP 0
-2. #endif
-1. #if PNG_LIBPNG_VER < 10700

/*READ_PNG and WRITE_PNG were not defined, so:*/

1. #  ifdef PNG_INFO_IMAGE_SUPPORTED
2. #     ifdef",Not Useful
/*SEQUENTIAL_READ*/,"-1. #  ifdef PNG_INFO_IMAGE_SUPPORTED
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED

/*SEQUENTIAL_READ*/

1. #        define PNG_READ_PNG_SUPPORTED",Not Useful
/*pre 1.7.0*/,"-4. #     ifdef PNG_WRITE_SUPPORTED
-3. #        define PNG_WRITE_PNG_SUPPORTED

/*pre 1.7.0*/

1. #ifdef PNG_READ_PNG_SUPPORTED
2. /* If a transform is valid on both read and write this implies that if the
3.  * transform is applied to read it must also ",Not Useful
/*the transform was tested somewhere*/,"-4.    png_byte    when;
-3. #     define TRANSFORM_R  1
-2. #     define TRANSFORM_W  2
-1. #     define TRANSFORM_RW 3

/*the transform was tested somewhere*/

1. } transform_info[] =
2. {",Not Useful
/*!tested*/,"-3. #  define T(name,chunk,cm_required,cm_absent,bd,when)\
-2.    {  #name, PNG_TRANSFORM_ ## name, CHUNK_ ## chunk,\
-1.       COLOR_MASK_ ## cm_required, COLOR_MASK_ ## cm_absent, BD_ ## bd,\

/*!tested*/

1. #ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
2.  ",Not Useful
/*name*/,"-10.  * 6) PNG_INFO_chunk; a mask of the chunks that must be present for the
-9.  *    transform to fire.  All must be present - the requirement is that
-8.  *    png_get_valid() & mask == mask, so if mask is 0 there is no requirement.
-7.  *
-6.  * The c",Not Useful
/*!tested*/,"-3. #  define T(name,chunk,cm_required,cm_absent,bd,when)\
-2.    {  #name, PNG_TRANSFORM_ ## name, CHUNK_ ## chunk,\
-1.       COLOR_MASK_ ## cm_required, COLOR_MASK_ ## cm_absent, BD_ ## bd,\

/*!tested*/

1. #ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
2.  ",Not Useful
"/*problem, antidote*/","-2. static int known_bad_combos[][2] =
-1. {

/*problem, antidote*/

 ",Not Useful
/*antidote*/,"-2. static int known_bad_combos[][2] =
-1. {

/*antidote*/

 ",Not Useful
/*combo is ok*/,"-10. is_bad_combo(int transforms)
-9. {
-8.    unsigned int i;
-7.    for (i=0; i<ARRAY_SIZE(known_bad_combos); ++i)
-6.    {
-5.       int combo = known_bad_combos[i][0];
-4.       if ((combo & transforms) == combo &&
-3.          (transforms & known_bad",Not Useful
/*such as out-of-memory in a callback*/,"-6.    LIBPNG_WARNING,
-5.    APP_WARNING,

/*such as out-of-memory in a callback*/

 ",Not Useful
/*such as file-not-found*/,"-8.    LIBPNG_WARNING,
-7.    APP_WARNING,

/*such as file-not-found*/

1.    INTERNAL_ERROR
2. } error_level;",Not Useful
/*See display_log below*/,"-10.  * warnings (--relaxes) or nothing worse than information (--strict)
-9.  */
-8. #define RESULT_STRICT(r)   (((r) & ~((1U<<WARNINGS)-1)) == 0)
-7. #define RESULT_RELAXED(r)  (((r) & ~((1U<<ERRORS)-1)) == 0)
-6. struct display
-5. {

/*See display_log",Not Useful
/*prevents a crash*/,"-5. {
-4.    struct display *dp = (struct display*)png_get_error_ptr(pp);
-3.    if (dp == NULL)
-2.    {
-1.       fprintf(stderr, ""pngimage: internal error (no display)\n"");

/*prevents a crash*/

1.    }
2.    return dp;
3. }",Not Useful
/*NOTREACHED*/,"-10.    struct buffer_list *last = bp->current;
-9.    size_t read_count = bp->read_count;
-8.    while (size > 0)
-7.    {
-6.       size_t avail;
-5.       if (last == NULL ||
-4.          (last == bp->last && read_count >= bp->end_count))
-3.       {
-",Not Useful
/*NOTREACHED*/,"-10.    struct buffer_list *last = bp->current;
-9.    size_t read_count = bp->read_count;
-8.    while (size > 0)
-7.    {
-6.       size_t avail;
-5.       if (last == NULL ||
-4.          (last == bp->last && read_count >= bp->end_count))
-3.       {
-",Not Useful
/*no transform*/,"-8. #ifdef PNG_READ_PNG_SUPPORTED
-7. /* If a transform is valid on both read and write this implies that if the
-6.  * transform is applied to read it must also be applied on write to produce
-5.  * meaningful data.  This is because these transforms when",Not Useful
/*rowbytes should be the same*/,"-7.    {
-6.       unsigned long chunks =
-5.          png_get_valid(dp->read_pp, dp->read_ip, 0xffffffff);
-4.       if (chunks != dp->chunks)
-3.          display_log(dp, APP_FAIL, ""PNG chunks changed from 0x%lx to 0x%lx"",
-2.             (unsigned long",Not Useful
/*NOTREACHED*/,"-10.    struct buffer_list *last = bp->current;
-9.    size_t read_count = bp->read_count;
-8.    while (size > 0)
-7.    {
-6.       size_t avail;
-5.       if (last == NULL ||
-4.          (last == bp->last && read_count >= bp->end_count))
-3.       {
-",Not Useful
"/*allowed, but dumb*/","-3.                for (b=0; b*8 < bpp; ++b)
-2.                   sig_bits[b] = (png_byte)(0xff00 >> sig_bits[b]);
-1.                break;

/*allowed, but dumb*/

 ",Not Useful
/*!sBIT*/,"-1.       }

/*!sBIT*/

1.          display_log(dp, INTERNAL_ERROR,
2.                ""active shift transform but no sBIT support"");",Not Useful
/*!sBIT*/,"-1.       }

/*!sBIT*/

1.          display_log(dp, INTERNAL_ERROR,
2.                ""active shift transform but no sBIT support"");",Not Useful
/*safety*/,"-10.    buffer->end_count = end_count;
-9. }
-8. static void PNGCBAPI
-7. write_function(png_structp pp, png_bytep data, png_size_t size)
-6. {
-5.    buffer_write(get_dp(pp), get_buffer(pp), data, size);
-4. }
-3. static void
-2. write_png(struct display",Not Useful
/*flush*/,"-8.    buffer_start_write(&dp->written_file);
-7.    dp->operation = ""write"";
-6.    dp->transforms = transforms;
-5.    dp->write_pp = png_create_write_struct(PNG_LIBPNG_VER_STRING, dp,
-4.       display_error, display_warning);
-3.    if (dp->write_pp =",Not Useful
/*WRITE_PNG*/,"-6. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
-5. #  define SKIP 77
-4. #else
-3. #  define SKIP 0
-2. #endif
-1. #if PNG_LIBPNG_VER < 10700

/*WRITE_PNG*/

1. #  ifdef PNG_INFO_IMAGE_SUPPORTED
2. #     ifdef PNG_SEQUENTIAL_READ_SUPPORTED
3. #",Not Useful
/*skip*/,"-2. #endif
-1. /* 1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:

/*skip*/

1.  */
2. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
3. ",Not Useful
/*don't skip*/,"-1.    }

/*don't skip*/

1. }
2. static void
3. test_one_file(struct display *dp, const char *filename)
4. {",Not Useful
/*transforms applied*/,"-5.    if (dp->ignored_transforms != 0)
-4.    {
-3.       read_png(dp, &dp->original_file, ""ignored transforms"",
-2.          dp->ignored_transforms);

/*transforms applied*/

 ",Not Useful
/*transforms*/,"-10.  * Copyright (c) 2015,2016 John Cunningham Bowler
-9.  *
-8.  * Last changed in libpng 1.6.24 [August 4, 2016]
-7.  *
-6.  * This code is released under the libpng license.
-5.  * For conditions of distribution and use, see the disclaimer
-4.  * and ",Not Useful
/*transforms*/,"-10.  * Copyright (c) 2015,2016 John Cunningham Bowler
-9.  *
-8.  * Last changed in libpng 1.6.24 [August 4, 2016]
-7.  *
-6.  * This code is released under the libpng license.
-5.  * For conditions of distribution and use, see the disclaimer
-4.  * and ",Not Useful
/*transforms applied*/,"-5.    if (dp->ignored_transforms != 0)
-4.    {
-3.       read_png(dp, &dp->original_file, ""ignored transforms"",
-2.          dp->ignored_transforms);

/*transforms applied*/

 ",Not Useful
/*Everything tested*/,"-4.          {
-3.             unsigned int next = current;
-2.             do
-1.             {

/*Everything tested*/

1.                   goto combo;
2.                ++next;",Not Useful
/*shouldn't longjmp on warnings*/,"-7. {
-6.    int ret = setjmp(dp->error_return);
-5.    if (ret == 0)
-4.    {
-3.       test_one_file(dp, file);
-2.       return 0;
-1.    }

/*shouldn't longjmp on warnings*/

1.       display_log(dp, INTERNAL_ERROR, ""unexpected return code %d"", ret);
",Not Useful
/*!READ_PNG*/,"-4.       display_destroy(&d);
-3.       return errors != 0;
-2.    }
-1. }

/*!READ_PNG*/

1. int
2. main(void)
3. {
4.    fprintf(stderr, ""pngimage: no support for png_read/write_image\n"");
5.    return SKIP;
6. }
7. #endif",Not Useful
/*WRITE_FLUSH*/,"
#ifdef PNG_WRITE_FLUSH_SUPPORTED



/*WRITE_FLUSH*/

 ",Not Useful
/*MAIN routine*/,"-4. static char *szProgName = PROGNAME;
-3. static char *szAppName = LONGNAME;
-2. static char *szIconName = PROGNAME;
-1. static char szCmdFileName [MAX_PATH];

/*MAIN routine*/

1. int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
2.    ",Not Useful
/*WvS: don't ask me why?*/,"-6.     ixBorders = 2 * (GetSystemMetrics (SM_CXBORDER) +
-5.                      GetSystemMetrics (SM_CXDLGFRAME));
-4.     iyBorders = 2 * (GetSystemMetrics (SM_CYBORDER) +
-3.                      GetSystemMetrics (SM_CYDLGFRAME)) +
-2.               ",Not Useful
"/*CW_USEDEFAULT, CW_USEDEFAULT,*/","-2.     hwnd = CreateWindow (szProgName, szAppName,
-1.         WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,

/*CW_USEDEFAULT, CW_USEDEFAULT,*/

1.         512 + 2 * MARGIN + ixBorders, 384 + 2 * MARGIN + iyBorders,",Not Useful
/*next/previous commands*/,"-4.         if (szCmdFileName[0] != '\0')
-3.         {
-2.             strcpy (szImgPathName, szCmdFileName);

/*next/previous commands*/

1.             BuildPngList (szImgPathName, &pPngFileList, &iPngFileCount,
2.                           &iPngFileIn",Not Useful
/*show the File Open dialog box*/,"-10.         if (pbImage)
-9.             EnableMenuItem (hMenu, IDM_FILE_SAVE, MF_ENABLED);
-8.         else
-7.             EnableMenuItem (hMenu, IDM_FILE_SAVE, MF_GRAYED);
-6.         return 0;
-5.     case WM_COMMAND:
-4.         hMenu = GetMenu (hwn",Not Useful
/*next/previous commands*/,"-4.         if (szCmdFileName[0] != '\0')
-3.         {
-2.             strcpy (szImgPathName, szCmdFileName);

/*next/previous commands*/

1.             BuildPngList (szImgPathName, &pPngFileList, &iPngFileCount,
2.                           &iPngFileIn",Not Useful
/*show the File Save dialog box*/,"-4.             DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,
-3.                 pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);
-2.             return 0;
-1.         case IDM_FILE_SAVE:

/*show the File Save dialog box*/

1.      ",Not Useful
/*save the PNG to a disk file*/,"-2.             if (!PngFileSaveDlg (hwnd, szImgPathName, szTitleName))
-1.                 return 0;

/*save the PNG to a disk file*/

1.             SetCursor (LoadCursor (NULL, IDC_WAIT));
2.             ShowCursor (TRUE);
3.             bOk = PngSaveI",Not Useful
/*more cleanup needed...*/,"-5.                 DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,
-4.                     pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);
-3.             }
-2.             return 0;
-1.         case IDM_FILE_EXIT:

/*more cleanup ne",Not Useful
/*let's go ...*/,"-5.             if (pPngFileList != NULL)
-4.             {
-3.                 free (pPngFileList);
-2.                 pPngFileList = NULL;
-1.             }

/*let's go ...*/

1.             exit (0);
2.             return 0;
3.         case IDM_OPTION",Not Useful
"/*---------------
 *  CenterAbout
 *---------------*/","-1.  *  VisualPng.C -- Shows a PNG image
 *

/*---------------
 *  CenterAbout
 *---------------*/

1.  *
2.  * Copyright 2000,2017 Willem van Schaik.
3.  *
4.  * This code is released under the libpng license.
5.  * For conditions of distribution and use",Not Useful
"/*extract foldername, filename and search-name*/","-5.     if (*ppFileList != NULL)
-4.     {
-3.         free (*ppFileList);
-2.         *ppFileList = NULL;
-1.     }

/*extract foldername, filename and search-name*/

1.     strcpy (szImgPathName, pstrPathName);
2.     strcpy (szImgFileName, strrchr (pst",Not Useful
"/*----------------
 *  SearchPngList
 *----------------*/","-1.  *  VisualPng.C -- Shows a PNG image
 *

/*----------------
 *  SearchPngList
 *----------------*/

1.  *
2.  * Copyright 2000,2017 Willem van Schaik.
3.  *
4.  * This code is released under the libpng license.
5.  * For conditions of distribution and",Not Useful
/*BITMAPFILEHEADER        *pbmfh;*/,"-10.  *  DisplayImage
-9.  *----------------
-8.  */
-7. BOOL DisplayImage (HWND hwnd, BYTE **ppDib,
-6.         BYTE **ppDiData, int cxWinSize, int cyWinSize,
-5.         BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels,
-4.         BOOL bSt",Not Useful
"/*--------------
 *  InitBitmap
 *--------------*/","-1.  *  VisualPng.C -- Shows a PNG image
 *

/*--------------
 *  InitBitmap
 *--------------*/

1.  *
2.  * Copyright 2000,2017 Willem van Schaik.
3.  *
4.  * This code is released under the libpng license.
5.  * For conditions of distribution and use, s",Not Useful
"/*--------------
 *  FillBitmap
 *--------------*/","-1.  *  VisualPng.C -- Shows a PNG image
 *

/*--------------
 *  FillBitmap
 *--------------*/

1.  *
2.  * Copyright 2000,2017 Willem van Schaik.
3.  *
4.  * This code is released under the libpng license.
5.  * For conditions of distribution and use, s",Not Useful
/*calculate row-bytes*/,"-10.                 *pImg++ = g;
-9.                 *pImg++ = b;
-8.                 if (cImgChannels == 4)
-7.                 {
-6.                     a = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld)
-5.                         + 3);
-4.   ",Not Useful
/*calculate both row-bytes*/,"-4.         if (cxImgPos < MARGIN)
-3.             cxImgPos = MARGIN;
-2.         if (cyImgPos < MARGIN)
-1.             cyImgPos = MARGIN;

/*calculate both row-bytes*/

1.         wImgRowBytes = cImgChannels * cxImgSize;
2.         wDIRowBytes = (WORD) ",Not Useful
/*known to be > 0*/,"-4. static png_voidp
-3. png_malloc_array_checked(png_const_structrp png_ptr, int nelements,
-2.     size_t element_size)
-1. {

/*known to be > 0*/

1.    if (req <= PNG_SIZE_MAX/element_size)
2.       return png_malloc_base(png_ptr, req * element_size);",Not Useful
/*TEXT || sPLT || STORE_UNKNOWN_CHUNKS*/,"-1. }

/*TEXT || sPLT || STORE_UNKNOWN_CHUNKS*/

 ",Not Useful
/*USER_MEM*/,"-10. PNG_FUNCTION(png_voidp,PNGAPI
-9. png_calloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-8. {
-7.    png_voidp ret;
-6.    ret = png_malloc(png_ptr, size);
-5.    if (ret != NULL)
-4.       memset(ret, 0, size);
-3.    return ",Not Useful
/*USER_MEM*/,"-10. PNG_FUNCTION(png_voidp,PNGAPI
-9. png_calloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-8. {
-7.    png_voidp ret;
-6.    ret = png_malloc(png_ptr, size);
-5.    if (ret != NULL)
-4.       memset(ret, 0, size);
-3.    return ",Not Useful
/*USER_MEM*/,"-10. PNG_FUNCTION(png_voidp,PNGAPI
-9. png_calloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-8. {
-7.    png_voidp ret;
-6.    ret = png_malloc(png_ptr, size);
-5.    if (ret != NULL)
-4.       memset(ret, 0, size);
-3.    return ",Not Useful
/*__cplusplus*/,"
#ifdef __cplusplus



/*__cplusplus*/

1. #  define voidcast(type, value) static_cast<type>(value)
2. #  define aligncastconst(type, value) \
3.       static_cast<type>(static_cast<const void*>(value))
4. #else
5. #  define voidcast(type, value) (value)
6. #  define aligncastconst(type, value) ((const void*)(value))",Not Useful
/*not used*/,"-8. {
-7.    return u8d(255 * sRGB_from_linear(linear));
-6. }
-5. static png_byte
-4. isRGB(int fixed_linear)
-3. {
-2.    return sRGB(fixed_linear / 65535.);
-1. }

/*not used*/

1. static png_byte
2. unpremultiply(int component, int alpha)
3. {
4.    i",Not Useful
/*unused*/,"-1. #define ALLOW_UNUSED_GPC 0
   /* If true include unused static GPC functions and declare an external array

/*unused*/

1.     * of them to hide the fact that they are unused.  This is for development
2.     * use while testing the correct function to",Not Useful
/*by experiment*/,"-5.       e = 1+floor(255 * e);
-4.       return (int)e;
-3.    }
-2.    return 0;
-1. }

/*by experiment*/

1. static int
2. power_law_error16(int value)
3. {
4.    if (value > 0 && value < 65535)
5.    {",Not Useful
/*unused*/,"-1. #define ALLOW_UNUSED_GPC 0
   /* If true include unused static GPC functions and declare an external array

/*unused*/

1.     * of them to hide the fact that they are unused.  This is for development
2.     * use while testing the correct function to",Not Useful
/*All off*/,"-10. #define FORMAT_SET_COUNT (FORMAT_COUNT / 32)
-9. typedef struct
-8. {
-7.    png_uint_32 bits[FORMAT_SET_COUNT];
-6. }
-5. format_list;
-4. static void format_init(format_list *pf)
-3. {
-2.    int i;
-1.    for (i=0; i<FORMAT_SET_COUNT; ++i)

/*All ",Not Useful
/*currently unused*/,"-1. }

/*currently unused*/

1. static void format_clear(format_list *pf)
2. {
3.    int i;
4.    for (i=0; i<FORMAT_SET_COUNT; ++i)
5.       pf->bits[i] = 0;
6. }
7. #endif
8. static int format_is_initial(format_list *pf)
9. {
10.    int i;",Not Useful
/*currently unused*/,"-1. }

/*currently unused*/

1. static void format_clear(format_list *pf)
2. {
3.    int i;
4.    for (i=0; i<FORMAT_SET_COUNT; ++i)
5.       pf->bits[i] = 0;
6. }
7. #endif
8. static int format_is_initial(format_list *pf)
9. {
10.    int i;",Not Useful
/*8-bit to 8-bit conversions*/,"-10.       out->r = out->g = out->b = 65535;
-9.    else
-8.    {
-7.       out->r = in->r;
-6.       out->g = in->g;
-5.       out->b = in->b;
-4.    }
-3.    out->a = in->a;
-2. }
-1. #endif

/*8-bit to 8-bit conversions*/

 ",Not Useful
/*8-bit to 16-bit conversions*/,"-10.             sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));
-9.    }
-8.    else
-7.    {
-6.       double a = in->a/255.;
-5.       out->r = out->g = out->b = sRGB(a * YfromRGB(sRGB_to_d[in->r],
-4.          sRGB_to_d[in->g], sRGB_to_d[in->b",Not Useful
/*16-bit to 8-bit conversions*/,"-10. {
-9.    (void)back;
-8.    if (in->r == in->g && in->g == in->b)
-7.       out->r = out->g = out->b = ilineara_g22(in->g, in->a);
-6.    else
-5.       out->r = out->g = out->b = u16d(in->a * 257 *
-4.          YfromRGB(g22_to_d[in->r], g22_to_d[in-",Not Useful
/*16-bit to 16-bit conversions*/,"-10.    {
-9.       double a = in->a / 65535.;
-8.       double a1 = 1-a;
-7.       a /= 65535;
-6.       out->r = sRGB(in->r * a + back->dr * a1);
-5.       out->g = sRGB(in->g * a + back->dg * a1);
-4.       out->b = sRGB(in->b * a + back->db * a1);
-3.",Not Useful
/*in*/,"-3. /*-
-2.  * pngstest.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*in*/

1.  * Copyright (c) 2013-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see t",Not Useful
/*in*/,"-3. /*-
-2.  * pngstest.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*in*/

1.  * Copyright (c) 2013-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see t",Not Useful
/*not used*/,"-8. {
-7.    return u8d(255 * sRGB_from_linear(linear));
-6. }
-5. static png_byte
-4. isRGB(int fixed_linear)
-3. {
-2.    return sRGB(fixed_linear / 65535.);
-1. }

/*not used*/

1. static png_byte
2. unpremultiply(int component, int alpha)
3. {
4.    i",Not Useful
/*not used*/,"-8. {
-7.    return u8d(255 * sRGB_from_linear(linear));
-6. }
-5. static png_byte
-4. isRGB(int fixed_linear)
-3. {
-2.    return sRGB(fixed_linear / 65535.);
-1. }

/*not used*/

1. static png_byte
2. unpremultiply(int component, int alpha)
3. {
4.    i",Not Useful
/*(128.5 * 255 / 65535)*/,"-10.       /* 16-bit values less than 128.5 get rounded to 8-bit 0 and so the worst
-9.        * case error arises with 16-bit 128.5, work out what sRGB
-8.        * (non-associated) value generates 128.5; any value less than this is
-7.        * going to",Not Useful
/*not used*/,"-8. {
-7.    return u8d(255 * sRGB_from_linear(linear));
-6. }
-5. static png_byte
-4. isRGB(int fixed_linear)
-3. {
-2.    return sRGB(fixed_linear / 65535.);
-1. }

/*not used*/

1. static png_byte
2. unpremultiply(int component, int alpha)
3. {
4.    i",Not Useful
/*exact match*/,"-6.    {
-5.       int err_r = abs(pixel_calc.r - pixel_out.r);
-4.       int err_g = abs(pixel_calc.g - pixel_out.g);
-3.       int err_b = abs(pixel_calc.b - pixel_out.b);
-2.       int limit;
-1.       if ((err_r | err_g | err_b) == 0)

/*exact match*/",Not Useful
/*opaque*/,"-8. static int
-7. logerror(Image *image, const char *a1, const char *a2, const char *a3)
-6. {
-5.    fflush(stdout);
-4.    if (image->image.warning_or_error)
-3.       fprintf(stderr, ""%s%s%s: %s\n"", a1, a2, a3, image->image.message);
-2.    else
-1.  ",Not Useful
/*SAFE*/,"-4.          if (amax >= a->image.colormap_entries)
-3.          {
-2.             char pindex[3+2*BYTE_CHARS];
-1.             sprintf(pindex, ""%d[%u]"", amax,

/*SAFE*/

1.             return logerror(a, a->file_name, "": bad pixel index: "", pindex);
2.  ",Not Useful
/*SAFE*/,"-4.          if (amax >= a->image.colormap_entries)
-3.          {
-2.             char pindex[3+2*BYTE_CHARS];
-1.             sprintf(pindex, ""%d[%u]"", amax,

/*SAFE*/

1.             return logerror(a, a->file_name, "": bad pixel index: "", pindex);
2.  ",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.     ",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.     ",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.     ",Not Useful
/*x loop*/,"-3.                   case 1:
-2.                      if (pua[btoa[0]] != pub[0]) break;
-1.                      if (alpha_added != 4 && pub[alpha_added] != 65535) break;

/*x loop*/

1.                   default:",Not Useful
/*impossible*/,"-10.  *
-9.  * Errors in alpha should only occur when converting from a direct format
-8.  * to a colormapped format, when alpha is effectively smashed (so large
-7.  * errors can occur.)  There should be no error in the '0' and 'opaque'
-6.  * values.  T",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.     ",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.     ",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.     ",Not Useful
/*x loop*/,"-3.                   case 1:
-2.                      if (pua[btoa[0]] != pub[0]) break;
-1.                      if (alpha_added != 4 && pub[alpha_added] != 65535) break;

/*x loop*/

1.                   default:",Not Useful
/*impossible*/,"-10.  *
-9.  * Errors in alpha should only occur when converting from a direct format
-8.  * to a colormapped format, when alpha is effectively smashed (so large
-7.  * errors can occur.)  There should be no error in the '0' and 'opaque'
-6.  * values.  T",Not Useful
/*SIMPLIFIED_WRITE_STDIO*/,"-10.    return read_file(image, FORMAT_NO_CHANGE, NULL);
-9. }
-8. #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
-7. static int
-6. write_one_file(Image *output, Image *image, int convert_to_8bit)
-5. {
-4.    if (image->opts & FAST_WRITE)
-3.       image->image.",Not Useful
/*SIMPLIFIED_WRITE_STDIO*/,"-10.    return read_file(image, FORMAT_NO_CHANGE, NULL);
-9. }
-8. #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
-7. static int
-6. write_one_file(Image *output, Image *image, int convert_to_8bit)
-5. {
-4.    if (image->opts & FAST_WRITE)
-3.       image->image.",Not Useful
/*SIMPLIFIED_WRITE_STDIO*/,"-10.    return read_file(image, FORMAT_NO_CHANGE, NULL);
-9. }
-8. #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
-7. static int
-6. write_one_file(Image *output, Image *image, int convert_to_8bit)
-5. {
-4.    if (image->opts & FAST_WRITE)
-3.       image->image.",Not Useful
/*SIMPLIFIED_WRITE_STDIO*/,"-10.    return read_file(image, FORMAT_NO_CHANGE, NULL);
-9. }
-8. #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
-7. static int
-6. write_one_file(Image *output, Image *image, int convert_to_8bit)
-5. {
-4.    if (image->opts & FAST_WRITE)
-3.       image->image.",Not Useful
/*via_linear*/,"-10. }
-9. static int
-8. compare_16bit(int v1, int v2, int error_limit, int multiple_algorithms)
-7. {
-6.    int e = abs(v1-v2);
-5.    int ev1, ev2;
-4.    if (e <= error_limit)
-3.       return 1;
-2.    /* ""multiple_algorithms"" in this case means tha",Not Useful
/*PNG_SIMPLIFIED_WRITE_SUPPORTED*/,"-10.             else
-9.                return logclose(image, f, image->file_name, "": seek failed: "");
-8.          }
-7.       }
-6.       else
-5.          return logerror(image, image->file_name, "": open failed: "",
-4.             strerror(errno));
-",Not Useful
/*skipped: no support*/,"-10.          log_pass = 1;
-9.       else if (strcmp(arg, ""--fresh"") == 0)
-8.       {
-7.          memset(gpc_error, 0, sizeof gpc_error);
-6.          memset(gpc_error_via_linear, 0, sizeof gpc_error_via_linear);
-5.       }
-4.       else if (strcmp(a",Not Useful
/*skipped: no support*/,"-10.          log_pass = 1;
-9.       else if (strcmp(arg, ""--fresh"") == 0)
-8.       {
-7.          memset(gpc_error, 0, sizeof gpc_error);
-6.          memset(gpc_error_via_linear, 0, sizeof gpc_error_via_linear);
-5.       }
-4.       else if (strcmp(a",Not Useful
/*in*/,"-3. /*-
-2.  * pngstest.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*in*/

1.  * Copyright (c) 2013-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see t",Not Useful
/*a*/,"-3. /*-
-2.  * pngstest.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*a*/

1.  * Copyright (c) 2013-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see th",Not Useful
/*i*/,"-3. /*-
-2.  * pngstest.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*i*/

1.  * Copyright (c) 2013-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see th",Not Useful
/*o*/,"-4. /*-
-3.  * pngstest.c
-2.  *
-1.  * Last changed in libpng 1.6.31 [July 27, 2017]
 * Copyright (c) 2013-2017 John Cunningham Bowler

/*o*/

1.  *
2.  * This code is released under the libpng license.
3.  * For conditions of distribution and use, see t",Not Useful
/*!PNG_SIMPLIFIED_READ_SUPPORTED*/,"-10.       }
-9.       else
-8.       {
-7.          fflush(stdout);
-6.          fprintf(stderr, ""%s: open failed\n"", touch);
-5.          exit(99);
-4.       }
-3.    }
-2.    return retval;
-1. }

/*!PNG_SIMPLIFIED_READ_SUPPORTED*/

1. int main(void)
2",Not Useful
/*So the test is skipped:*/,"-3. int main(void)
-2. {
-1.    fprintf(stderr, ""pngstest: no read support in libpng, test skipped\n"");

/*So the test is skipped:*/

1.    return SKIP;
2. }",Not Useful
/*PNG_SIMPLIFIED_READ_SUPPORTED*/,"-5. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
-4. #  define SKIP 77
-3. #else
-2. #  define SKIP 0
-1. #endif

/*PNG_SIMPLIFIED_READ_SUPPORTED*/

1. #include ""../tools/sRGB.h""",Not Useful
/*deprecated*/,"-2. #define png_gAMA PNG_U32(103,  65,  77,  65)
-1. #define png_gIFg PNG_U32(103,  73,  70, 103)

/*deprecated*/

1. #define png_gIFx PNG_U32(103,  73,  70, 120)
2. #define png_hIST PNG_U32(104,  73,  83,  84)
3. #define png_iCCP PNG_U32(105,  67,  67,  ",Not Useful
/*__cplusplus*/,"
#ifdef __cplusplus



/*__cplusplus*/

1. #  define this not_the_cpp_this
2. #  define new not_the_cpp_new
3. #  define voidcast(type, value) static_cast<type>(value)
4. #else
5. #  define voidcast(type, value) (value)",Not Useful
/*Chunk information*/,"-1. #define png_vpAg PNG_U32(118, 112, 65, 103)

/*Chunk information*/

1. #define PNG_INFO_tEXt 0x10000000U
2. #define PNG_INFO_iTXt 0x20000000U
3. #define PNG_INFO_zTXt 0x40000000U
4. #define PNG_INFO_sTER 0x01000000U
5. #define PNG_INFO_vpAg 0x02000000",Not Useful
/*must be [0]*/,"-2. } chunk_info[] = {

/*must be [0]*/

1.    { ""PLTE"", PNG_INFO_PLTE, png_PLTE, 0, 0, ABSENT, 0 },",Not Useful
/*READ_USER_CHUNKS_SUPPORTED*/,"
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED) ||\



/*READ_USER_CHUNKS_SUPPORTED*/

1.    defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
2. #if PNG_LIBPNG_VER < 10500",Not Useful
/*impossible*/,"-2.          if (chunk < 0) switch (d->keep)
-1.          {

/*impossible*/

1.             case PNG_HANDLE_CHUNK_AS_DEFAULT:
2.             case PNG_HANDLE_CHUNK_NEVER:
3.                fprintf(stderr, ""%s(%s): %s: %s: unknown chunk saved\n"",
4.        ",Not Useful
/*FALLTHROUGH*/,"-10.                break;
-9.             case PNG_HANDLE_CHUNK_IF_SAFE:
-8.                if (!ancillaryb(unknown[num_unknown].name))
-7.                {
-6.                   fprintf(stderr,
-5.                      ""%s(%s): if-safe: %s: unknown crit",Not Useful
/*(safe)*/,"-10.                break;
-9.             case PNG_HANDLE_CHUNK_IF_SAFE:
-8.                if (!ancillaryb(unknown[num_unknown].name))
-7.                {
-6.                   fprintf(stderr,
-5.                      ""%s(%s): if-safe: %s: unknown crit",Not Useful
/*SAVE_UNKNOWN_CHUNKS*/,"-1. #if defined(PNG_READ_USER_CHUNKS_SUPPORTED) ||\
   defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)

/*SAVE_UNKNOWN_CHUNKS*/

1. #if PNG_LIBPNG_VER < 10500",Not Useful
/*READ_USER_CHUNKS*/,"
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED) ||\



/*READ_USER_CHUNKS*/

1.    defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
2. #if PNG_LIBPNG_VER < 10500",Not Useful
/*SAVE_UNKNOWN_CHUNKS*/,"-1. #if defined(PNG_READ_USER_CHUNKS_SUPPORTED) ||\
   defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)

/*SAVE_UNKNOWN_CHUNKS*/

1. #if PNG_LIBPNG_VER < 10500",Not Useful
/*chunk name*/,"-10.          else if (strcmp(equals+1, ""save"") == 0)
-9.             option = PNG_HANDLE_CHUNK_ALWAYS;
-8.          else
-7.          {
-6.             fprintf(stderr, ""%s(%s): %s: unrecognized chunk option\n"", d->file,
-5.                d->test, argv[i",Not Useful
/*1.7+ SAVE_UNKNOWN_CHUNKS*/,"-3. #                 if PNG_LIBPNG_VER >= 10700 &&\
-2.                      !defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
-1.                      if (option < PNG_HANDLE_CHUNK_IF_SAFE)

/*1.7+ SAVE_UNKNOWN_CHUNKS*/

1.                   {
2.             ",Not Useful
/*1.7+ SAVE_UNKNOWN_CHUNKS*/,"-3. #                 if PNG_LIBPNG_VER >= 10700 &&\
-2.                      !defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
-1.                      if (option < PNG_HANDLE_CHUNK_IF_SAFE)

/*1.7+ SAVE_UNKNOWN_CHUNKS*/

1.                   {
2.             ",Not Useful
/*all*/,"-10.  * Last changed in libpng 1.6.32 [August 24, 2017]
-9.  * Copyright (c) 2015,2017 Glenn Randers-Pehrson
-8.  * Written by John Cunningham Bowler
-7.  *
-6.  * This code is released under the libpng license.
-5.  * For conditions of distribution and u",Not Useful
/*1.7+ SAVE_UNKNOWN_CHUNKS*/,"-3. #                 if PNG_LIBPNG_VER >= 10700 &&\
-2.                      !defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
-1.                      if (option < PNG_HANDLE_CHUNK_IF_SAFE)

/*1.7+ SAVE_UNKNOWN_CHUNKS*/

1.                   {
2.             ",Not Useful
/*unknown chunk*/,"
/* pngunknown.c - test the read side unknown chunk handling



/*unknown chunk*/

1.  *
2.  * Last changed in libpng 1.6.32 [August 24, 2017]
3.  * Copyright (c) 2015,2017 Glenn Randers-Pehrson
4.  * Written by John Cunningham Bowler
5.  *
6.  * This code is released under the libpng license.
7.  * For conditions of distribution and use, see the disclaimer
8.  * and license in png.h
9.  *
10.  * NOTES:",Not Useful
/*known chunk*/,"
/* pngunknown.c - test the read side unknown chunk handling



/*known chunk*/

1.  *
2.  * Last changed in libpng 1.6.32 [August 24, 2017]
3.  * Copyright (c) 2015,2017 Glenn Randers-Pehrson
4.  * Written by John Cunningham Bowler
5.  *
6.  * This code is released under the libpng license.
7.  * For conditions of distribution and use, see the disclaimer
8.  * and license in png.h
9.  *
10.  * NOTES:",Not Useful
/*allow use of d->error_return*/,"-10.       ""before IDAT"", set_callback);
-9.    check_handling(d, def, flags[0][2] | flags[0][3], flags[1][2], flags[1][3],
-8.       ""after IDAT"", set_callback);
-7. }
-6. static void
-5. perform_one_test_safe(FILE *fp, int argc, const char **argv,
-4.  ",Not Useful
/*prevent use of d->error_return*/,"-6. #     ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
-5.          perform_one_test(fp, argc, argv, default_flags, d, 0);
-4. #     endif
-3. #     ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-2.          perform_one_test(fp, argc, argv, default_flags, d, 1);
-1. # ",Not Useful
"/*valid,unknown{before,after}*/","-10. {
-9.    fprintf(stderr, ""pngunknown: %s: usage:\n %s [--strict] ""
-8.       ""--default|{(CHNK|default|all)=(default|discard|if-safe|save)} ""
-7.       ""testfile.png\n"", reason, program);
-6.    exit(99);
-5. }
-4. int
-3. main(int argc, const char *",Not Useful
/*Now find what the various supplied options cause to change:*/,"-10. #     ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
-9.          0
-8. #     else
-7.          1
-6. #     endif
-5.       ) != PNG_HANDLE_CHUNK_ALWAYS)
-4.    {
-3.       fprintf(stderr, ""%s: %s: internal error\n"", d.program, d.file);
-2.       exit(99);
",Not Useful
/*!(READ_USER_CHUNKS || SAVE_UNKNOWN_CHUNKS)*/,"-10.          else
-9.          {
-8.             fprintf(stderr, ""%s: open failed\n"", touch_file);
-7.             exit(99);
-6.          }
-5.       }
-4.       return 0;
-3.    }
-2.    return 1;
-1. }

/*!(READ_USER_CHUNKS || SAVE_UNKNOWN_CHUNKS)*/

1",Not Useful
/*So the test is skipped:*/,"-5. int
-4. main(void)
-3. {
-2.    fprintf(stderr,
-1.       "" test ignored: no support to find out about unknown chunks\n"");

/*So the test is skipped:*/

1.    return SKIP;
2. }",Not Useful
/*READ_USER_CHUNKS || SAVE_UNKNOWN_CHUNKS*/,"-10.          else
-9.          {
-8.             fprintf(stderr, ""%s: open failed\n"", touch_file);
-7.             exit(99);
-6.          }
-5.       }
-4.       return 0;
-3.    }
-2.    return 1;
-1. }

/*READ_USER_CHUNKS || SAVE_UNKNOWN_CHUNKS*/

1. i",Not Useful
/*So the test is skipped:*/,"-5. int
-4. main(void)
-3. {
-2.    fprintf(stderr,
-1.       "" test ignored: no support to find out about unknown chunks\n"");

/*So the test is skipped:*/

1.    return SKIP;
2. }",Not Useful
/*USER_MEM*/,"-4. PNG_FUNCTION(png_structp,PNGAPI
-3. png_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
-2.     png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)
-1. {
#ifndef PNG_USER_MEM_SUPPORTED

/*USER_MEM*/

1.    png_structp ",Not Useful
/*It has been consumed*/,"-10.       else if (chunk_name == png_IEND)
-9.          png_handle_IEND(png_ptr, info_ptr, length);
-8. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-7.       else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)
-6.       {
-5.          png_",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*MNG_FEATURES*/,"-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
#ifdef PNG_MNG_FEATURES_SUPPORTED

/*MNG_FEATURES*/

 ",Not Useful
/*WARNINGS*/,"-1. #        if PNG_RELEASE_BUILD
            png_ptr->flags |= PNG_FLAG_APP_WARNINGS_WARN;

/*WARNINGS*/

1. #        endif
2. #     endif",Not Useful
/*row*/,"-8. void PNGAPI
-7. png_read_update_info(png_structrp png_ptr, png_inforp info_ptr)
-6. {
-5.    png_debug(1, ""in png_read_update_info"");
-4.    if (png_ptr != NULL)
-3.    {
-2.       if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
-1.       {
         pn",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*Local variables:*/,"-5.    png_imagep image;
-4.    png_voidp  buffer;
-3.    png_int_32 row_stride;
-2.    png_voidp  colormap;
-1.    png_const_colorp background;

/*Local variables:*/

1.    png_voidp       local_row;
2.    png_voidp       first_row;",Not Useful
/*warn*/,"-2. PNG_FUNCTION(png_structp,PNGAPI
-1. png_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)

/*warn*/

1. {
2. #ifndef PNG_USER_MEM_SUPPORTED
3.    png_structp png_pt",Not Useful
/*Clean up: just the opened file.*/,"-10.       {
-9.          FILE *fp = fopen(file_name, ""rb"");
-8.          if (fp != NULL)
-7.          {
-6.             if (png_image_read_init(image) != 0)
-5.             {
-4.                image->opaque->png_ptr->io_ptr = fp;
-3.                imag",Not Useful
/*STDIO*/,"-10.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
-9.  *
-8.  * This code is released under the libpng license.
-7.  * For conditions of distribution and use, see the disclaimer
-6.  * and license in png.h
-5.  *
-4.  * Thi",Not Useful
/*bKGD*/,"-10.          }
-9.       }
-8. #endif
-7.       else if (chunk_name == png_PLTE)
-6.          png_handle_PLTE(png_ptr, info_ptr, length);
-5.       else if (chunk_name == png_IDAT)
-4.       {
-3.          png_ptr->idat_size = length;
-2.          break;",Not Useful
/*cHRM*/,"-10.          png_handle_PLTE(png_ptr, info_ptr, length);
-9.       else if (chunk_name == png_IDAT)
-8.       {
-7.          png_ptr->idat_size = length;
-6.          break;
-5.       }
-4. #ifdef PNG_READ_bKGD_SUPPORTED
-3.       else if (chunk_name == ",Not Useful
/*gAMA*/,"-10.          png_handle_bKGD(png_ptr, info_ptr, length);
-9. #endif
-8. #ifdef PNG_READ_cHRM_SUPPORTED
-7.       else if (chunk_name == png_cHRM)
-6.          png_handle_cHRM(png_ptr, info_ptr, length);
-5. #endif
-4. #ifdef PNG_READ_eXIf_SUPPORTED
-3.  ",Not Useful
/*iCCP*/,"-10.          png_handle_pHYs(png_ptr, info_ptr, length);
-9. #endif
-8. #ifdef PNG_READ_sBIT_SUPPORTED
-7.       else if (chunk_name == png_sBIT)
-6.          png_handle_sBIT(png_ptr, info_ptr, length);
-5. #endif
-4. #ifdef PNG_READ_sRGB_SUPPORTED
-3.  ",Not Useful
/*sBIT*/,"-10.          png_handle_pCAL(png_ptr, info_ptr, length);
-9. #endif
-8. #ifdef PNG_READ_sCAL_SUPPORTED
-7.       else if (chunk_name == png_sCAL)
-6.          png_handle_sCAL(png_ptr, info_ptr, length);
-5. #endif
-4. #ifdef PNG_READ_pHYs_SUPPORTED
-3.  ",Not Useful
/*SAFE*/,"-1.        png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_AS_DEFAULT,

/*SAFE*/

1.    }
2. }
3. #  define PNG_SKIP_CHUNKS(p) png_image_skip_unused_chunks(p)
4. #else
5. #  define PNG_SKIP_CHUNKS(p) ((void)0)",Not Useful
/*HANDLE_AS_UNKNOWN*/,"-10.  * changed in v0.90 to allow reading a file that already has the magic
-9.  * bytes read from the stream.  You can tell libpng how many bytes have
-8.  * been read from the beginning of the stream (up to the maximum of 8)
-7.  * via png_set_sig_bytes",Not Useful
/*FALLTHROUGH*/,"-4.          switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
-3.          {
-2.             case 4:
-1.                entry[afirst ? 0 : 3] = (png_uint_16)alpha;

/*FALLTHROUGH*/

1.             case 3:
2.                if (alpha < 65535)
3.          ",Not Useful
/*FALLTHROUGH*/,"-4.          switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
-3.          {
-2.             case 4:
-1.                entry[afirst ? 0 : 3] = (png_uint_16)alpha;

/*FALLTHROUGH*/

1.             case 3:
2.                if (alpha < 65535)
3.          ",Not Useful
/*FALLTHROUGH*/,"-4.          switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
-3.          {
-2.             case 4:
-1.                entry[afirst ? 0 : 3] = (png_uint_16)alpha;

/*FALLTHROUGH*/

1.             case 3:
2.                if (alpha < 65535)
3.          ",Not Useful
/*FALLTHROUGH*/,"-4.          switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
-3.          {
-2.             case 4:
-1.                entry[afirst ? 0 : 3] = (png_uint_16)alpha;

/*FALLTHROUGH*/

1.             case 3:
2.                if (alpha < 65535)
3.          ",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized b",Not Useful
/*need_expand*/,"-1.                      png_set_background_fixed(png_ptr, &c,

/*need_expand*/

 ",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized b",Not Useful
/*need_expand*/,"-1.                      png_set_background_fixed(png_ptr, &c,

/*need_expand*/

 ",Not Useful
/*now P_FILE*/,"-1.                      gray = PNG_DIV257(png_gamma_16bit_correct(gray,

/*now P_FILE*/

 ",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized b",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized b",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized b",Not Useful
/*need_expand*/,"-1.                      png_set_background_fixed(png_ptr, &c,

/*need_expand*/

 ",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized b",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized b",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized b",Not Useful
/*need_expand*/,"-1.                      png_set_background_fixed(png_ptr, &c,

/*need_expand*/

 ",Not Useful
/*8-bit*/,"-9. #ifdef PNG_SIMPLIFIED_READ_SUPPORTED

/*8-bit*/

 ",Not Useful
/*FALLTHROUGH*/,"-4.          switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
-3.          {
-2.             case 4:
-1.                entry[afirst ? 0 : 3] = (png_uint_16)alpha;

/*FALLTHROUGH*/

1.             case 3:
2.                if (alpha < 65535)
3.          ",Not Useful
/*ok*/,"-10. #ifdef PNG_READ_GAMMA_SUPPORTED
-9.    png_destroy_gamma_table(png_ptr);
-8. #endif
-7.    png_free(png_ptr, png_ptr->big_row_buf);
-6.    png_ptr->big_row_buf = NULL;
-5.    png_free(png_ptr, png_ptr->big_prev_row);
-4.    png_ptr->big_prev_row = NU",Not Useful
/*opaque*/,"-3. static int
-2. png_image_read_init(png_imagep image)
-1. {
   if (image->opaque == NULL)

/*opaque*/

1.    {
2.       png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, image,
3.           png_safe_error, png_safe_warning);",Not Useful
/*As a flag*/,"-10. }
-9. static int
-8. png_image_read_colormapped(png_voidp argument)
-7. {
-6.    png_image_read_control *display = png_voidcast(png_image_read_control*,
-5.        argument);
-4.    png_imagep image = display->image;
-3.    png_controlp control = ima",Not Useful
/*216 + 1 + 27*/,"-3.          if (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
-2.             info_ptr->bit_depth == 8 &&
-1.             png_ptr->screen_gamma == PNG_GAMMA_sRGB &&

/*216 + 1 + 27*/

1.             break;
2.          goto bad_output;
3.       defa",Not Useful
/*maybe*/,"-9.                      }
-8.                      row += display->row_bytes;
-7.                   }
-6.                }
-5.             }
-4.          }
-3.          break;
-2.       case 16:
-1.          /* 16-bit linear with pre-multiplied alpha; th",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized b",Not Useful
/*need_expand*/,"-1.                      png_set_background_fixed(png_ptr, &c,

/*need_expand*/

 ",Not Useful
/*opaque filler*/,"-6.          {

/*opaque filler*/

1.             int where;
2.             if (linear != 0)
3.                filler = 65535;
4.             else
5.                filler = 255;
6. #ifdef PNG_FORMAT_AFIRST_SUPPORTED
7.             if ((format & PNG_FORMA",Not Useful
/*SAFE*/,"-1.        png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_AS_DEFAULT,

/*SAFE*/

1.    }
2. }
3. #  define PNG_SKIP_CHUNKS(p) png_image_skip_unused_chunks(p)
4. #else
5. #  define PNG_SKIP_CHUNKS(p) ((void)0)",Not Useful
/*SIMPLIFIED_READ*/,"-10.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
-9.  *
-8.  * This code is released under the libpng license.
-7.  * For conditions of distribution and use, see the disclaimer
-6.  * and license in png.h
-5.  *
-4.  * Thi",Not Useful
/*PRIVATE*/,#NAME?,Not Useful
/*WARNINGS*/,#NAME?,Not Useful
/*ERROR_TEXT*/,"
#ifdef PNG_ERROR_TEXT_SUPPORTED



/*ERROR_TEXT*/

1. PNG_FUNCTION(void,PNGAPI
2. png_error,(png_const_structrp png_ptr, png_const_charp error_message),
3.     PNG_NORETURN)
4. {
5. #ifdef PNG_ERROR_NUMBERS_SUPPORTED
6.    char msg[16];
7.    if (png_ptr != NULL)
8.    {
9.       if ((png_ptr->flags &
10.          (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT)) != 0)",Not Useful
/*digit output (for the fixed point format)*/,"-6. png_charp
-5. png_format_number(png_const_charp start, png_charp end, int format,
-4.     png_alloc_size_t number)
-3. {

/*digit output (for the fixed point format)*/

1.    *--end = '\0';",Not Useful
/*Expects at least 2 digits.*/,"-9.             mincount = 5;
-8.             if (output != 0 || number % 10 != 0)
-7.             {
-6.                *--end = digits[number % 10];
-5.                output = 1;
-4.             }
-3.             number /= 10;
-2.             break;
-1.",Not Useful
/*FALLTHROUGH*/,"-1.             mincount = 2;

/*FALLTHROUGH*/

1.          case PNG_NUMBER_FORMAT_u:
2.             *--end = digits[number % 10];
3.             number /= 10;
4.             break;
5.          case PNG_NUMBER_FORMAT_02x:",Not Useful
/*FALLTHROUGH*/,"-1.             mincount = 2;

/*FALLTHROUGH*/

1.          case PNG_NUMBER_FORMAT_u:
2.             *--end = digits[number % 10];
3.             number /= 10;
4.             break;
5.          case PNG_NUMBER_FORMAT_02x:",Not Useful
/*Float a fixed number here:*/,"-1.       ++count;

/*Float a fixed number here:*/

1.       if ((format == PNG_NUMBER_FORMAT_fixed) && (count == 5) && (end > start))
2.       {",Not Useful
/*Consume the '@'*/,"-2.       if (p != NULL && *message == '@' && message[1] != '\0')
-1.       {

/*Consume the '@'*/

1.          static const char valid_parameters[] = ""123456789"";
2.          int parameter = 0;",Not Useful
/*WARNINGS*/,#NAME?,Not Useful
/*PRIVATE*/,#NAME?,Not Useful
/*PRIVATE*/,#NAME?,Not Useful
/*BENIGN_ERRORS*/,"
#ifdef PNG_BENIGN_ERRORS_SUPPORTED



/*BENIGN_ERRORS*/

1. void PNGAPI
2. png_benign_error(png_const_structrp png_ptr, png_const_charp error_message)
3. {
4.    if ((png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN) != 0)
5.    {
6. #     ifdef PNG_READ_SUPPORTED
7.          if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&
8.             png_ptr->chunk_name != 0)
9.             png_chunk_warning(png_ptr, error_message);
10.          else",Not Useful
/*Currently limited by profile_error in png.c*/,"-10. {
-9.    if ((png_ptr->flags & PNG_FLAG_APP_ERRORS_WARN) != 0)
-8.       png_warning(png_ptr, error_message);
-7.    else
-6.       png_error(png_ptr, error_message);
-5. #  ifndef PNG_ERROR_TEXT_SUPPORTED
-4.       PNG_UNUSED(error_message)
-3. #  e",Not Useful
/*PRIVATE*/,#NAME?,Not Useful
"/*iin < PNG_MAX_ERROR_TEXT, so the following is safe:*/","-10.    }
-9.    if (error_message == NULL)
-8.       buffer[iout] = '\0';
-7.    else
-6.    {
-5.       int iin = 0;
-4.       buffer[iout++] = ':';
-3.       buffer[iout++] = ' ';
-2.       while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\0",Not Useful
/*WARNINGS || ERROR_TEXT*/,"-3.       buffer[iout] = '\0';
-2.    }
-1. }

/*WARNINGS || ERROR_TEXT*/

1. #if defined(PNG_READ_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED)
2. PNG_FUNCTION(void,PNGAPI
3. png_chunk_error,(png_const_structrp png_ptr, png_const_charp error_message),
",Not Useful
/*READ && ERROR_TEXT*/,"-10. {
-9.    char msg[18+PNG_MAX_ERROR_TEXT];
-8.    if (png_ptr == NULL)
-7.       png_error(png_ptr, error_message);
-6.    else
-5.    {
-4.       png_format_buffer(png_ptr, msg, error_message);
-3.       png_error(png_ptr, msg);
-2.    }
-1. }

/*REA",Not Useful
/*WARNINGS*/,#NAME?,Not Useful
/*PRIVATE*/,#NAME?,Not Useful
/*png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local;*/,"-1.       if (jmp_buf_size <= (sizeof png_ptr->jmp_buf_local))
         png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local;

/*png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local;*/

1.       else
2.       {
3.          png_ptr->jmp_buf_ptr = png_voidcast(jmp_buf ",Not Useful
/*PRIVATE*/,#NAME?,Not Useful
/*PRIVATE*/,#NAME?,Not Useful
/*PRIVATE*/,#NAME?,Not Useful
/*WARNINGS*/,#NAME?,Not Useful
/*PRIVATE*/,#NAME?,Not Useful
/*PRIVATE*/,#NAME?,Not Useful
/*PRIVATE*/,#NAME?,Not Useful
/*SIMPLIFIED READ || SIMPLIFIED_WRITE*/,"-4.    if (result == 0)
-3.       png_image_free(image);
-2.    return result;
-1. }

/*SIMPLIFIED READ || SIMPLIFIED_WRITE*/

 ",Not Useful
/*#define STDERR stderr*/,"-10.  * If a filename is given on the command-line, then this file is used
-9.  * for the input, rather than the default ""pngtest.png"".  This allows
-8.  * testing a wide variety of files easily.  You can also test a number
-7.  * of files at once by typi",Not Useful
/*count calls to png_error*/,"-6. #endif
-5. static int verbose = 0;
-4. static int strict = 0;
-3. static int relaxed = 0;
-2. static int xfail = 0;

/*count calls to png_error*/

 ",Not Useful
/*count calls to png_warning*/,"-7. #endif
-6. static int verbose = 0;
-5. static int strict = 0;
-4. static int relaxed = 0;
-3. static int xfail = 0;

/*count calls to png_warning*/

 ",Not Useful
/*Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng*/,"-8. #endif
-7. static int verbose = 0;
-6. static int strict = 0;
-5. static int relaxed = 0;
-4. static int xfail = 0;

/*Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng*/

1. #ifndef png_jmpbuf
2. #  define png_jmpbuf(png_ptr) png",Not Useful
/*WRITE_USER_TRANSFORM*/,"-8. static void PNGCBAPI
-7. read_user_callback(png_structp png_ptr, png_row_infop row_info, png_bytep data)
-6. {
-5.    PNG_UNUSED(png_ptr)
-4.    PNG_UNUSED(row_info)
-3.    PNG_UNUSED(data)
-2. }
-1. #endif
#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED

/",Not Useful
/*!STDIO*/,"-10.    png_size_t check;
-9.    check = fwrite(data, 1, length, (png_FILE_p)png_get_io_ptr(png_ptr));
-8.    if (check != length)
-7.    {
-6.       png_error(png_ptr, ""Write Error"");
-5.    }
-4. #ifdef PNG_IO_STATE_SUPPORTED
-3.    pngtest_check_io_sta",Not Useful
/*already have one of these*/,"-10. init_callback_info(png_const_infop info_ptr)
-9. {
-8.    MEMZERO(user_chunk_data);
-7.    user_chunk_data.info_ptr = info_ptr;
-6. }
-5. static int
-4. set_location(png_structp png_ptr, struct user_chunk_data *data, int what)
-3. {
-2.    int locati",Not Useful
/*s  T*/,"-10.     *    return (0);  did not recognize
-9.     *    return (n);  success
-8.     *
-7.     * The unknown chunk structure contains the chunk data:
-6.     * png_byte name[5];
-5.     * png_byte *data;
-4.     * png_size_t size;
-3.     *
-2.     * No",Not Useful
/*E  R*/,"-10.     *    return (n);  success
-9.     *
-8.     * The unknown chunk structure contains the chunk data:
-7.     * png_byte name[5];
-6.     * png_byte *data;
-5.     * png_size_t size;
-4.     *
-3.     * Note that libpng has already taken care of the",Not Useful
/*Found sTER chunk*/,"-1.       {

/*Found sTER chunk*/

1.          if (chunk->size != 1)",Not Useful
/*v  p*/,"-1.       }

/*v  p*/

 ",Not Useful
/*A  g*/,"-2.       }

/*A  g*/

 ",Not Useful
/*Did not recognize*/,"-3.       }

/*Did not recognize*/

 ",Not Useful
/*duplicate vpAg*/,"-1.    if (set_location(png_ptr, my_user_chunk_data, have_vpAg) == 0)

/*duplicate vpAg*/

1.    my_user_chunk_data->vpAg_width = png_get_uint_31(png_ptr, chunk->data);
2.    my_user_chunk_data->vpAg_height = png_get_uint_31(png_ptr, chunk->data + 4);
3. ",Not Useful
/*!READ_USER_CHUNKS*/,"-10.     */
-9.    for (i=0; i<2; ++i)
-8.    {
-7.       if (user_chunk_data.location[i] == (location | have_sTER))
-6.          write_sTER_chunk(write_ptr);
-5.       else if (user_chunk_data.location[i] == (location | have_vpAg))
-4.          write_vpA",Not Useful
/*Test one file*/,"-7.             png_error(png_ptr, ""invalid text chunk compression field"");
-6.             break;
-5.       }
-4.    }
-3. }
-2. #endif

/*Test one file*/

1. static int
2. test_one_file(PNG_CONST char *inname, PNG_CONST char *outname)
3. {
4.    static ",Not Useful
/*WRITE_FILTER*/,"-7.    pngtest_error_parameters error_parameters;
-6.    png_structp read_ptr;
-5.    png_infop read_info_ptr, end_info_ptr;
-4. #ifdef PNG_WRITE_SUPPORTED
-3.    png_structp write_ptr;
-2.    png_infop write_info_ptr;
-1.    png_infop write_end_info_ptr;",Not Useful
/*BENIGN_ERRORS*/,"-10.       if (verbose != 0)
-9.         fprintf(STDERR, ""   destroying write structs\n"");
-8.       png_destroy_info_struct(write_ptr, &write_end_info_ptr);
-7.       png_destroy_write_struct(&write_ptr, &write_info_ptr);
-6.       FCLOSE(fpin);
-5.     ",Not Useful
/*Use floating point versions*/,"-10.       }
-9.    }
-8. #endif
-7. #ifdef PNG_gAMA_SUPPORTED
-6.    {
-5.       png_fixed_point gamma;
-4.       if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma) != 0)
-3.          png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);
-2.    }
-1",Not Useful
/*Floating point*/,"-10.       }
-9.    }
-8. #endif
-7. #ifdef PNG_gAMA_SUPPORTED
-6.    {
-5.       double gamma;
-4.       if (png_get_gAMA(read_ptr, read_info_ptr, &gamma) != 0)
-3.          png_set_gAMA(write_ptr, write_info_ptr, gamma);
-2.    }
-1. #endif

/*Floating ",Not Useful
/*Fixed point*/,"-10.    }
-9. #endif
-8. #ifdef PNG_gAMA_SUPPORTED
-7.    {
-6.       double gamma;
-5.       if (png_get_gAMA(read_ptr, read_info_ptr, &gamma) != 0)
-4.          png_set_gAMA(write_ptr, write_info_ptr, gamma);
-3.    }
-2. #endif

/*Fixed point*/

1. #if",Not Useful
/*TIME_RFC1123*/,"-7. #ifndef PNG_FLOATING_POINT_SUPPORTED
-6. #undef PNGTEST_TIMING
-5. #endif
-4. #ifdef PNGTEST_TIMING
-3. static float t_start, t_stop, t_decode, t_encode, t_misc;
-2. #include <time.h>
-1. #endif
#ifdef PNG_TIME_RFC1123_SUPPORTED

/*TIME_RFC1123*/

1. ",Not Useful
/*before PLTE*/,"-1.    png_write_info_before_PLTE(write_ptr, write_info_ptr);

/*before PLTE*/

1.    png_write_info(write_ptr, write_info_ptr);",Not Useful
/*after PLTE*/,"-1.    png_write_info(write_ptr, write_info_ptr);

/*after PLTE*/

1.    png_write_info(write_ptr, write_end_info_ptr);",Not Useful
/*SINGLE_ROWBUF_ALLOC*/,"-10. #if PNG_DEBUG > 1
-9. #  define pngtest_debug(m)        ((void)fprintf(stderr, m ""\n""))
-8. #  define pngtest_debug1(m,p1)    ((void)fprintf(stderr, m ""\n"", p1))
-7. #  define pngtest_debug2(m,p1,p2) ((void)fprintf(stderr, m ""\n"", p1, p2))
-6. #else
",Not Useful
/*!SINGLE_ROWBUF_ALLOC*/,"-10. #     endif
-9.       pngtest_debug1(""Writing row data for pass %d"", pass);
-8.       for (y = 0; y < pass_height; y++)
-7.       {
-6. #ifndef SINGLE_ROWBUF_ALLOC
-5.          pngtest_debug2(""Allocating row buffer (pass %d, y = %u)..."", pass, y);
-4",Not Useful
/*!SINGLE_ROWBUF_ALLOC*/,"-10. #     endif
-9.       pngtest_debug1(""Writing row data for pass %d"", pass);
-8.       for (y = 0; y < pass_height; y++)
-7.       {
-6. #ifndef SINGLE_ROWBUF_ALLOC
-5.          pngtest_debug2(""Allocating row buffer (pass %d, y = %u)..."", pass, y);
-4",Not Useful
/*TIME_RFC1123*/,"-7. #ifndef PNG_FLOATING_POINT_SUPPORTED
-6. #undef PNGTEST_TIMING
-5. #endif
-4. #ifdef PNGTEST_TIMING
-3. static float t_start, t_stop, t_decode, t_encode, t_misc;
-2. #include <time.h>
-1. #endif
#ifdef PNG_TIME_RFC1123_SUPPORTED

/*TIME_RFC1123*/

1. ",Not Useful
/*SINGLE_ROWBUF_ALLOC*/,"-10. #if PNG_DEBUG > 1
-9. #  define pngtest_debug(m)        ((void)fprintf(stderr, m ""\n""))
-8. #  define pngtest_debug1(m,p1)    ((void)fprintf(stderr, m ""\n"", p1))
-7. #  define pngtest_debug2(m,p1,p2) ((void)fprintf(stderr, m ""\n"", p1, p2))
-6. #else
",Not Useful
/*WRITE && WRITE_FILTER*/,"-10.              * mode being changed (to NONE) yet, in the test case, the result
-9.              * can be exactly the same size!
-8.              */
-7.             if (strict != 0 && unsupported_chunks == 0)
-6.               return (1);
-5.          ",Not Useful
/*TIME_RFC1123*/,"-7. #ifndef PNG_FLOATING_POINT_SUPPORTED
-6. #undef PNGTEST_TIMING
-5. #endif
-4. #ifdef PNGTEST_TIMING
-3. static float t_start, t_stop, t_decode, t_encode, t_misc;
-2. #include <time.h>
-1. #endif
#ifdef PNG_TIME_RFC1123_SUPPORTED

/*TIME_RFC1123*/

1. ",Not Useful
/*TIME_RFC1123*/,"-7. #ifndef PNG_FLOATING_POINT_SUPPORTED
-6. #undef PNGTEST_TIMING
-5. #endif
-4. #ifdef PNGTEST_TIMING
-3. static float t_start, t_stop, t_decode, t_encode, t_misc;
-2. #include <time.h>
-1. #endif
#ifdef PNG_TIME_RFC1123_SUPPORTED

/*TIME_RFC1123*/

1. ",Not Useful
/*And skip this test*/,"-10.           (unsigned long) png_get_chunk_malloc_max(dummy_ptr));
-9.    png_destroy_read_struct(&dummy_ptr, NULL, NULL);
-8.    return (int)(ierror != 0);
-7. }
-6. #else
-5. int
-4. main(void)
-3. {
-2.    fprintf(STDERR,
-1.        "" test ignored be",Not Useful
/*GNU 7.1.x*/,"-10.  * the optimizer in such a way that the results of the comparison will change
-9.  * if signed integer overflow occurs.  Such comparisons are not permitted in
-8.  * ANSI C90, however GCC isn't clever enough to work out that that do not occur
-7.  * ",Not Useful
/*GNU*/,"-1. typedef png_libpng_version_1_6_34 Your_png_h_is_not_version_1_6_34;
#ifdef __GNUC__

/*GNU*/

1. /* The version tests may need to be added to, but the problem warning has
2.  * consistently been fixed in GCC versions which obtain wide-spread release.
",Not Useful
/*critical*/,"-9. png_calculate_crc(png_structrp png_ptr, png_const_bytep ptr, png_size_t length)
-8. {
-7.    int need_crc = 1;
-6.    if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)
-5.    {
-4.       if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
-3.      ",Not Useful
/*Should never issue a warning*/,"-2.    if (need_crc != 0 && length > 0)
-1.    {

/*Should never issue a warning*/

1.       do
2.       {
3.          uInt safe_length = (uInt)length;
4. #ifndef __COVERITY__
5.          if (safe_length == 0)",Not Useful
"/*evil, but safe*/","-5.       do
-4.       {
-3.          uInt safe_length = (uInt)length;
-2. #ifndef __COVERITY__
-1.          if (safe_length == 0)

/*evil, but safe*/

1. #endif
2.          crc = crc32(crc, ptr, safe_length);",Not Useful
"/*png_ptr->zstream holds a back-pointer to the png_struct, so
                * this can only be done now:*/","-6.          if (png_user_version_check(&create_struct, user_png_ver) != 0)
-5.          {
-4.             png_structrp png_ptr = png_voidcast(png_structrp,
-3.                 png_malloc_warn(&create_struct, (sizeof *png_ptr)));
-2.             if (png_p",Not Useful
/*The following line is why this API should not be used:*/,"-10. png_info_init_3,(png_infopp ptr_ptr, png_size_t png_info_struct_size),
-9.     PNG_DEPRECATED)
-8. {
-7.    png_inforp info_ptr = *ptr_ptr;
-6.    png_debug(1, ""in png_info_init_3"");
-5.    if (info_ptr == NULL)
-4.       return;
-3.    if ((sizeof (",Not Useful
/*Free any tRNS entry*/,"-10.          for (i = 0; i < info_ptr->num_text; i++)
-9.             png_free(png_ptr, info_ptr->text[i].key);
-8.          png_free(png_ptr, info_ptr->text);
-7.          info_ptr->text = NULL;
-6.          info_ptr->num_text = 0;
-5.          info_ptr",Not Useful
/*Free any sCAL entry*/,"-9.    if (((mask & PNG_FREE_TRNS) & info_ptr->free_me) != 0)
-8.    {
-7.       info_ptr->valid &= ~PNG_INFO_tRNS;
-6.       png_free(png_ptr, info_ptr->trans_alpha);
-5.       info_ptr->trans_alpha = NULL;
-4.       info_ptr->num_trans = 0;
-3.    }
-2.",Not Useful
/*Free any pCAL entry*/,"-10.    if (((mask & PNG_FREE_SCAL) & info_ptr->free_me) != 0)
-9.    {
-8.       png_free(png_ptr, info_ptr->scal_s_width);
-7.       png_free(png_ptr, info_ptr->scal_s_height);
-6.       info_ptr->scal_s_width = NULL;
-5.       info_ptr->scal_s_height =",Not Useful
/*Free any profile entry*/,"-10.             int i;
-9.             for (i = 0; i < info_ptr->pcal_nparams; i++)
-8.                png_free(png_ptr, info_ptr->pcal_params[i]);
-7.             png_free(png_ptr, info_ptr->pcal_params);
-6.             info_ptr->pcal_params = NULL;
-5",Not Useful
"/*Free a given sPLT entry, or (if num == -1) all sPLT entries*/","-10.    if (((mask & PNG_FREE_ICCP) & info_ptr->free_me) != 0)
-9.    {
-8.       png_free(png_ptr, info_ptr->iccp_name);
-7.       png_free(png_ptr, info_ptr->iccp_profile);
-6.       info_ptr->iccp_name = NULL;
-5.       info_ptr->iccp_profile = NULL;
-",Not Useful
/*Free any eXIf entry*/,"-10.          int i;
-9.          for (i = 0; i < info_ptr->unknown_chunks_num; i++)
-8.             png_free(png_ptr, info_ptr->unknown_chunks[i].data);
-7.          png_free(png_ptr, info_ptr->unknown_chunks);
-6.          info_ptr->unknown_chunks = NUL",Not Useful
/*Free any hIST entry*/,"-10. # endif
-9.       if (info_ptr->exif)
-8.       {
-7.          png_free(png_ptr, info_ptr->exif);
-6.          info_ptr->exif = NULL;
-5.       }
-4.       info_ptr->valid &= ~PNG_INFO_eXIf;
-3.    }
-2. #endif
-1. #ifdef PNG_hIST_SUPPORTED

/*Free a",Not Useful
/*Free any PLTE entry that was internally allocated*/,"-7.    if (((mask & PNG_FREE_HIST) & info_ptr->free_me) != 0)
-6.    {
-5.       png_free(png_ptr, info_ptr->hist);
-4.       info_ptr->hist = NULL;
-3.       info_ptr->valid &= ~PNG_INFO_hIST;
-2.    }
-1. #endif

/*Free any PLTE entry that was internall",Not Useful
/*RFC1123 limitation*/,"-10.  * a ""Creation Time"" or other text-based time string.
-9.  */
-8. int PNGAPI
-7. png_convert_to_rfc1123_buffer(char out[29], png_const_timep ptime)
-6. {
-5.    static PNG_CONST char short_months[12][4] =
-4.         {""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May",Not Useful
/*TIME_RFC1123*/,"-10.  * Where UNSIGNED_MAX is the appropriate maximum unsigned value, so when the
-9.  * negative integral value is added the result will be an unsigned value
-8.  * correspnding to the 2's complement representation.
-7.  */
-6. void PNGAPI
-5. png_save_i",Not Useful
"/*num_chunk_list > 0, so at least one*/","-9.    png_const_bytep p, p_end;
-8.    if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list == 0)
-7.       return PNG_HANDLE_CHUNK_AS_DEFAULT;
-6.    p_end = png_ptr->chunk_list;

/*num_chunk_list > 0, so at least one*/

1.    {
2.      ",Not Useful
/*READ_UNKNOWN_CHUNKS || HANDLE_AS_UNKNOWN*/,"-6. png_chunk_unknown_handling(png_const_structrp png_ptr, png_uint_32 chunk_name)
-5. {
-4.    png_byte chunk_string[5];
-3.    PNG_CSTRING_FROM_CHUNK(chunk_string, chunk_name);
-2.    return png_handle_as_unknown(png_ptr, chunk_string);
-1. }

/*READ_UN",Not Useful
/*SET_UNKNOWN_CHUNKS*/,"-10.          break;
-9.    }
-8.    for (i = 0, v = 0; i < num_palette; i++, v += color_inc)
-7.    {
-6.       palette[i].red = (png_byte)(v & 0xff);
-5.       palette[i].green = (png_byte)(v & 0xff);
-4.       palette[i].blue = (png_byte)(v & 0xff);
-3",Not Useful
/*from gAMA*/,"-5.    else if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)
-4.       return;
-3.    else
-2.    {
-1.       if (png_colorspace_check_gamma(png_ptr, colorspace, gAMA,

/*from gAMA*/

1.       {",Not Useful
/*not used*/,"-10.    return PNG_HEADER_VERSION_STRING
-9. #  ifndef PNG_READ_SUPPORTED
-8.       "" (NO READ SUPPORT)""
-7. #  endif
-6.       PNG_STRING_NEWLINE;
-5. #else
-4.    return PNG_HEADER_VERSION_STRING;
-3. #endif
-2. }
-1. #ifdef PNG_BUILD_GRAYSCALE_PALETTE_",Not Useful
/*And fill in the png_XYZ:*/,"-4.    blue_scale = png_reciprocal(xy->whitey) - png_reciprocal(red_inverse) -
-3.        png_reciprocal(green_inverse);
-2.    if (blue_scale <= 0)
-1.       return 1;

/*And fill in the png_XYZ:*/

1.    if (png_muldiv(&XYZ->red_X, xy->redx, PNG_FP_1, r",Not Useful
"/*actually, the math is pretty accurate*/","-7.    result = png_XYZ_from_xy(XYZ, xy);
-6.    if (result != 0)
-5.       return result;
-4.    result = png_xy_from_XYZ(&xy_test, XYZ);
-3.    if (result != 0)
-2.       return result;
-1.    if (png_colorspace_endpoints_match(xy, &xy_test,

/*actually",Not Useful
/*Too much slip*/,"-1.       return 0;

/*Too much slip*/

1.    return 1;
2. }",Not Useful
/*From ITU-R BT.709-3*/,"-10.    result = png_XYZ_normalize(XYZ);
-9.    if (result != 0)
-8.       return result;
-7.    result = png_xy_from_XYZ(xy, XYZ);
-6.    if (result != 0)
-5.       return result;
-4.    XYZtemp = *XYZ;
-3.    return png_colorspace_check_xy(&XYZtemp, xy)",Not Useful
/*white*/,"-9. png_colorspace_set_gamma(png_const_structrp png_ptr,
-8.     png_colorspacerp colorspace, png_fixed_point gAMA)
-7. {
-6.    /* Changed in libpng-1.5.4 to limit the values to ensure overflow can't
-5.     * occur.  Since the fixed point representation",Not Useful
/*+2 = 90*/,"-4.    if (colorspace != NULL)
-3.       colorspace->flags |= PNG_COLORSPACE_INVALID;

/*+2 = 90*/

1.    if (is_ICC_signature(value) != 0)
2.    {",Not Useful
/*+24 = 114*/,"-6.       message[pos++] = ':';
-5.       message[pos++] = ' ';
-4.    }
-3. #  ifdef PNG_WARNINGS_SUPPORTED
-2.    else
-1.       {

/*+24 = 114*/

1.          pos = png_safecat(message, (sizeof message), pos,
2.              png_format_number(number, nu",Not Useful
/*+2 = 116*/,"-3.          pos = png_safecat(message, (sizeof message), pos,
-2.              png_format_number(number, number+(sizeof number),
-1.              PNG_NUMBER_FORMAT_x, value));

/*+2 = 116*/

1.       }
2. #  endif",Not Useful
/*endpoints*/,"-10.       if (png_muldiv(&XYZ->blue_X, XYZ->blue_X, PNG_FP_1, Y) == 0)
-9.          return 1;
-8.       if (png_muldiv(&XYZ->blue_Y, XYZ->blue_Y, PNG_FP_1, Y) == 0)
-7.          return 1;
-6.       if (png_muldiv(&XYZ->blue_Z, XYZ->blue_Z, PNG_FP_1, Y) =",Not Useful
/*bool*/,"-2. static const png_byte D50_nCIEXYZ[12] =
-1.    { 0x00, 0x00, 0xf6, 0xd6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d };

/*bool*/

1. icc_check_length(png_const_structrp png_ptr, png_colorspacerp colorspace,
2.     png_const_charp name, png_uint_32",Not Useful
/*!SET_USER_LIMITS*/,"-10.     */
-9. #  ifdef PNG_SET_USER_LIMITS_SUPPORTED
-8.       else if (png_ptr->user_chunk_malloc_max > 0 &&
-7.                png_ptr->user_chunk_malloc_max < profile_length)
-6.          return png_icc_profile_error(png_ptr, colorspace, name, profil",Not Useful
/*!SET_USER_LIMITS*/,"-10.     */
-9. #  ifdef PNG_SET_USER_LIMITS_SUPPORTED
-8.       else if (png_ptr->user_chunk_malloc_max > 0 &&
-7.                png_ptr->user_chunk_malloc_max < profile_length)
-6.          return png_icc_profile_error(png_ptr, colorspace, name, profil",Not Useful
/*READ_iCCP*/,"-8. icc_check_length(png_const_structrp png_ptr, png_colorspacerp colorspace,
-7.     png_const_charp name, png_uint_32 profile_length)
-6. {
-5.    if (profile_length < 132)
-4.       return png_icc_profile_error(png_ptr, colorspace, name, profile_length",Not Useful
/*The ICC limit*/,"-1.    temp = png_get_uint_32(profile+64);

/*The ICC limit*/

1.       return png_icc_profile_error(png_ptr, colorspace, name, temp,
2.           ""invalid rendering intent"");",Not Useful
/*signature 'ascp'*/,"-10.     * been loaded; however, various header fields can be checked.  These checks
-9.     * are for values permitted by the PNG spec in an ICC profile; the PNG spec
-8.     * restricts the profiles that can be passed in an iCCP chunk (they must be
-7. ",Not Useful
/*scnr'*/,"-10.          if ((color_type & PNG_COLOR_MASK_COLOR) != 0)
-9.             return png_icc_profile_error(png_ptr, colorspace, name, temp,
-8.                 ""Gray color space not permitted on RGB PNG"");
-7.          break;
-6.       default:
-5.         ",Not Useful
/*mntr'*/,"-10.          if ((color_type & PNG_COLOR_MASK_COLOR) != 0)
-9.             return png_icc_profile_error(png_ptr, colorspace, name, temp,
-8.                 ""Gray color space not permitted on RGB PNG"");
-7.          break;
-6.       default:
-5.         ",Not Useful
/*prtr'*/,"-10.             return png_icc_profile_error(png_ptr, colorspace, name, temp,
-9.                 ""Gray color space not permitted on RGB PNG"");
-8.          break;
-7.       default:
-6.          return png_icc_profile_error(png_ptr, colorspace, name, te",Not Useful
/*All supported*/,"-6.    switch (temp)
-5.    {

/*All supported*/

1.          break;",Not Useful
/*abst'*/,"-1.          break;

/*abst'*/

 ",Not Useful
/*nmcl'*/,"-2.          return png_icc_profile_error(png_ptr, colorspace, name, temp,
-1.              ""unexpected DeviceLink ICC profile class"");

/*nmcl'*/

 ",Not Useful
/*XYZ '*/,"-3.    temp = png_get_uint_32(profile+20);
-2.    switch (temp)
-1.    {

/*XYZ '*/

 ",Not Useful
/*Lab '*/,"-4.    temp = png_get_uint_32(profile+20);
-3.    switch (temp)
-2.    {

/*Lab '*/

1.          break;
2.       default:
3.          return png_icc_profile_error(png_ptr, colorspace, name, temp,
4.              ""unexpected ICC PCS encoding"");
5.    }
6. ",Not Useful
/*broken*/,"-4.          colorspace->flags |= PNG_COLORSPACE_INVALID;
-3.          png_benign_error(png_ptr, ""invalid chromaticities"");
-2.          break;
-1.       default:
         /* libpng is broken; this should be a warning but if it happens we

/*broken*/

1. ",Not Useful
/*broken*/,"-4.          colorspace->flags |= PNG_COLORSPACE_INVALID;
-3.          png_benign_error(png_ptr, ""invalid chromaticities"");
-2.          break;
-1.       default:
         /* libpng is broken; this should be a warning but if it happens we

/*broken*/

1. ",Not Useful
/*no match*/,"-10.                      png_chunk_report(png_ptr,
-9.                          ""out-of-date sRGB profile with no signature"",
-8.                          PNG_CHUNK_WARNING);
-7.                   }
-6.                   return 1+png_sRGB_checks[i].is_br",Not Useful
/*PNG_sRGB_PROFILE_CHECKS >= 0*/,"-2. }
-1. #ifdef PNG_sRGB_SUPPORTED
#if PNG_sRGB_PROFILE_CHECKS >= 0

/*PNG_sRGB_PROFILE_CHECKS >= 0*/

 ",Not Useful
/*sRGB*/,"-10. static int
-9. png_colorspace_check_gamma(png_const_structrp png_ptr,
-8.     png_colorspacerp colorspace, png_fixed_point gAMA, int from)
-7.    /* This is called to check a new gamma value against an existing one.  The
-6.     * routine returns fal",Not Useful
/*iCCP*/,"-10.          {
-9.             int i;
-8.             for (i = 0; i < info_ptr->pcal_nparams; i++)
-7.                png_free(png_ptr, info_ptr->pcal_params[i]);
-6.             png_free(png_ptr, info_ptr->pcal_params);
-5.             info_ptr->pcal_pa",Not Useful
/*big_row_buf hack*/,"-10.       png_warning(png_ptr, ""Image width is zero in IHDR"");
-9.       error = 1;
-8.    }
-7.    if (width > PNG_UINT_31_MAX)
-6.    {
-5.       png_warning(png_ptr, ""Invalid image width in IHDR"");
-4.       error = 1;
-3.    }
-2.    if (png_gt(((wid",Not Useful
/*two dots*/,"-4.          png_fp_add(state, type);
-3.          break;
-2.       case PNG_FP_INTEGER + PNG_FP_SAW_DOT:

/*two dots*/

1.             goto PNG_FP_End;",Not Useful
/*trailing dot?*/,"-1.             goto PNG_FP_End;

/*trailing dot?*/

1.             png_fp_add(state, type);
2.          else
3.             png_fp_set(state, PNG_FP_FRACTION | type);
4.          break;
5.       case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT:",Not Useful
"/*This is correct because the trailing '.' on an
          * integer is handled above - so we can only get here
          * with the sequence "".E"" (with no preceding digits).*/","-4.       case PNG_FP_FRACTION + PNG_FP_SAW_DIGIT:
-3.          png_fp_add(state, type | PNG_FP_WAS_VALID);
-2.          break;
-1.       case PNG_FP_FRACTION + PNG_FP_SAW_E:
         /* This is correct because the trailing '.' on an
          * integer i",Not Useful
/*must be non-zero - see above*/,"-7. int
-6. png_check_fp_string(png_const_charp string, png_size_t size)
-5. {
-4.    int        state=0;
-3.    png_size_t char_index=0;
-2.    if (png_check_fp_number(string, size, &state, &char_index) != 0 &&
-1.       (char_index == size || string[cha",Not Useful
/*pCAL || sCAL*/,"-1. }

/*pCAL || sCAL*/

1. #ifdef PNG_sCAL_SUPPORTED
2. #  ifdef PNG_FLOATING_POINT_SUPPORTED",Not Useful
"/*Function to format a floating point value in ASCII with a given
 * precision.*/","-2.    return d;
-1. }
/* Function to format a floating point value in ASCII with a given
 * precision.

/*Function to format a floating point value in ASCII with a given
 * precision.*/

1.  */
2. #if GCC_STRICT_OVERFLOW
3. #pragma GCC diagnostic push",Not Useful
/*See the requirements below.*/,"-3.    if (precision > DBL_DIG+1)
-2.       precision = DBL_DIG+1;

/*See the requirements below.*/

1.    {
2.       if (fp < 0)
3.       {
4.          fp = -fp;",Not Useful
/*10^exp_b10*/,"-5.          --size;
-4.       }
-3.       if (fp >= DBL_MIN && fp <= DBL_MAX)
-2.       {

/*10^exp_b10*/

 ",Not Useful
/*Avoid underflow here.*/,"-10.           * the calculation below rounds down when converting
-9.           * from base 2 to base 10 (multiply by log10(2) -
-8.           * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to
-7.           * be increased.  Note that the arithmetic shi",Not Useful
/*May underflow*/,"-10.           * from base 2 to base 10 (multiply by log10(2) -
-9.           * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to
-8.           * be increased.  Note that the arithmetic shift
-7.           * performs a floor() unlike C arithmetic - using ",Not Useful
/*I.e. 1+(ch-48)*/,"-3.                               exp_b10 = 1;
-2.                            }
-1.                            --cdigits;

/*I.e. 1+(ch-48)*/

1.                         }",Not Useful
/*cdigits == 0*/,"-3.                      if (czero > 0)
-2.                      {
-1.                         --czero; d = 1;
                        if (cdigits == 0) --clead;

/*cdigits == 0*/

1.                      }
2.                      else
3.                 ",Not Useful
/*0'*/,"-10.             if (size > cdigits)
-9.             {
-8.                while (cdigits > 0) *ascii++ = exponent[--cdigits];
-7.                *ascii = 0;
-6.                return;
-5.             }
-4.          }
-3.       }
-2.       else if (!(fp >=",Not Useful
/*i'*/,"-5.          *ascii = 0;
-4.          return;
-3.       }
-2.       else
-1.       {

/*i'*/

 ",Not Useful
/*n'*/,"-6.          *ascii = 0;
-5.          return;
-4.       }
-3.       else
-2.       {

/*n'*/

 ",Not Useful
/*f'*/,"-7.          *ascii = 0;
-6.          return;
-5.       }
-4.       else
-3.       {

/*f'*/

1.          *ascii = 0;
2.          return;
3.       }
4.    }",Not Useful
/*FLOATING_POINT*/,"-1. #ifdef PNG_sCAL_SUPPORTED
#  ifdef PNG_FLOATING_POINT_SUPPORTED

/*FLOATING_POINT*/

 ",Not Useful
/*Avoid overflow here on the minimum integer.*/,"-3.    if (size > 12)
-2.    {
-1.       png_uint_32 num;

/*Avoid overflow here on the minimum integer.*/

1.       if (fp < 0)
2.       {
3.          *ascii++ = 45; num = (png_uint_32)(-fp);
4.       }
5.       else
6.          num = (png_uint_32)fp;",Not Useful
/*FIXED_POINT*/,"
#  ifdef PNG_FIXED_POINT_SUPPORTED



/*FIXED_POINT*/

 ",Not Useful
/*SCAL*/,"if (((mask & PNG_FREE_SCAL) & info_ptr->free_me) != 0)

/*SCAL*/

1.    {
2.       png_free(png_ptr, info_ptr->scal_s_width);
3.       png_free(png_ptr, info_ptr->scal_s_height);
4.       info_ptr->scal_s_width = NULL;
5.       info_ptr->scal_s_height = NULL;
6.       info_ptr->valid &= ~PNG_INFO_sCAL;
7.    }
8. #endif
9. #ifdef PNG_pCAL_SUPPORTED",Not Useful
/*from above*/,"-10. }
-9. #endif
-8. #if defined(PNG_GAMMA_SUPPORTED) || defined(PNG_COLORSPACE_SUPPORTED) ||\
-7.     defined(PNG_INCH_CONVERSIONS_SUPPORTED) || defined(PNG_READ_pHYs_SUPPORTED)

/*from above*/

 ",Not Useful
/*READ_GAMMA || INCH_CONVERSIONS*/,"-10.             }
-9.          }
-8. #endif
-7.       }
-6.    }
-5.    return 0;
-4. }
-3. #if GCC_STRICT_OVERFLOW
-2. #pragma GCC diagnostic pop

/*READ_GAMMA || INCH_CONVERSIONS*/

1. #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIO",Not Useful
/*error/overflow*/,"-10. {
-9. #ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
-8.    double r = floor(1E10/a+.5);
-7.    if (r <= 2147483647. && r >= -2147483648.)
-6.       return (png_fixed_point)r;
-5. #else
-4.    png_fixed_point res;
-3.    if (png_muldiv(&res, 100000, 100000",Not Useful
/*A local convenience routine.*/,"-8. png_gamma_significant(png_fixed_point gamma_val)
-7. {
-6.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-5.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-4. }
-3. #endif
-2. #ifdef PNG_READ_GAMMA_SUPPORTED
-1. #ifdef PNG_1",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT",Not Useful
/*<= '257'*/,"-1.    x -= 1U << 24;

/*<= '257'*/

1.       lg2 += ((23591U * (65536U-x)) + (1U << (16+6-12-1))) >> (16+6-12);
2.    else
3.       lg2 -= ((23499U * (x-65536U)) + (1U << (16+6-12-1))) >> (16+6-12);",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT",Not Useful
/*FLOATING_ARITHMETIC*/,"-6. #if defined(PNG_FLOATING_POINT_SUPPORTED) && \
-5.    !defined(PNG_FIXED_POINT_MACRO_SUPPORTED) && \
-4.    (defined(PNG_gAMA_SUPPORTED) || defined(PNG_cHRM_SUPPORTED) || \
-3.    defined(PNG_sCAL_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) |",Not Useful
/*SAFE*/,"-10.           * We can be reasonably sure that an unsigned to float conversion
-9.           * won't be faster than an int to float one.  Therefore this code
-8.           * assumes responsibility for the undefined behavior, which it knows
-7.           ",Not Useful
"/*The same (unsigned int)->(double) constraints apply here as above,
       * however in this case the (unsigned int) to (int) conversion can
       * overflow on an ANSI-C90 compliant system so the cast needs to ensure
       * that this is not possible.*/","-10.    }
-9.    return (png_byte)(value & 0xff);
-8. }
-7. #ifdef PNG_16BIT_SUPPORTED
-6. png_uint_16
-5. png_gamma_16bit_correct(unsigned int value, png_fixed_point gamma_val)
-4. {
-3.    if (value > 0 && value < 65535)
-2.    {
-1. # ifdef PNG_FLOATIN",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT",Not Useful
/*should not reach this*/,"-9. png_gamma_correct(png_structrp png_ptr, unsigned int value,
-8.     png_fixed_point gamma_val)
-7. {
-6.    if (png_ptr->bit_depth == 8)
-5.       return png_gamma_8bit_correct(value, gamma_val);
-4. #ifdef PNG_16BIT_SUPPORTED
-3.    else
-2.       re",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT",Not Useful
/*Guarantees at least one table!*/,"-4.          if (shift < (16U - PNG_MAX_GAMMA_8))
-3.             shift = (16U - PNG_MAX_GAMMA_8);
-2.       }
-1.       if (shift > 8U)

/*Guarantees at least one table!*/

1.       png_ptr->gamma_shift = shift;",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT",Not Useful
/*SIMPLIFIED_READ*/,"
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\



/*SIMPLIFIED_READ*/

1.    defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)
2. /* sRGB conversion tables; these are machine generated with the code in
3.  * contrib/tools/makesRGB.c.  The actual sRGB transfer curve defined in the",Not Useful
/*SIMPLIFIED READ/WRITE SUPPORT*/,"-10.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-9.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-8.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-7.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-6.    8,8,8,8,8,8,8,8,8,7,7,7,7,7,7,7,
-5.    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-4.    7,7,7,7",Not Useful
/*SIMPLIFIED READ/WRITE*/,"-10.    9,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-9.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-8.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-7.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-6.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-5.    8,8,8,8,8,8,8,8,8,7,7,7,7,7,7,7,
-4.    7,7,7,7",Not Useful
/*FALLTHROUGH*/,"-2.          png_warning(png_ptr,
-1.              ""Can't discard critical data on CRC error"");

/*FALLTHROUGH*/

 ",Not Useful
/*Error/quit*/,"-3.          png_warning(png_ptr,
-2.              ""Can't discard critical data on CRC error"");

/*Error/quit*/

1.       case PNG_CRC_DEFAULT:
2.       default:
3.          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
4.          break;
5.    }",Not Useful
/*Error/quit*/,"-3.          png_warning(png_ptr,
-2.              ""Can't discard critical data on CRC error"");

/*Error/quit*/

1.       case PNG_CRC_DEFAULT:
2.       default:
3.          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
4.          break;
5.    }",Not Useful
/*Ok*/,"-1.          png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;

/*Ok*/

1.       }
2.    }",Not Useful
/*no png_error possible!*/,"-2.       }
-1.    }

/*no png_error possible!*/

1. }
2. #endif
3. #ifdef PNG_READ_BACKGROUND_SUPPORTED",Not Useful
/*FLOATING_POINT*/,"-10.    png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
-9.    png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-8.    png_ptr->background = *background_color;
-7.    png_ptr->background_gamma = background_gamma;
-6.    png_ptr->background_gamma_type = (png_byt",Not Useful
/*Chop 16-bit depth files to 8-bit depth*/,"-10. void PNGAPI
-9. png_set_scale_16(png_structrp png_ptr)
-8. {
-7.    png_debug(1, ""in png_set_scale_16"");
-6.    if (png_rtran_ok(png_ptr, 0) == 0)
-5.       return;
-4.    png_ptr->transformations |= PNG_SCALE_16_TO_8;
-3. }
-2. #endif
-1. #ifdef PNG",Not Useful
/*This preserves -1 and -2 exactly:*/,"-2.    if (output_gamma > 0 && output_gamma < 128)
-1.       output_gamma *= PNG_FP_1;

/*This preserves -1 and -2 exactly:*/

1.    output_gamma = floor(output_gamma + .5);
2.    if (output_gamma > PNG_FP_MAX || output_gamma < PNG_FP_MIN)
3.       png_fi",Not Useful
/*Initialize the quantize_sort array*/,"-2.          png_ptr->quantize_sort = (png_bytep)png_malloc(png_ptr,
-1.              (png_alloc_size_t)((png_uint_32)num_palette * (sizeof (png_byte))));

/*Initialize the quantize_sort array*/

1.          for (i = 0; i < num_palette; i++)
2.           ",Not Useful
/*int dr = abs(ir - r);*/,"-10.           (sizeof (png_byte))));
-9.       memset(distance, 0xff, num_entries * (sizeof (png_byte)));
-8.       for (i = 0; i < num_palette; i++)
-7.       {
-6.          int ir, ig, ib;
-5.          int r = (palette[i].red >> (8 - PNG_QUANTIZE_RED_B",Not Useful
/*int dg = abs(ig - g);*/,"-5.             int dr = ((ir > r) ? ir - r : r - ir);
-4.             int index_r = (ir << (PNG_QUANTIZE_BLUE_BITS +
-3.                 PNG_QUANTIZE_GREEN_BITS));
-2.             for (ig = 0; ig < num_green; ig++)
-1.             {

/*int dg = abs(ig - ",Not Useful
/*int db = abs(ib - b);*/,"-7.                int dg = ((ig > g) ? ig - g : g - ig);
-6.                int dt = dr + dg;
-5.                int dm = ((dr > dg) ? dr : dg);
-4.                int index_g = index_r | (ig << PNG_QUANTIZE_BLUE_BITS);
-3.                for (ib = 0; ib",Not Useful
/*READ_QUANTIZE*/,"-10. }
-9. #  ifdef PNG_FLOATING_POINT_SUPPORTED
-8. void PNGAPI
-7. png_set_alpha_mode(png_structrp png_ptr, int mode, double output_gamma)
-6. {
-5.    png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,
-4.        output_gamma));
-3. }",Not Useful
/*file*/,"-10.  *
-9.  * Last changed in libpng 1.6.33 [September 28, 2017]
-8.  * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
-7.  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
-6.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Scha",Not Useful
/*FLOATING_POINT*/,"-10.    png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
-9.    png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-8.    png_ptr->background = *background_color;
-7.    png_ptr->background_gamma = background_gamma;
-6.    png_ptr->background_gamma_type = (png_byt",Not Useful
/*READ_EXPAND*/,"
#ifdef PNG_READ_EXPAND_SUPPORTED



/*READ_EXPAND*/

 ",Not Useful
/*READ_EXPAND && READ_BACKGROUND*/,"-2.       }

/*READ_EXPAND && READ_BACKGROUND*/

1. }",Not Useful
/*FALLTHROUGH*/,"-2.          png_warning(png_ptr,
-1.              ""Can't discard critical data on CRC error"");

/*FALLTHROUGH*/

 ",Not Useful
/*back_1*/,"png_color back, back_1;

/*back_1*/

1.             png_colorp palette = png_ptr->palette;
2.             int num_palette = png_ptr->num_palette;
3.             int i;
4.             if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)
5.             {
6.                back.red = png_ptr->gamma_table[png_ptr->background.red];
7.                back.green = png_ptr->gamma_table[png_ptr->background.green];
8.                back.blue = png_ptr->gamma_table[png_ptr->background.blue];
9.                back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];
10.                back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];",Not Useful
/*back*/,"-3. }
-2. #endif
-1. #ifdef PNG_READ_BACKGROUND_SUPPORTED

/*back*/

1. void PNGFAPI
2. png_set_background_fixed(png_structrp png_ptr,
3.     png_const_color_16p background_color, int background_gamma_code,
4.     int need_expand, png_fixed_point backgrou",Not Useful
/*if (png_ptr->trans_alpha[i] != 0xff)*/,"-10.             }
-9.             for (i = 0; i < num_palette; i++)
-8.             {
-7.                if (i < (int)png_ptr->num_trans &&
-6.                    png_ptr->trans_alpha[i] != 0xff)
-5.                {
-4.                   if (png_ptr->tr",Not Useful
/*gs = PNG_FP_1;*/,"-10.                back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];
-9.                back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];
-8.             }
-7.             else
-6.             {
-5.                png_fixed_point ",Not Useful
/*RGB or RGBA with color background*/,"-10.             if (g_sig != 0)
-9.                png_ptr->background_1.gray = png_gamma_correct(png_ptr,
-8.                    png_ptr->background.gray, g);
-7.             if (gs_sig != 0)
-6.                png_ptr->background.gray = png_gamma_corre",Not Useful
"/*GRAY, GRAY ALPHA, RGB, or RGBA with gray background*/","-10.                   png_ptr->background.red = png_gamma_correct(png_ptr,
-9.                       png_ptr->background.red, gs);
-8.                   png_ptr->background.green = png_gamma_correct(png_ptr,
-7.                       png_ptr->background.",Not Useful
/*READ_SHIFT*/,"
#ifdef PNG_READ_SHIFT_SUPPORTED



/*READ_SHIFT*/

1.    if ((png_ptr->transformations & PNG_SHIFT) != 0 &&
2.        (png_ptr->transformations & PNG_EXPAND) == 0 &&
3.        (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
4.    {
5.       int i;
6.       int istop = png_ptr->num_palette;
7.       int shift = 8 - png_ptr->sig_bit.red;
8.       png_ptr->transformations &= ~PNG_SHIFT;
9.       /* significant bits can be in the range 1 to 7 for a meaninful result, if
10.        * the number of significant bits is 0 then no shift is done (this is an",Not Useful
/*PRIVATE*/,"-10.    png_ptr->read_user_transform_fn = read_user_transform_fn;
-9. #endif
-8. }
-7. #endif
-6. #ifdef PNG_READ_TRANSFORMS_SUPPORTED
-5. #ifdef PNG_READ_GAMMA_SUPPORTED

/*PRIVATE*/

1. png_gamma_threshold(png_fixed_point screen_gamma, png_fixed_point f",Not Useful
/*!READ_16BIT*/,"-10.          png_ptr->transformations |= PNG_16_TO_8;
-9.          info_ptr->bit_depth = 8;
-8. #     else
-7. #        ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-6.             png_ptr->transformations |= PNG_SCALE_16_TO_8;
-5.             info_ptr->bit_de",Not Useful
/*NOTREACHED*/,"-10.             else
-9.                have_shift = 1;
-8.          }
-7.          if (have_shift == 0)
-6.             return;
-5.       }
-4.       switch (bit_depth)
-3.       {
-2.          default:

/*NOTREACHED*/

1.             break;
2.         ",Not Useful
/*source*/,"-2. #ifdef PNG_READ_GAMMA_SUPPORTED
-1.    /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds
    * png_set_alpha_mode and this is another source for a default file gamma so

/*source*/

1.     * the test needs to be performed lat",Not Useful
/*end+1*/,"-8. static void
-7. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-6. {
-5.    png_debug(1, ""in png_do_scale_16_to_8"");
-4.    if (row_info->bit_depth == 16)
-3.    {

/*end+1*/

1.       while (sp < ep)
2.       {
3.          /* The input i",Not Useful
/*source*/,"-2. #ifdef PNG_READ_GAMMA_SUPPORTED
-1.    /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds
    * png_set_alpha_mode and this is another source for a default file gamma so

/*source*/

1.     * the test needs to be performed lat",Not Useful
/*destination*/,"-7. static void
-6. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-5. {
-4.    png_debug(1, ""in png_do_scale_16_to_8"");
-3.    if (row_info->bit_depth == 16)
-2.    {

/*destination*/

 ",Not Useful
/*end+1*/,"-8. static void
-7. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-6. {
-5.    png_debug(1, ""in png_do_scale_16_to_8"");
-4.    if (row_info->bit_depth == 16)
-3.    {

/*end+1*/

1.       while (sp < ep)
2.       {
3.          /* The input i",Not Useful
"/**(--dp) = *(--sp);
            *(--dp) = *(--sp);*/","-9.          if (row_info->bit_depth == 8)
-8.          {
-7.             png_bytep sp = row + row_info->rowbytes;
-6.             png_bytep dp = sp;
-5.             png_byte save;
-4.             png_uint_32 i;
-3.             for (i = 0; i < row_width; ",Not Useful
/*RGB bit_depth == 16*/,"-10.                    */
-9.                   *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
-8.                }
-7.                else
-6.                   *(dp++) = red;
-5.                if (have_alpha != 0)
-4.                   *(dp+",Not Useful
/*if (row_info->bit_depth == 16)*/,"-4. static void
-3. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-2. {
-1.    png_debug(1, ""in png_do_scale_16_to_8"");
   if (row_info->bit_depth == 16)

/*if (row_info->bit_depth == 16)*/

1.    {",Not Useful
/*if (png_ptr->bit_depth == 16)*/,"-10.                   for (i = 0; i < row_width; i++, sp += 2)
-9.                   {
-8.                      png_byte a = *(sp + 1);
-7.                      if (a == 0)
-6.                         *sp = (png_byte)png_ptr->background.gray;
-5.        ",Not Useful
/*if (row_info->bit_depth == 16)*/,"-4. static void
-3. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-2. {
-1.    png_debug(1, ""in png_do_scale_16_to_8"");
   if (row_info->bit_depth == 16)

/*if (row_info->bit_depth == 16)*/

1.    {",Not Useful
/*if (row_info->bit_depth == 16)*/,"-4. static void
-3. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-2. {
-1.    png_debug(1, ""in png_do_scale_16_to_8"");
   if (row_info->bit_depth == 16)

/*if (row_info->bit_depth == 16)*/

1.    {",Not Useful
/*if (row_info->bit_depth == 16)*/,"-4. static void
-3. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-2. {
-1.    png_debug(1, ""in png_do_scale_16_to_8"");
   if (row_info->bit_depth == 16)

/*if (row_info->bit_depth == 16)*/

1.    {",Not Useful
/*if (row_info->bit_depth == 16)*/,"-4. static void
-3. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-2. {
-1.    png_debug(1, ""in png_do_scale_16_to_8"");
   if (row_info->bit_depth == 16)

/*if (row_info->bit_depth == 16)*/

1.    {",Not Useful
/*READ_QUANTIZE*/,"-10. }
-9. #  ifdef PNG_FLOATING_POINT_SUPPORTED
-8. void PNGAPI
-7. png_set_alpha_mode(png_structrp png_ptr, int mode, double output_gamma)
-6. {
-5.    png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,
-4.        output_gamma));
-3. }",Not Useful
/*READ_QUANTIZE*/,"-10. }
-9. #  ifdef PNG_FLOATING_POINT_SUPPORTED
-8. void PNGAPI
-7. png_set_alpha_mode(png_structrp png_ptr, int mode, double output_gamma)
-6. {
-5.    png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,
-4.        output_gamma));
-3. }",Not Useful
/*png_ptr*/,"-1. void PNGAPI
png_set_crc_action(png_structrp png_ptr, int crit_action, int ancil_action)

/*png_ptr*/

1. {
2.    png_debug(1, ""in png_set_crc_action"");
3.    if (png_ptr == NULL)
4.       return;",Not Useful
/*row_info:*/,"-10.    if ((png_ptr->transformations & PNG_SWAP_BYTES) != 0)
-9.       png_do_swap(row_info, png_ptr->row_buf + 1);
-8. #endif
-7. #endif
-6. #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-5.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-4.   ",Not Useful
/*png_uint_32 width;       width of row*/,"-10.       png_do_swap(row_info, png_ptr->row_buf + 1);
-9. #endif
-8. #endif
-7. #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-6.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-5.    {
-4.       if (png_ptr->read_user_transform_fn != NULL)

/*",Not Useful
/*png_byte bit_depth;      bit depth of samples*/,"-10. #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-9.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-8.    {
-7.       if (png_ptr->read_user_transform_fn != NULL)

/*png_byte bit_depth;      bit depth of samples*/

 ",Not Useful
/*READ_TRANSFORMS*/,"-6.       case PNG_CRC_DEFAULT:
-5.       default:
-4.          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
-3.          break;
-2.    }
-1. }
#ifdef PNG_READ_TRANSFORMS_SUPPORTED

/*READ_TRANSFORMS*/

 ",Not Useful
"/*SAFE, does not exceed 8*/","-2. png_push_read_sig(png_structrp png_ptr, png_inforp info_ptr)
-1. {

/*SAFE, does not exceed 8*/

1.        num_to_check = 8 - num_checked;
2.    if (png_ptr->buffer_size < num_to_check)
3.    {
4.       num_to_check = png_ptr->buffer_size;
5.    }
6. ",Not Useful
/*READ_INTERLACING*/,"-8.    if (png_ptr->transformed_pixel_depth == 0)
-7.    {
-6.       png_ptr->transformed_pixel_depth = row_info.pixel_depth;
-5.       if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
-4.          png_error(png_ptr, ""progressive row overflow"");
-",Not Useful
/*READ_INTERLACING*/,"-8.    if (png_ptr->transformed_pixel_depth == 0)
-7.    {
-6.       png_ptr->transformed_pixel_depth = row_info.pixel_depth;
-5.       if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
-4.          png_error(png_ptr, ""progressive row overflow"");
-",Not Useful
/*Put the chunk name into png_ptr->chunk_name*/,"-3.    png_save_uint_32(buf, length);
-2.    png_save_uint_32(buf + 4, chunk_name);
-1.    png_write_data(png_ptr, buf, 8);

/*Put the chunk name into png_ptr->chunk_name*/

1.    png_ptr->chunk_name = chunk_name;",Not Useful
/*Finish a chunk started with png_write_chunk_header().*/,"-3.       png_calculate_crc(png_ptr, data, length);
-2.    }
-1. }

/*Finish a chunk started with png_write_chunk_header().*/

1. void PNGAPI
2. png_write_chunk_end(png_structrp png_ptr)
3. {
4.    png_byte buf[4];
5.    if (png_ptr == NULL) return;
6. #i",Not Useful
/*WRITE_OPTIMIZE_CMF*/,"-10.                cb_base += (PNG_ROWBYTES(pd, pw)+1) * PNG_PASS_ROWS(h, pass);
-9.          }
-8.          return cb_base;
-7.       }
-6.       else
-5.          return (png_ptr->rowbytes+1) * h;
-4.    }
-3.    else
-2.       return 0xffffffffU;
-1. ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*The uncompressed input data*/,"-10.  * The compression_state structure is shared context for these functions
-9.  * set up by the caller to allow access to the relevant local variables.
-8.  *
-7.  * compression_buffer (new in 1.6.0) is just a linked list of zbuffer_size
-6.  * tempora",Not Useful
/*Its length*/,"-10.  * set up by the caller to allow access to the relevant local variables.
-9.  *
-8.  * compression_buffer (new in 1.6.0) is just a linked list of zbuffer_size
-7.  * temporary buffers.  From 1.6.0 it is retained in png_struct so that it will
-6.  * b",Not Useful
/*Final compressed length*/,"-10.  *
-9.  * compression_buffer (new in 1.6.0) is just a linked list of zbuffer_size
-8.  * temporary buffers.  From 1.6.0 it is retained in png_struct so that it will
-7.  * be correctly freed in the event of a write error (previous implementations
-6.",Not Useful
/*may be zero!*/,"-2.    {
-1.       png_compression_bufferp *end = &png_ptr->zbuffer_list;

/*may be zero!*/

1.       png_uint_32 output_len;",Not Useful
/*safety*/,"-10.          (png_ptr->zlib_set_level != level ||
-9.          png_ptr->zlib_set_method != method ||
-8.          png_ptr->zlib_set_window_bits != windowBits ||
-7.          png_ptr->zlib_set_mem_level != memLevel ||
-6.          png_ptr->zlib_set_strate",Not Useful
/*safety*/,"-10.          (png_ptr->zlib_set_level != level ||
-9.          png_ptr->zlib_set_method != method ||
-8.          png_ptr->zlib_set_window_bits != windowBits ||
-7.          png_ptr->zlib_set_mem_level != memLevel ||
-6.          png_ptr->zlib_set_strate",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Save the relevant information*/,"-10. #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-9.    if (interlace_type != PNG_INTERLACE_NONE &&
-8.        interlace_type != PNG_INTERLACE_ADAM7)
-7.    {
-6.       png_warning(png_ptr, ""Invalid interlace type specified"");
-5.       interlace_type = PNG_IN",Not Useful
/*not READY_FOR_ZTXT*/,"-9.    png_write_complete_chunk(png_ptr, png_IHDR, buf, (png_size_t)13);
-8.    if ((png_ptr->do_filter) == PNG_NO_FILTERS)
-7.    {
-6.       if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
-5.           png_ptr->bit_depth < 8)
-4.          png_ptr-",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write an IEND chunk*/,"-5.          png_zstream_error(png_ptr, ret);
-4.          png_error(png_ptr, png_ptr->zstream.msg);
-3.       }
-2.    }
-1. }

/*Write an IEND chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write a gAMA chunk*/,"-7. png_write_IEND(png_structrp png_ptr)
-6. {
-5.    png_debug(1, ""in png_write_IEND"");
-4.    png_write_complete_chunk(png_ptr, png_IEND, NULL, (png_size_t)0);
-3.    png_ptr->mode |= PNG_HAVE_IEND;
-2. }
-1. #ifdef PNG_WRITE_gAMA_SUPPORTED

/*Write a g",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write a sRGB chunk*/,"-5.    png_save_uint_32(buf, (png_uint_32)file_gamma);
-4.    png_write_complete_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_sRGB_SUPPORTED

/*Write a sRGB chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write an iCCP chunk*/,"-10.    png_byte buf[1];
-9.    png_debug(1, ""in png_write_sRGB"");
-8.    if (srgb_intent >= PNG_sRGB_INTENT_LAST)
-7.       png_warning(png_ptr,
-6.           ""Invalid sRGB rendering intent specified"");
-5.    buf[0]=(png_byte)srgb_intent;
-4.    png_wri",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write a sPLT chunk*/,"-9.    if (png_text_compress(png_ptr, png_iCCP, &comp, name_len) != Z_OK)
-8.       png_error(png_ptr, png_ptr->zstream.msg);
-7.    png_write_chunk_header(png_ptr, png_iCCP, name_len + comp.output_len);
-6.    png_write_chunk_data(png_ptr, new_name, name",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write the sBIT chunk*/,"-10.          png_save_uint_16(entrybuf + 6, ep[i].alpha);
-9.          png_save_uint_16(entrybuf + 8, ep[i].frequency);
-8.       }
-7.       png_write_chunk_data(png_ptr, entrybuf, entry_size);
-6.    }
-5. #endif
-4.    png_write_chunk_end(png_ptr);
-3",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write the cHRM chunk*/,"-10.       {
-9.          png_warning(png_ptr, ""Invalid sBIT depth specified"");
-8.          return;
-7.       }
-6.       buf[size++] = sbit->alpha;
-5.    }
-4.    png_write_complete_chunk(png_ptr, png_sBIT, buf, size);
-3. }
-2. #endif
-1. #ifdef PNG_W",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write the tRNS chunk*/,"-10.    png_save_int_32(buf +  8, xy->redx);
-9.    png_save_int_32(buf + 12, xy->redy);
-8.    png_save_int_32(buf + 16, xy->greenx);
-7.    png_save_int_32(buf + 20, xy->greeny);
-6.    png_save_int_32(buf + 24, xy->bluex);
-5.    png_save_int_32(buf + ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write the Exif data*/,"-10.          png_warning(png_ptr,
-9.              ""Ignoring attempt to write bKGD chunk out-of-range for bit_depth"");
-8.          return;
-7.       }
-6.       png_save_uint_16(buf, back->gray);
-5.       png_write_complete_chunk(png_ptr, png_bKGD, buf",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write a tEXt chunk*/,"-10.    png_write_chunk_header(png_ptr, png_hIST, (png_uint_32)(num_hist * 2));
-9.    for (i = 0; i < num_hist; i++)
-8.    {
-7.       png_save_uint_16(buf, hist[i]);
-6.       png_write_chunk_data(png_ptr, buf, (png_size_t)2);
-5.    }
-4.    png_write",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Close the chunk*/,"-1.    png_write_compressed_data_out(png_ptr, &comp);

/*Close the chunk*/

1.    png_write_chunk_end(png_ptr);
2. }
3. #endif
4. #ifdef PNG_WRITE_iTXt_SUPPORTED",Not Useful
/*Write an iTXt chunk*/,"-4.    png_write_chunk_end(png_ptr);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_iTXt_SUPPORTED

/*Write an iTXt chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*SAFE*/,"-10.    if (compression != 0)
-9.    {
-8.       if (png_text_compress(png_ptr, png_iTXt, &comp, prefix_len) != Z_OK)
-7.          png_error(png_ptr, png_ptr->zstream.msg);
-6.    }
-5.    else
-4.    {
-3.       if (comp.input_len > PNG_UINT_31_MAX-prefi",Not Useful
/*Write the oFFs chunk*/,"-10.    png_write_chunk_data(png_ptr, (png_const_bytep)lang, lang_len);
-9.    png_write_chunk_data(png_ptr, (png_const_bytep)lang_key, lang_key_len);
-8.    if (compression != 0)
-7.       png_write_compressed_data_out(png_ptr, &comp);
-6.    else
-5.   ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write the pCAL chunk (described in the PNG extensions document)*/,"-10.    png_debug(1, ""in png_write_oFFs"");
-9.    if (unit_type >= PNG_OFFSET_LAST)
-8.       png_warning(png_ptr, ""Unrecognized unit type for oFFs chunk"");
-7.    png_save_int_32(buf, x_offset);
-6.    png_save_int_32(buf + 4, y_offset);
-5.    buf[8] = ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*Write the pHYs chunk*/,"-5.    png_debug1(3, ""sCAL total length = %u"", (unsigned int)total_len);
-4.    png_write_complete_chunk(png_ptr, png_sCAL, buf, total_len);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_pHYs_SUPPORTED

/*Write the pHYs chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*WRITE_FILTER*/,"-4.    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-3. #endif
-2.    png_alloc_size_t buf_size;
-1.    int usr_pixel_depth;
#ifdef PNG_WRITE_FILTER_SUPPORTED

/*WRITE_FILTER*/

1.    png_byte filters;
2. #endif
3.    png_debug(1, """,Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*WRITE_FILTER*/,"-4.    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-3. #endif
-2.    png_alloc_size_t buf_size;
-1.    int usr_pixel_depth;
#ifdef PNG_WRITE_FILTER_SUPPORTED

/*WRITE_FILTER*/

1.    png_byte filters;
2. #endif
3.    png_debug(1, """,Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_fr",Not Useful
/*WRITE_FILTER*/,"-4.    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-3. #endif
-2.    png_alloc_size_t buf_size;
-1.    int usr_pixel_depth;
#ifdef PNG_WRITE_FILTER_SUPPORTED

/*WRITE_FILTER*/

1.    png_byte filters;
2. #endif
3.    png_debug(1, """,Not Useful
/*WRITE_FILTER*/,"-4.    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-3. #endif
-2.    png_alloc_size_t buf_size;
-1.    int usr_pixel_depth;
#ifdef PNG_WRITE_FILTER_SUPPORTED

/*WRITE_FILTER*/

1.    png_byte filters;
2. #endif
3.    png_debug(1, """,Not Useful
/*WRITE_FLUSH*/,"-1.    png_write_finish_row(png_ptr);
#ifdef PNG_WRITE_FLUSH_SUPPORTED

/*WRITE_FLUSH*/

1.    png_ptr->flush_rows++;
2.    if (png_ptr->flush_dist > 0 &&
3.        png_ptr->flush_rows >= png_ptr->flush_dist)
4.    {
5.       png_write_flush(png_ptr);
6. ",Not Useful
/*PACKSWAP || WRITE_PACKSWAP*/,"-10.       else if (row_info->bit_depth == 2)
-9.          table = twobppswaptable;
-8.       else if (row_info->bit_depth == 4)
-7.          table = fourbppswaptable;
-6.       else
-5.          return;
-4.       for (rp = row; rp < end; rp++)
-3.       ",Not Useful
/*source pointer*/,"-2. png_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)
-1. {

/*source pointer*/

 ",Not Useful
/*destination pointer*/,"-3. png_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)
-2. {

/*destination pointer*/

 ",Not Useful
/*READ_BGR || WRITE_BGR*/,"-10.                *(rp + 4) = save;
-9.                save = *(rp + 1);
-8.                *(rp + 1) = *(rp + 5);
-7.                *(rp + 5) = save;
-6.             }
-5.          }
-4.       }
-3. #endif
-2.    }
-1. }

/*READ_BGR || WRITE_BGR*/

1.",Not Useful
/*num_palette can be 0 in MNG files*/,"-3. png_do_check_palette_indexes(png_structrp png_ptr, png_row_infop row_info)
-2. {
-1.    if (png_ptr->num_palette < (1 << row_info->bit_depth) &&

/*num_palette can be 0 in MNG files*/

1.    {",Not Useful
/*CHECK_FOR_INVALID_INDEX*/,"
#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \



/*CHECK_FOR_INVALID_INDEX*/

1.     defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)",Not Useful
/*USER_TRANSFORM_INFO*/,"-10.  */
-9. #ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
-8. png_voidp PNGAPI
-7. png_get_user_transform_ptr(png_const_structrp png_ptr)
-6. {
-5.    if (png_ptr == NULL)
-4.       return (NULL);
-3.    return png_ptr->user_transform_ptr;
-2. }
-1. #endif
#if",Not Useful
/*READ_USER_TRANSFORM || WRITE_USER_TRANSFORM*/,"-2. }

/*READ_USER_TRANSFORM || WRITE_USER_TRANSFORM*/

 ",Not Useful
/*png_set_invert_mono*/,"-10. {
-9.    UNUSED(colour_type)
-8.    this->next = *that;
-7.    *that = this;
-6.    return bit_depth < 8;
-5. }
-4. IT(packswap);
-3. #undef PT
-2. #define PT ITSTRUCT(packswap)

/*png_set_invert_mono*/

1. #ifdef PNG_READ_INVERT_MONO_SUPPORTED",Not Useful
/*PNG_READ_INVERT_MONO_SUPPORTED*/,"
#ifdef PNG_READ_INVERT_MONO_SUPPORTED



/*PNG_READ_INVERT_MONO_SUPPORTED*/

 ",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*PNG_READ_SHIFT_SUPPORTED*/,"
#ifdef PNG_READ_SHIFT_SUPPORTED



/*PNG_READ_SHIFT_SUPPORTED*/

 ",Not Useful
/*PNG_READ_TRANSFORMS_SUPPORTED*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, ",Not Useful
/*Local variables*/,"-3.    png_modifier*              pm;
-2.    const image_transform* transform_list;
-1.    unsigned int max_gamma_8;

/*Local variables*/

1.    png_byte output_colour_type;
2.    png_byte output_bit_depth;
3.    png_byte unpacked;",Not Useful
/*Standard fields*/,"-5. static void
-4. transform_display_init(transform_display *dp, png_modifier *pm, png_uint_32 id,
-3.     const image_transform *transform_list)
-2. {
-1.    memset(dp, 0, sizeof *dp);

/*Standard fields*/

1.    standard_display_init(&dp->this, &pm->th",Not Useful
/*Reuse the standard stuff as appropriate.*/,"-4. }
-3. static void
-2. transform_info_imp(transform_display *dp, png_structp pp, png_infop pi)
-1. {

/*Reuse the standard stuff as appropriate.*/

1.    standard_info_part1(&dp->this, pp, pi);",Not Useful
/*The following works both in 1.5.4 and earlier versions:*/,"-4.    if (dp->scale16)
-3. #     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-2.          png_set_scale_16(pp);
-1. #     else

/*The following works both in 1.5.4 and earlier versions:*/

1. #        ifdef PNG_READ_16_TO_8_SUPPORTED
2.             png_set_st",Not Useful
/*need_expand*/,"-2. #ifdef PNG_READ_BACKGROUND_SUPPORTED
-1. /* png_set_background(png_structp, png_const_color_16p background_color,
 *    int background_gamma_code, int need_expand, double background_gamma)

/*need_expand*/

1.  * png_set_background_fixed(png_structp, ",Not Useful
/*need_expand*/,"-2. #ifdef PNG_READ_BACKGROUND_SUPPORTED
-1. /* png_set_background(png_structp, png_const_color_16p background_color,
 *    int background_gamma_code, int need_expand, double background_gamma)

/*need_expand*/

1.  * png_set_background_fixed(png_structp, ",Not Useful
/*A component*/,"-5.             output_is_encoded = 0;
-4.             log_max_error = 0;
-3.          }
-2.       }
-1. #ifdef PNG_READ_ALPHA_MODE_SUPPORTED

/*A component*/

1.       {
2.          if (do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED &&",Not Useful
/*Quantize this appropriately:*/,"-10.           * this encode input_sample adjusted by the maximum error (tmp) above.
-9.           */
-8.          es_lo = encoded_sample - vi->maxout;
-7.          if (es_lo > 0 && input_sample-tmp > 0)
-6.          {
-5.             double low_value = i",Not Useful
/*!use_input_precision*/,"-10.                      if (!(od < is_lo || od > is_hi))
-9.                      {
-8.                         if (encoded_error < vi->outlog)
-7.                            return i;
-6.                         pass = ""within 8 bit limits:\n"";
-5.    ",Not Useful
/*FALLTHROUGH*/,"-4.    switch (dp->output_colour_type)
-3.    {
-2.    case PNG_COLOR_TYPE_PALETTE:
-1.       if (dp->output_bit_depth > 8) goto error;

/*FALLTHROUGH*/

1.    case PNG_COLOR_TYPE_GRAY:
2.       if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 |",Not Useful
/*name' is the component name*/,"-2.             if (compose != do_compose)
-1.                png_error(vi->pp, ""internal error (compose)"");

/*name' is the component name*/

1.             pos = safecat(msg, sizeof msg, pos, name);
2.             pos = safecat(msg, sizeof msg, pos, ""(""",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an",Not Useful
/*No transform is expected on the threshold tests.*/,"-6.             }
-5.          }
-4.       }
-3.       else if (memcmp(std, pRow, cbRow) != 0)
-2.       {
-1.          char msg[64];

/*No transform is expected on the threshold tests.*/

1.          sprintf(msg, ""gamma: below threshold row %lu changed"",",Not Useful
/*row (y) loop*/,"-10.                out_pixel.blue, sample_depth, in_pixel.bluee,
-9.                dp->pm->limit + 1./(2*((1U<<in_pixel.blue_sBIT)-1)), ""blue"",
-8.                digitization_error);
-7.          if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0 &&
-6.         ",Not Useful
/*modifier_read expects a png_modifier**/,"-4.          modifier_progressive_read(d.pm, pp, pi);
-3.       }
-2.       else
-1.       {

/*modifier_read expects a png_modifier**/

1.          png_set_read_fn(pp, d.pm, modifier_read);",Not Useful
/*sBIT*/,"-7. #define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
-6. #define CHUNK_IHDR CHUNK(73,72,68,82)
-5. #define CHUNK_PLTE CHUNK(80,76,84,69)
-4. #define CHUNK_IDAT CHUNK(73,68,65,84)
-3. #define CHUNK_IEND CHUNK(73,69,78,68)
-2. #define CHUNK_cHRM CH",Not Useful
/*threshold test*/,"-10.    {
-9.       vi->sbit = dp->sbit;
-8.       vi->isbit_shift = in_depth - dp->sbit;
-7.    }
-6.    else
-5.    {
-4.       vi->sbit = (png_byte)in_depth;
-3.       vi->isbit_shift = 0;
-2.    }
-1.    vi->sbit_max = (1U << vi->sbit)-1;
   /* This m",Not Useful
/*no scale16*/,"-10. {
-9.    size_t pos = 0;
-8.    char name[64];
-7.    pos = safecat(name, sizeof name, pos, ""threshold "");
-6.    pos = safecatd(name, sizeof name, pos, file_gamma, 3);
-5.    pos = safecat(name, sizeof name, pos, ""/"");
-4.    pos = safecatd(name, si",Not Useful
/*hence*/,"-8. static int
-7. test_size(png_modifier* const pm, png_byte const colour_type,
-6.     int bdlo, int const bdhi)
-5. {
-4.    /* Run the tests on each combination.
-3.     *
-2.     * NOTE: on my 32 bit x86 each of the following blocks takes
-1.     * a",Not Useful
/*sBIT*/,"-7. #define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
-6. #define CHUNK_IHDR CHUNK(73,72,68,82)
-5. #define CHUNK_PLTE CHUNK(80,76,84,69)
-4. #define CHUNK_IDAT CHUNK(73,68,65,84)
-3. #define CHUNK_IEND CHUNK(73,69,78,68)
-2. #define CHUNK_cHRM CH",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int      ",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int      ",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int      ",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int      ",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int      ",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          brea",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          brea",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          brea",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          brea",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          brea",Not Useful
/*sBIT*/,"-7. #define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
-6. #define CHUNK_IHDR CHUNK(73,72,68,82)
-5. #define CHUNK_PLTE CHUNK(80,76,84,69)
-4. #define CHUNK_IDAT CHUNK(73,68,65,84)
-3. #define CHUNK_IEND CHUNK(73,69,78,68)
-2. #define CHUNK_cHRM CH",Not Useful
/*strip 16*/,"-4. #     ifdef PNG_READ_ACCURATE_SCALE_SUPPORTED
-3. #        if PNG_LIBPNG_VER >= 10504
-2. #           error PNG_READ_ACCURATE_SCALE should not be set
-1. #        endif
         /* The strip 16 algorithm drops the low 8 bits rather than calculating

/",Not Useful
/*who*/,"-2.    ps->cb_row = cbRow;
-1.    ps->image_h = cRows;
   /* For error checking, the whole buffer is set to 10110010 (0xb2 - 178).

/*who*/

1.     * This deliberately doesn't match the bits in the size test image which are
2.     * outside the image; the",Not Useful
/*Should be READ_16BIT_SUPPORTED*/,"-3.       if (fail(pm))
-2.          return;
-1.    }

/*Should be READ_16BIT_SUPPORTED*/

1.    if (pm->test_gamma_scale16)
2.    {",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

 ",Not Useful
/*Is row 'y' in pass 'pass'?*/,"-4. }
-3. static int
-2. png_row_in_interlace_pass(png_uint_32 y, int pass)
-1. {

/*Is row 'y' in pass 'pass'?*/

1.    int x;
2.    y &= 7;
3.    ++pass;
4.    for (x=0; x<8; ++x) if (adam7[y][x] == pass)
5.       return 1;
6.    return 0;
7. }
8. stati",Not Useful
/*Is column 'x' in pass 'pass'?*/,"-10.    int x;
-9.    y &= 7;
-8.    ++pass;
-7.    for (x=0; x<8; ++x) if (adam7[y][x] == pass)
-6.       return 1;
-5.    return 0;
-4. }
-3. static int
-2. png_col_in_interlace_pass(png_uint_32 x, int pass)
-1. {

/*Is column 'x' in pass 'pass'?*/

1. ",Not Useful
/*Kodak ProPhoto (wide gamut)*/,"-10.  * The png_modifier code assumes that encodings[0] is sRGB and treats it
-9.  * specially: do not change the first entry in this list!
-8.  */
-7. static const color_encoding test_encodings[] =
-6. {

/*Kodak ProPhoto (wide gamut)*/

 ",Not Useful
/*png_structp*/,"
#  define png_const_structp png_structp



/*png_structp*/

1. #endif
2. #ifndef RELEASE_BUILD",Not Useful
/*main program*/,"-10.     */
-9.    if (signum != SIGTERM)
-8.    {
-7.       struct exception_context *the_exception_context =
-6.          &pm.this.exception_context;
-5.       Throw &pm.this;
-4.    }
-3.    else
-2.       exit(1);
-1. }

/*main program*/

1. int main(",Not Useful
/*And the test encodings*/,"-10.     * this is fixed turn them off for some gamma cases:
-9.     */
-8. #  ifdef PNG_WRITE_tRNS_SUPPORTED
-7.       pm.test_tRNS = 1;
-6. #  endif
-5.    pm.test_lbg = PNG_LIBPNG_VER >= 10600;
-4.    pm.test_lbg_gamma_threshold = 1;
-3.    pm.test_lbg",Not Useful
/*1/20000*/,"-10.    pm.use_input_precision_16to8 = 1U;

/*1/20000*/

 ",Not Useful
/*1/20000*/,"-10.    pm.use_input_precision_16to8 = 1U;

/*1/20000*/

 ",Not Useful
"/*I.e., 1/200% - 1/20000*/","-10.       pm.maxcalcG = 1./((1<<16)-1);
-9. #  endif

/*I.e., 1/200% - 1/20000*/

 ",Not Useful
/*PNG_READ_TRANSFORMS_SUPPORTED*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, ",Not Useful
/*!CAN_WRITE_INTERLACE*/,"-4.       else if (strcmp(*argv, ""--interlace"") == 0)
-3.       {
-2. #        if CAN_WRITE_INTERLACE
-1.             pm.interlace_type = PNG_INTERLACE_ADAM7;

/*!CAN_WRITE_INTERLACE*/

1.             fprintf(stderr, ""pngvalid: no write interlace support\",Not Useful
/*!CAN_WRITE_INTERLACE*/,"-4.       else if (strcmp(*argv, ""--interlace"") == 0)
-3.       {
-2. #        if CAN_WRITE_INTERLACE
-1.             pm.interlace_type = PNG_INTERLACE_ADAM7;

/*!CAN_WRITE_INTERLACE*/

1.             fprintf(stderr, ""pngvalid: no write interlace support\",Not Useful
/*PNG_SET_OPTION_SUPPORTED*/,"-10. #     ifdef PNG_USER_MEM_SUPPORTED
-9.          if (!ps->speed)
-8.             ps->pwrite = png_create_write_struct_2(PNG_LIBPNG_VER_STRING,
-7.                ps, store_error, store_warning, &ps->write_memory_pool,
-6.                store_malloc, ",Not Useful
/*consumed an extra *argv*/,"-5.       else
-4.       {
-3.          fprintf(stderr, ""pngvalid: %s: unknown argument\n"", *argv);
-2.          exit(99);
-1.       }

/*consumed an extra *argv*/

1.       {
2.          cp = safecat(command, sizeof command, cp, "" "");
3.          cp = sa",Not Useful
/*Nothing to test so turn everything off:*/,"-10.    {
-9.       pm.test_gamma_threshold = 1;
-8.       pm.test_gamma_transform = 1;
-7.       pm.test_gamma_sbit = 1;
-6.       pm.test_gamma_scale16 = 1;
-5.       pm.test_gamma_background = 1;
-4.       pm.test_gamma_alpha_mode = 1;
-3.    }
-2.    ",Not Useful
/*Combinatorial transforms:*/,"-8.       if (pm.test_size)
-7.       {
-6.          make_size_images(&pm.this);
-5. #        ifdef PNG_READ_SUPPORTED
-4.             perform_size_test(&pm);
-3. #        endif
-2.       }
-1. #ifdef PNG_READ_TRANSFORMS_SUPPORTED

/*Combinatorial transfo",Not Useful
/*PNG_READ_TRANSFORMS_SUPPORTED*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, ",Not Useful
/*So the test is skipped:*/,"-4. int main(void)
-3. {
-2.    fprintf(stderr,
-1.       ""pngvalid: no low level write support in libpng, all tests skipped\n"");

/*So the test is skipped:*/

1.    return SKIP;
2. }
3. #endif",Not Useful
/*!EOF*/,"-5.    for (i=8; i; i--)
-4.    {
-3.       GETBREAK;
-2.       putchar(c);
-1.    }

/*!EOF*/

1. for (;;)
2.  {",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will ",Not Useful
/*Calculate the CRC*/,"-1.          break;

/*Calculate the CRC*/

1.       crc = crc32(crc, buf+4, (uInt)length+4);
2.       for (;;)
3.       {",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will ",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will ",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will ",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will ",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp+",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp+",Not Useful
"/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/","-5.             png_bytep sp, dp;
-4.             png_uint_32 i;
-3.             png_uint_32 row_width = row_info->width;
-2.             for (i = 0, sp = dp = row; i < row_width; i++)
-1.             {
               /* Does nothing
               *(dp++",Not Useful
"/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/","-5.             png_bytep sp, dp;
-4.             png_uint_32 i;
-3.             png_uint_32 row_width = row_info->width;
-2.             for (i = 0, sp = dp = row; i < row_width; i++)
-1.             {
               /* Does nothing
               *(dp++",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp+",Not Useful
"/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/","-5.             png_bytep sp, dp;
-4.             png_uint_32 i;
-3.             png_uint_32 row_width = row_info->width;
-2.             for (i = 0, sp = dp = row; i < row_width; i++)
-1.             {
               /* Does nothing
               *(dp++",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp+",Not Useful
/*png_ptr*/,"
png_do_write_transformations(png_structrp png_ptr, png_row_infop row_info)



/*png_ptr*/

1. {
2.    png_debug(1, ""in png_do_write_transformations"");
3.    if (png_ptr == NULL)
4.       return;
5. #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
6.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
7.       if (png_ptr->write_user_transform_fn != NULL)",Not Useful
/*row_info:*/,"-10. {
-9.    png_debug(1, ""in png_do_write_transformations"");
-8.    if (png_ptr == NULL)
-7.       return;
-6. #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-5.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-4.       if (png_ptr->write_user_t",Not Useful
/*png_uint_32 width;       width of row*/,"-10.    png_debug(1, ""in png_do_write_transformations"");
-9.    if (png_ptr == NULL)
-8.       return;
-7. #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-6.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-5.       if (png_ptr->write_user_transfo",Not Useful
/*WRITE_TRANSFORMS*/,"-10.  * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
-9.  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
-8.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
-7.  *
-6.  * This code is released under t",Not Useful
/*FLOATING_POINT*/,"-10.    XYZ.green_Y = int_green_Y;
-9.    XYZ.green_Z = int_green_Z;
-8.    XYZ.blue_X = int_blue_X;
-7.    XYZ.blue_Y = int_blue_Y;
-6.    XYZ.blue_Z = int_blue_Z;
-5.    if (png_colorspace_set_endpoints(png_ptr, &info_ptr->colorspace,
-4.        &XYZ, 2",Not Useful
/*cHRM*/,"-10. png_set_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_16p background)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""bKGD"");
-6.    if (png_ptr == NULL || info_ptr == NULL || background == NULL)
-5.       return",Not Useful
/*eXIf*/,"
#ifdef PNG_eXIf_SUPPORTED



/*eXIf*/

1. void PNGAPI
2. png_set_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,
3.     const png_bytep eXIf_buf)
4. {
5.   png_warning(png_ptr, ""png_set_eXIf does not work; use png_set_eXIf_1"");
6.   PNG_UNUSED(info_ptr)
7.   PNG_UNUSED(eXIf_buf)
8. }
9. void PNGAPI
10. png_set_eXIf_1(png_const_structrp png_ptr, png_inforp info_ptr,",Not Useful
/*Validate params[nparams]*/,"-10.       png_chunk_report(png_ptr, ""Invalid pCAL equation type"",
-9.             PNG_CHUNK_WRITE_ERROR);
-8.       return;
-7.    }
-6.    if (nparams < 0 || nparams > 255)
-5.    {
-4.       png_chunk_report(png_ptr, ""Invalid pCAL parameter count"",
-3.",Not Useful
/*-'*/,"-3.    if (unit != 1 && unit != 2)
-2.       png_error(png_ptr, ""Invalid sCAL unit"");
-1.    if (swidth == NULL || (lengthw = strlen(swidth)) == 0 ||

/*-'*/

1.       png_error(png_ptr, ""Invalid sCAL width"");
2.    if (sheight == NULL || (lengthh = strle",Not Useful
/*-'*/,"-3.    if (unit != 1 && unit != 2)
-2.       png_error(png_ptr, ""Invalid sCAL unit"");
-1.    if (swidth == NULL || (lengthw = strlen(swidth)) == 0 ||

/*-'*/

1.       png_error(png_ptr, ""Invalid sCAL width"");
2.    if (sheight == NULL || (lengthh = strle",Not Useful
/*sRGB*/,"-10. png_set_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_8p sig_bit)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""sBIT"");
-6.    if (png_ptr == NULL || info_ptr == NULL || sig_bit == NULL)
-5.       return;
-4.  ",Not Useful
/*iTXt*/,"-10.              PNG_CHUNK_WRITE_ERROR);
-9.          continue;
-8.       }
-7.       key_len = strlen(text_ptr[i].key);
-6.       if (text_ptr[i].compression <= 0)
-5.       {
-4.          lang_len = 0;
-3.          lang_key_len = 0;
-2.       }
-1.    ",Not Useful
/*sPLT*/,"-10.          num_trans = 1;
-9.    }
-8.    info_ptr->num_trans = (png_uint_16)num_trans;
-7.    if (num_trans != 0)
-6.    {
-5.       info_ptr->valid |= PNG_INFO_tRNS;
-4.       info_ptr->free_me |= PNG_FREE_TRNS;
-3.    }
-2. }
-1. #endif
#ifdef PNG_s",Not Useful
/*Use the old behavior*/,"-2.       png_app_warning(png_ptr,
-1.           ""png_set_unknown_chunks now expects a valid location"");

/*Use the old behavior*/

1.       location = (png_byte)(png_ptr->mode &
2.           (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT));
3.    }",Not Useful
/*But just skip storing the unknown chunk*/,"-10.          np->size = 0;
-9.       }
-8.       else
-7.       {
-6.          np->data = png_voidcast(png_bytep,
-5.              png_malloc_base(png_ptr, unknowns->size));
-4.          if (np->data == NULL)
-3.          {
-2.             png_chunk_repo",Not Useful
/*undocumented!*/,"-10.     *
-9.     * TODO: add a png_app_warning in 1.7
-8.     */
-7.    if (png_ptr != NULL && info_ptr != NULL && chunk >= 0 &&
-6.       chunk < info_ptr->unknown_chunks_num)
-5.    {
-4.       if ((location & (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_ID",Not Useful
/*also undocumented*/,"-2.             location = PNG_AFTER_IDAT;
-1.          else

/*also undocumented*/

1.       }
2.       info_ptr->unknown_chunks[chunk].location =
3.          check_location(png_ptr, location);
4.    }
5. }",Not Useful
/*STORE_UNKNOWN_CHUNKS*/,"
#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED



/*STORE_UNKNOWN_CHUNKS*/

1. static png_byte
2. check_location(png_const_structrp png_ptr, int location)
3. {
4.    location &= (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT);",Not Useful
/*bKGD*/,#NAME?,Not Useful
/*cHRM*/,"-10. png_set_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_16p background)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""bKGD"");
-6.    if (png_ptr == NULL || info_ptr == NULL || background == NULL)
-5.       return",Not Useful
/*eXIf*/,"
#ifdef PNG_eXIf_SUPPORTED



/*eXIf*/

1. void PNGAPI
2. png_set_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,
3.     const png_bytep eXIf_buf)
4. {
5.   png_warning(png_ptr, ""png_set_eXIf does not work; use png_set_eXIf_1"");
6.   PNG_UNUSED(info_ptr)
7.   PNG_UNUSED(eXIf_buf)
8. }
9. void PNGAPI
10. png_set_eXIf_1(png_const_structrp png_ptr, png_inforp info_ptr,",Not Useful
/*gAMA*/,"
#ifdef PNG_gAMA_SUPPORTED



/*gAMA*/

1. void PNGFAPI
2. png_set_gAMA_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_fixed_point file_gamma)
4. {
5.    png_debug1(1, ""in %s storage function"", ""gAMA"");
6.    if (png_ptr == NULL || info_ptr == NULL)
7.       return;
8.    png_colorspace_set_gamma(png_ptr, &info_ptr->colorspace, file_gamma);
9.    png_colorspace_sync_info(png_ptr, info_ptr);
10. }",Not Useful
/*hIST*/,"-10. }
-9. #  ifdef PNG_FLOATING_POINT_SUPPORTED
-8. void PNGAPI
-7. png_set_gAMA(png_const_structrp png_ptr, png_inforp info_ptr, double file_gamma)
-6. {
-5.    png_set_gAMA_fixed(png_ptr, info_ptr, png_fixed(png_ptr, file_gamma,
-4.        ""png_set_gAM",Not Useful
/*iCCP*/,"
#ifdef PNG_iCCP_SUPPORTED



/*iCCP*/

1. void PNGAPI
2. png_set_iCCP(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_const_charp name, int compression_type,
4.     png_const_bytep profile, png_uint_32 proflen)
5. {
6.    png_charp new_iccp_name;
7.    png_bytep new_iccp_profile;
8.    png_size_t length;
9.    png_debug1(1, ""in %s storage function"", ""iCCP"");
10.    if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)",Not Useful
/*iTXt*/,"-10.              PNG_CHUNK_WRITE_ERROR);
-9.          continue;
-8.       }
-7.       key_len = strlen(text_ptr[i].key);
-6.       if (text_ptr[i].compression <= 0)
-5.       {
-4.          lang_len = 0;
-3.          lang_key_len = 0;
-2.       }
-1.    ",Not Useful
/*oFFs*/,"-10.       info_ptr->channels = 1;
-9.    else if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
-8.       info_ptr->channels = 3;
-7.    else
-6.       info_ptr->channels = 1;
-5.    if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
-4.      ",Not Useful
/*pCAL*/,"-10. {
-9.    png_debug1(1, ""in %s storage function"", ""oFFs"");
-8.    if (png_ptr == NULL || info_ptr == NULL)
-7.       return;
-6.    info_ptr->x_offset = offset_x;
-5.    info_ptr->y_offset = offset_y;
-4.    info_ptr->offset_unit_type = (png_byte)unit",Not Useful
/*pHYs*/,"-9.       char swidth[PNG_sCAL_MAX_DIGITS+1];
-8.       char sheight[PNG_sCAL_MAX_DIGITS+1];
-7.       png_ascii_from_fixed(png_ptr, swidth, (sizeof swidth), width);
-6.       png_ascii_from_fixed(png_ptr, sheight, (sizeof sheight), height);
-5.       png",Not Useful
/*sBIT*/,"-10.    png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,
-9.        PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));
-8.    if (num_palette > 0)
-7.       memcpy(png_ptr->palette, palette, (unsigned int)num_palette *
-6.           (sizeof (",Not Useful
/*sCAL*/,"-10.       {
-9.          png_warning(png_ptr, ""Insufficient memory for pCAL parameter"");
-8.          return;
-7.       }
-6.       memcpy(info_ptr->pcal_params[i], params[i], length);
-5.    }
-4.    info_ptr->valid |= PNG_INFO_pCAL;
-3.    info_ptr->fr",Not Useful
/*sPLT*/,"-10.          num_trans = 1;
-9.    }
-8.    info_ptr->num_trans = (png_uint_16)num_trans;
-7.    if (num_trans != 0)
-6.    {
-5.       info_ptr->valid |= PNG_INFO_tRNS;
-4.       info_ptr->free_me |= PNG_FREE_TRNS;
-3.    }
-2. }
-1. #endif
#ifdef PNG_s",Not Useful
/*sTER*/,"-10.         103,  65,  77,  65, '\0',  /* gAMA */
-9.         104,  73,  83,  84, '\0',  /* hIST */
-8.         105,  67,  67,  80, '\0',  /* iCCP */
-7.         105,  84,  88, 116, '\0',  /* iTXt */
-6.          ,  70,  70, 115, '\0',  /* oFFs */
-5.   ",Not Useful
/*sRGB*/,"-10. png_set_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_8p sig_bit)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""sBIT"");
-6.    if (png_ptr == NULL || info_ptr == NULL || sig_bit == NULL)
-5.       return;
-4.  ",Not Useful
/*tEXt*/,"-10.         105,  67,  67,  80, '\0',  /* iCCP */
-9.         105,  84,  88, 116, '\0',  /* iTXt */
-8.          ,  70,  70, 115, '\0',  /* oFFs */
-7.         112,  67,  65,  76, '\0',  /* pCAL */
-6.         112,  72,  89, 115, '\0',  /* pHYs */
-5.   ",Not Useful
/*tIME*/,"-10.       {
-9.          textp->text_length = text_length;
-8.          textp->itxt_length = 0;
-7.       }
-6.       info_ptr->num_text++;
-5.       png_debug1(3, ""transferred text chunk %d"", info_ptr->num_text);
-4.    }
-3.    return(0);
-2. }
-1. #en",Not Useful
/*zTXt*/,"-10.          ,  70,  70, 115, '\0',  /* oFFs */
-9.         112,  67,  65,  76, '\0',  /* pCAL */
-8.         112,  72,  89, 115, '\0',  /* pHYs */
-7.         115,  66,  73,  84, '\0',  /* sBIT */
-6.         115,  67,  65,  76, '\0',  /* sCAL */
-5.   ",Not Useful
/*SAFE*/,"-10.         115,  66,  73,  84, '\0',  /* sBIT */
-9.         115,  67,  65,  76, '\0',  /* sCAL */
-8.         115,  80,  76,  84, '\0',  /* sPLT */
-7.         115,  84,  69,  82, '\0',  /* sTER */
-6.         115,  82,  71,  66, '\0',  /* sRGB */
-5. ",Not Useful
/*num_chunks_in > 0*/,"-4.       };
-3.       chunk_list = chunks_to_ignore;

/*num_chunks_in > 0*/

1.    {
2.       if (chunk_list == NULL)
3.       {",Not Useful
/*must fit*/,"-4.       if (size > ZLIB_IO_MAX)
-3.       {
-2.          png_warning(png_ptr,
-1.              ""Compression buffer size limited to system maximum"");

/*must fit*/

1.       }
2. #endif
3.       if (size < 6)
4.       {",Not Useful
"/*Deflate will potentially go into an infinite loop on a SYNC_FLUSH
          * if this is permitted.*/","-4.       }
-3. #endif
-2.       if (size < 6)
-1.       {
         /* Deflate will potentially go into an infinite loop on a SYNC_FLUSH
          * if this is permitted.

/*Deflate will potentially go into an infinite loop on a SYNC_FLUSH
          * if ",Not Useful
/*?SET_USER_LIMITS*/,"-7. void PNGAPI
-6. png_set_chunk_malloc_max (png_structrp png_ptr,
-5.     png_alloc_size_t user_chunk_malloc_max)
-4. {
-3.    if (png_ptr != NULL)
-2.       png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;
-1. }

/*?SET_USER_LIMITS*/

1. #ifdef ",Not Useful
/*BENIGN_ERRORS*/,"
#ifdef PNG_BENIGN_ERRORS_SUPPORTED



/*BENIGN_ERRORS*/

1. void PNGAPI
2. png_set_benign_errors(png_structrp png_ptr, int allowed)
3. {
4.    png_debug(1, ""in png_set_benign_errors"");",Not Useful
/*&& ch <= 255*/,"-10.    int space = 1;
-9.    png_debug(1, ""in png_check_keyword"");
-8.    if (key == NULL)
-7.    {
-6.       *new_key = 0;
-5.       return 0;
-4.    }
-3.    while (*key && key_len < 79)
-2.    {
-1.       png_byte ch = (png_byte)*key++;

/*&& ch <= 25",Not Useful
/*Terminate the keyword*/,"-5.    {
-4.       --key_len; --new_key;
-3.       if (bad_character == 0)
-2.          bad_character = 32;
-1.    }

/*Terminate the keyword*/

1.    *new_key = 0;
2.    if (key_len == 0)
3.       return 0;
4. #ifdef PNG_WARNINGS_SUPPORTED",Not Useful
/*keyword too long*/,"-5.    *new_key = 0;
-4.    if (key_len == 0)
-3.       return 0;
-2. #ifdef PNG_WARNINGS_SUPPORTED

/*keyword too long*/

1.       png_warning(png_ptr, ""keyword truncated"");
2.    else if (bad_character != 0)
3.    {
4.       PNG_WARNING_PARAMETERS(p)
5.",Not Useful
/*!WARNINGS*/,"-8.       png_warning(png_ptr, ""keyword truncated"");
-7.    else if (bad_character != 0)
-6.    {
-5.       PNG_WARNING_PARAMETERS(p)
-4.       png_warning_parameter(p, 1, orig_key);
-3.       png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_02x, bad_",Not Useful
/*!WARNINGS*/,"-8.       png_warning(png_ptr, ""keyword truncated"");
-7.    else if (bad_character != 0)
-6.    {
-5.       PNG_WARNING_PARAMETERS(p)
-4.       png_warning_parameter(p, 1, orig_key);
-3.       png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_02x, bad_",Not Useful
/*TEXT || pCAL || iCCP || sPLT*/,"-2.    return key_len;
-1. }

/*TEXT || pCAL || iCCP || sPLT*/

 ",Not Useful
/*pHYs*/,"-10. png_get_compression_type(png_const_structrp png_ptr, png_const_inforp info_ptr)
-9. {
-8.    if (png_ptr != NULL && info_ptr != NULL)
-7.       return info_ptr->compression_type;
-6.    return (0);
-5. }
-4. png_uint_32 PNGAPI
-3. png_get_x_pixels_pe",Not Useful
/*INCH_CONVERSIONS*/,"-10.       png_debug1(1, ""in %s retrieval function"", ""png_get_y_offset_pixels"");
-9.       if (info_ptr->offset_unit_type == PNG_OFFSET_PIXEL)
-8.          return (info_ptr->y_offset);
-7.    }
-6. #else
-5.    PNG_UNUSED(png_ptr)
-4.    PNG_UNUSED(info_p",Not Useful
/*EASY_ACCESS*/,"-10. }
-9. #ifdef PNG_INFO_IMAGE_SUPPORTED
-8. png_bytepp PNGAPI
-7. png_get_rows(png_const_structrp png_ptr, png_const_inforp info_ptr)
-6. {
-5.    if (png_ptr != NULL && info_ptr != NULL)
-4.       return(info_ptr->row_pointers);
-3.    return(0);
-2. ",Not Useful
/*FLOATING_ARITHMETIC*/,"-10.       *nparams = (int)info_ptr->pcal_nparams;
-9.       *units = info_ptr->pcal_units;
-8.       *params = info_ptr->pcal_params;
-7.       return (PNG_INFO_pCAL);
-6.    }
-5.    return (0);
-4. }
-3. #endif
-2. #ifdef PNG_sCAL_SUPPORTED
-1. #  ifde",Not Useful
/*FIXED_POINT*/,"-10.          return ((float)((float)info_ptr->y_pixels_per_unit
-9.              /(float)info_ptr->x_pixels_per_unit));
-8.    }
-7. #else
-6.    PNG_UNUSED(png_ptr)
-5.    PNG_UNUSED(info_ptr)
-4. #endif
-3.    return ((float)0.0);
-2. }
-1. #endif
#ifd",Not Useful
/*sCAL*/,"-10.       *X1 = info_ptr->pcal_X1;
-9.       *type = (int)info_ptr->pcal_type;
-8.       *nparams = (int)info_ptr->pcal_nparams;
-7.       *units = info_ptr->pcal_units;
-6.       *params = info_ptr->pcal_params;
-5.       return (PNG_INFO_pCAL);
-4.    ",Not Useful
/*pHYs*/,"-10. png_get_compression_type(png_const_structrp png_ptr, png_const_inforp info_ptr)
-9. {
-8.    if (png_ptr != NULL && info_ptr != NULL)
-7.       return info_ptr->compression_type;
-6.    return (0);
-5. }
-4. png_uint_32 PNGAPI
-3. png_get_x_pixels_pe",Not Useful
/*SET_USER_LIMITS*/,"-10.       return png_ptr->IDAT_read_size;
-9. #else
-8.       return PNG_IDAT_READ_SIZE;
-7. #endif
-6.    }
-5. #ifdef PNG_WRITE_SUPPORTED
-4.    else
-3.       return png_ptr->zbuffer_size;
-2. #endif
-1. }
#ifdef PNG_SET_USER_LIMITS_SUPPORTED

/*SET_U",Not Useful
/*IO_STATE*/,"
#ifdef PNG_IO_STATE_SUPPORTED



/*IO_STATE*/

1. png_uint_32 PNGAPI
2. png_get_io_state (png_const_structrp png_ptr)
3. {
4.    return png_ptr->io_state;
5. }
6. png_uint_32 PNGAPI
7. png_get_io_chunk_type (png_const_structrp png_ptr)
8. {
9.    return png_ptr->chunk_name;
10. }",Not Useful
/*1.6.3*/,"-2. /* pngfix.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*1.6.3*/

1.  * Copyright (c) 2014-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see the disc",Not Useful
/*__cplusplus*/,"
#ifdef __cplusplus



/*__cplusplus*/

1. #  define voidcast(type, value) static_cast<type>(value)
2. #  define constcast(type, value) const_cast<type>(value)
3. #  define aligncast(type, value) \
4.    static_cast<type>(static_cast<void*>(value))
5. #  define aligncastconst(type, value) \
6.    static_cast<type>(static_cast<const void*>(value))
7. #else
8. #  define voidcast(type, value) (value)
9. #  define constcast(type, value) ((type)(value))
10. #  define aligncast(type, value) ((void*)(value))",Not Useful
/*Chunk tags (copied from pngpriv.h)*/,"-1. #if PNG_LIBPNG_VER < 10700

/*Chunk tags (copied from pngpriv.h)*/

1. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
2. #define PNG_U32(b1,b2,b3,b4) \
3.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))",Not Useful
/*deprecated*/,"-2. #define png_gAMA PNG_U32(103,  65,  77,  65)
-1. #define png_gIFg PNG_U32(103,  73,  70, 103)

/*deprecated*/

1. #define png_gIFx PNG_U32(103,  73,  70, 120)
2. #define png_hIST PNG_U32(104,  73,  83,  84)
3. #define png_iCCP PNG_U32(105,  67,  67,  ",Not Useful
/*Is the chunk critical?*/,"-2. #define sig1 PNG_U32(137,  80,  78,  71)
-1. #define sig2 PNG_U32( 13,  10,  26,  10)

/*Is the chunk critical?*/

1. #define CRITICAL(chunk) (((chunk) & PNG_U32(32,0,0,0)) == 0)",Not Useful
/*Is it safe to copy?*/,"-1. #define CRITICAL(chunk) (((chunk) & PNG_U32(32,0,0,0)) == 0)

/*Is it safe to copy?*/

1. #define SAFE_TO_COPY(chunk) (((chunk) & PNG_U32(0,0,0,32)) != 0)",Not Useful
/*may be 0*/,"-10.    }
-9.    while (add != 0 && add != (-1))
-8.    {
-7.       num[out_digits++] = (png_uint_16)(add & 0xffff);
-6.       add >>= 16;
-5.    }
-4.    if (add == 0)
-3.    {
-2.       while (out_digits > 0 && num[out_digits-1] == 0)
-1.          --out",Not Useful
/*UNUSED*/,"-10.       return -1;
-9.    if (adigits > bdigits)
-8.       return 1;
-7.    while (adigits-- > 0)
-6.       if (a[adigits] < b[adigits])
-5.          return -1;
-4.       else if (a[adigits] > b[adigits])
-3.          return 1;
-2.    return 0;
-1. }

",Not Useful
/**************************** CONTROL INFORMATION *****************************/,"-4.    c -= PNG_U32(25,25,25,26);
-3.    t |= ~c;
-2.    return (t & 0xe0e0e0e0) == 0;
-1. }

/**************************** CONTROL INFORMATION *****************************/

 ",Not Useful
/*Everything but tRNS and sBIT*/,"-6. #     define SKIP_NONE      0

/*Everything but tRNS and sBIT*/

 ",Not Useful
/*0 to perform no re-chunking*/,"-7. #     define SKIP_NONE      0

/*0 to perform no re-chunking*/

 ",Not Useful
/*truncated but still readable*/,"-10. #     define SKIP_UNSAFE    2    /* Chunks not safe to copy */
-9. #     define SKIP_UNUSED    3    /* Chunks not used by libpng */
-8. #     define SKIP_TRANSFORM 4    /* Chunks only used in transforms */
-7. #     define SKIP_COLOR     5    /* Ever",Not Useful
/*Never strip critical chunks:*/,"-1. {

/*Never strip critical chunks:*/

1.    if (CRITICAL(type))
2.       return 0;
3.    switch (type)
4.    {",Not Useful
/*as above*/,"-3.       default:
-2.          if (SAFE_TO_COPY(type))
-1.          {

/*as above*/

1.                return 1;
2.          }
3.          else if (global->skip >= SKIP_UNSAFE)
4.             return 1;
5.          return 0;
6.    }
7. }",Not Useful
/*IHDR information*/,"-7.    const char *   file_name;

/*IHDR information*/

1.    png_uint_32    width;
2.    png_uint_32    height;
3.    png_byte       bit_depth;
4.    png_byte       color_type;
5.    png_byte       compression_method;
6.    png_byte       filter_method;
",Not Useful
/*Open the files:*/,"-6.    file->read_count = 0;
-5.    file->state = STATE_SIGNATURE;
-4.    file->chunk = NULL;
-3.    file->idat = NULL;
-2.    file->alloc_ptr = alloc_ptr;
-1.    file->alloc = alloc;

/*Open the files:*/

1.    assert(file_name != NULL);
2.    file->file",Not Useful
/*need two quiets to stop this.*/,"-10.     * finding errors in the previous chunks.  We know that is happening because
-9.     * we are at the start of the IDAT (i.e. no IDAT data has yet been written.)
-8.     *
-7.     * SUMMARY FORMAT (stop):
-6.     *
-5.     * IDAT ERR status code re",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*Truncated*/,"-10.     * if the input is truncated.
-9.     */
-8. {
-7.    if (length > 0)
-6.    {
-5.       png_uint_32 crc = file->crc;
-4.       do
-3.       {
-2.          int ch = read_byte(file);
-1.          if (ch == EOF)

/*Truncated*/

1.          crc = crc",Not Useful
/*OK*/,"-5.          crc = crc_one_byte(crc, ch);
-4.       }
-3.       while (--length > 0);
-2.       file->crc = crc;
-1.    }

/*OK*/

1. }
2. static int
3. calc_image_size(struct file *file)",Not Useful
/*g*/,"
/* pngfix.c



/*g*/

1.  *
2.  * Last changed in libpng 1.6.31 [July 27, 2017]
3.  * Copyright (c) 2014-2017 John Cunningham Bowler
4.  *
5.  * This code is released under the libpng license.
6.  * For conditions of distribution and use, see the disclaimer
7.  * and license in png.h
8.  *
9.  * Tool to check and fix the zlib inflate 'too far back' problem.
10.  * See the usage message for more information.",Not Useful
/*ga*/,"-10.     * pngfix.c:
-9.     * In function 'zlib_advance':
-8.     * pngfix.c:181:13: error: assuming signed overflow does not
-7.     *   occur when simplifying conditional to constant [-Werror=strict-overflow]
-6.     */
-5. #  define FIX_GCC volatile
-",Not Useful
/*calculate 1+((pw*pd+7)>>3) in row_bytes*/,"-10.          {
-9.             int pass;
-8.             int image_digits = 0;
-7.             udigit row_width[2], row_bytes[3];
-6.             for (pass=0; pass<=6; ++pass)
-5.             {
-4.                png_uint_32 pw = PNG_PASS_COLS(file->widt",Not Useful
/*magic*/,"-4.       else
-3.          type = file->type;
-2.       if (type)
-1.          type_name(type, stdout);

/*magic*/

 ",Not Useful
/*skip*/,"-10.       while (out_digits < n_digits || carry > 0)
-9.       {
-8.          if (out_digits < a_digits)
-7.             carry += acc[out_digits];
-6.          if (out_digits < n_digits)
-5.             carry += (png_uint_32)num[out_digits] * val;
-4.   ",Not Useful
/*Like zTXt but more fields.*/,"-4. }
-3. static int
-2. process_iTXt(struct file *file)
-1. {

/*Like zTXt but more fields.*/

1.    struct chunk *chunk = file->chunk;
2.    png_uint_32 length;
3.    png_uint_32 index = 0;
4.    assert(chunk != NULL && file->idat == NULL);
5.    length",Not Useful
/*Skip the translated keyword*/,"-1.             {

/*Skip the translated keyword*/

1.                while (length >= 8)
2.                {
3.                   --length;
4.                   ++index;",Not Useful
/*skip*/,"-10.       while (out_digits < n_digits || carry > 0)
-9.       {
-8.          if (out_digits < a_digits)
-7.             carry += acc[out_digits];
-6.          if (out_digits < n_digits)
-5.             carry += (png_uint_32)num[out_digits] * val;
-4.   ",Not Useful
/*chunk*/,"-3. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
-2. #define PNG_U32(b1,b2,b3,b4) \
-1.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))

/*chunk*/

1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
2. #define png_IEND PNG_U32( 73,  69",Not Useful
/*use the cache*/,"-4.    {
-3.       const struct IDAT_list *cur;
-2.       unsigned int count;
-1.       if (start)

/*use the cache*/

 ",Not Useful
/*rechunking*/,"-5.    file->idat = idat;
-4. }
-3. static png_uint_32
-2. rechunk_length(struct IDAT *idat, int start)
-1.    /* Return the length for the next IDAT chunk, taking into account
    * rechunking.

/*rechunking*/

1.     */
2. {
3.    png_uint_32 len = idat",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*unset*/,"-1.    zlib->file_bits = 24;

/*unset*/

 ",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLT",Not Useful
/*keep going*/,"-10.    if (cb >   256) return  9;
-9.    return 8;
-8. }
-7. static int
-6. zlib_advance(struct zlib *zlib, png_uint_32 nbytes)
-5.    /* Read nbytes compressed bytes; the stream will be initialized if required.
-4.     * Bytes are always being reread an",Not Useful
/*stop*/,"-1. };

/*stop*/

 ",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLT",Not Useful
/*expected*/,"-8. };

/*expected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLT",Not Useful
/*The loop guarantees this*/,"-5.          {
-4.             zlib_end(&zlib);
-3.             return 0;
-2.          }
-1.       }

/*The loop guarantees this*/

1.       assert(zlib.ok_bits == max_bits);
2.       zlib_end(&zlib);
3.       return 1;
4.    }",Not Useful
/*This will cause an IEND with a bad CRC to stop*/,"-2.       if (file->global->skip != SKIP_BAD_CRC)
-1.          type_message(file, type, ""bad CRC"");

/*This will cause an IEND with a bad CRC to stop*/

1.       else if (CRITICAL(type))
2.          stop(file, READ_ERROR_CODE, ""bad CRC in critical chunk"")",Not Useful
/*chunk*/,"-3. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
-2. #define PNG_U32(b1,b2,b3,b4) \
-1.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))

/*chunk*/

1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
2. #define png_IEND PNG_U32( 73,  69",Not Useful
"/*or, nused &= 7 ;-)*/","-1.                nread -= nused & ~7;

/*or, nused &= 7 ;-)*/

 ",Not Useful
/*IEND*/,"-1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
#define png_IEND PNG_U32( 73,  69,  78,  68)

/*IEND*/

1. #define png_IHDR PNG_U32( 73,  72,  68,  82)
2. #define png_PLTE PNG_U32( 80,  76,  84,  69)
3. #define png_bKGD PNG_U32( 98,  75,  71,  68)
4. #de",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLT",Not Useful
/*Advance one chunk*/,"-2.                      while (idat->idat_index >= idat->idat_length)
-1.                      {

/*Advance one chunk*/

1.                         struct IDAT_list *cur = idat->idat_cur;
2.                         assert(idat->idat_index == idat->idat_l",Not Useful
/*conditioning*/,"-10.    return crc_table[(crc ^ b) & 0xff] ^ (crc >> 8);
-9. }
-8. static png_uint_32
-7. crc_init_4(png_uint_32 value)
-6. {
-5.    /* This is an alternative to the algorithm used in zlib, which requires four
-4.     * separate tables to parallelize the ",Not Useful
/*chunk*/,"-3. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
-2. #define PNG_U32(b1,b2,b3,b4) \
-1.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))

/*chunk*/

1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
2. #define png_IEND PNG_U32( 73,  69",Not Useful
/*NYI*/,"-10. ""      Write the optimized/corrected version of the next PNG to <file>.  This"",
-9. ""      overrides the following two options"",
-8. ""    --suffix=<suffix>:"",
-7. ""      Set --out=<name><suffix> for all following files unless overridden on"",
-6. ""   ",Not Useful
/*NYI*/,"-10. ""      Write the optimized/corrected version of the next PNG to <file>.  This"",
-9. ""      overrides the following two options"",
-8. ""    --suffix=<suffix>:"",
-7. ""      Set --out=<name><suffix> for all following files unless overridden on"",
-6. ""   ",Not Useful
/*Consider the prefix/suffix options*/,"-1.          {

/*Consider the prefix/suffix options*/

1.             if (prefix != NULL)
2.             {
3.                size_t prefixlen = strlen(prefix);
4.                if (prefixlen+outlen > FILENAME_MAX)
5.                {
6.                 ",Not Useful
/*ZLIB_VERNUM < 0x1240*/,"-10.          }
-9.          (void)one_file(&global, *argv, outfile);
-8.          ++done;
-7.          outfile = NULL;
-6.       }
-5.    }
-4.    if (!done)
-3.       usage(prog);
-2.    return global_end(&global);
-1. }

/*ZLIB_VERNUM < 0x1240*/

1. in",Not Useful
/*ZLIB_VERNUM*/,"#if ZLIB_VERNUM < 0x1260

/*ZLIB_VERNUM*/

1. #  define PNGZ_MSG_CAST(s) constcast(char*,s)
2. #  define PNGZ_INPUT_CAST(b) constcast(png_bytep,b)
3. #else
4. #  define PNGZ_MSG_CAST(s) (s)
5. #  define PNGZ_INPUT_CAST(b) (b)
6. #endif
7. #ifndef PNG_MAXIMUM_INFLATE_WINDOW
8. #  error ""pngfix not supported in this libpng version""
9. #endif
10. #if ZLIB_VERNUM >= 0x1240",Not Useful
/*PNG_READ_SUPPORTED && PNG_EASY_ACCESS_SUPPORTED*/,"-6. int
-5. main(void)
-4. {
-3.    fprintf(stderr, ""pngfix does not work without read deinterlace support\n"");
-2.    return 77;
-1. }

/*PNG_READ_SUPPORTED && PNG_EASY_ACCESS_SUPPORTED*/

 ",Not Useful
"/*This is the function that does the actual writing of data.  If you are
 * not writing to a standard C stream, you should create a replacement
 * write_data function and use it at run time with png_set_write_fn(), rather
 * than changing the library.*/","-7.    if (png_ptr->write_data_fn != NULL )
-6.       (*(png_ptr->write_data_fn))(png_ptr, png_constcast(png_bytep,data),
-5.           length);
-4.    else
-3.       png_error(png_ptr, ""Call to NULL write function"");
-2. }
-1. #ifdef PNG_STDIO_SUPPORTED
",Useful
"/*This function is called to output any data pending writing (normally
 * to disk).  After png_flush is called, there should be no data pending
 * writing in any buffers.*/","-10. png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-9. {
-8.    png_size_t check;
-7.    if (png_ptr == NULL)
-6.       return;
-5.    check = fwrite(data, 1, length, (png_FILE_p)(png_ptr->io_ptr));
-4.    if (check != len",Useful
"/*This function allows the application to supply new output functions for
 * libpng if standard C streams aren't being used.
 *
 * This function takes as its arguments:
 * png_ptr       - pointer to a png output data structure
 * io_ptr        - pointer to user supplied structure containing info about
 *                 the output functions.  May be NULL.
 * write_data_fn - pointer to a new output function that takes as its
 *                 arguments a pointer to a png_struct, a pointer to
 *                 data to be written, and a 32-bit unsigned int that is
 *                 the number of bytes to be written.  The new write
 *                 function should call png_error(png_ptr, ""Error msg"")
 *                 to exit and output any fatal error messages.  May be
 *                 NULL, in which case libpng's default function will
 *                 be used.
 * flush_data_fn - pointer to a new flush function that takes as its
 *                 arguments a pointer to a png_struct.  After a call to
 *                 the flush function, there should be no data in any buffers
 *                 or pending transmission.  If the output method doesn't do
 *                 any buffering of output, a function prototype must still be
 *                 supplied although it doesn't have to do anything.  If
 *                 PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
 *                 time, output_flush_fn will be ignored, although it must be
 *                 supplied for compatibility.  May be NULL, in which case
 *                 libpng's default function will be used, if
 *                 PNG_WRITE_FLUSH_SUPPORTED is defined.  This is not
 *                 a good idea if io_ptr does not point to a standard
 *                 *FILE structure.*/","-10. png_default_flush(png_structp png_ptr)
-9. {
-8.    png_FILE_p io_ptr;
-7.    if (png_ptr == NULL)
-6.       return;
-5.    io_ptr = png_voidcast(png_FILE_p, (png_ptr->io_ptr));
-4.    fflush(io_ptr);
-3. }
-2. #  endif
-1. #endif
/* This function al",Useful
/*It is an error to read while writing a png file*/,"-1. #ifdef PNG_READ_SUPPORTED

 /*It is an error to read while writing a png file*/

1.    if (png_ptr->read_data_fn != NULL)
2.    {
3.       png_ptr->read_data_fn = NULL;
4.       png_warning(png_ptr,
5.           ""Can't set both read_data_fn and write_",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd,",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd,",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd,",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd,",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd,",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd,",Useful
/*Get the Height and Width of the child window*/,"-6. BOOL CenterAbout (HWND hwndChild, HWND hwndParent)
-5. {
-4.    RECT    rChild, rParent, rWorkArea;
-3.    int     wChild, hChild, wParent, hParent;
-2.    int     xNew, yNew;
-1.    BOOL  bResult;

 /*Get the Height and Width of the child window*/

1",Useful
/*Get the Height and Width of the parent window*/,"-3.    GetWindowRect (hwndChild, &rChild);
-2.    wChild = rChild.right - rChild.left;
-1.    hChild = rChild.bottom - rChild.top;

 /*Get the Height and Width of the parent window*/

1.    GetWindowRect (hwndParent, &rParent);
2.    wParent = rParent.rig",Useful
/*system parameter to query or set*/,"-1.    bResult = SystemParametersInfo(

 /*system parameter to query or set*/

1.       sizeof(RECT),
2.       &rWorkArea,
3.       0);
4.    if (!bResult) {
5.       rWorkArea.left = rWorkArea.top = 0;
6.       rWorkArea.right = GetSystemMetrics(SM_CXSCR",Useful
"/*Calculate new X position, then adjust for workarea*/","-8.       sizeof(RECT),
-7.       &rWorkArea,
-6.       0);
-5.    if (!bResult) {
-4.       rWorkArea.left = rWorkArea.top = 0;
-3.       rWorkArea.right = GetSystemMetrics(SM_CXSCREEN);
-2.       rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN);
-1.    ",Useful
"/*Calculate new Y position, then adjust for workarea*/","-6.    xNew = rParent.left + ((wParent - wChild) /2);
-5.    if (xNew < rWorkArea.left) {
-4.       xNew = rWorkArea.left;
-3.    } else if ((xNew+wChild) > rWorkArea.right) {
-2.       xNew = rWorkArea.right - wChild;
-1.    }

 /*Calculate new Y positio",Useful
"/*If true include unused static GPC functions and declare an external array
    * of them to hide the fact that they are unused.  This is for development
    * use while testing the correct function to use to take into account libpng
    * misbehavior, such as using a simple power law to correct sRGB to linear.*/","-1. #define ALLOW_UNUSED_GPC 0
   /* If true include unused static GPC functions and declare an external array
    * of them to hide the fact that they are unused.  This is for development
    * use while testing the correct function to use to take into a",Useful
"/*During parallel runs of pngstest each temporary file needs a unique name,
 * this is used to permit uniqueness using a command line argument which can be
 * up to 22 characters long.*/","/* During parallel runs of pngstest each temporary file needs a unique name,
 * this is used to permit uniqueness using a command line argument which can be
 * up to 22 characters long.

 /*During parallel runs of pngstest each temporary file needs a unique name,
 * this is used to permit uniqueness using a command line argument which can be
 * up to 22 characters long.*/

1.  */
2. static char tmpf[23] = ""TMP"";",Useful
"/*Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick
 * ""Algorithms"") but it comes from the 'feedback taps' table in Horowitz and
 * Hill, ""The Art of Electronics"".*/","-1. static char tmpf[23] = ""TMP"";
/* Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick",Useful
"/*There are thirty three bits, the next bit in the sequence is bit-33 XOR
    * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.*/","-10.  * is implemented here so that it gives the same set of numbers on every
-9.  * architecture.  It's a linear congruential generator (Knuth or Sedgewick
-8.  * ""Algorithms"") but it comes from the 'feedback taps' table in Horowitz and
-7.  * Hill, ""The",Useful
/*First generate 8 new bits then shift them in at the end.*/,"-3.    size_t i;
-2.    for (i=0; i<size; ++i)
-1.    {

 /*First generate 8 new bits then shift them in at the end.*/

1.       png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;
2.       u1 <<= 8;
3.       u1 |= u0 >> 24;
4.       u",Useful
"/*Math support - neither Cygwin nor Visual Studio have C99 support and we need
 * a predictable rounding function, so make one here:*/","-10. reseed(void)
-9. {
-8.    color_seed[0] = 0x12345678U;
-7.    color_seed[1] = 0x9abcdefU;
-6. }
-5. static void
-4. random_color(png_colorp color)
-3. {
-2.    make_random_bytes(color_seed, color, sizeof *color);
-1. }
/* Math support - neither Cygwi",Useful
/*Cast support: remove GCC whines.*/,"-5. static double
-4. closestinteger(double x)
-3. {
-2.    return floor(x + .5);
-1. }

 /*Cast support: remove GCC whines.*/

1. static png_byte
2. u8d(double d)
3. {
4.    d = closestinteger(d);
5.    return (png_byte)d;
6. }
7. static png_uint_16
8. u",Useful
"/*sRGB support: use exact calculations rounded to the nearest int, see the
 * fesetround() call in main().  sRGB_to_d optimizes the 8 to 16-bit conversion.*/","-10. {
-9.    d = closestinteger(d);
-8.    return (png_byte)d;
-7. }
-6. static png_uint_16
-5. u16d(double d)
-4. {
-3.    d = closestinteger(d);
-2.    return (png_uint_16)d;
-1. }
/* sRGB support: use exact calculations rounded to the nearest int, see",Useful
"/*The error that results from using a 2.2 power law in place of the correct
 * sRGB transform, given an 8-bit value which might be either sRGB or power-law.*/","/* The error that results from using a 2.2 power law in place of the correct
 * sRGB transform, given an 8-bit value which might be either sRGB or power-law.

 /*The error that results from using a 2.2 power law in place of the correct
 * sRGB transform, given an 8-bit value which might be either sRGB or power-law.*/

1.  */
2. static int
3. power_law_error8(int value)
4. {
5.    if (value > 0 && value < 255)
6.    {
7.       double vd = value / 255.;
8.       double e = fabs(
9.          pow(sRGB_to_d[value], 1/2.2) - sRGB_from_linear(pow(vd, 2.2)));",Useful
/*Always allow an extra 1 here for rounding errors*/,"-10.  * sRGB transform, given an 8-bit value which might be either sRGB or power-law.
-9.  */
-8. static int
-7. power_law_error8(int value)
-6. {
-5.    if (value > 0 && value < 255)
-4.    {
-3.       double vd = value / 255.;
-2.       double e = fabs(",Useful
/*Always allow an extra 1 here for rounding errors*/,"-10.  * sRGB transform, given an 8-bit value which might be either sRGB or power-law.
-9.  */
-8. static int
-7. power_law_error8(int value)
-6. {
-5.    if (value > 0 && value < 255)
-4.    {
-3.       double vd = value / 255.;
-2.       double e = fabs(",Useful
"/*""multiple_algorithms"" in this case means that a color-map has been
    * involved somewhere, so we can deduce that the values were forced to 8-bit
    * (like the via_linear case for 8-bit.)*/","-10.       return 1;
-9.    return 0;
-8. }
-7. static int
-6. compare_16bit(int v1, int v2, int error_limit, int multiple_algorithms)
-5. {
-4.    int e = abs(v1-v2);
-3.    int ev1, ev2;
-2.    if (e <= error_limit)
-1.       return 1;
   /* ""multiple_a",Useful
/*else delete temporary files*/,"-1. #define VERBOSE 8

 /*else delete temporary files*/

1. #define KEEP_GOING 32
2. #define ACCUMULATE 64
3. #define FAST_WRITE 128
4. #define sRGB_16BIT 256",Useful
/*do not reseed on each new file*/,"-4. #define KEEP_GOING 32
-3. #define ACCUMULATE 64
-2. #define FAST_WRITE 128
-1. #define sRGB_16BIT 256

 /*do not reseed on each new file*/

 ",Useful
"/*do not ignore the gamma+background_rgb_to_gray
                          * libpng warning.*/","-5. #define KEEP_GOING 32
-4. #define ACCUMULATE 64
-3. #define FAST_WRITE 128
-2. #define sRGB_16BIT 256

 /*do not ignore the gamma+background_rgb_to_gray
                          * libpng warning.*/

1. static void
2. print_opts(png_uint_32 opts)
3. {",Useful
/*else on by default*/,"-5.       printf("" --slow"");
-4.    if (opts & sRGB_16BIT)
-3.       printf("" --sRGB-16bit"");
-2.    if (opts & NO_RESEED)
-1.       printf("" --noreseed"");

 /*else on by default*/

1.    if (opts & GBG_ERROR)
2.       printf("" --fault-gbg-warning"");
3. #",Useful
"/*A name table for all the formats - defines the format of the '+' arguments to
 * pngstest.*/","
/* A name table for all the formats - defines the format of the '+' arguments to
 * pngstest.



 /*A name table for all the formats - defines the format of the '+' arguments to
 * pngstest.*/

1.  */
2. #define FORMAT_COUNT 64
3. #define FORMAT_MASK 0x3f
4. static PNG_CONST char * PNG_CONST format_names[FORMAT_COUNT] =
5. {
6.    ""sRGB-gray"",
7.    ""sRGB-gray+alpha"",
8.    ""sRGB-rgb"",
9.    ""sRGB-rgb+alpha"",
10.    ""linear-gray"",",Useful
/*Decode an argument to a format number.*/,"-10.    ""alpha+linear-bgr"",
-9.    ""color-mapped-sRGB-gray"",
-8.    ""color-mapped-alpha+sRGB-gray"",
-7.    ""color-mapped-sRGB-bgr"",
-6.    ""color-mapped-alpha+sRGB-bgr"",
-5.    ""color-mapped-linear-gray"",
-4.    ""color-mapped-alpha+linear-gray"",
-3.    ""c",Useful
"/*set everything, including flags that are pointless*/","-10. static int format_isset(format_list *pf, png_uint_32 format)
-9. {
-8.    return format < FORMAT_COUNT &&
-7.       (pf->bits[format >> 5] & (((png_uint_32)1) << (format & 31))) != 0;
-6. }
-5. static void format_default(format_list *pf, int redundan",Useful
/*HACK: fixed value*/,"-3.             if ((f & PNG_FORMAT_FLAG_COLOR) == 0 &&
-2.                (f & PNG_FORMAT_FLAG_BGR) != 0)
-1. #        else

 /*HACK: fixed value*/

1. #        endif
2.             continue;",Useful
/*HACK: fixed value*/,"-3.             if ((f & PNG_FORMAT_FLAG_COLOR) == 0 &&
-2.                (f & PNG_FORMAT_FLAG_BGR) != 0)
-1. #        else

 /*HACK: fixed value*/

1. #        endif
2.             continue;",Useful
"/*The super-class of a png_image, contains the decoded image plus the input
 * data necessary to re-read the file with a different format.*/","
/* The super-class of a png_image, contains the decoded image plus the input
 * data necessary to re-read the file with a different format.



 /*The super-class of a png_image, contains the decoded image plus the input
 * data necessary to re-read the file with a different format.*/

1.  */
2. typedef struct
3. {
4.    png_image   image;
5.    png_uint_32 opts;
6.    const char *file_name;
7.    int         stride_extra;
8.    FILE       *input_file;
9.    png_voidp   input_memory;
10.    png_size_t  input_memory_size;",Useful
/*Initializer: also sets the permitted error limit for 16-bit operations.*/,"-10.    png_voidp   input_memory;
-9.    png_size_t  input_memory_size;
-8.    png_bytep   buffer;
-7.    ptrdiff_t   stride;
-6.    png_size_t  bufsize;
-5.    png_size_t  allocsize;
-4.    char        tmpfile_name[32];
-3.    png_uint_16 colormap[256*4]",Useful
/*Reset the image to be read again - only needs to rewind the FILE* at present.*/,"-5. static void
-4. newimage(Image *image)
-3. {
-2.    memset(image, 0, sizeof *image);
-1. }
/* Reset the image to be read again - only needs to rewind the FILE* at present.

 /*Reset the image to be read again - only needs to rewind the FILE* at presen",Useful
"/*Free the image buffer; the buffer is re-used on a re-read, this is just for
 * cleanup.*/","-6. static void
-5. resetimage(Image *image)
-4. {
-3.    if (image->input_file != NULL)
-2.       rewind(image->input_file);
-1. }
/* Free the image buffer; the buffer is re-used on a re-read, this is just for
 * cleanup.

 /*Free the image buffer; the b",Useful
"/*Delete function; cleans out all the allocated data and the temporary file in
 * the image.*/","-10.  * cleanup.
-9.  */
-8. static void
-7. freebuffer(Image *image)
-6. {
-5.    if (image->buffer) free(image->buffer);
-4.    image->buffer = NULL;
-3.    image->bufsize = 0;
-2.    image->allocsize = 0;
-1. }
/* Delete function; cleans out all the al",Useful
"/*This is actually a re-initializer; allows an image structure to be re-used by
 * freeing everything that relates to an old image.*/","-10.       free(image->input_memory);
-9.       image->input_memory = NULL;
-8.       image->input_memory_size = 0;
-7.    }
-6.    if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)
-5.    {
-4.       (void)remove(image->tmpfile_name)",Useful
"/*Make sure the image buffer is big enough; allows re-use of the buffer if the
 * image is re-read.*/","-10.  */
-9. static void initimage(Image *image, png_uint_32 opts, const char *file_name,
-8.    int stride_extra)
-7. {
-6.    freeimage(image);
-5.    memset(&image->image, 0, sizeof image->image);
-4.    image->opts = opts;
-3.    image->file_name = fi",Useful
/*Make sure 16 bytes match the given byte.*/,"-10.             ""simpletest: out of memory allocating %lu(+32) byte buffer\n"",
-9.             (unsigned long)size);
-8.          exit(1);
-7.       }
-6.       image->bufsize = size+32;
-5.    }
-4.    memset(image->buffer, 95, image->bufsize);
-3.    m",Useful
/*Check for overwrite in the image buffer.*/,"-9. static int
-8. check16(png_const_bytep bp, int b)
-7. {
-6.    int i = 16;
-5.    do
-4.       if (*bp != b) return 1;
-3.    while (--i);
-2.    return 0;
-1. }

 /*Check for overwrite in the image buffer.*/

1. static void
2. checkbuffer(Image *imag",Useful
"/*Log a terminal error, also frees the libpng part of the image if necessary.*/","
/* Log a terminal error, also frees the libpng part of the image if necessary.



 /*Log a terminal error, also frees the libpng part of the image if necessary.*/

1.  */
2. static int
3. logerror(Image *image, const char *a1, const char *a2, const char *a3)
4. {
5.    fflush(stdout);
6.    if (image->image.warning_or_error)
7.       fprintf(stderr, ""%s%s%s: %s\n"", a1, a2, a3, image->image.message);
8.    else
9.       fprintf(stderr, ""%s%s%s\n"", a1, a2, a3);
10.    if (image->image.opaque != NULL)",Useful
"/*Log an error and close a file (just a utility to do both things in one
 * function call.)*/","-10.    else
-9.       fprintf(stderr, ""%s%s%s\n"", a1, a2, a3);
-8.    if (image->image.opaque != NULL)
-7.    {
-6.       fprintf(stderr, ""%s: image opaque pointer non-NULL on error\n"",
-5.          image->file_name);
-4.       png_image_free(&image->ima",Useful
"/*Make sure the png_image has been freed - validates that libpng is doing what
 * the spec says and freeing the image.*/","-7. static int
-6. logclose(Image *image, FILE *f, const char *name, const char *operation)
-5. {
-4.    int e = errno;
-3.    fclose(f);
-2.    return logerror(image, name, operation, strerror(e));
-1. }
/* Make sure the png_image has been freed - valida",Useful
"/*Separate out the gamma+background_rgb_to_gray warning because it may
    * produce opaque component errors:*/","-10.  * the spec says and freeing the image.
-9.  */
-8. static int
-7. checkopaque(Image *image)
-6. {
-5.    if (image->image.opaque != NULL)
-4.    {
-3.       png_image_free(&image->image);
-2.       return logerror(image, image->file_name, "": opaque ",Useful
"/*Compare the pixels of two images, which should be the same but aren't.  The
 * images must have been checked for a size match.*/","
/* Compare the pixels of two images, which should be the same but aren't.  The
 * images must have been checked for a size match.



 /*Compare the pixels of two images, which should be the same but aren't.  The
 * images must have been checked for a size match.*/

1.  */
2. typedef struct
3. {",Useful
"/*The components, for grayscale images the gray value is in 'g' and if alpha
    * is not present 'a' is set to 255 or 65535 according to format.*/","-2. typedef struct
-1. {
   /* The components, for grayscale images the gray value is in 'g' and if alpha
    * is not present 'a' is set to 255 or 65535 according to format.

 /*The components, for grayscale images the gray value is in 'g' and if alpha
 ",Useful
"/*The background as the original sRGB 8-bit value converted to the final
    * integer format and as a double precision linear value in the range 0..1
    * for with partially transparent pixels.*/","-4.    int         r, g, b, a;
-3. } Pixel;
-2. typedef struct
-1. {
   /* The background as the original sRGB 8-bit value converted to the final
    * integer format and as a double precision linear value in the range 0..1
    * for with partially transp",Useful
"/*Read a Pixel from a buffer.  The code below stores the correct routine for
 * the format in a function pointer, these are the routines:*/","-2. #define BASE_FORMATS\
-1.    (PNG_FORMAT_FLAG_ALPHA|PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_LINEAR)
/* Read a Pixel from a buffer.  The code below stores the correct routine for
 * the format in a function pointer, these are the routines:

 /*Read a Pix",Useful
"/*The color-map flag is irrelevant here - the caller of the function
    * returned must either pass the buffer or, for a color-mapped image, the
    * correct entry in the color-map.*/","-3. static void (*
-2. get_pixel(png_uint_32 format))(Pixel *p, png_const_voidp pb)
-1. {
   /* The color-map flag is irrelevant here - the caller of the function
    * returned must either pass the buffer or, for a color-mapped image, the
    * correct e",Useful
/*bckg: composite on gray background*/,"-10.  *  8 G     .    .    .    .     lin  lin  lin  lin
-9.  *  8 GA    bckg .    bckc .     pre' pre  pre' pre
-8.  *  8 RGB   g8   g8   .    .     glin glin lin  lin
-7.  *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
-6.  * 16 G     sRGB sRGB sRGB",Useful
/*bckc: composite on color background*/,"-10.  *  8 GA    bckg .    bckc .     pre' pre  pre' pre
-9.  *  8 RGB   g8   g8   .    .     glin glin lin  lin
-8.  *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
-7.  * 16 G     sRGB sRGB sRGB sRGB  .    .    .    .
-6.  * 16 GA    b16g unpg b16c u",Useful
/*g8: convert sRGB components to sRGB grayscale*/,"-10.    }
-9.    else
-8.    {
-7.       double a = in->a / 255.;
-6.       out->r = sRGB(sRGB_to_d[in->r] * a + back->dr * (1-a));
-5.       out->g = sRGB(sRGB_to_d[in->g] * a + back->dg * (1-a));
-4.       out->b = sRGB(sRGB_to_d[in->b] * a + back->db *",Useful
/*g8b: convert sRGB components to grayscale and composite on gray background*/,"-10. gpc_g8(Pixel *out, const Pixel *in, const Background *back)
-9. {
-8.    (void)back;
-7.    if (in->r == in->g && in->g == in->b)
-6.       out->r = out->g = out->b = in->g;
-5.    else
-4.       out->r = out->g = out->b =
-3.          sRGB(YfromRGB(",Useful
"/*lin: make sRGB components linear, alpha := 65535*/","-10.    }
-9.    else
-8.    {
-7.       double a = in->a/255.;
-6.       out->r = out->g = out->b = sRGB(a * YfromRGB(sRGB_to_d[in->r],
-5.          sRGB_to_d[in->g], sRGB_to_d[in->b]) + back->dg * (1-a));
-4.    }
-3.    out->a = 255;
-2. }

 /*lin: mak",Useful
/*pre: make sRGB components linear and premultiply by alpha (scale alpha)*/,"-10.       out->g = ilinear(in->g);
-9.       if (in->b == in->r)
-8.          out->b = out->r;
-7.       else if (in->b == in->g)
-6.          out->b = out->g;
-5.       else
-4.          out->b = ilinear(in->b);
-3.    }
-2.    out->a = 65535;
-1. }

 /",Useful
"/*glin: make sRGB components linear, convert to grayscale, alpha := 65535*/","-10.  *  8-bit to 8-bit:
-9.  * bckg: composite on gray background
-8.  * bckc: composite on color background
-7.  * g8:   convert sRGB components to sRGB grayscale
-6.  * g8b:  convert sRGB components to grayscale and composite on gray background
-5.  *
",Useful
/*gpre: make sRGB components grayscale and linear and premultiply by alpha*/,"-10.  * bckg: composite on gray background
-9.  * bckc: composite on color background
-8.  * g8:   convert sRGB components to sRGB grayscale
-7.  * g8b:  convert sRGB components to grayscale and composite on gray background
-6.  *
-5.  *  8-bit to 16-bit:",Useful
"/*Lin: make gAMA 45455 components linear, alpha := 65535*/","-10. {
-9.    (void)back;
-8.    if (in->r == in->g && in->g == in->b)
-7.       out->r = out->g = out->b = ilineara(in->g, in->a);
-6.    else
-5.       out->r = out->g = out->b = u16d(in->a * 257 *
-4.          YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g",Useful
"/*Glin: make gAMA 45455 components linear, convert to grayscale, alpha := 65535*/","-10.          out->b = out->r;
-9.       else if (in->b == in->g)
-8.          out->b = out->g;
-7.       else
-6.          out->b = ilineara_g22(in->b, in->a);
-5.    }
-4.    out->a = 65535;
-3. }
-2. #endif
-1. #if ALLOW_UNUSED_GPC
/* Glin: make gAMA 4",Useful
"/*Gpre: make gAMA 45455 components grayscale and linear and premultiply by
 * alpha.*/","-10.    (void)back;
-9.    if (in->r == in->g && in->g == in->b)
-8.       out->r = out->g = out->b = ilinear_g22(in->g);
-7.    else
-6.       out->r = out->g = out->b = u16d(65535 *
-5.          YfromRGB(g22_to_d[in->r], g22_to_d[in->g], g22_to_d[in->b]",Useful
"/*sRGB: convert linear components to sRGB, alpha := 255*/","-10.  *
-9.  *  8-bit to 16-bit:
-8.  * lin:  make sRGB components linear, alpha := 65535
-7.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
-6.  * pre': as 'pre' but alpha := 65535
-5.  * glin: make sRGB components linear, c",Useful
/*unpg: unpremultiply gray component and convert to sRGB (scale alpha)*/,"-10.  *  8-bit to 16-bit:
-9.  * lin:  make sRGB components linear, alpha := 65535
-8.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
-7.  * pre': as 'pre' but alpha := 65535
-6.  * glin: make sRGB components linear, convert ",Useful
/*unpc: unpremultiply color components and convert to sRGB (scale alpha)*/,"-10.  * lin:  make sRGB components linear, alpha := 65535
-9.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
-8.  * pre': as 'pre' but alpha := 65535
-7.  * glin: make sRGB components linear, convert to grayscale, alpha := 65",Useful
/*b16g: composite linear onto gray background and convert the result to sRGB*/,"-10.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
-9.  * pre': as 'pre' but alpha := 65535
-8.  * glin: make sRGB components linear, convert to grayscale, alpha := 65535
-7.  * gpre: make sRGB components grayscale and linea",Useful
/*b16c: composite linear onto color background and convert the result to sRGB*/,"-10.  * pre': as 'pre' but alpha := 65535
-9.  * glin: make sRGB components linear, convert to grayscale, alpha := 65535
-8.  * gpre: make sRGB components grayscale and linear and premultiply by alpha
-7.  * gpr': as 'gpre' but alpha := 65535
-6.  *
-5.  ",Useful
/*sG: convert linear RGB to sRGB grayscale*/,"-10.    {
-9.       double a = in->a/65535.;
-8.       double a1 = 1-a;
-7.       a /= 65535;
-6.       out->r = sRGB(in->r * a + back->dr * a1);
-5.       out->g = sRGB(in->g * a + back->dg * a1);
-4.       out->b = sRGB(in->b * a + back->db * a1);
-3.  ",Useful
/*sGp: unpremultiply RGB then convert to sRGB grayscale*/,"-7. static void
-6. gpc_sG(Pixel *out, const Pixel *in, const Background *back)
-5. {
-4.    (void)back;
-3.    out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/65535);
-2.    out->a = 255;
-1. }

 /*sGp: unpremultiply RGB then convert to ",Useful
/*gb16: composite linear onto background and convert to sRGB grayscale*/,"-10.  *
-9.  *  16-bit to 8-bit:
-8.  * sRGB: convert linear components to sRGB, alpha := 255
-7.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
-6.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
-5.  * ",Useful
"/*(order doesn't matter, the composite and grayscale operations permute)*/","-10.  *  16-bit to 8-bit:
-9.  * sRGB: convert linear components to sRGB, alpha := 255
-8.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
-7.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
-6.  * b16g: c",Useful
/*cb16: composite linear onto background and convert to sRGB*/,"-10.  * sRGB: convert linear components to sRGB, alpha := 255
-9.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
-8.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
-7.  * b16g: composite linear onto gray",Useful
/*g16:  convert linear RGB to linear grayscale (alpha := 65535)*/,"-10.  * b16c: composite linear onto color background and convert the result to sRGB
-9.  * sG:   convert linear RGB to sRGB grayscale
-8.  * sGp:  unpremultiply RGB then convert to sRGB grayscale
-7.  * sCp:  unpremultiply RGB then convert to sRGB
-6.  * ",Useful
/*Unused functions (to hide them from GCC unused function warnings)*/,"-8. static void
-7. gpc_g16q(Pixel *out, const Pixel *in, const Background *back)
-6. {
-5.    (void)back;
-4.    out->r = out->g = out->b = u16d(YfromRGBint(in->r, in->g, in->b));
-3.    out->a = in->a;
-2. }
-1. #if ALLOW_UNUSED_GPC

 /*Unused functions",Useful
"/*OUT:    ----- 8-bit -----    ----- 16-bit -----
 *   IN     G    GA   RGB  RGBA  G    GA   RGB  RGBA
 *  8 G     .    .    .    .     lin  lin  lin  lin
 *  8 GA    bckg .    bckc .     pre' pre  pre' pre
 *  8 RGB   g8   g8   .    .     glin glin lin  lin
 *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
 * 16 G     sRGB sRGB sRGB sRGB  .    .    .    .
 * 16 GA    b16g unpg b16c unpc  A    .    A    .
 * 16 RGB   sG   sG   sRGB sRGB  g16  g16  .    .
 * 16 RGBA  gb16 sGp  cb16 sCp   g16  g16' A    .
 *
 * The matrix is held in an array indexed thus:
 *
 *   gpc_fn[out_format & BASE_FORMATS][in_format & BASE_FORMATS];*/","-6. void (* const gpc_unused[])
-5.    (Pixel *out, const Pixel *in, const Background *back) =
-4. {
-3.    gpc_Pre, gpc_Preq, gpc_Glin, gpc_Gpre, gpc_Gprq, gpc_nop8, gpc_nop6
-2. };
-1. #endif
/*   OUT:    ----- 8-bit -----    ----- 16-bit -----
 *   IN ",Useful
"/*This will produce a compile time error if the FORMAT_FLAG values don't
 * match the above matrix!*/","-10.  *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
-9.  * 16 G     sRGB sRGB sRGB sRGB  .    .    .    .
-8.  * 16 GA    b16g unpg b16c unpc  A    .    A    .
-7.  * 16 RGB   sG   sG   sRGB sRGB  g16  g16  .    .
-6.  * 16 RGBA  gb16 sGp  cb16 sCp  ",Useful
"/*The array is repeated for the cases where both the input and output are color
 * mapped because then different algorithms are used.*/","-9.    {gpc_noop,gpc_noop,gpc_noop,gpc_noop, gpc_Lin, gpc_Lin, gpc_Lin, gpc_Lin },
-8.    {gpc_bckg,gpc_noop,gpc_bckc,gpc_noop, gpc_preq,gpc_pre, gpc_preq,gpc_pre },
-7.    {gpc_g8,  gpc_g8,  gpc_noop,gpc_noop, gpc_glin,gpc_glin,gpc_lin, gpc_lin },
-6.   ",Useful
"/*The error arrays record the error in the same matrix; 64 entries, however
 * the different algorithms used in libpng for colormap and direct conversions
 * mean that four separate matrices are used (for each combination of
 * colormapped and direct.)
 *
 * In some cases the conversion between sRGB formats goes via a linear
 * intermediate; an sRGB to linear conversion (as above) is followed by a simple
 * linear to sRGB step with no other conversions.  This is done by a separate
 * error array from an arbitrary 'in' format to one of the four basic outputs
 * (since final output is always sRGB not colormapped).
 *
 * These arrays may be modified if the --accumulate flag is set during the run;
 * then instead of logging errors they are simply added in.
 *
 * The three entries are currently for transparent, partially transparent and
 * opaque input pixel values.  Notice that alpha should be exact in each case.
 *
 * Errors in alpha should only occur when converting from a direct format
 * to a colormapped format, when alpha is effectively smashed (so large
 * errors can occur.)  There should be no error in the '0' and 'opaque'
 * values.  The fourth entry in the array is used for the alpha error (and it
 * should always be zero for the 'via linear' case since this is never color
 * mapped.)
 *
 * Mapping to a colormap smashes the colors, it is necessary to have separate
 * values for these cases because they are much larger; it is very much
 * impossible to obtain a reasonable result, these are held in
 * gpc_error_to_colormap.*/","-10. /*out: G-8     GA-8     RGB-8    RGBA-8    G-16     GA-16   RGB-16  RGBA-16 */
-9.    {gpc_noop,gpc_noop,gpc_noop,gpc_noop, gpc_lin, gpc_lin, gpc_lin, gpc_lin },
-8.    {gpc_bckg,gpc_noop,gpc_bckc,gpc_noop, gpc_preq,gpc_pre, gpc_preq,gpc_pre },
-7.  ",Useful
"/*background' is the value passed to the gpc_ routines, it may be NULL if
    * it should not be used (*this* program has an error if it crashes as a
    * result!)*/","-5. typedef struct
-4. {

 /*background' is the value passed to the gpc_ routines, it may be NULL if
    * it should not be used (*this* program has an error if it crashes as a
    * result!)*/

1.     */
2.    Background        background_color;
3.    co",Useful
"/*For 'via_linear' transforms the final, from linear, step, else NULL*/","-1.    void (*from_linear)(Pixel *out, const Pixel *in, const Background *back);

 /*For 'via_linear' transforms the final, from linear, step, else NULL*/

1.    png_uint_16 error[4];",Useful
"/*Three error values for transparent, partially transparent and opaque
       * input pixels (in turn).*/","-1.    png_uint_16 error[4];
      /* Three error values for transparent, partially transparent and opaque
       * input pixels (in turn).

 /*Three error values for transparent, partially transparent and opaque
       * input pixels (in turn).*/

1.    ",Useful
/*Where these are stored in the static array (for 'accumulate')*/,"-1.    png_uint_16 *error_ptr;

 /*Where these are stored in the static array (for 'accumulate')*/

1. }
2. Transform;",Useful
/*Return a 'transform' as above for the given format conversion.*/,"-2. }
-1. Transform;

 /*Return a 'transform' as above for the given format conversion.*/

1. static void
2. transform_from_formats(Transform *result, Image *in_image,
3.    const Image *out_image, png_const_colorp background, int via_linear)
4. {
5.    p",Useful
/*Store the original images for error messages*/,"-7. static void
-6. transform_from_formats(Transform *result, Image *in_image,
-5.    const Image *out_image, png_const_colorp background, int via_linear)
-4. {
-3.    png_uint_32 in_format, out_format;
-2.    png_uint_32 in_base, out_base;
-1.    memset(",Useful
/*set by caller if required*/,"-9.    result->in_image = in_image;
-8.    result->out_image = out_image;
-7.    in_format = in_image->image.format;
-6.    out_format = out_image->image.format;
-5.    if (in_format & PNG_FORMAT_FLAG_LINEAR)
-4.       result->in_opaque = 65535;
-3.    el",Useful
/*Check for an error in this program:*/,"-6.    in_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP;
-5.    in_base = in_format & BASE_FORMATS;
-4.    out_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP;
-3.    out_base = out_format & BASE_FORMATS;
-2.    if (via_linear)
-1.    {

 /*Check fo",Useful
"/*The input is not colormapped but the output is, the errors will
       * typically be large (only the grayscale-no-alpha case permits preserving
       * even 8-bit values.)*/","-10.          fprintf(stderr, ""internal transform via linear error 0x%x->0x%x\n"",
-9.             in_format, out_format);
-8.          exit(1);
-7.       }
-6.       result->transform = gpc_fn[in_base][out_base | PNG_FORMAT_FLAG_LINEAR];
-5.       result-",Useful
"/*The caller handles the colormap->pixel value conversion, so the
       * transform function just gets a pixel value, however because libpng
       * currently contains a different implementation for mapping a colormap if
       * both input and output are colormapped we need different conversion
       * functions to deal with errors in the libpng implementation.*/","-6.       result->transform = gpc_fn[in_base][out_base];
-5.       result->from_linear = NULL;
-4.       result->error_ptr = gpc_error_to_colormap[in_base][out_base];
-3.    }
-2.    else
-1.    {
      /* The caller handles the colormap->pixel value conv",Useful
"/*Follow the libpng simplified API rules to work out what to pass to the gpc
    * routines as a background value, if one is not required pass NULL so that
    * this program crashes in the even of a programming error.*/","-10.        * both input and output are colormapped we need different conversion
-9.        * functions to deal with errors in the libpng implementation.
-8.        */
-7.       if (in_format & out_format & PNG_FORMAT_FLAG_COLORMAP)
-6.          result->t",Useful
/*default: not required*/,"-10.          result->transform = gpc_fn_colormapped[in_base][out_base];
-9.       else
-8.          result->transform = gpc_fn[in_base][out_base];
-7.       result->from_linear = NULL;
-6.       result->error_ptr = gpc_error[in_format][out_format];
-5.  ",Useful
/*Rule 1: background only need be supplied if alpha is to be removed*/,"-10.       else
-9.          result->transform = gpc_fn[in_base][out_base];
-8.       result->from_linear = NULL;
-7.       result->error_ptr = gpc_error[in_format][out_format];
-6.    }

 /*Rule 1: background only need be supplied if alpha is to be remov",Useful
"/*The input value is 'NULL' to use the background and (otherwise) an sRGB
       * background color (to use a solid color).  The code above uses a fixed
       * byte value, BUFFER_INIT8, for buffer even for 16-bit output.  For
       * linear (16-bit) output the sRGB background color is ignored; the
       * composition is always on the background (so BUFFER_INIT8 * 257), except
       * that for the colormap (i.e. linear colormapped output) black is used.*/","-2.    if (in_format & ~out_format & PNG_FORMAT_FLAG_ALPHA)
-1.    {
      /* The input value is 'NULL' to use the background and (otherwise) an sRGB
       * background color (to use a solid color).  The code above uses a fixed
       * byte value, BUFFE",Useful
/*grayscale: libpng only looks at 'g'*/,"-4.                result->background_color.dr = sRGB_to_d[background->red];
-3.                result->background_color.dg = sRGB_to_d[background->green];
-2.                result->background_color.db = sRGB_to_d[background->blue];
-1.             }

 /",Useful
"/*Else the output is colormapped and a background color must be
          * provided; if pngstest crashes then that is a bug in this program
          * (though libpng should png_error as well.)*/","-4.             result->background_color.dr =
-3.                result->background_color.dg =
-2.                result->background_color.db = sRGB_to_d[BUFFER_INIT8];
-1.          }
         /* Else the output is colormapped and a background color must ",Useful
"/*Compare two pixels.
 *
 * OLD error values:
static int error_to_linear = 811; * by experiment *
static int error_to_linear_grayscale = 424; * by experiment *
static int error_to_sRGB = 6; * by experiment *
static int error_to_sRGB_grayscale = 17; * libpng error by calculation +
                                            2 by experiment *
static int error_in_compose = 2; * by experiment *
static int error_in_premultiply = 1;
 *
 * The following is *just* the result of a round trip from 8-bit sRGB to linear
 * then back to 8-bit sRGB when it is done by libpng.  There are two problems:
 *
 * 1) libpng currently uses a 2.2 power law with no linear segment, this results
 * in instability in the low values and even with 16-bit precision sRGB(1) ends
 * up mapping to sRGB(0) as a result of rounding in the 16-bit representation.
 * This gives an error of 1 in the handling of value 1 only.
 *
 * 2) libpng currently uses an intermediate 8-bit linear value in gamma
 * correction of 8-bit values.  This results in many more errors, the worse of
 * which is mapping sRGB(14) to sRGB(0).
 *
 * The general 'error_via_linear' is more complex because of pre-multiplication,
 * this compounds the 8-bit errors according to the alpha value of the pixel.
 * As a result 256 values are pre-calculated for error_via_linear.*/","-10.       result->background_color.dr =
-9.          result->background_color.dg =
-8.          result->background_color.db = 1E30; /* not used */
-7.    }
-6.    /* Copy the error values into the Transform: */
-5.    result->error[0] = result->error_ptr",Useful
/*transparent pixel*/,"-6.    int         r, g, b, a;
-5. } Pixel;
-4. typedef struct
-3. {
-2.    /* The background as the original sRGB 8-bit value converted to the final
-1.     * integer format and as a double precision linear value in the range 0..1
    * for with partiall",Useful
"/*16-bit values less than 128.5 get rounded to 8-bit 0 and so the worst
       * case error arises with 16-bit 128.5, work out what sRGB
       * (non-associated) value generates 128.5; any value less than this is
       * going to map to 0, so the worst error is floor(value).
       *
       * Note that errors are considerably higher (more than a factor of 2)
       * because libpng uses a simple power law for sRGB data at present.
       *
       * Add .1 for arithmetic errors inside libpng.*/","-2.    for (alpha=1; alpha<=255; ++alpha)
-1.    {
      /* 16-bit values less than 128.5 get rounded to 8-bit 0 and so the worst
       * case error arises with 16-bit 128.5, work out what sRGB
       * (non-associated) value generates 128.5; any value l",Useful
"/*And as a result the *read* format which did any background processing
       * was itself linear, so the background color information is also
       * linear.*/","-10.    print_pixel(pixel_in, in, in_format);
-9.    print_pixel(pixel_calc, calc, out_format);
-8.    print_pixel(pixel_out, out, out_format);
-7.    if (transform->is_palette)
-6.       sprintf(pixel_loc, ""palette: %lu"", (unsigned long)y);
-5.    else
-",Useful
/*Eliminate the case where the input and output values match exactly.*/,"-10.    Pixel pixel_in, pixel_calc, pixel_out;
-9.    transform->in_gp(&pixel_in, in);
-8.    if (transform->from_linear == NULL)
-7.       transform->transform(&pixel_calc, &pixel_in, transform->background);
-6.    else
-5.    {
-4.       transform->tran",Useful
"/*Eliminate the case where the output pixel is transparent and the output
    * is 8-bit - any component values are valid.  Don't check the input alpha
    * here to also skip the 16-bit small alpha cases.*/","-3.    if (pixel_calc.a == pixel_out.a && pixel_calc.r == pixel_out.r &&
-2.       pixel_calc.g == pixel_out.g && pixel_calc.b == pixel_out.b)
-1.       return 1;
   /* Eliminate the case where the output pixel is transparent and the output
    * is 8-bit",Useful
"/*Check for alpha errors first; an alpha error can damage the components too
    * so avoid spurious checks on components if one is found.*/","-2.    if (transform->output_8bit && pixel_calc.a == 0 && pixel_out.a == 0)
-1.       return 1;
   /* Check for alpha errors first; an alpha error can damage the components too
    * so avoid spurious checks on components if one is found.

 /*Check for al",Useful
"/*Now if *either* of the output alphas are 0 but alpha is within tolerance
    * eliminate the 8-bit component comparison.*/","-6.          if (transform->accumulate)
-5.             transform->error[3] = (png_uint_16)err_a;
-4.          else
-3.             errmsg = ""alpha"";
-2.       }
-1.    }
   /* Now if *either* of the output alphas are 0 but alpha is within tolerance
    *",Useful
/*else just signal an alpha error*/,"-3.    if (errmsg == NULL && transform->output_8bit &&
-2.       (pixel_calc.a == 0 || pixel_out.a == 0))
-1.       return 1;

 /*else just signal an alpha error*/

1.    {
2.       int err_r = abs(pixel_calc.r - pixel_out.r);
3.       int err_g = abs(pix",Useful
"/*Handle a component mis-match; log it, just return an error code, or
       * accumulate it.*/","
      /* Handle a component mis-match; log it, just return an error code, or
       * accumulate it.



 /*Handle a component mis-match; log it, just return an error code, or
       * accumulate it.*/

1.        */
2.       if (transform->accumulate)
3.       {
4.          transform->error[limit] = (png_uint_16)maxerr;",Useful
"/*Failure to match and not accumulating, so the error must be logged.*/","-2.       }
-1.    }

 /*Failure to match and not accumulating, so the error must be logged.*/

1.    return logpixel(transform, x, y, &pixel_in, &pixel_calc, &pixel_out, errmsg);
2. }
3. static png_byte
4. component_loc(png_byte loc[4], png_uint_32 forma",Useful
"/*Given a format return the number of channels and the location of
    * each channel.
    *
    * The mask 'loc' contains the component offset of the channels in the
    * following order.  Note that if 'format' is grayscale the entries 1-3 must
    * all contain the location of the gray channel.
    *
    * 0: alpha
    * 1: red or gray
    * 2: green or gray
    * 3: blue or gray*/","-5.    return logpixel(transform, x, y, &pixel_in, &pixel_calc, &pixel_out, errmsg);
-4. }
-3. static png_byte
-2. component_loc(png_byte loc[4], png_uint_32 format)
-1. {
   /* Given a format return the number of channels and the location of
    * each c",Useful
"/*Compare two images, the original 'a', which was written out then read back in
 * to * give image 'b'.  The formats may have been changed.*/","-2.    return channels;
-1. }
/* Compare two images, the original 'a', which was written out then read back in
 * to * give image 'b'.  The formats may have been changed.

 /*Compare two images, the original 'a', which was written out then read back in
 *",Useful
/*Find the first row and inter-row space.*/,"-1.    transform_from_formats(&tr, a, b, background, via_linear);

 /*Find the first row and inter-row space.*/

1.    if (!(formata & PNG_FORMAT_FLAG_COLORMAP) &&
2.       (formata & PNG_FORMAT_FLAG_LINEAR))
3.       stridea *= 2;
4.    if (!(formatb & P",Useful
"/*First shortcut the two colormap case by comparing the image data; if it
    * matches then we expect the colormaps to match, although this is not
    * absolutely necessary for an image match.  If the colormaps fail to match
    * then there is a problem in libpng.*/","-8.    if (!(formata & PNG_FORMAT_FLAG_COLORMAP) &&
-7.       (formata & PNG_FORMAT_FLAG_LINEAR))
-6.       stridea *= 2;
-5.    if (!(formatb & PNG_FORMAT_FLAG_COLORMAP) &&
-4.       (formatb & PNG_FORMAT_FLAG_LINEAR))
-3.       strideb *= 2;
-2.    if (",Useful
"/*Do this the slow way to accumulate the 'in_use' flags, don't break out
       * of the loop until the end; this validates the color-mapped data to
       * ensure all pixels are valid color-map indexes.*/","-6.       png_const_bytep ppa, ppb;
-5.       int match;
-4.       png_byte in_use[256], amax = 0, bmax = 0;
-3.       memset(in_use, 0, sizeof in_use);
-2.       ppa = rowa;
-1.       ppb = rowb;
      /* Do this the slow way to accumulate the 'in_use' f",Useful
/*If the buffers match then the colormaps must too.*/,"-10.             png_byte aval = ppa[x];
-9.             if (bval > bmax)
-8.                bmax = bval;
-7.             if (bval != aval)
-6.                match = 0;
-5.             in_use[aval] = 1;
-4.             if (aval > amax)
-3.               ",Useful
"/*Do the color-maps match, entry by entry?  Only check the 'in_use'
          * entries.  An error here should be logged as a color-map error.*/","-2.       if (match)
-1.       {
         /* Do the color-maps match, entry by entry?  Only check the 'in_use'
          * entries.  An error here should be logged as a color-map error.

 /*Do the color-maps match, entry by entry?  Only check the 'in_use'",Useful
"/*The colormap entries should be valid, but because libpng doesn't
             * do any checking at present the original image may contain invalid
             * pixel values.  These cause an error here (at present) unless
             * accumulating errors in which case the program just ignores them.*/","-4.          tr.is_palette = 1;
-3.          for (y=0; y<256; ++y, a_cmap += a_sample, b_cmap += b_sample)
-2.             if (in_use[y])
-1.          {
            /* The colormap entries should be valid, but because libpng doesn't
             * do any ",Useful
"/*else the image buffers don't match pixel-wise so compare sample values
       * instead, but first validate that the pixel indexes are in range (but
       * only if not accumulating, when the error is ignored.)*/","-3.          }
-2.          return result;
-1.       }
      /* else the image buffers don't match pixel-wise so compare sample values
       * instead, but first validate that the pixel indexes are in range (but
       * only if not accumulating, when th",Useful
/*2^32: GCC sprintf warning*/,"-3.       else if ((a->opts & ACCUMULATE) == 0)
-2.       {
-1. #        ifdef __GNUC__

 /*2^32: GCC sprintf warning*/

1. #        else",Useful
/*2^8: real maximum value*/,"-1. #        else

 /*2^8: real maximum value*/

1. #        endif",Useful
"/*Check the original image first,
          * TODO: deal with input images with bad pixel values?*/","-1. #        endif
         /* Check the original image first,
          * TODO: deal with input images with bad pixel values?

 /*Check the original image first,
          * TODO: deal with input images with bad pixel values?*/

1.           */
2.       ",Useful
"/*We can directly compare pixel values without the need to use the read
    * or transform support (i.e. a memory compare) if:
    *
    * 1) The bit depth has not changed.
    * 2) RGB to grayscale has not been done (the reverse is ok; we just compare
    *    the three RGB values to the original grayscale.)
    * 3) An alpha channel has not been removed from an 8-bit format, or the
    *    8-bit alpha value of the pixel was 255 (opaque).
    *
    * If an alpha channel has been *added* then it must have the relevant opaque
    * value (255 or 65535).
    *
    * The fist two the tests (in the order given above) (using the boolean
    * equivalence !a && !b == !(a || b))*/","-4.             return logerror(b, b->file_name, "": bad pixel index: "", pindex);
-3.          }
-2.       }
-1.    }
   /* We can directly compare pixel values without the need to use the read
    * or transform support (i.e. a memory compare) if:
    *
 ",Useful
/*Was an alpha channel changed?*/,"-10.     *
-9.     * If an alpha channel has been *added* then it must have the relevant opaque
-8.     * value (255 or 65535).
-7.     *
-6.     * The fist two the tests (in the order given above) (using the boolean
-5.     * equivalence !a && !b == !(a ",Useful
"/*Was an alpha channel removed?  (The third test.)  If so the direct
       * comparison is only possible if the input alpha is opaque.*/","-2.       const png_uint_32 alpha_changed = (formata ^ formatb) &
-1.          PNG_FORMAT_FLAG_ALPHA;
      /* Was an alpha channel removed?  (The third test.)  If so the direct
       * comparison is only possible if the input alpha is opaque.

 /*Was an",Useful
/*Was an alpha channel added?*/,"-1.       alpha_removed = (formata & alpha_changed) != 0;

 /*Was an alpha channel added?*/

1.       alpha_added = (formatb & alpha_changed) != 0;",Useful
"/*The channels may have been moved between input and output, this finds
       * out how, recording the result in the btoa array, which says where in
       * 'a' to find each channel of 'b'.  If alpha was added then btoa[alpha]
       * ends up as 4 (and is not used.)*/","-1.       alpha_added = (formatb & alpha_changed) != 0;
      /* The channels may have been moved between input and output, this finds
       * out how, recording the result in the btoa array, which says where in
       * 'a' to find each channel of 'b'. ",Useful
"/*The following are used only if the formats match, except that
          * 'bchannels' is a flag for matching formats.  btoa[x] says, for each
          * channel in b, where to find the corresponding value in a, for the
          * bchannels.  achannels may be different for a gray to rgb transform
          * (a will be 1 or 2, b will be 3 or 4 channels.)*/","-4.       {
-3.          int i;
-2.          png_byte aloc[4];
-1.          png_byte bloc[4];
         /* The following are used only if the formats match, except that
          * 'bchannels' is a flag for matching formats.  btoa[x] says, for each
       ",Useful
/*location of alpha channel in image b*/,"-1.          if (alpha_added)

 /*location of alpha channel in image b*/

1.          else",Useful
/*Won't match an image b channel*/,"-1.          else

 /*Won't match an image b channel*/

1.          if (alpha_removed)",Useful
/*location of alpha channel in image a*/,"-1.          if (alpha_removed)

 /*location of alpha channel in image a*/

1.          else
2.             alpha_removed = 4;
3.       }
4.    }
5.    else
6.    {",Useful
"/*Direct compare is not possible, cancel out all the corresponding local
       * variables.*/","-6.          else
-5.             alpha_removed = 4;
-4.       }
-3.    }
-2.    else
-1.    {
      /* Direct compare is not possible, cancel out all the corresponding local
       * variables.

 /*Direct compare is not possible, cancel out all the corre",Useful
"/*Check each 'b' channel against either the corresponding 'a'
             * channel or the opaque alpha value, as appropriate.  If
             * alpha_removed value is set (not 4) then also do this only if the
             * 'a' alpha channel (alpha_removed) is opaque; only relevant for
             * the 8-bit case.*/","-2.          if (bchannels)
-1.          {
            /* Check each 'b' channel against either the corresponding 'a'
             * channel or the opaque alpha value, as appropriate.  If
             * alpha_removed value is set (not 4) then also do this",Useful
"/*If we get to here the fast match failed; do the slow match for this
          * pixel.*/","-3.                }
-2.             }
-1.          }
         /* If we get to here the fast match failed; do the slow match for this
          * pixel.

 /*If we get to here the fast match failed; do the slow match for this
          * pixel.*/

1.      ",Useful
"/*Read the file; how the read gets done depends on which of input_file and
 * input_memory have been set.*/","-9.    if (a->opts & ACCUMULATE)
-8.    {
-7.       tr.error_ptr[0] = tr.error[0];
-6.       tr.error_ptr[1] = tr.error[1];
-5.       tr.error_ptr[2] = tr.error[2];
-4.       tr.error_ptr[3] = tr.error[3];
-3.    }
-2.    return 1;
-1. }
/* Read the file;",Useful
"/*Have an initialized image with all the data we need plus, maybe, an
    * allocated file (myfile) or buffer (mybuffer) that need to be freed.*/","-2.    if (image->opts & sRGB_16BIT)
-1.       image->image.flags |= PNG_IMAGE_FLAG_16BIT_sRGB;
   /* Have an initialized image with all the data we need plus, maybe, an
    * allocated file (myfile) or buffer (mybuffer) that need to be freed.

 /*Have an",Useful
/*Print both original and output formats.*/,"-3.    {
-2.       int result;
-1.       png_uint_32 image_format;

 /*Print both original and output formats.*/

1.       image_format = image->image.format;
2.       if (image->opts & VERBOSE)
3.       {
4.          printf(""%s %lu x %lu %s -> %s"", image",Useful
"/*NO_CHANGE' combined with the color-map flag forces the base format
       * flags to be set on read to ensure that the original representation is
       * not lost in the pass through a colormap format.*/","-10.             format_names[image_format & FORMAT_MASK],
-9.             (format & FORMAT_NO_CHANGE) != 0 || image->image.format == format
-8.             ? ""no change"" : format_names[format & FORMAT_MASK]);
-7.          if (background != NULL)
-6.     ",Useful
"/*Reads from a filename, which must be in image->file_name, but uses
 * image->opts to choose the method.  The file is always read in its native
 * format (the one the simplified API suggests).*/","-10.       allocbuffer(image);
-9.       result = png_image_finish_read(&image->image, background,
-8.          image->buffer+16, (png_int_32)image->stride, image->colormap);
-7.       checkbuffer(image, image->file_name);
-6.       if (result)
-5.       ",Useful
"/*cb is the length of the file as a (long) and
                      * this is greater than the maximum amount of
                      * memory that can be requested from malloc.*/","-10.                               "": read failed: "");
-9.                         }
-8.                      }
-7.                      else
-6.                         return logclose(image, f, image->file_name,
-5.                            "": out of ",Useful
"/*Experimental. Coverity says tmpfile() is insecure because it
       * generates predictable names.
       *
       * It is possible to satisfy Coverity by using mkstemp(); however,
       * any platform supporting mkstemp() undoubtedly has a secure tmpfile()
       * implementation as well, and doesn't need the fix.  Note that
       * the fix won't work on platforms that don't support mkstemp().
       *
       * https://www.securecoding.cert.org/confluence/display/c/
       * FIO21-C.+Do+not+create+temporary+files+in+shared+directories
       * says that most historic implementations of tmpfile() provide
       * only a limited number of possible temporary file names
       * (usually 26) before file names are recycled. That article also
       * provides a secure solution that unfortunately depends upon mkstemp().*/","* FIO21-C.+Do+not+create+temporary+files+in+shared+directories
       * says that most historic implementations of tmpfile() provide
       * only a limited number of possible temporary file names
       * (usually 26) before file names are recycled. That article also
       * provides a secure solution that unfortunately depends upon mkstemp().

 /*Experimental. Coverity says tmpfile() is insecure because it
       * generates predictable names.
       *
       * It is possible to satisfy Coverity by using mkstemp(); however,
       * any platform supporting mkstemp() undoubtedly has a secure tmpfile()
       * implementation as well, and doesn't need the fix.  Note that
       * the fix won't work on platforms that don't support mkstemp().
       *
       * https://www.securecoding.cert.org/confluence/display/c/
       * FIO21-C.+Do+not+create+temporary+files+in+shared+directories
       * says that most historic implementations of tmpfile() provide
       * only a limited number of possible temporary file names
       * (usually 26) before file names are recycled. That article also
       * provides a secure solution that unfortunately depends upon mkstemp().*/

1.        */
2.       char tmpfile[] = ""pngstest-XXXXXX"";
3.       int filedes;
4.       FILE *f;
5.       umask(0177);
6.       filedes = mkstemp(tmpfile);
7.       if (filedes < 0)
8.         f = NULL;
9.       else
10.       {",Useful
"/*output' has an initialized temporary image, read this back in and compare
    * this against the original: there should be no change since the original
    * format was written unmodified unless 'convert_to_8bit' was specified.
    * However, if the original image was color-mapped, a simple read will zap
    * the linear, color and maybe alpha flags, this will cause spurious failures
    * under some circumstances.*/","-10.             }
-9.             else
-8.                return logerror(image, ""memory"", "": write failed"", """");
-7.          }
-6.          else
-5.             return logerror(image, ""memory"", "": out of memory"", """");
-4.       }
-3.       else
-2.    ",Useful
"/*Copy the original data, stealing it from 'image'*/","-10.    else
-9.       return logerror(output, output->tmpfile_name,
-8.          "": read of new file failed"", """");
-7. }
-6. #endif
-5. static int
-4. testimage(Image *image, png_uint_32 opts, format_list *pf)
-3. {
-2.    int result;
-1.    Image copy;
",Useful
"/*Use the low bit of 'counter' to indicate whether or not to do alpha
       * removal with a background color or by composting onto the image; this
       * step gets skipped if it isn't relevant*/","-10.    copy.allocsize = 0;
-9.    image->input_file = NULL;
-8.    image->input_memory = NULL;
-7.    image->input_memory_size = 0;
-6.    image->tmpfile_name[0] = 0;
-5.    {
-4.       png_uint_32 counter;
-3.       Image output;
-2.       newimage(&out",Useful
"/*If there is a format change that removes the alpha channel then
          * the background is relevant.  If the output is 8-bit color-mapped
          * then a background color *must* be provided, otherwise there are
          * two tests to do - one with a color, the other with NULL.  The
          * NULL test happens second.*/","-6.       for (counter=0; counter<2*FORMAT_COUNT; ++counter)
-5.          if (format_isset(pf, counter >> 1))
-4.       {
-3.          png_uint_32 format = counter >> 1;
-2.          png_color background_color;
-1.          png_colorp background = NULL;
 ",Useful
"/*Alpha/transparency will be removed, the background is
                * relevant: make it a color the first time*/","-10.           * the background is relevant.  If the output is 8-bit color-mapped
-9.           * then a background color *must* be provided, otherwise there are
-8.           * two tests to do - one with a color, the other with NULL.  The
-7.           *",Useful
"/*BUT if the output is to a color-mapped 8-bit format then
                * the background must always be a color, so increment 'counter'
                * to skip the NULL test.*/","-2.                random_color(&background_color);
-1.                background = &background_color;
               /* BUT if the output is to a color-mapped 8-bit format then
                * the background must always be a color, so increment 'counte",Useful
"/*Otherwise an alpha channel is not being eliminated, just leave
             * background NULL and skip the (counter & 1) NULL test.*/","-4.                if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 &&
-3.                   (format & PNG_FORMAT_FLAG_LINEAR) == 0)
-2.                   ++counter;
-1.             }
            /* Otherwise an alpha channel is not being eliminated, just lea",Useful
/*else just use NULL for background*/,"-3.             else
-2.                ++counter;
-1.          }

 /*else just use NULL for background*/

1.          resetimage(&copy);",Useful
/*Make sure the file just read matches the original file.*/,"-3.          result = read_file(&copy, format, background);
-2.          if (!result)
-1.             break;

 /*Make sure the file just read matches the original file.*/

 ",Useful
"/*Write the *copy* just made to a new file to make sure the write
             * side works ok.  Check the conversion to sRGB if the copy is
             * linear.*/","-3.          if (!result)
-2.             break;
-1. #        ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
            /* Write the *copy* just made to a new file to make sure the write
             * side works ok.  Check the conversion to sRGB if the copy is
  ",Useful
"/*Validate against the original too; the background is needed here
             * as well so that compare_two_images knows what color was used.*/","-2.             if (!result)
-1.                break;
            /* Validate against the original too; the background is needed here
             * as well so that compare_two_images knows what color was used.

 /*Validate against the original too; the ",Useful
"/*output' is linear, convert to the corresponding sRGB format.*/","-6.             result = compare_two_images(image, &output, 0, background);
-5.             if (!result)
-4.                break;
-3.             if ((format & PNG_FORMAT_FLAG_LINEAR) != 0 &&
-2.                (format & PNG_FORMAT_FLAG_COLORMAP) == 0)
-",Useful
"/*This may involve a conversion via linear; in the ideal world
                * this would round-trip correctly, but libpng 1.5.7 is not the
                * ideal world so allow a drift (error_via_linear).
                *
                * 'image' has an alpha channel but 'output' does not then there
                * will a strip-alpha-channel operation (because 'output' is
                * linear), handle this by composing on black when doing the
                * comparison.*/","-2.                if (!result)
-1.                   break;
               /* This may involve a conversion via linear; in the ideal world
                * this would round-trip correctly, but libpng 1.5.7 is not the
                * ideal world so all",Useful
/*ensure that the random numbers don't depend on file order*/,"-10.    freeimage(&copy);
-9.    return result;
-8. }
-7. static int
-6. test_one_file(const char *file_name, format_list *formats, png_uint_32 opts,
-5.    int stride_extra, int log_pass)
-4. {
-3.    int result;
-2.    Image image;
-1.    if (!(opts & N",Useful
/*Ensure that stderr is flushed into any log file*/,"-6.    newimage(&image);
-5.    initimage(&image, opts, file_name, stride_extra);
-4.    result = read_one_file(&image);
-3.    if (result)
-2.       result = testimage(&image, opts, formats);
-1.    freeimage(&image);

 /*Ensure that stderr is flushed in",Useful
"/*Loop reading files, use a static buffer to simplify this and just
             * stop if the name gets to long.*/","-10.          exit(99);
-9.       }
-8.       else
-7.       {
-6.          if (format_is_initial(&formats))
-5.             format_default(&formats, redundant);
-4.          if (arg[0] == '-')
-3.          {
-2.             const int term = (arg[1] == '0",Useful
"/*Don't allow '\0' in file names, and terminate with '\n' or,
                * for -0, just '\0' (use -print0 to find to make this work!)*/","-4.             static char buffer[4096];
-3.             do
-2.             {
-1.                int ch = getchar();
               /* Don't allow '\0' in file names, and terminate with '\n' or,
                * for -0, just '\0' (use -print0 to find to",Useful
"/*Define the following to use this test against your installed libpng, rather
 * than the one being built here:*/","-10.  * NOTES:
-9.  *   This is a C program that is intended to be linked against libpng.  It
-8.  *   allows the libpng unknown handling code to be tested by interpreting
-7.  *   arguments to save or discard combinations of chunks.  The program is
-6.  ",Useful
"/*1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:*/","-5. #ifdef PNG_FREESTANDING_TESTS
-4. #  include <png.h>
-3. #else
-2. #  include ""../../png.h""
-1. #endif
/* 1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skip",Useful
"/*Since this program tests the ability to change the unknown chunk handling
 * these must be defined:*/","-5. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
-4. #  define SKIP 77
-3. #else
-2. #  define SKIP 0
-1. #endif
/* Since this program tests the ability to change the unknown chunk handling
 * these must be defined:

 /*Since this program tests t",Useful
"/*One of these must be defined to allow us to find out what happened.  It is
 * still useful to set unknown chunk handling without either of these in order
 * to cause *known* chunks to be discarded.  This can be a significant
 * efficiency gain, but it can't really be tested here.*/","-3. #if defined(PNG_SET_UNKNOWN_CHUNKS_SUPPORTED) &&\
-2.    defined(PNG_STDIO_SUPPORTED) &&\
-1.    defined(PNG_READ_SUPPORTED)
/* One of these must be defined to allow us to find out what happened.  It is
 * still useful to set unknown chunk handling wi",Useful
/*These are needed too for the default build:*/,"-10.    (((yIn)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))
-9. #define PNG_COL_FROM_PASS_COL(xIn, pass) \
-8.    (((xIn)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))
-7. #define PNG_PASS_MASK(pass,off) ( \
-6.    ((0x110145AFU>>(((7-(off",Useful
"/*Unused formal parameter errors are removed using the following macro which is
 * expected to have no bad effects on performance.*/","
/* Unused formal parameter errors are removed using the following macro which is
 * expected to have no bad effects on performance.



 /*Unused formal parameter errors are removed using the following macro which is
 * expected to have no bad effects on performance.*/

1.  */
2. #ifndef UNUSED
3. #  if defined(__GNUC__) || defined(_MSC_VER)
4. #     define UNUSED(param) (void)param;
5. #  else
6. #     define UNUSED(param)
7. #  endif
8. #endif",Useful
/*Chunk set by the '-1' option*/,"-10. #define PNG_INFO_vpAg 0x02000000U
-9. #define ABSENT  0
-8. #define START   1
-7. #define END     2
-6. static struct
-5. {
-4.    char        name[5];
-3.    png_uint_32 flag;
-2.    png_uint_32 tag;

 /*Chunk set by the '-1' option*/

 ",Useful
"/*This is a mess but it seems to be the only way to do it - there is no way
    * to check for a definition outside a #if.*/","-2.    { ""PLTE"", PNG_INFO_PLTE, png_PLTE, 0, 0, ABSENT, 0 },

 /*This is a mess but it seems to be the only way to do it - there is no way
    * to check for a definition outside a #if.*/

1.     */
2.    { ""bKGD"", PNG_INFO_bKGD, png_bKGD,
3. #     ifdef ",Useful
"/*During initialization and if this is a single command line argument set
    * exit now - there is only one test, otherwise longjmp to do the next test.*/","-10.       fprintf(stderr, ""%s(%s): png_destroy_read_struct error\n"", d->file,
-9.          d->test);
-8.       exit(1);
-7.    }
-6. }
-5. PNG_FUNCTION(void, display_exit, (display *d), static PNG_NORETURN)
-4. {
-3.    ++(d->error_count);
-2.    if (d->",Useful
/*Map the text chunks back into the flags*/,"-10. warning(png_structp png_ptr, const char *message)
-9. {
-8.    display *d = (display*)png_get_error_ptr(png_ptr);
-7.    fprintf(stderr, ""%s(%s): libpng warning: %s\n"", d->file, d->test, message);
-6.    ++(d->warning_count);
-5. }
-4. static png_uin",Useful
"/*This function mimics the behavior of png_set_keep_unknown_chunks by
    * returning '0' to keep the chunk and '1' to discard it.*/","-10.                d->test, text[ntext].compression);
-9.             display_exit(d);
-8.       }
-7.    }
-6.    return flags;
-5. }
-4. #ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-3. static int PNGCBAPI
-2. read_callback(png_structp pp, png_unknown_chunkp ",Useful
"/*See the comments in png.h - use the default for unknown chunks,
          * do not keep known chunks.*/","-6.       keep = d->keep;
-5.    else
-4.    {
-3.       keep = chunk_info[chunk].keep;
-2.       if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)
-1.       {
         /* See the comments in png.h - use the default for unknown chunks,
          * do not keep know",Useful
"/*Also store information about this chunk in the display, the relevant flag
    * is set if the chunk is to be kept ('not handled'.)*/","-2.          break;
-1.    }
   /* Also store information about this chunk in the display, the relevant flag
    * is set if the chunk is to be kept ('not handled'.)

 /*Also store information about this chunk in the display, the relevant flag
    * is se",Useful
"/*However if there is no support to store unknown chunks don't ask libpng to
    * do it; there will be an png_error.*/","-7.    {
-6.       png_uint_32 flag = chunk_info[chunk].flag;
-5.       if (pc->location & PNG_AFTER_IDAT)
-4.          d->after_IDAT |= flag;
-3.       else
-2.          d->before_IDAT |= flag;
-1.    }
   /* However if there is no support to store unkno",Useful
"/*Chunks not known to pngunknown must be validated here; since they
          * must also be unknown to libpng the 'display->keep' behavior should
          * have been used.*/","-8.    png_uint_32 flags = 0;
-7.    UNUSED(after_IDAT)
-6.    {
-5.       png_unknown_chunkp unknown;
-4.       int num_unknown = png_get_unknown_chunks(d->png_ptr, info_ptr, &unknown);
-3.       while (--num_unknown >= 0)
-2.       {
-1.          int ch",Useful
/*Otherwise this will return the cached values set by any user callback*/,"-2. static png_uint_32
-1. get_unknown(display *d, png_infop info_ptr, int after_IDAT)

 /*Otherwise this will return the cached values set by any user callback*/

1. {
2.    UNUSED(info_ptr);
3.    if (after_IDAT)
4.       return d->after_IDAT;
5.    els",Useful
"/*The #defines above should mean this is never reached, it's just here as
       * a check to ensure the logic is correct.*/","-8. {
-7.    UNUSED(info_ptr);
-6.    if (after_IDAT)
-5.       return d->after_IDAT;
-4.    else
-3.       return d->before_IDAT;
-2. }
-1. #  ifndef PNG_READ_USER_CHUNKS_SUPPORTED
      /* The #defines above should mean this is never reached, it's just ",Useful
"/*Some of these errors are permanently fatal and cause an exit here, others
    * are per-test and cause an error return.*/","-7.    display *d, int set_callback)
-6. {
-5.    int i, npasses, ipass;
-4.    png_uint_32 height;
-3.    d->keep = PNG_HANDLE_CHUNK_AS_DEFAULT;
-2.    d->before_IDAT = 0;
-1.    d->after_IDAT = 0;
   /* Some of these errors are permanently fatal and cau",Useful
"/*Terminate here, this error is not test specific.*/","-6.    d->png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, d, error,
-5.       warning);
-4.    if (d->png_ptr == NULL)
-3.    {
-2.       fprintf(stderr, ""%s(%s): could not allocate png struct\n"", d->file,
-1.          d->test);

 /*Terminate here",Useful
"/*Handle each argument in turn; multiple settings are possible for the same
    * chunk and multiple calls will occur (the last one should override all
    * preceding ones).*/","-5.       if (set_callback)
-4.          png_set_read_user_chunk_fn(d->png_ptr, d, read_callback);
-3. #  else
-2.       UNUSED(set_callback)
-1. #  endif
   /* Handle each argument in turn; multiple settings are possible for the same
    * chunk and mult",Useful
"/*These #if tests have the effect of skipping the arguments
                   * if SAVE support is unavailable - we can't do a useful test
                   * in this case, so we just check the arguments!  This could
                   * be improved in the future by using the read callback.*/","-3.                chunk = find(argv[i]);
-2.                if (chunk >= 0)
-1.                {
                  /* These #if tests have the effect of skipping the arguments
                   * if SAVE support is unavailable - we can't do a useful tes",Useful
"/*Skip the image data, if IDAT is not being handled then don't do this
    * because it will cause a CRC error.*/","-4.          fprintf(stderr, ""%s(%s): invalid interlace type\n"", d->file, d->test);
-3.          clean_display(d);
-2.          exit(1);
-1.    }
   /* Skip the image data, if IDAT is not being handled then don't do this
    * because it will cause a CRC ",Useful
"/*chunk was processed, it won't have been saved because that is
             * caught below when checking for inconsistent processing.*/","-4.       {
-3.          type = ""KNOWN"";
-2.          if (flag & known)
-1.          {
            /* chunk was processed, it won't have been saved because that is
             * caught below when checking for inconsistent processing.

 /*chunk was proces",Useful
"/*If IDAT is being handled as unknown the image read is skipped and all the
    * IDATs after the first end up in the end info struct, so in this case add
    * IDAT to the list of unknowns.  (Do this after 'check' above sets the
    * chunk_info 'keep' fields.)
    *
    * Note that the flag setting has to be in the 'known' field to avoid
    * triggering the consistency check below and the flag must only be set if
    * there are multiple IDATs, so if the check above did find an unknown IDAT
    * after IDAT.*/","-10. static void
-9. perform_one_test(FILE *fp, int argc, const char **argv,
-8.    png_uint_32 *default_flags, display *d, int set_callback)
-7. {
-6.    int def;
-5.    png_uint_32 flags[2][4];
-4.    rewind(fp);
-3.    clear_keep();
-2.    memcpy(flags",Useful
"/*Chunks should either be known or unknown, never both and this should apply
    * whether the chunk is before or after the IDAT (actually, the app can
    * probably change this by swapping the handling after the image, but this
    * test does not do that.)*/","-2.        (flags[1][3] & PNG_INFO_IDAT) != 0)
-1.       flags[0][2] |= PNG_INFO_IDAT;
   /* Chunks should either be known or unknown, never both and this should apply
    * whether the chunk is before or after the IDAT (actually, the app can
    * probab",Useful
"/*Now find out what happened to each chunk before and after the IDAT and
    * determine if the behavior was correct.  First some basic sanity checks,
    * any known chunk should be known in the original count, any unknown chunk
    * should be either known or unknown in the original.*/","-4.    check_error(d, (flags[0][0]|flags[0][2]) & (flags[0][1]|flags[0][3]),
-3.       ""chunk handled inconsistently in count tests"");
-2.    check_error(d, (flags[1][0]|flags[1][2]) & (flags[1][1]|flags[1][3]),
-1.       ""chunk handled inconsistently in ",Useful
"/*Now each chunk in the original list should have been handled according to
    * the options set for that chunk, regardless of whether libpng knows about
    * it or not.*/","-10.       png_uint_32 test;
-9.       test = flags[1][0] & ~flags[0][0];
-8.       check_error(d, test, ""new known chunk before IDAT"");
-7.       test = flags[1][1] & ~(flags[0][0] | flags[0][1]);
-6.       check_error(d, test, ""new unknown chunk before ",Useful
"/*A file name is required, but there should be no other arguments if
    * --default was specified.*/","-10.       else if (strcmp(*argv, ""--touch"") == 0)
-9.       {
-8.          if (argc > 1)
-7.             touch_file = *++argv, --argc;
-6.          else
-5.             usage(d.program, ""--touch: missing file name"");
-4.       }
-3.       else
-2.       ",Useful
"/*GCC BUG: if (default_tests && argc != 1) triggers some weird GCC argc
    * optimization which causes warnings with -Wstrict-overflow!*/","-2.    if (argc <= 0)
-1.       usage(d.program, ""missing test file"");
   /* GCC BUG: if (default_tests && argc != 1) triggers some weird GCC argc
    * optimization which causes warnings with -Wstrict-overflow!

 /*GCC BUG: if (default_tests && argc != 1",Useful
/*The name of the test file is the last argument; remove it.*/,"-2.    else if (default_tests) if (argc != 1)
-1.       usage(d.program, ""extra arguments"");

 /*The name of the test file is the last argument; remove it.*/

1.    d.file = argv[--argc];
2.    fp = fopen(d.file, ""rb"");
3.    if (fp == NULL)
4.    {
5.   ",Useful
"/*First find all the chunks, known and unknown, in the test file, a failure
    * here aborts the whole test.
    *
    * If 'save' is supported then the normal saving method should happen,
    * otherwise if 'read' is supported then the read callback will do the
    * same thing.  If both are supported the 'read' callback won't be
    * instantiated by default.  If 'save' is *not* supported then a user
    * callback is required even though we can call png_get_unknown_chunks.*/","-7.    d.file = argv[--argc];
-6.    fp = fopen(d.file, ""rb"");
-5.    if (fp == NULL)
-4.    {
-3.       perror(d.file);
-2.       exit(99);
-1.    }
   /* First find all the chunks, known and unknown, in the test file, a failure
    * here aborts the who",Useful
"/*Set the exit_test pointer here so we can continue after a libpng error.
       * NOTE: this leaks memory because the png_struct data from the failing
       * test is never freed.*/","-10.          perform_one_test(fp, argc, argv, default_flags, &d, 0);
-9. #     endif
-8. #     ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-7.          perform_one_test(fp, argc, argv, default_flags, &d, 1);
-6. #     endif
-5.       d.test = init;
-4.    }
-3.",Useful
"/*Success, touch the success file if appropriate*/","-10.             result = ""PASS"";
-9.          else
-8.             result = ""FAIL"";
-7.          printf(""%s: %s %s\n"", result, d.program, this_test);
-6.          test = next+1;
-5.       }
-4.    }
-3.    fclose(fp);
-2.    if (display_rc(&d, strict) ==",Useful
"/*Create a PNG structure for reading, and allocate any memory needed.*/","-10.  * and license in png.h
-9.  *
-8.  * This file contains routines that an application calls directly to
-7.  * read a PNG file or stream.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_SIMPLIFIED_READ_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)
",Useful
"/*Alternate create PNG structure for reading, and allocate any memory
 * needed.*/","-10. png_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
-9.     png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)
-8. {
-7. #ifndef PNG_USER_MEM_SUPPORTED
-6.    png_structp png_ptr = png_create_png_struct(user_png_ver,",Useful
"/*Added in libpng-1.6.0; this can be used to detect a read structure if
       * required (it will be zero in a write structure.)*/","-3.    if (png_ptr != NULL)
-2.    {
-1.       png_ptr->mode = PNG_IS_READ_STRUCT;
      /* Added in libpng-1.6.0; this can be used to detect a read structure if
       * required (it will be zero in a write structure.)

 /*Added in libpng-1.6.0; this can",Useful
"/*In stable builds only warn if an application error can be completely
          * handled.*/","-5. #     ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-4.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
-3. #     endif
-2. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
-1.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;
         /* In stable bui",Useful
"/*TODO: delay this, it can be done in png_init_io (if the app doesn't
       * do it itself) avoiding setting the default function if it is not
       * required.*/","-4. #        if PNG_RELEASE_BUILD
-3.             png_ptr->flags |= PNG_FLAG_APP_WARNINGS_WARN;
-2. #        endif
-1. #     endif
      /* TODO: delay this, it can be done in png_init_io (if the app doesn't
       * do it itself) avoiding setting the def",Useful
"/*Read the information before the actual image data.  This has been
 * changed in v0.90 to allow reading a file that already has the magic
 * bytes read from the stream.  You can tell libpng how many bytes have
 * been read from the beginning of the stream (up to the maximum of 8)
 * via png_set_sig_bytes(), and we will only check the remaining bytes
 * here.  The application can then have access to the signature bytes we
 * read if it is determined that this isn't a valid PNG file.*/","-5.       png_set_read_fn(png_ptr, NULL, NULL);
-4.    }
-3.    return png_ptr;
-2. }
-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the information before the actual image data.  This has been
 * changed in v0.90 to allow reading a file that already ha",Useful
"/*IDAT logic needs to happen here to simplify getting the two flags
       * right.*/","-5.    png_read_sig(png_ptr, info_ptr);
-4.    for (;;)
-3.    {
-2.       png_uint_32 length = png_read_chunk_header(png_ptr);
-1.       png_uint_32 chunk_name = png_ptr->chunk_name;
      /* IDAT logic needs to happen here to simplify getting the two fl",Useful
"/*This should be a binary subdivision search or a hash for
       * matching the chunk name rather than a linear search.*/","-10.             png_chunk_error(png_ptr, ""Missing PLTE before IDAT"");
-9.          else if ((png_ptr->mode & PNG_AFTER_IDAT) != 0)
-8.             png_chunk_benign_error(png_ptr, ""Too many IDATs found"");
-7.          png_ptr->mode |= PNG_HAVE_IDAT;
-6.  ",Useful
/*Optional call to update the users info_ptr structure*/,"-10. #ifdef PNG_READ_iTXt_SUPPORTED
-9.       else if (chunk_name == png_iTXt)
-8.          png_handle_iTXt(png_ptr, info_ptr, length);
-7. #endif
-6.       else
-5.          png_handle_unknown(png_ptr, info_ptr, length,
-4.              PNG_HANDLE_CHUNK_",Useful
/*New in 1.6.0 this avoids the bug of doing the initializations twice*/,"-10.    {
-9.       if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
-8.       {
-7.          png_read_start_row(png_ptr);
-6. #        ifdef PNG_READ_TRANSFORMS_SUPPORTED
-5.             png_read_transform_info(png_ptr, info_ptr);
-4. #        else
-3.    ",Useful
"/*Initialize palette, background, etc, after transformations
 * are set, but before any reading takes place.  This allows
 * the user to obtain a gamma-corrected palette, for example.
 * If the user doesn't call this, we will do it ourselves.*/","-6.       else
-5.          png_app_error(png_ptr,
-4.              ""png_read_update_info/png_start_read_image: duplicate call"");
-3.    }
-2. }
-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Initialize palette, background, etc, after transformations
 * are ",Useful
/*New in 1.6.0 this avoids the bug of doing the initializations twice*/,"-10.    {
-9.       if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
-8.       {
-7.          png_read_start_row(png_ptr);
-6. #        ifdef PNG_READ_TRANSFORMS_SUPPORTED
-5.             png_read_transform_info(png_ptr, info_ptr);
-4. #        else
-3.    ",Useful
"/*Undoes intrapixel differencing,
 * NOTE: this is apparently only supported in the 'sequential' reader.*/","-2. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-1. #ifdef PNG_MNG_FEATURES_SUPPORTED
/* Undoes intrapixel differencing,
 * NOTE: this is apparently only supported in the 'sequential' reader.

 /*Undoes intrapixel differencing,
 * NOTE: this is apparently only s",Useful
/*1.5.6: row_info moved out of png_struct to a local here.*/,"-2.    if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
-1.       png_read_start_row(png_ptr);

 /*1.5.6: row_info moved out of png_struct to a local here.*/

 ",Useful
/*Check for transforms that have been set but were defined out*/,"-8.    row_info.color_type = png_ptr->color_type;
-7.    row_info.bit_depth = png_ptr->bit_depth;
-6.    row_info.channels = png_ptr->channels;
-5.    row_info.pixel_depth = png_ptr->pixel_depth;
-4.    row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_dept",Useful
"/*If interlaced and we do not need a new row, combine row and return.
    * Notice that the pixels we have from previous rows have been transformed
    * already; we can only combine like with like (transformed or
    * untransformed) and, because of the libpng API for interlaced images, this
    * means we must transform before de-interlacing.*/","-1. #ifdef PNG_READ_INTERLACING_SUPPORTED
   /* If interlaced and we do not need a new row, combine row and return.
    * Notice that the pixels we have from previous rows have been transformed
    * already; we can only combine like with like (transforme",Useful
/*to force error if no data was found*/,"-10.                png_read_finish_row(png_ptr);
-9.                return;
-8.             }
-7.             break;
-6.       }
-5.    }
-4. #endif
-3.    if ((png_ptr->mode & PNG_HAVE_IDAT) == 0)
-2.       png_error(png_ptr, ""Invalid attempt to read ro",Useful
"/*libpng 1.5.6: the following line was copying png_ptr->rowbytes before
    * 1.5.6, while the buffer really is this big in current versions of libpng
    * it may not be in the future, so this was changed just to copy the
    * interlaced count:*/","-9.    png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1);
-8.    if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)
-7.    {
-6.       if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)
-5.          png_read_filter_row(png_ptr, &row_info, p",Useful
/*Expand interlaced rows to full size*/,"-9.    if (png_ptr->transformed_pixel_depth == 0)
-8.    {
-7.       png_ptr->transformed_pixel_depth = row_info.pixel_depth;
-6.       if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
-5.          png_error(png_ptr, ""sequential row overflow"");
-4",Useful
"/*Read one or more rows of image data.  If the image is interlaced,
 * and png_set_interlace_handling() has been called, the rows need to
 * contain the contents of the rows from the previous pass.  If the
 * image has alpha or transparency, and png_handle_alpha()[*] has been
 * called, the rows contents must be initialized to the contents of the
 * screen.
 *
 * ""row"" holds the actual image, and pixels are placed in it
 * as they arrive.  If the image is displayed after each pass, it will
 * appear to ""sparkle"" in.  ""display_row"" can be used to display a
 * ""chunky"" progressive image, with finer detail added as it becomes
 * available.  If you do not want this ""chunky"" display, you may pass
 * NULL for display_row.  If you do not want the sparkle display, and
 * you have not called png_handle_alpha(), you may pass NULL for rows.
 * If you have called png_handle_alpha(), and the image has either an
 * alpha channel or a transparency chunk, you must provide a buffer for
 * rows.  In this case, you do not have to provide a display_row buffer
 * also, but you may.  If the image is not interlaced, or if you have
 * not called png_set_interlace_handling(), the display_row buffer will
 * be ignored, so pass NULL to it.
 *
 * [*] png_handle_alpha() does not exist yet, as of this version of libpng*/","-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read one or more rows of image data.  If the image is interlaced,
 * and png_set_interlace_handling() has been called, the rows need to
 * contain the contents of the rows from the previous pass.  If the
 * imag",Useful
"/*Read the entire image.  If the image has an alpha channel or a tRNS
 * chunk, and you have called png_handle_alpha()[*], you will need to
 * initialize the image to the current image that PNG will be overlaying.
 * We set the num_rows again here, in case it was incorrectly set in
 * png_read_start_row() by a call to png_read_update_info() or
 * png_start_read_image() if png_set_interlace_handling() wasn't called
 * prior to either of these functions like it should have been.  You can
 * only call this function once.  If you desire to have an image for
 * each pass of a interlaced image, use png_read_rows() instead.
 *
 * [*] png_handle_alpha() does not exist yet, as of this version of libpng*/","-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the entire image.  If the image has an alpha channel or a tRNS
 * chunk, and you have called png_handle_alpha()[*], you will need to
 * initialize the image to the current image that PNG will be overlaying.",Useful
/*And make sure transforms are initialized.*/,"-10.    png_uint_32 i, image_height;
-9.    int pass, j;
-8.    png_bytepp rp;
-7.    png_debug(1, ""in png_read_image"");
-6.    if (png_ptr == NULL)
-5.       return;
-4. #ifdef PNG_READ_INTERLACING_SUPPORTED
-3.    if ((png_ptr->flags & PNG_FLAG_ROW_INIT",Useful
"/*Caller called png_start_read_image or png_read_update_info without
          * first turning on the PNG_INTERLACE transform.  We can fix this here,
          * but the caller should do it!*/","-7.       png_start_read_image(png_ptr);
-6.    }
-5.    else
-4.    {
-3.       if (png_ptr->interlaced != 0 &&
-2.           (png_ptr->transformations & PNG_INTERLACE) == 0)
-1.       {
         /* Caller called png_start_read_image or png_read_update_i",Useful
"/*Obtain the pass number, which also turns on the PNG_INTERLACE flag in
       * the above error case.*/","-2.          png_ptr->num_rows = png_ptr->height;
-1.       }
      /* Obtain the pass number, which also turns on the PNG_INTERLACE flag in
       * the above error case.

 /*Obtain the pass number, which also turns on the PNG_INTERLACE flag in
       * ",Useful
"/*Read the end of the PNG file.  Will not read past the end of the
 * file, will verify the end is accurate, and will read any comments
 * or time information at the end of the file, if info is not NULL.*/","-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the end of the PNG file.  Will not read past the end of the
 * file, will verify the end is accurate, and will read any comments
 * or time information at the end of the file, if info is not NULL.

 /*Read ",Useful
"/*If png_read_end is called in the middle of reading the rows there may
    * still be pending IDAT data and an owned zstream.  Deal with this here.*/","-10.  */
-9. void PNGAPI
-8. png_read_end(png_structrp png_ptr, png_inforp info_ptr)
-7. {
-6. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-5.    int keep;
-4. #endif
-3.    png_debug(1, ""in png_read_end"");
-2.    if (png_ptr == NULL)
-1.       return;
   /* I",Useful
/*Report invalid palette index; added at libng-1.5.10*/,"-5. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-4.    if (png_chunk_unknown_handling(png_ptr, png_IDAT) == 0)
-3. #endif
-2.       png_read_finish_IDAT(png_ptr);
-1. #ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED

 /*Report invalid palette index; added at ",Useful
"/*Zero length IDATs are legal after the last IDAT has been
          * read, but not after other chunks have been read.  1.6 does not
          * always read all the deflate data; specifically it cannot be relied
          * upon to read the Adler32 at the end.  If it doesn't ignore IDAT
          * chunks which are longer than zero as well:*/","-10.                 || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT) != 0)
-9.                png_benign_error(png_ptr, "".Too many IDATs found"");
-8.          }
-7.          png_handle_unknown(png_ptr, info_ptr, length, keep);
-6.          if (chunk_name =",Useful
/*Free all memory used in the read struct*/,"-10. #ifdef PNG_READ_iTXt_SUPPORTED
-9.       else if (chunk_name == png_iTXt)
-8.          png_handle_iTXt(png_ptr, info_ptr, length);
-7. #endif
-6.       else
-5.          png_handle_unknown(png_ptr, info_ptr, length,
-4.              PNG_HANDLE_CHUNK_",Useful
"/*NOTE: the 'setjmp' buffer may still be allocated and the memory and error
    * callbacks are still set at this point.  They are required to complete the
    * destruction of the png_struct itself.*/","-10. #endif
-9. #if defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) && \
-8.    defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
-7.    png_free(png_ptr, png_ptr->unknown_chunk.data);
-6.    png_ptr->unknown_chunk.data = NULL;
-5. #endif
-4. #ifdef PNG_SET_UNKNOWN_",Useful
/*Free all memory used by the read*/,"-1. }

 /*Free all memory used by the read*/

1. void PNGAPI
2. png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,
3.     png_infopp end_info_ptr_ptr)
4. {
5.    png_structrp png_ptr = NULL;
6.    png_debug(1, ""in png_destroy_read_",Useful
"/*libpng 1.6.0: use the API to destroy info structs to ensure consistent
    * behavior.  Prior to 1.6.0 libpng did extra 'info' destruction in this API.
    * The extra was, apparently, unnecessary yet this hides memory leak bugs.*/","-10. void PNGAPI
-9. png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,
-8.     png_infopp end_info_ptr_ptr)
-7. {
-6.    png_structrp png_ptr = NULL;
-5.    png_debug(1, ""in png_destroy_read_struct"");
-4.    if (png_ptr_ptr != NUL",Useful
"/*png_read_info() gives us all of the information from the
    * PNG file before the first IDAT (image data chunk).*/","-10.    png_ptr->read_row_fn = read_row_fn;
-9. }
-8. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-7. #ifdef PNG_INFO_IMAGE_SUPPORTED
-6. void PNGAPI
-5. png_read_png(png_structrp png_ptr, png_inforp info_ptr,
-4.     int transforms, voidp params)
-3. {
-2.    i",Useful
/*-------------- image transformations start here -------------------*/,"-3.    png_read_info(png_ptr, info_ptr);
-2.    if (info_ptr->height > PNG_UINT_32_MAX/(sizeof (png_bytep)))
-1.       png_error(png_ptr, ""Image is too high to process with png_read_png()"");

 /*-------------- image transformations start here ------------",Useful
"/*libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM
    * is not implemented.  This will only happen in de-configured (non-default)
    * libpng builds.  The results can be unexpected - png_read_png may return
    * short or mal-formed rows because the transform is skipped.*/","/* libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM
    * is not implemented.  This will only happen in de-configured (non-default)
    * libpng builds.  The results can be unexpected - png_read_png may return
    * short or mal-formed rows because the transform is skipped.

 /*libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM
    * is not implemented.  This will only happen in de-configured (non-default)
    * libpng builds.  The results can be unexpected - png_read_png may return
    * short or mal-formed rows because the transform is skipped.*/

1.     */",Useful
/*Tell libpng to strip 16-bit/color files down to 8 bits per color.*/,"/* Tell libpng to strip 16-bit/color files down to 8 bits per color.

 /*Tell libpng to strip 16-bit/color files down to 8 bits per color.*/

1.     */
2.    if ((transforms & PNG_TRANSFORM_SCALE_16) != 0)",Useful
"/*Added at libpng-1.5.4. ""strip_16"" produces the same result that it
       * did in earlier versions, while ""scale_16"" is now more accurate.*/","-1.    if ((transforms & PNG_TRANSFORM_SCALE_16) != 0)
      /* Added at libpng-1.5.4. ""strip_16"" produces the same result that it
       * did in earlier versions, while ""scale_16"" is now more accurate.

 /*Added at libpng-1.5.4. ""strip_16"" produces the ",Useful
"/*If both SCALE and STRIP are required pngrtran will effectively cancel the
    * latter by doing SCALE first.  This is ok and allows apps not to check for
    * which is supported to get the right answer.*/","-5. #ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-4.       png_set_scale_16(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_SCALE_16 not supported"");
-1. #endif
   /* If both SCALE and STRIP are required pngrtran will effectively cancel the",Useful
"/*Strip alpha bytes from the input data without combining with
    * the background (not recommended).*/","-6.    if ((transforms & PNG_TRANSFORM_STRIP_16) != 0)
-5. #ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
-4.       png_set_strip_16(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_STRIP_16 not supported"");
-1. #endif
   /* Strip alpha bytes ",Useful
"/*Extract multiple pixels with bit depths of 1, 2, or 4 from a single
    * byte into separate bytes (useful for paletted and grayscale images).*/","-6.    if ((transforms & PNG_TRANSFORM_STRIP_ALPHA) != 0)
-5. #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-4.       png_set_strip_alpha(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_STRIP_ALPHA not supported"");
-1. #endif
   /* Extract mul",Useful
"/*Change the order of packed pixels to least significant bit first
    * (not useful if you are using png_set_packing).*/","-6.    if ((transforms & PNG_TRANSFORM_PACKING) != 0)
-5. #ifdef PNG_READ_PACK_SUPPORTED
-4.       png_set_packing(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_PACKING not supported"");
-1. #endif
   /* Change the order of packed pix",Useful
"/*Expand paletted colors into true RGB triplets
    * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
    * Expand paletted or RGB images with transparency to full alpha
    * channels so the data will be available as RGBA quartets.*/","-6.    if ((transforms & PNG_TRANSFORM_PACKSWAP) != 0)
-5. #ifdef PNG_READ_PACKSWAP_SUPPORTED
-4.       png_set_packswap(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_PACKSWAP not supported"");
-1. #endif
   /* Expand paletted colors ",Useful
/*We don't handle background color or gamma transformation or quantizing.*/,"-10.     * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
-9.     * Expand paletted or RGB images with transparency to full alpha
-8.     * channels so the data will be available as RGBA quartets.
-7.     */
-6.    if ((transforms & PNG",Useful
"/*If you want to shift the pixel values from the range [0,255] or
    * [0,65535] to the original [0,7] or [0,31], or whatever range the
    * colors were originally in:*/","-6.    if ((transforms & PNG_TRANSFORM_INVERT_MONO) != 0)
-5. #ifdef PNG_READ_INVERT_SUPPORTED
-4.       png_set_invert_mono(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_INVERT_MONO not supported"");
-1. #endif
   /* If you want to s",Useful
/*Flip the RGB pixels to BGR (or RGBA to BGRA)*/,"-10.     * [0,65535] to the original [0,7] or [0,31], or whatever range the
-9.     * colors were originally in:
-8.     */
-7.    if ((transforms & PNG_TRANSFORM_SHIFT) != 0)
-6. #ifdef PNG_READ_SHIFT_SUPPORTED
-5.       if ((info_ptr->valid & PNG_INFO_s",Useful
/*Swap bytes of 16-bit files to least significant byte first*/,"-6.    if ((transforms & PNG_TRANSFORM_SWAP_ALPHA) != 0)
-5. #ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
-4.       png_set_swap_alpha(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_SWAP_ALPHA not supported"");
-1. #endif

 /*Swap bytes of 16-",Useful
/*Invert the alpha channel from opacity to transparency*/,"-7.    if ((transforms & PNG_TRANSFORM_SWAP_ENDIAN) != 0)
-6. #ifdef PNG_READ_SWAP_SUPPORTED
-5.       png_set_swap(png_ptr);
-4. #else
-3.       png_app_error(png_ptr, ""PNG_TRANSFORM_SWAP_ENDIAN not supported"");
-2. #endif

 /*Invert the alpha channel fr",Useful
/*Expand grayscale image to RGB*/,"-7.    if ((transforms & PNG_TRANSFORM_INVERT_ALPHA) != 0)
-6. #ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-5.       png_set_invert_alpha(png_ptr);
-4. #else
-3.       png_app_error(png_ptr, ""PNG_TRANSFORM_INVERT_ALPHA not supported"");
-2. #endif

 /*Expand gr",Useful
/*We don't handle adding filler bytes*/,"-6.    if ((transforms & PNG_TRANSFORM_EXPAND_16) != 0)
-5. #ifdef PNG_READ_EXPAND_16_SUPPORTED
-4.       png_set_expand_16(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_EXPAND_16 not supported"");
-1. #endif

 /*We don't handle addin",Useful
"/*Optional call to gamma correct and add the background to the palette
    * and update info structure.  REQUIRED if you are expecting libpng to
    * update the palette for you (i.e., you selected such a transform above).*/","-1.    (void)png_set_interlace_handling(png_ptr);
   /* Optional call to gamma correct and add the background to the palette
    * and update info structure.  REQUIRED if you are expecting libpng to
    * update the palette for you (i.e., you selected suc",Useful
/*-------------- image transformations end here -------------------*/,"-1.    png_read_update_info(png_ptr, info_ptr);

 /*-------------- image transformations end here -------------------*/

1.    png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);
2.    if (info_ptr->row_pointers == NULL)
3.    {
4.       png_uint_32 iptr;",Useful
"/*Read rest of file, and get additional chunks in info_ptr - REQUIRED*/","-10.           info_ptr->height * (sizeof (png_bytep))));
-9.       for (iptr=0; iptr<info_ptr->height; iptr++)
-8.          info_ptr->row_pointers[iptr] = NULL;
-7.       info_ptr->free_me |= PNG_FREE_ROWS;
-6.       for (iptr = 0; iptr < info_ptr->heigh",Useful
"/*SIMPLIFIED READ
 *
 * This code currently relies on the sequential reader, though it could easily
 * be made to work with the progressive one.*/","-1. #ifdef PNG_SIMPLIFIED_READ_SUPPORTED
/* SIMPLIFIED READ
 *
 * This code currently relies on the sequential reader, though it could easily
 * be made to work with the progressive one.

 /*SIMPLIFIED READ
 *
 * This code currently relies on the sequenti",Useful
/*Encoding of PNG data (used by the color-map code)*/,"-7. #ifdef PNG_SIMPLIFIED_READ_SUPPORTED

 /*Encoding of PNG data (used by the color-map code)*/

 ",Useful
/*8-bit encoded to sRGB gamma*/,"-9. #ifdef PNG_SIMPLIFIED_READ_SUPPORTED

 /*8-bit encoded to sRGB gamma*/

 ",Useful
"/*8-bit encoded to file gamma, not sRGB or linear*/","-10. /* SIMPLIFIED READ
-9.  *
-8.  * This code currently relies on the sequential reader, though it could easily
-7.  * be made to work with the progressive one.
-6.  */
-5. /* Arguments to png_image_finish_read: */
-4. /* Encoding of PNG data (used by t",Useful
/*8-bit linear: only from a file value*/,"-10.  *
-9.  * This code currently relies on the sequential reader, though it could easily
-8.  * be made to work with the progressive one.
-7.  */

 /*8-bit linear: only from a file value*/

 ",Useful
"/*Color-map processing: after libpng has run on the PNG image further
 * processing may be needed to convert the data to color-map indices.*/","-10.  * This code currently relies on the sequential reader, though it could easily
-9.  * be made to work with the progressive one.
-8.  */

 /*Color-map processing: after libpng has run on the PNG image further
 * processing may be needed to convert the",Useful
/*Process GA data to a color-map with alpha*/,"-10. /* Encoding of PNG data (used by the color-map code) */
-9. #  define P_NOTSET  0 /* File encoding not yet known */
-8. #  define P_sRGB    1 /* 8-bit encoded to sRGB gamma */
-7. #  define P_LINEAR  2 /* 16-bit linear: not encoded, NOT pre-multiplie",Useful
/*Process GA data to a background index*/,"-2. #define PNG_CMAP_NONE      0

 /*Process GA data to a background index*/

 ",Useful
/*The following document where the background is for each processing case.*/,"-5. #define PNG_CMAP_NONE      0

 /*The following document where the background is for each processing case.*/

1. #define PNG_CMAP_NONE_BACKGROUND      256
2. #define PNG_CMAP_GA_BACKGROUND        231
3. #define PNG_CMAP_TRANS_BACKGROUND     254
4. #def",Useful
"/*Do all the *safe* initialization - 'safe' means that png_error won't be
 * called, so setting up the jmp_buf is not required.  This means that anything
 * called from here must *not* call png_malloc - it has to call png_malloc_warn
 * instead so that control is returned safely back to this routine.*/","-1. } png_image_read_control;
/* Do all the *safe* initialization - 'safe' means that png_error won't be
 * called, so setting up the jmp_buf is not required.  This means that anything
 * called from here must *not* call png_malloc - it has to call png_ma",Useful
"/*And set the rest of the structure to NULL to ensure that the various
       * fields are consistent.*/","-10.  * called from here must *not* call png_malloc - it has to call png_malloc_warn
-9.  * instead so that control is returned safely back to this routine.
-8.  */
-7. static int
-6. png_image_read_init(png_imagep image)
-5. {
-4.    if (image->opaque ==",Useful
"/*Use png_ptr here, not info_ptr, because by examination png_handle_tRNS
    * sets the png_struct fields; that's all we are interested in here.  The
    * precise interaction with an app call to png_set_tRNS and PNG file reading
    * is unclear.*/","-8. static png_uint_32
-7. png_image_format(png_structrp png_ptr)
-6. {
-5.    png_uint_32 format = 0;
-4.    if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
-3.       format |= PNG_FORMAT_FLAG_COLOR;
-2.    if ((png_ptr->color_type & PNG_COLOR_MAS",Useful
"/*Is the given gamma significantly different from sRGB?  The test is the same
 * one used in pngrtran.c when deciding whether to do gamma correction.  The
 * arithmetic optimizes the division by using the fact that the inverse of the
 * file sRGB gamma is 2.2*/","-10.     * is unclear.
-9.     */
-8.    else if (png_ptr->num_trans > 0)
-7.       format |= PNG_FORMAT_FLAG_ALPHA;
-6.    if (png_ptr->bit_depth == 16)
-5.       format |= PNG_FORMAT_FLAG_LINEAR;
-4.    if ((png_ptr->color_type & PNG_COLOR_MASK_PALETTE)",Useful
